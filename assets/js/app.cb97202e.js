(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,o,l=e[0],s=e[1],c=e[2],u=0,p=[];u<l.length;u++)o=l[u],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&p.push(i[o][0]),i[o]=0;for(r in s)Object.prototype.hasOwnProperty.call(s,r)&&(n[r]=s[r]);for(d&&d(e);p.length;)p.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,l=1;l<t.length;l++){var s=t[l];0!==i[s]&&(r=!1)}r&&(a.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},i={1:0},a=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=i[n]=[e,r]}));e.push(t[2]=r);var a,l=document.createElement("script");l.charset="utf-8",l.timeout=120,o.nc&&l.setAttribute("nonce",o.nc),l.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"fa058597",3:"4b71d9fe",4:"3836de01",5:"f79f1e82",6:"ceb8656c",7:"25301cde",8:"613325ef",9:"31c9a510",10:"fbbc33f8",11:"e3d7ecd4",12:"6de50559",13:"8dedab1e",14:"ead62617",15:"377f9eff",16:"763bd371",17:"452907d0",18:"bfb4eb4c",19:"3a381546",20:"a58c8d54",21:"2396ac9a",22:"bb98ebd0",23:"b7fdba34",24:"0b80133a",25:"69b28bfb",26:"bf4988d2",27:"0b6c643d",28:"f2a75d7c",29:"de74b523",30:"a3285463",31:"bee37403",32:"4c4ce223",33:"2b15780c",34:"242c9c33",35:"65867b33",36:"aa83c10f",37:"21526183",38:"27a51a78",39:"d49a2493",40:"6a058e64",41:"406875cc",42:"bbdd8e3f",43:"d40b65fe",44:"c0f90ae5",45:"888d6df5",46:"f7e33e57",47:"45f53f88",48:"77efa4d7",49:"222129ad",50:"5f2dae6e",51:"54d77935",52:"935ac9e4",53:"0561a5cf",54:"b64090af",55:"e720956e",56:"05ceed8c",57:"b43f5784",58:"1ccee6f6",59:"11da92d7",60:"72015a1a",61:"3aacd878",62:"693f7f4a",63:"f666517a",64:"456d56a4",65:"5af02db9",66:"dd0db447",67:"0670b2ab",68:"09d5204c",69:"db09bda6",70:"ce9ceff6",71:"df171820",72:"cd125ee6",73:"e033fc1b",74:"5160e9b2",75:"495ec91d",76:"8121dc30",77:"405ab201",78:"091cc5a6",79:"8fcedf93",80:"65ec1411",81:"1151b577",82:"1064cbc3",83:"d6b435b9",84:"d40835b6",85:"bbb92aeb",86:"4b654a58",87:"49f96070",88:"1cd4bf4b",89:"6f0cf925",90:"fdf245ed",91:"596c04cb",92:"1656dd04",93:"08106ce8",94:"00f357bc",95:"54112709",96:"aed60490"}[n]+".js"}(n);var s=new Error;a=function(e){l.onerror=l.onload=null,clearTimeout(c);var t=i[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;s.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",s.name="ChunkLoadError",s.type=r,s.request=a,t[1](s)}i[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:l})}),12e4);l.onerror=l.onload=a,document.head.appendChild(l)}return Promise.all(e)},o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/design/",o.oe=function(n){throw console.error(n),n};var l=window.webpackJsonp=window.webpackJsonp||[],s=l.push.bind(l);l.push=e,l=l.slice();for(var c=0;c<l.length;c++)e(l[c]);var d=s;a.push([241,0]),t()}([function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var r=t(0),i=t(38).f,a=t(24),o=t(14),l=t(115),s=t(119),c=t(106);n.exports=function(n,e){var t,d,u,p,m,h=n.target,g=n.global,f=n.stat;if(t=g?r:f?r[h]||l(h,{}):(r[h]||{}).prototype)for(d in e){if(p=e[d],u=n.noTargetGet?(m=i(t,d))&&m.value:t[d],!c(g?d:h+(f?".":"#")+d,n.forced)&&void 0!==u){if(typeof p==typeof u)continue;s(p,u)}(n.sham||u&&u.sham)&&a(p,"sham",!0),o(t,d,p,n)}}},function(n,e,t){var r=t(65),i=Function.prototype,a=i.bind,o=i.call,l=r&&a.bind(o,o);n.exports=r?function(n){return n&&l(n)}:function(n){return n&&function(){return o.apply(n,arguments)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var r=t(0),i=t(51),a=t(9),o=t(85),l=t(52),s=t(156),c=i("wks"),d=r.Symbol,u=d&&d.for,p=s?d:d&&d.withoutSetter||o;n.exports=function(n){if(!a(c,n)||!l&&"string"!=typeof c[n]){var e="Symbol."+n;l&&a(d,n)?c[n]=d[n]:c[n]=s&&u?u(e):p(e)}return c[n]}},function(n,e,t){var r=t(122),i=t(14),a=t(261);r||i(Object.prototype,"toString",a,{unsafe:!0})},function(n,e,t){var r=t(65),i=Function.prototype.call;n.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e,t){var r=t(3);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(2),i=t(16),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(i(n),e)}},function(n,e,t){var r=t(0),i=t(11),a=r.String,o=r.TypeError;n.exports=function(n){if(i(n))return n;throw o(a(n)+" is not an object")}},function(n,e,t){var r=t(4);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(0),i=t(82),a=r.String;n.exports=function(n){if("Symbol"===i(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var r=t(0),i=t(8),a=t(158),o=t(157),l=t(10),s=t(87),c=r.TypeError,d=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=i?o?function(n,e,t){if(l(n),e=s(e),l(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=u(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return d(n,e,t)}:d:function(n,e,t){if(l(n),e=s(e),l(t),a)try{return d(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(0),i=t(4),a=t(9),o=t(24),l=t(115),s=t(91),c=t(37),d=t(70).CONFIGURABLE,u=c.get,p=c.enforce,m=String(String).split("String");(n.exports=function(n,e,t,s){var c,u=!!s&&!!s.unsafe,h=!!s&&!!s.enumerable,g=!!s&&!!s.noTargetGet,f=s&&void 0!==s.name?s.name:e;i(t)&&("Symbol("===String(f).slice(0,7)&&(f="["+String(f).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!a(t,"name")||d&&t.name!==f)&&o(t,"name",f),(c=p(t)).source||(c.source=m.join("string"==typeof f?f:""))),n!==r?(u?!g&&n[e]&&(h=!0):delete n[e],h?n[e]=t:o(n,e,t)):h?n[e]=t:l(e,t)})(Function.prototype,"toString",(function(){return i(this)&&u(this).source||s(this)}))},function(n,e,t){var r=t(0),i=t(4),a=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e,t){var r=t(0),i=t(18),a=r.Object;n.exports=function(n){return a(i(n))}},function(n,e){n.exports=!1},function(n,e,t){var r=t(0).TypeError;n.exports=function(n){if(null==n)throw r("Can't call method on "+n);return n}},function(n,e,t){"use strict";var r=t(1),i=t(97);r({target:"RegExp",proto:!0,forced:/./.exec!==i},{exec:i})},function(n,e,t){var r=t(54);n.exports=function(n){return r(n.length)}},function(n,e,t){var r=t(64),i=t(18);n.exports=function(n){return r(i(n))}},function(n,e,t){var r=t(0),i=t(4),a=t(67),o=r.TypeError;n.exports=function(n){if(i(n))return n;throw o(a(n)+" is not a function")}},function(n,e,t){var r=t(2),i=r({}.toString),a=r("".slice);n.exports=function(n){return a(i(n),8,-1)}},function(n,e,t){var r=t(8),i=t(13),a=t(49);n.exports=r?function(n,e,t){return i.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";var r=t(175).charAt,i=t(12),a=t(37),o=t(162),l=a.set,s=a.getterFor("String Iterator");o(String,"String",(function(n){l(this,{type:"String Iterator",string:i(n),index:0})}),(function(){var n,e=s(this),t=e.string,i=e.index;return i>=t.length?{value:void 0,done:!0}:(n=r(t,i),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var r=t(14),i=t(282),a=Error.prototype;a.toString!==i&&r(a,"toString",i)},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(15);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(192),i="object"==typeof self&&self&&self.Object===Object&&self,a=r||i||Function("return this")();n.exports=a},function(n,e,t){"use strict";function r(n,e,t,r,i,a,o,l){var s,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),o?(s=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=s):i&&(s=l?function(){i.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:i),s)if(c.functional){c._injectStyles=s;var d=c.render;c.render=function(n,e){return s.call(e),d(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,s):[s]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(1),i=t(59).filter;r({target:"Array",proto:!0,forced:!t(75)("filter")},{filter:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(0),i=t(176),a=t(177),o=t(145),l=t(24),s=t(5),c=s("iterator"),d=s("toStringTag"),u=o.values,p=function(n,e){if(n){if(n[c]!==u)try{l(n,c,u)}catch(e){n[c]=u}if(n[d]||l(n,d,e),i[e])for(var t in o)if(n[t]!==o[t])try{l(n,t,o[t])}catch(e){n[t]=o[t]}}};for(var m in i)p(r[m]&&r[m].prototype,m);p(a,"DOMTokenList")},function(n,e,t){"use strict";var r=t(1),i=t(181);r({target:"Array",proto:!0,forced:[].forEach!=i},{forEach:i})},function(n,e,t){var r=t(0),i=t(176),a=t(177),o=t(181),l=t(24),s=function(n){if(n&&n.forEach!==o)try{l(n,"forEach",o)}catch(e){n.forEach=o}};for(var c in i)i[c]&&s(r[c]&&r[c].prototype);s(a)},function(n,e,t){var r,i=t(10),a=t(146),o=t(117),l=t(68),s=t(161),c=t(86),d=t(90),u=d("IE_PROTO"),p=function(){},m=function(n){return"<script>"+n+"<\/script>"},h=function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e},g=function(){try{r=new ActiveXObject("htmlfile")}catch(n){}var n,e;g="undefined"!=typeof document?document.domain&&r?h(r):((e=c("iframe")).style.display="none",s.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F):h(r);for(var t=o.length;t--;)delete g.prototype[o[t]];return g()};l[u]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=i(n),t=new p,p.prototype=null,t[u]=n):t=g(),void 0===e?t:a.f(t,e)}},function(n,e,t){var r=t(2);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r,i,a,o=t(243),l=t(0),s=t(2),c=t(11),d=t(24),u=t(9),p=t(114),m=t(90),h=t(68),g=l.TypeError,f=l.WeakMap;if(o||p.state){var v=p.state||(p.state=new f),b=s(v.get),y=s(v.has),x=s(v.set);r=function(n,e){if(y(v,n))throw new g("Object already initialized");return e.facade=n,x(v,n,e),e},i=function(n){return b(v,n)||{}},a=function(n){return y(v,n)}}else{var T=m("state");h[T]=!0,r=function(n,e){if(u(n,T))throw new g("Object already initialized");return e.facade=n,d(n,T,e),e},i=function(n){return u(n,T)?n[T]:{}},a=function(n){return u(n,T)}}n.exports={set:r,get:i,has:a,enforce:function(n){return a(n)?i(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=i(e)).type!==n)throw g("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(8),i=t(7),a=t(118),o=t(49),l=t(21),s=t(87),c=t(9),d=t(158),u=Object.getOwnPropertyDescriptor;e.f=r?u:function(n,e){if(n=l(n),e=s(e),d)try{return u(n,e)}catch(n){}if(c(n,e))return o(!i(a.f,n,e),n[e])}},function(n,e,t){var r=t(65),i=Function.prototype,a=i.apply,o=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(a):function(){return o.apply(a,arguments)})},function(n,e,t){var r=t(1),i=t(0),a=t(39),o=t(278),l=i.WebAssembly,s=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,s),r({global:!0,forced:s},t)},d=function(n,e){if(l&&l[n]){var t={};t[n]=o("WebAssembly."+n,e,s),r({target:"WebAssembly",stat:!0,forced:s},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var r=t(302),i=t(305);n.exports=function(n,e){var t=i(n,e);return r(t)?t:void 0}},function(n,e,t){t(378),t(379)},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return s})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return p})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return f})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return x}));t(19),t(45),t(140),t(81),t(138),t(113),t(44),t(33),t(6),t(34),t(31),t(84),t(80),t(155),t(79),t(213),t(26),t(144);var r=/#.*$/,i=/\.(md|html)$/,a=/\/$/,o=/^[a-z]+:/i;function l(n){return decodeURI(n).replace(r,"").replace(i,"")}function s(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function u(n){if(s(n))return n;if(!n)return"404";var e=n.match(r),t=e?e[0]:"",i=l(n);return a.test(i)?n:i+".html"+t}function p(n,e){var t=n.hash,i=function(n){var e=n&&n.match(r);if(e)return e[0]}(e);return(!i||t===i)&&l(n.path)===l(e)}function m(n,e,t){if(s(e))return{type:"external",path:e};t&&(e=function(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var l=a[o];".."===l?i.pop():"."!==l&&i.push(l)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));for(var r=l(e),i=0;i<n.length;i++)if(l(n[i].regularPath)===r)return Object.assign({},n[i],{type:"page",path:u(n[i].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(e,'"')),{}}function h(n,e,t,r){var i=t.pages,a=t.themeConfig,o=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||o.sidebar||a.sidebar))return g(n);var l=o.sidebar||a.sidebar;if(l){var s=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(var t in e)if(0===(r=n,/(\.html|\/)$/.test(r)?r:r+"/").indexOf(encodeURI(t)))return{base:t,config:e[t]};var r;return{}}(e,l),c=s.base,d=s.config;return"auto"===d?g(n):d?d.map((function(n){return function n(e,t,r){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof e)return m(t,e,r);if(Array.isArray(e))return Object.assign(m(t,e[0],r),{title:e[1]});i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var a=e.children||[];return 0===a.length&&e.path?Object.assign(m(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map((function(e){return n(e,t,r,i+1)})),collapsable:!1!==e.collapsable}}(n,i,c)})):[]}return[]}function g(n){var e=f(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map((function(e){return{type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}}))}]}function f(n){var e;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){var e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e,t){"use strict";var r=t(1),i=t(59).map;r({target:"Array",proto:!0,forced:!t(75)("map")},{map:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(39),i=t(7),a=t(2),o=t(111),l=t(3),s=t(10),c=t(4),d=t(46),u=t(54),p=t(12),m=t(18),h=t(127),g=t(48),f=t(283),v=t(112),b=t(5)("replace"),y=Math.max,x=Math.min,T=a([].concat),k=a([].push),w=a("".indexOf),I=a("".slice),C="$0"==="a".replace(/./,"$0"),S=!!/./[b]&&""===/./[b]("a","$0");o("replace",(function(n,e,t){var a=S?"$":"$0";return[function(n,t){var r=m(this),a=null==n?void 0:g(n,b);return a?i(a,n,r,t):i(e,p(r),n,t)},function(n,i){var o=s(this),l=p(n);if("string"==typeof i&&-1===w(i,a)&&-1===w(i,"$<")){var m=t(e,o,l,i);if(m.done)return m.value}var g=c(i);g||(i=p(i));var b=o.global;if(b){var C=o.unicode;o.lastIndex=0}for(var S=[];;){var E=v(o,l);if(null===E)break;if(k(S,E),!b)break;""===p(E[0])&&(o.lastIndex=h(l,u(o.lastIndex),C))}for(var _,z="",A=0,P=0;P<S.length;P++){for(var R=p((E=S[P])[0]),B=y(x(d(E.index),l.length),0),j=[],D=1;D<E.length;D++)k(j,void 0===(_=E[D])?_:String(_));var M=E.groups;if(g){var L=T([R],j,B,l);void 0!==M&&k(L,M);var O=p(r(i,void 0,L))}else O=f(R,l,B,j,M,i);B>=A&&(z+=I(l,A,B)+O,A=B+R.length)}return z+I(l,A)}]}),!!l((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!C||S)},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=function(n){var e=+n;return e!=e||0===e?0:(e>0?r:t)(e)}},function(n,e,t){"use strict";var r=t(3);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(22);n.exports=function(n,e){var t=n[e];return null==t?void 0:r(t)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(17),i=t(114);(n.exports=function(n,e){return i[n]||(i[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.22.2",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.22.2/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){var r=t(53),i=t(3);n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,i,a=t(0),o=t(28),l=a.process,s=a.Deno,c=l&&l.versions||s&&s.version,d=c&&c.v8;d&&(i=(r=d.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(i=+r[1]),n.exports=i},function(n,e,t){var r=t(46),i=Math.min;n.exports=function(n){return n>0?i(r(n),9007199254740991):0}},function(n,e,t){var r=t(0);n.exports=r.Promise},function(n,e,t){"use strict";var r=t(87),i=t(13),a=t(49);n.exports=function(n,e,t){var o=r(e);o in n?i.f(n,o,a(0,t)):n[o]=t}},function(n,e,t){"use strict";var r=t(1),i=t(0),a=t(62),o=t(94),l=t(11),s=t(89),c=t(20),d=t(21),u=t(56),p=t(5),m=t(75),h=t(72),g=m("slice"),f=p("species"),v=i.Array,b=Math.max;r({target:"Array",proto:!0,forced:!g},{slice:function(n,e){var t,r,i,p=d(this),m=c(p),g=s(n,m),y=s(void 0===e?m:e,m);if(a(p)&&(t=p.constructor,(o(t)&&(t===v||a(t.prototype))||l(t)&&null===(t=t[f]))&&(t=void 0),t===v||void 0===t))return h(p,g,y);for(r=new(void 0===t?v:t)(b(y-g,0)),i=0;g<y;g++,i++)g in p&&u(r,i,p[g]);return r.length=i,r}})},function(n,e,t){var r=t(2),i=t(22),a=t(65),o=r(r.bind);n.exports=function(n,e){return i(n),void 0===e?n:a?o(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){var r=t(58),i=t(2),a=t(64),o=t(16),l=t(20),s=t(108),c=i([].push),d=function(n){var e=1==n,t=2==n,i=3==n,d=4==n,u=6==n,p=7==n,m=5==n||u;return function(h,g,f,v){for(var b,y,x=o(h),T=a(x),k=r(g,f),w=l(T),I=0,C=v||s,S=e?C(h,w):t||p?C(h,0):void 0;w>I;I++)if((m||I in T)&&(y=k(b=T[I],I,x),n))if(e)S[I]=y;else if(y)switch(n){case 3:return!0;case 5:return b;case 6:return I;case 2:c(S,b)}else switch(n){case 4:return!1;case 7:c(S,b)}return u?-1:i||d?d:S}};n.exports={forEach:d(0),map:d(1),filter:d(2),some:d(3),every:d(4),find:d(5),findIndex:d(6),filterReject:d(7)}},function(n,e,t){var r=t(160),i=t(117).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,e,t){var r=t(13).f,i=t(9),a=t(5)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!i(n,a)&&r(n,a,{configurable:!0,value:e})}},function(n,e,t){var r=t(23);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e,t){var r=t(76),i=t(287),a=t(288),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?i(n):a(n)}},function(n,e,t){var r=t(0),i=t(2),a=t(3),o=t(23),l=r.Object,s=i("".split);n.exports=a((function(){return!l("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?s(n,""):l(n)}:l},function(n,e,t){var r=t(3);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(0),i=t(15),a=t(4),o=t(36),l=t(156),s=r.Object;n.exports=l?function(n){return"symbol"==typeof n}:function(n){var e=i("Symbol");return a(e)&&o(e.prototype,s(n))}},function(n,e,t){var r=t(0).String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){var r=t(8),i=t(9),a=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,l=i(a,"name"),s=l&&"something"===function(){}.name,c=l&&(!r||r&&o(a,"name").configurable);n.exports={EXISTS:l,PROPER:s,CONFIGURABLE:c}},function(n,e,t){var r=t(2),i=t(10),a=t(244);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return i(t),a(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e,t){var r=t(2);n.exports=r([].slice)},function(n,e,t){var r=t(0),i=t(55),a=t(4),o=t(106),l=t(91),s=t(5),c=t(252),d=t(17),u=t(53),p=i&&i.prototype,m=s("species"),h=!1,g=a(r.PromiseRejectionEvent),f=o("Promise",(function(){var n=l(i),e=n!==String(i);if(!e&&66===u)return!0;if(d&&(!p.catch||!p.finally))return!0;if(u>=51&&/native code/.test(n))return!1;var t=new i((function(n){n(1)})),r=function(n){n((function(){}),(function(){}))};return(t.constructor={})[m]=r,!(h=t.then((function(){}))instanceof r)||!e&&c&&!g}));n.exports={CONSTRUCTOR:f,REJECTION_EVENT:g,SUBCLASSING:h}},function(n,e,t){"use strict";var r=t(22),i=function(n){var e,t;this.promise=new n((function(n,r){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=r})),this.resolve=r(e),this.reject=r(t)};n.exports.f=function(n){return new i(n)}},function(n,e,t){var r=t(3),i=t(5),a=t(53),o=i("species");n.exports=function(n){return a>=51||!r((function(){var e=[];return(e.constructor={})[o]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){var r=t(29).Symbol;n.exports=r},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(84);var r=t(78);t(83),t(96),t(6),t(126),t(25),t(32),t(187);var i=t(103);t(40),t(26);function a(n){return function(n){if(Array.isArray(n))return Object(r.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(i.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(1),i=t(0),a=t(3),o=t(62),l=t(11),s=t(16),c=t(20),d=t(56),u=t(108),p=t(75),m=t(5),h=t(53),g=m("isConcatSpreadable"),f=i.TypeError,v=h>=51||!a((function(){var n=[];return n[g]=!1,n.concat()[0]!==n})),b=p("concat"),y=function(n){if(!l(n))return!1;var e=n[g];return void 0!==e?!!e:o(n)};r({target:"Array",proto:!0,forced:!v||!b},{concat:function(n){var e,t,r,i,a,o=s(this),l=u(o,0),p=0;for(e=-1,r=arguments.length;e<r;e++)if(y(a=-1===e?o:arguments[e])){if(p+(i=c(a))>9007199254740991)throw f("Maximum allowed index exceeded");for(t=0;t<i;t++,p++)t in a&&d(l,p,a[t])}else{if(p>=9007199254740991)throw f("Maximum allowed index exceeded");d(l,p++,a)}return l.length=p,l}})},function(n,e,t){"use strict";var r=t(1),i=t(2),a=t(116).indexOf,o=t(47),l=i([].indexOf),s=!!l&&1/l([1],1,-0)<0,c=o("indexOf");r({target:"Array",proto:!0,forced:s||!c},{indexOf:function(n){var e=arguments.length>1?arguments[1]:void 0;return s?l(this,n,e)||0:a(this,n,e)}})},function(n,e,t){"use strict";t(19);var r,i,a=t(1),o=t(0),l=t(7),s=t(2),c=t(4),d=t(11),u=(r=!1,(i=/[ac]/).exec=function(){return r=!0,/./.exec.apply(this,arguments)},!0===i.test("abc")&&r),p=o.Error,m=s(/./.test);a({target:"RegExp",proto:!0,forced:!u},{test:function(n){var e=this.exec;if(!c(e))return m(this,n);var t=l(e,this,n);if(null!==t&&!d(t))throw new p("RegExp exec method returned something other than an Object or null");return!!t}})},function(n,e,t){var r=t(0),i=t(122),a=t(4),o=t(23),l=t(5)("toStringTag"),s=r.Object,c="Arguments"==o(function(){return arguments}());n.exports=i?o:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),l))?t:c?o(e):"Object"==(r=o(e))&&a(e.callee)?"Arguments":r}},function(n,e,t){t(270),t(273),t(274),t(125),t(275)},function(n,e,t){t(1)({target:"Array",stat:!0},{isArray:t(62)})},function(n,e,t){var r=t(2),i=0,a=Math.random(),o=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++i+a,36)}},function(n,e,t){var r=t(0),i=t(11),a=r.document,o=i(a)&&i(a.createElement);n.exports=function(n){return o?a.createElement(n):{}}},function(n,e,t){var r=t(159),i=t(66);n.exports=function(n){var e=r(n,"string");return i(e)?e:e+""}},function(n,e,t){var r=t(160),i=t(117);n.exports=Object.keys||function(n){return r(n,i)}},function(n,e,t){var r=t(46),i=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?i(t+e,0):a(t,e)}},function(n,e,t){var r=t(51),i=t(85),a=r("keys");n.exports=function(n){return a[n]||(a[n]=i(n))}},function(n,e,t){var r=t(2),i=t(4),a=t(114),o=r(Function.toString);i(a.inspectSource)||(a.inspectSource=function(n){return o(n)}),n.exports=a.inspectSource},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(23),i=t(0);n.exports="process"==r(i.process)},function(n,e,t){var r=t(2),i=t(3),a=t(4),o=t(82),l=t(15),s=t(91),c=function(){},d=[],u=l("Reflect","construct"),p=/^\s*(?:class|function)\b/,m=r(p.exec),h=!p.exec(c),g=function(n){if(!a(n))return!1;try{return u(c,d,n),!0}catch(n){return!1}},f=function(n){if(!a(n))return!1;switch(o(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return h||!!m(p,s(n))}catch(n){return!0}};f.sham=!0,n.exports=!u||i((function(){var n;return g(g.call)||!g(Object)||!g((function(){n=!0}))||n}))?f:g},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(6);function r(n,e,t,r,i,a,o){try{var l=n[a](o),s=l.value}catch(n){return void t(n)}l.done?e(s):Promise.resolve(s).then(r,i)}function i(n){return function(){var e=this,t=arguments;return new Promise((function(i,a){var o=n.apply(e,t);function l(n){r(o,i,a,l,s,"next",n)}function s(n){r(o,i,a,l,s,"throw",n)}l(void 0)}))}}},function(n,e,t){"use strict";var r=t(1),i=t(8),a=t(0),o=t(2),l=t(9),s=t(4),c=t(36),d=t(12),u=t(13).f,p=t(119),m=a.Symbol,h=m&&m.prototype;if(i&&s(m)&&(!("description"in h)||void 0!==m().description)){var g={},f=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:d(arguments[0]),e=c(h,this)?new m(n):void 0===n?m():m(n);return""===n&&(g[e]=!0),e};p(f,m),f.prototype=h,h.constructor=f;var v="Symbol(test)"==String(m("test")),b=o(h.toString),y=o(h.valueOf),x=/^Symbol\((.*)\)[^)]+$/,T=o("".replace),k=o("".slice);u(h,"description",{configurable:!0,get:function(){var n=y(this),e=b(n);if(l(g,n))return"";var t=v?k(e,7,-1):T(e,x,"$1");return""===t?void 0:t}}),r({global:!0,forced:!0},{Symbol:f})}},function(n,e,t){"use strict";var r,i,a=t(7),o=t(2),l=t(12),s=t(188),c=t(110),d=t(51),u=t(35),p=t(37).get,m=t(226),h=t(232),g=d("native-string-replace",String.prototype.replace),f=RegExp.prototype.exec,v=f,b=o("".charAt),y=o("".indexOf),x=o("".replace),T=o("".slice),k=(i=/b*/g,a(f,r=/a/,"a"),a(f,i,"a"),0!==r.lastIndex||0!==i.lastIndex),w=c.BROKEN_CARET,I=void 0!==/()??/.exec("")[1];(k||I||w||m||h)&&(v=function(n){var e,t,r,i,o,c,d,m=this,h=p(m),C=l(n),S=h.raw;if(S)return S.lastIndex=m.lastIndex,e=a(v,S,C),m.lastIndex=S.lastIndex,e;var E=h.groups,_=w&&m.sticky,z=a(s,m),A=m.source,P=0,R=C;if(_&&(z=x(z,"y",""),-1===y(z,"g")&&(z+="g"),R=T(C,m.lastIndex),m.lastIndex>0&&(!m.multiline||m.multiline&&"\n"!==b(C,m.lastIndex-1))&&(A="(?: "+A+")",R=" "+R,P++),t=new RegExp("^(?:"+A+")",z)),I&&(t=new RegExp("^"+A+"$(?!\\s)",z)),k&&(r=m.lastIndex),i=a(f,_?t:m,R),_?i?(i.input=T(i.input,P),i[0]=T(i[0],P),i.index=m.lastIndex,m.lastIndex+=i[0].length):m.lastIndex=0:k&&i&&(m.lastIndex=m.global?i.index+i[0].length:r),I&&i&&i.length>1&&a(g,i[0],t,(function(){for(o=1;o<arguments.length-2;o++)void 0===arguments[o]&&(i[o]=void 0)})),i&&E)for(i.groups=c=u(null),o=0;o<E.length;o++)c[(d=E[o])[0]]=i[d[1]];return i}),n.exports=v},function(n,e,t){var r=t(292),i=t(293),a=t(294),o=t(295),l=t(296);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=i,s.prototype.get=a,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e,t){var r=t(194);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(41)(Object,"create");n.exports=r},function(n,e,t){var r=t(314);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(135);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(57),t(6),t(109),t(187),t(25),t(19),t(81);var r=t(78);function i(n,e){if(n){if("string"==typeof n)return Object(r.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(r.a)(n,e):void 0}}},function(n,e,t){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,r.minimum,1),t.status=1===n?null:n;var s=t.render(!e),c=s.querySelector(r.barSelector),d=r.speed,u=r.easing;return s.offsetWidth,o((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),l(c,function(n,e,t){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,i}(n,d,u)),1===n?(l(s,{transition:"none",opacity:1}),s.offsetWidth,setTimeout((function(){l(s,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var i,o=e.querySelector(r.barSelector),s=n?"-100":a(t.status||0),d=document.querySelector(r.parent);return l(o,{transition:"all 0 linear",transform:"translate3d("+s+"%,0,0)"}),r.showSpinner||(i=e.querySelector(r.spinnerSelector))&&p(i),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),l=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,i=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((r=n[i]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,i,a=arguments;if(2==a.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&r(n,t,i);else r(n,a[1],a[2])}}();function s(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),r=t+e;s(t,e)||(n.className=r.substring(1))}function d(n,e){var t,r=u(n);s(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=i)},function(n,e,t){var r=t(1),i=t(16),a=t(88);r({target:"Object",stat:!0,forced:t(3)((function(){a(1)}))},{keys:function(n){return a(i(n))}})},function(n,e,t){var r=t(3),i=t(4),a=/#|\.prototype\./,o=function(n,e){var t=s[l(n)];return t==d||t!=c&&(i(e)?r(e):!!e)},l=o.normalize=function(n){return String(n).replace(a,".").toLowerCase()},s=o.data={},c=o.NATIVE="N",d=o.POLYFILL="P";n.exports=o},function(n,e,t){var r=t(82),i=t(48),a=t(69),o=t(5)("iterator");n.exports=function(n){if(null!=n)return i(n,o)||i(n,"@@iterator")||a[r(n)]}},function(n,e,t){var r=t(262);n.exports=function(n,e){return new(r(n))(0===e?0:e)}},function(n,e,t){var r=t(8),i=t(70).EXISTS,a=t(2),o=t(13).f,l=Function.prototype,s=a(l.toString),c=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,d=a(c.exec);r&&!i&&o(l,"name",{configurable:!0,get:function(){try{return d(c,s(this))[1]}catch(n){return""}}})},function(n,e,t){var r=t(3),i=t(0).RegExp,a=r((function(){var n=i("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),o=a||r((function(){return!i("a","y").sticky})),l=a||r((function(){var n=i("^r","gy");return n.lastIndex=2,null!=n.exec("str")}));n.exports={BROKEN_CARET:l,MISSED_STICKY:o,UNSUPPORTED_Y:a}},function(n,e,t){"use strict";t(19);var r=t(2),i=t(14),a=t(97),o=t(3),l=t(5),s=t(24),c=l("species"),d=RegExp.prototype;n.exports=function(n,e,t,u){var p=l(n),m=!o((function(){var e={};return e[p]=function(){return 7},7!=""[n](e)})),h=m&&!o((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[c]=function(){return t},t.flags="",t[p]=/./[p]),t.exec=function(){return e=!0,null},t[p](""),!e}));if(!m||!h||t){var g=r(/./[p]),f=e(p,""[n],(function(n,e,t,i,o){var l=r(n),s=e.exec;return s===a||s===d.exec?m&&!o?{done:!0,value:g(e,t,i)}:{done:!0,value:l(t,e,i)}:{done:!1}}));i(String.prototype,n,f[0]),i(d,p,f[1])}u&&s(d[p],"sham",!0)}},function(n,e,t){var r=t(0),i=t(7),a=t(10),o=t(4),l=t(23),s=t(97),c=r.TypeError;n.exports=function(n,e){var t=n.exec;if(o(t)){var r=i(t,n,e);return null!==r&&a(r),r}if("RegExp"===l(n))return i(s,n,e);throw c("RegExp#exec called on incompatible receiver")}},function(n,e,t){"use strict";var r=t(1),i=t(2),a=t(64),o=t(21),l=t(47),s=i([].join),c=a!=Object,d=l("join",",");r({target:"Array",proto:!0,forced:c||!d},{join:function(n){return s(o(this),void 0===n?",":n)}})},function(n,e,t){var r=t(0),i=t(115),a=r["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=a},function(n,e,t){var r=t(0),i=Object.defineProperty;n.exports=function(n,e){try{i(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(21),i=t(89),a=t(20),o=function(n){return function(e,t,o){var l,s=r(e),c=a(s),d=i(o,c);if(n&&t!=t){for(;c>d;)if((l=s[d++])!=l)return!0}else for(;c>d;d++)if((n||d in s)&&s[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,a=i&&!r.call({1:2},1);e.f=a?function(n){var e=i(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(9),i=t(163),a=t(38),o=t(13);n.exports=function(n,e,t){for(var l=i(e),s=o.f,c=a.f,d=0;d<l.length;d++){var u=l[d];r(n,u)||t&&r(t,u)||s(n,u,c(e,u))}}},function(n,e,t){var r=t(0),i=t(9),a=t(4),o=t(16),l=t(90),s=t(165),c=l("IE_PROTO"),d=r.Object,u=d.prototype;n.exports=s?d.getPrototypeOf:function(n){var e=o(n);if(i(e,c))return e[c];var t=e.constructor;return a(t)&&e instanceof t?t.prototype:e instanceof d?u:null}},function(n,e,t){var r=t(10),i=t(166),a=t(5)("species");n.exports=function(n,e){var t,o=r(n).constructor;return void 0===o||null==(t=r(o)[a])?e:i(t)}},function(n,e,t){var r={};r[t(5)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e,t){var r=t(0),i=t(89),a=t(20),o=t(56),l=r.Array,s=Math.max;n.exports=function(n,e,t){for(var r=a(n),c=i(e,r),d=i(void 0===t?r:t,r),u=l(s(d-c,0)),p=0;c<d;c++,p++)o(u,p,n[c]);return u.length=p,u}},function(n,e,t){var r=t(1),i=t(15),a=t(39),o=t(7),l=t(2),s=t(3),c=t(62),d=t(4),u=t(11),p=t(66),m=t(72),h=t(52),g=i("JSON","stringify"),f=l(/./.exec),v=l("".charAt),b=l("".charCodeAt),y=l("".replace),x=l(1..toString),T=/[\uD800-\uDFFF]/g,k=/^[\uD800-\uDBFF]$/,w=/^[\uDC00-\uDFFF]$/,I=!h||s((function(){var n=i("Symbol")();return"[null]"!=g([n])||"{}"!=g({a:n})||"{}"!=g(Object(n))})),C=s((function(){return'"\\udf06\\ud834"'!==g("\udf06\ud834")||'"\\udead"'!==g("\udead")})),S=function(n,e){var t=m(arguments),r=e;if((u(e)||void 0!==n)&&!p(n))return c(e)||(e=function(n,e){if(d(r)&&(e=o(r,this,n,e)),!p(e))return e}),t[1]=e,a(g,null,t)},E=function(n,e,t){var r=v(t,e-1),i=v(t,e+1);return f(k,n)&&!f(w,i)||f(w,n)&&!f(k,r)?"\\u"+x(b(n,0),16):n};g&&r({target:"JSON",stat:!0,forced:I||C},{stringify:function(n,e,t){var r=m(arguments),i=a(I?S:g,null,r);return C&&"string"==typeof i?y(i,T,E):i}})},function(n,e,t){t(185)("iterator")},function(n,e,t){"use strict";var r=t(175).charAt;n.exports=function(n,e,t){return e+(t?r(n,e).length:1)}},function(n,e,t){var r=t(286),i=t(50),a=Object.prototype,o=a.hasOwnProperty,l=a.propertyIsEnumerable,s=r(function(){return arguments}())?r:function(n){return i(n)&&o.call(n,"callee")&&!l.call(n,"callee")};n.exports=s},function(n,e,t){var r=t(41)(t(29),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(306),i=t(313),a=t(315),o=t(316),l=t(317);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=i,s.prototype.get=a,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(27),i=t(135),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(o.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(63),i=t(50);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(84);t(83),t(96),t(6),t(126),t(25),t(32);var r=t(103);t(40),t(26);function i(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var r,i,a=[],o=!0,l=!1;try{for(t=t.call(n);!(o=(r=t.next()).done)&&(a.push(r.value),!e||a.length!==e);o=!0);}catch(n){l=!0,i=n}finally{try{o||null==t.return||t.return()}finally{if(l)throw i}}return a}}(n,e)||Object(r.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";var r=t(39),i=t(7),a=t(2),o=t(111),l=t(149),s=t(10),c=t(18),d=t(121),u=t(127),p=t(54),m=t(12),h=t(48),g=t(124),f=t(112),v=t(97),b=t(110),y=t(3),x=b.UNSUPPORTED_Y,T=Math.min,k=[].push,w=a(/./.exec),I=a(k),C=a("".slice);o("split",(function(n,e,t){var a;return a="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var a=m(c(this)),o=void 0===t?4294967295:t>>>0;if(0===o)return[];if(void 0===n)return[a];if(!l(n))return i(e,a,n,o);for(var s,d,u,p=[],h=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),f=0,b=new RegExp(n.source,h+"g");(s=i(v,b,a))&&!((d=b.lastIndex)>f&&(I(p,C(a,f,s.index)),s.length>1&&s.index<a.length&&r(k,p,g(s,1)),u=s[0].length,f=d,p.length>=o));)b.lastIndex===s.index&&b.lastIndex++;return f===a.length?!u&&w(b,"")||I(p,""):I(p,C(a,f)),p.length>o?g(p,0,o):p}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:i(e,this,n,t)}:e,[function(e,t){var r=c(this),o=null==e?void 0:h(e,n);return o?i(o,e,r,t):i(a,m(r),e,t)},function(n,r){var i=s(this),o=m(n),l=t(a,i,o,r,a!==e);if(l.done)return l.value;var c=d(i,RegExp),h=i.unicode,g=(i.ignoreCase?"i":"")+(i.multiline?"m":"")+(i.unicode?"u":"")+(x?"g":"y"),v=new c(x?"^(?:"+i.source+")":i,g),b=void 0===r?4294967295:r>>>0;if(0===b)return[];if(0===o.length)return null===f(v,o)?[o]:[];for(var y=0,k=0,w=[];k<o.length;){v.lastIndex=x?0:k;var S,E=f(v,x?C(o,k):o);if(null===E||(S=T(p(v.lastIndex+(x?k:0)),o.length))===y)k=u(o,k,h);else{if(I(w,C(o,y,k)),w.length===b)return w;for(var _=1;_<=E.length-1;_++)if(I(w,E[_]),w.length===b)return w;k=y=S}}return I(w,C(o,y)),w}]}),!!y((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]})),x)},function(n,e,t){"use strict";var r=t(1),i=t(59).some;r({target:"Array",proto:!0,forced:!t(47)("some")},{some:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(7),i=t(111),a=t(10),o=t(54),l=t(12),s=t(18),c=t(48),d=t(127),u=t(112);i("match",(function(n,e,t){return[function(e){var t=s(this),i=null==e?void 0:c(e,n);return i?r(i,e,t):new RegExp(e)[n](l(t))},function(n){var r=a(this),i=l(n),s=t(e,r,i);if(s.done)return s.value;if(!r.global)return u(r,i);var c=r.unicode;r.lastIndex=0;for(var p,m=[],h=0;null!==(p=u(r,i));){var g=l(p[0]);m[h]=g,""===g&&(r.lastIndex=d(i,o(r.lastIndex),c)),h++}return 0===h?null:m}]}))},function(n,e,t){var r=t(5),i=t(35),a=t(13),o=r("unscopables"),l=Array.prototype;null==l[o]&&a.f(l,o,{configurable:!0,value:i(null)}),n.exports=function(n){l[o][n]=!0}},function(n,e,t){var r=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},i=r.iterator||"@@iterator",a=r.asyncIterator||"@@asyncIterator",o=r.toStringTag||"@@toStringTag";function l(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{l({},"")}catch(n){l=function(n,e,t){return n[e]=t}}function s(n,e,t,r){var i=e&&e.prototype instanceof u?e:u,a=Object.create(i.prototype),o=new w(r||[]);return a._invoke=function(n,e,t){var r="suspendedStart";return function(i,a){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===i)throw a;return C()}for(t.method=i,t.arg=a;;){var o=t.delegate;if(o){var l=x(o,t);if(l){if(l===d)continue;return l}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var s=c(n,e,t);if("normal"===s.type){if(r=t.done?"completed":"suspendedYield",s.arg===d)continue;return{value:s.arg,done:t.done}}"throw"===s.type&&(r="completed",t.method="throw",t.arg=s.arg)}}}(n,t,o),a}function c(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=s;var d={};function u(){}function p(){}function m(){}var h={};l(h,i,(function(){return this}));var g=Object.getPrototypeOf,f=g&&g(g(I([])));f&&f!==e&&t.call(f,i)&&(h=f);var v=m.prototype=u.prototype=Object.create(h);function b(n){["next","throw","return"].forEach((function(e){l(n,e,(function(n){return this._invoke(e,n)}))}))}function y(n,e){var r;this._invoke=function(i,a){function o(){return new e((function(r,o){!function r(i,a,o,l){var s=c(n[i],n,a);if("throw"!==s.type){var d=s.arg,u=d.value;return u&&"object"==typeof u&&t.call(u,"__await")?e.resolve(u.__await).then((function(n){r("next",n,o,l)}),(function(n){r("throw",n,o,l)})):e.resolve(u).then((function(n){d.value=n,o(d)}),(function(n){return r("throw",n,o,l)}))}l(s.arg)}(i,a,r,o)}))}return r=r?r.then(o,o):o()}}function x(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,x(n,e),"throw"===e.method))return d;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return d}var r=c(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,d;var i=r.arg;return i?i.done?(e[n.resultName]=i.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,d):i:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,d)}function T(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function k(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function w(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(T,this),this.reset(!0)}function I(n){if(n){var e=n[i];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,a=function e(){for(;++r<n.length;)if(t.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return a.next=a}}return{next:C}}function C(){return{value:void 0,done:!0}}return p.prototype=m,l(v,"constructor",m),l(m,"constructor",p),p.displayName=l(m,o,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===p||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,m):(n.__proto__=m,l(n,o,"GeneratorFunction")),n.prototype=Object.create(v),n},n.awrap=function(n){return{__await:n}},b(y.prototype),l(y.prototype,a,(function(){return this})),n.AsyncIterator=y,n.async=function(e,t,r,i,a){void 0===a&&(a=Promise);var o=new y(s(e,t,r,i),a);return n.isGeneratorFunction(t)?o:o.next().then((function(n){return n.done?n.value:o.next()}))},b(v),l(v,o,"Generator"),l(v,i,(function(){return this})),l(v,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},n.values=I,w.prototype={constructor:w,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(k),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function r(t,r){return o.type="throw",o.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],o=a.completion;if("root"===a.tryLoc)return r("end");if(a.tryLoc<=this.prev){var l=t.call(a,"catchLoc"),s=t.call(a,"finallyLoc");if(l&&s){if(this.prev<a.catchLoc)return r(a.catchLoc,!0);if(this.prev<a.finallyLoc)return r(a.finallyLoc)}else if(l){if(this.prev<a.catchLoc)return r(a.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return r(a.finallyLoc)}}}},abrupt:function(n,e){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&t.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var a=i;break}}a&&("break"===n||"continue"===n)&&a.tryLoc<=e&&e<=a.finallyLoc&&(a=null);var o=a?a.completion:{};return o.type=n,o.arg=e,a?(this.method="next",this.next=a.finallyLoc,d):this.complete(o)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),d},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),k(t),d}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var i=r.arg;k(t)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:I(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),d}},n}(n.exports);try{regeneratorRuntime=r}catch(n){"object"==typeof globalThis?globalThis.regeneratorRuntime=r:Function("r","regeneratorRuntime = r")(r)}},function(n,e,t){var r=t(1),i=t(8),a=t(13).f;r({target:"Object",stat:!0,forced:Object.defineProperty!==a,sham:!i},{defineProperty:a})},function(n,e,t){"use strict";var r=t(70).PROPER,i=t(14),a=t(10),o=t(12),l=t(3),s=t(238),c=RegExp.prototype.toString,d=l((function(){return"/a/b"!=c.call({source:"a",flags:"b"})})),u=r&&"toString"!=c.name;(d||u)&&i(RegExp.prototype,"toString",(function(){var n=a(this);return"/"+o(n.source)+"/"+o(s(n))}),{unsafe:!0})},function(n,e,t){"use strict";var r=t(21),i=t(141),a=t(69),o=t(37),l=t(13).f,s=t(162),c=t(17),d=t(8),u=o.set,p=o.getterFor("Array Iterator");n.exports=s(Array,"Array",(function(n,e){u(this,{type:"Array Iterator",target:r(n),index:0,kind:e})}),(function(){var n=p(this),e=n.target,t=n.kind,r=n.index++;return!e||r>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:r,done:!1}:"values"==t?{value:e[r],done:!1}:{value:[r,e[r]],done:!1}}),"values");var m=a.Arguments=a.Array;if(i("keys"),i("values"),i("entries"),!c&&d&&"values"!==m.name)try{l(m,"name",{value:"values"})}catch(n){}},function(n,e,t){var r=t(8),i=t(157),a=t(13),o=t(10),l=t(21),s=t(88);e.f=r&&!i?Object.defineProperties:function(n,e){o(n);for(var t,r=l(e),i=s(e),c=i.length,d=0;c>d;)a.f(n,t=i[d++],r[t]);return n}},function(n,e,t){var r=t(0).TypeError;n.exports=function(n,e){if(n<e)throw r("Not enough arguments");return n}},function(n,e,t){var r=t(0),i=t(7),a=t(22),o=t(10),l=t(67),s=t(107),c=r.TypeError;n.exports=function(n,e){var t=arguments.length<2?s(n):e;if(a(t))return o(i(t,n));throw c(l(n)+" is not iterable")}},function(n,e,t){var r=t(11),i=t(23),a=t(5)("match");n.exports=function(n){var e;return r(n)&&(void 0!==(e=n[a])?!!e:"RegExp"==i(n))}},function(n,e,t){var r=t(4),i=t(11),a=t(71);n.exports=function(n,e,t){var o,l;return a&&r(o=e.constructor)&&o!==t&&i(l=o.prototype)&&l!==t.prototype&&a(n,l),n}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,a=/^0o[0-7]+$/i,o=parseInt,l="object"==typeof global&&global&&global.Object===Object&&global,s="object"==typeof self&&self&&self.Object===Object&&self,c=l||s||Function("return this")(),d=Object.prototype.toString,u=Math.max,p=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var l=i.test(n);return l||a.test(n)?o(n.slice(2),l?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,i,a,o,l,s,c=0,d=!1,f=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,a=i;return r=i=void 0,c=e,o=n.apply(a,t)}function y(n){return c=n,l=setTimeout(T,e),d?b(n):o}function x(n){var t=n-s;return void 0===s||t>=e||t<0||f&&n-c>=a}function T(){var n=m();if(x(n))return k(n);l=setTimeout(T,function(n){var t=e-(n-s);return f?p(t,a-(n-c)):t}(n))}function k(n){return l=void 0,v&&r?b(n):(r=i=void 0,o)}function w(){var n=m(),t=x(n);if(r=arguments,i=this,s=n,t){if(void 0===l)return y(s);if(f)return l=setTimeout(T,e),b(s)}return void 0===l&&(l=setTimeout(T,e)),o}return e=g(e)||0,h(t)&&(d=!!t.leading,a=(f="maxWait"in t)?u(g(t.maxWait)||0,e):a,v="trailing"in t?!!t.trailing:v),w.cancel=function(){void 0!==l&&clearTimeout(l),c=0,r=s=i=l=void 0},w.flush=function(){return void 0===l?o:k(m())},w}},function(n,e,t){var r=t(2),i=t(18),a=t(12),o=t(154),l=r("".replace),s="["+o+"]",c=RegExp("^"+s+s+"*"),d=RegExp(s+s+"*$"),u=function(n){return function(e){var t=a(i(e));return 1&n&&(t=l(t,c,"")),2&n&&(t=l(t,d,"")),t}};n.exports={start:u(1),end:u(2),trim:u(3)}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){var r=t(2),i=t(14),a=Date.prototype,o=r(a.toString),l=r(a.getTime);"Invalid Date"!=String(new Date(NaN))&&i(a,"toString",(function(){var n=l(this);return n==n?o(this):"Invalid Date"}))},function(n,e,t){var r=t(52);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(8),i=t(3);n.exports=r&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(8),i=t(3),a=t(86);n.exports=!r&&!i((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(0),i=t(7),a=t(11),o=t(66),l=t(48),s=t(242),c=t(5),d=r.TypeError,u=c("toPrimitive");n.exports=function(n,e){if(!a(n)||o(n))return n;var t,r=l(n,u);if(r){if(void 0===e&&(e="default"),t=i(r,n,e),!a(t)||o(t))return t;throw d("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var r=t(2),i=t(9),a=t(21),o=t(116).indexOf,l=t(68),s=r([].push);n.exports=function(n,e){var t,r=a(n),c=0,d=[];for(t in r)!i(l,t)&&i(r,t)&&s(d,t);for(;e.length>c;)i(r,t=e[c++])&&(~o(d,t)||s(d,t));return d}},function(n,e,t){var r=t(15);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(1),i=t(7),a=t(17),o=t(70),l=t(4),s=t(227),c=t(120),d=t(71),u=t(61),p=t(24),m=t(14),h=t(5),g=t(69),f=t(164),v=o.PROPER,b=o.CONFIGURABLE,y=f.IteratorPrototype,x=f.BUGGY_SAFARI_ITERATORS,T=h("iterator"),k=function(){return this};n.exports=function(n,e,t,o,h,f,w){s(t,e,o);var I,C,S,E=function(n){if(n===h&&R)return R;if(!x&&n in A)return A[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},_=e+" Iterator",z=!1,A=n.prototype,P=A[T]||A["@@iterator"]||h&&A[h],R=!x&&P||E(h),B="Array"==e&&A.entries||P;if(B&&(I=c(B.call(new n)))!==Object.prototype&&I.next&&(a||c(I)===y||(d?d(I,y):l(I[T])||m(I,T,k)),u(I,_,!0,!0),a&&(g[_]=k)),v&&"values"==h&&P&&"values"!==P.name&&(!a&&b?p(A,"name","values"):(z=!0,R=function(){return i(P,this)})),h)if(C={values:E("values"),keys:f?R:E("keys"),entries:E("entries")},w)for(S in C)(x||z||!(S in A))&&m(A,S,C[S]);else r({target:e,proto:!0,forced:x||z},C);return a&&!w||A[T]===R||m(A,T,R,{name:h}),g[e]=R,C}},function(n,e,t){var r=t(15),i=t(2),a=t(60),o=t(92),l=t(10),s=i([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(l(n)),t=o.f;return t?s(e,t(n)):e}},function(n,e,t){"use strict";var r,i,a,o=t(3),l=t(4),s=t(35),c=t(120),d=t(14),u=t(5),p=t(17),m=u("iterator"),h=!1;[].keys&&("next"in(a=[].keys())?(i=c(c(a)))!==Object.prototype&&(r=i):h=!0),null==r||o((function(){var n={};return r[m].call(n)!==n}))?r={}:p&&(r=s(r)),l(r[m])||d(r,m,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:h}},function(n,e,t){var r=t(3);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var r=t(0),i=t(94),a=t(67),o=r.TypeError;n.exports=function(n){if(i(n))return n;throw o(a(n)+" is not a constructor")}},function(n,e,t){var r,i,a,o,l=t(0),s=t(39),c=t(58),d=t(4),u=t(9),p=t(3),m=t(161),h=t(72),g=t(86),f=t(147),v=t(168),b=t(93),y=l.setImmediate,x=l.clearImmediate,T=l.process,k=l.Dispatch,w=l.Function,I=l.MessageChannel,C=l.String,S=0,E={};try{r=l.location}catch(n){}var _=function(n){if(u(E,n)){var e=E[n];delete E[n],e()}},z=function(n){return function(){_(n)}},A=function(n){_(n.data)},P=function(n){l.postMessage(C(n),r.protocol+"//"+r.host)};y&&x||(y=function(n){f(arguments.length,1);var e=d(n)?n:w(n),t=h(arguments,1);return E[++S]=function(){s(e,void 0,t)},i(S),S},x=function(n){delete E[n]},b?i=function(n){T.nextTick(z(n))}:k&&k.now?i=function(n){k.now(z(n))}:I&&!v?(o=(a=new I).port2,a.port1.onmessage=A,i=c(o.postMessage,o)):l.addEventListener&&d(l.postMessage)&&!l.importScripts&&r&&"file:"!==r.protocol&&!p(P)?(i=P,l.addEventListener("message",A,!1)):i="onreadystatechange"in g("script")?function(n){m.appendChild(g("script")).onreadystatechange=function(){m.removeChild(this),_(n)}}:function(n){setTimeout(z(n),0)}),n.exports={set:y,clear:x}},function(n,e,t){var r=t(28);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(r)},function(n,e,t){var r=t(0),i=t(58),a=t(7),o=t(10),l=t(67),s=t(170),c=t(20),d=t(36),u=t(148),p=t(107),m=t(171),h=r.TypeError,g=function(n,e){this.stopped=n,this.result=e},f=g.prototype;n.exports=function(n,e,t){var r,v,b,y,x,T,k,w=t&&t.that,I=!(!t||!t.AS_ENTRIES),C=!(!t||!t.IS_ITERATOR),S=!(!t||!t.INTERRUPTED),E=i(e,w),_=function(n){return r&&m(r,"normal",n),new g(!0,n)},z=function(n){return I?(o(n),S?E(n[0],n[1],_):E(n[0],n[1])):S?E(n,_):E(n)};if(C)r=n;else{if(!(v=p(n)))throw h(l(n)+" is not iterable");if(s(v)){for(b=0,y=c(n);y>b;b++)if((x=z(n[b]))&&d(f,x))return x;return new g(!1)}r=u(n,v)}for(T=r.next;!(k=a(T,r)).done;){try{x=z(k.value)}catch(n){m(r,"throw",n)}if("object"==typeof x&&x&&d(f,x))return x}return new g(!1)}},function(n,e,t){var r=t(5),i=t(69),a=r("iterator"),o=Array.prototype;n.exports=function(n){return void 0!==n&&(i.Array===n||o[a]===n)}},function(n,e,t){var r=t(7),i=t(10),a=t(48);n.exports=function(n,e,t){var o,l;i(n);try{if(!(o=a(n,"return"))){if("throw"===e)throw t;return t}o=r(o,n)}catch(n){l=!0,o=n}if("throw"===e)throw t;if(l)throw o;return i(o),t}},function(n,e,t){var r=t(55),i=t(173),a=t(73).CONSTRUCTOR;n.exports=a||!i((function(n){r.all(n).then(void 0,(function(){}))}))},function(n,e,t){var r=t(5)("iterator"),i=!1;try{var a=0,o={next:function(){return{done:!!a++}},return:function(){i=!0}};o[r]=function(){return this},Array.from(o,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!i)return!1;var t=!1;try{var a={};a[r]=function(){return{next:function(){return{done:t=!0}}}},n(a)}catch(n){}return t}},function(n,e,t){var r=t(10),i=t(11),a=t(74);n.exports=function(n,e){if(r(n),i(e)&&e.constructor===n)return e;var t=a.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){var r=t(2),i=t(46),a=t(12),o=t(18),l=r("".charAt),s=r("".charCodeAt),c=r("".slice),d=function(n){return function(e,t){var r,d,u=a(o(e)),p=i(t),m=u.length;return p<0||p>=m?n?"":void 0:(r=s(u,p))<55296||r>56319||p+1===m||(d=s(u,p+1))<56320||d>57343?n?l(u,p):r:n?c(u,p,p+2):d-56320+(r-55296<<10)+65536}};n.exports={codeAt:d(!1),charAt:d(!0)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var r=t(86)("span").classList,i=r&&r.constructor&&r.constructor.prototype;n.exports=i===Object.prototype?void 0:i},function(n,e,t){var r=t(1),i=t(3),a=t(16),o=t(120),l=t(165);r({target:"Object",stat:!0,forced:i((function(){o(1)})),sham:!l},{getPrototypeOf:function(n){return o(a(n))}})},function(n,e,t){var r=t(0),i=t(149),a=r.TypeError;n.exports=function(n){if(i(n))throw a("The method doesn't accept regular expressions");return n}},function(n,e,t){var r=t(5)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[r]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){"use strict";var r=t(59).forEach,i=t(47)("forEach");n.exports=i?[].forEach:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var r=t(3);n.exports=!r((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var r=t(23),i=t(21),a=t(60).f,o=t(124),l="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return l&&"Window"==r(n)?function(n){try{return a(n)}catch(n){return o(l)}}(n):a(i(n))}},function(n,e,t){var r=t(5);e.f=r},function(n,e,t){var r=t(271),i=t(9),a=t(184),o=t(13).f;n.exports=function(n){var e=r.Symbol||(r.Symbol={});i(e,n)||o(e,n,{value:a.f(n)})}},function(n,e,t){var r=t(52);n.exports=r&&!!Symbol.for&&!!Symbol.keyFor},function(n,e,t){var r=t(1),i=t(276);r({target:"Array",stat:!0,forced:!t(173)((function(n){Array.from(n)}))},{from:i})},function(n,e,t){"use strict";var r=t(10);n.exports=function(){var n=r(this),e="";return n.hasIndices&&(e+="d"),n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var r=t(12);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){t(1)({target:"Object",stat:!0,sham:!t(8)},{create:t(35)})},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,i=n.length;++t<r;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(98),i=t(297),a=t(298),o=t(299),l=t(300),s=t(301);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=i,c.prototype.delete=a,c.prototype.get=o,c.prototype.has=l,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(63),i=t(130);n.exports=function(n){if(!i(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(318),i=t(50);n.exports=function n(e,t,a,o,l){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:r(e,t,a,o,n,l))}},function(n,e,t){var r=t(199),i=t(321),a=t(200);n.exports=function(n,e,t,o,l,s){var c=1&t,d=n.length,u=e.length;if(d!=u&&!(c&&u>d))return!1;var p=s.get(n),m=s.get(e);if(p&&m)return p==e&&m==n;var h=-1,g=!0,f=2&t?new r:void 0;for(s.set(n,e),s.set(e,n);++h<d;){var v=n[h],b=e[h];if(o)var y=c?o(b,v,h,e,n,s):o(v,b,h,n,e,s);if(void 0!==y){if(y)continue;g=!1;break}if(f){if(!i(e,(function(n,e){if(!a(f,e)&&(v===n||l(v,n,t,o,s)))return f.push(e)}))){g=!1;break}}else if(v!==b&&!l(v,b,t,o,s)){g=!1;break}}return s.delete(n),s.delete(e),g}},function(n,e,t){var r=t(131),i=t(319),a=t(320);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=i,o.prototype.has=a,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(331),i=t(337),a=t(205);n.exports=function(n){return a(n)?r(n):i(n)}},function(n,e,t){(function(n){var r=t(29),i=t(333),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,l=o&&o.exports===a?r.Buffer:void 0,s=(l?l.isBuffer:void 0)||i;n.exports=s}).call(this,t(151)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(334),i=t(335),a=t(336),o=a&&a.isTypedArray,l=o?i(o):r;n.exports=l},function(n,e,t){var r=t(195),i=t(133);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,e,t){var r=t(41)(t(29),"Set");n.exports=r},function(n,e,t){var r=t(130);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(210),i=t(102);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[i(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(27),i=t(134),a=t(348),o=t(351);n.exports=function(n,e){return r(n)?n:i(n,e)?[n]:a(o(n))}},function(n,e,t){var r=t(0),i=t(39),a=t(4),o=t(28),l=t(72),s=t(147),c=/MSIE .\./.test(o),d=r.Function,u=function(n){return c?function(e,t){var r=s(arguments.length,1)>2,o=a(e)?e:d(e),c=r?l(arguments,2):void 0;return n(r?function(){i(o,this,c)}:o,t)}:n};n.exports={setTimeout:u(r.setTimeout),setInterval:u(r.setInterval)}},function(n,e,t){"use strict";var r=t(0),i=t(2),a=t(22),o=t(11),l=t(9),s=t(72),c=t(65),d=r.Function,u=i([].concat),p=i([].join),m={},h=function(n,e,t){if(!l(m,e)){for(var r=[],i=0;i<e;i++)r[i]="a["+i+"]";m[e]=d("C,a","return new C("+p(r,",")+")")}return m[e](n,t)};n.exports=c?d.bind:function(n){var e=a(this),t=e.prototype,r=s(arguments,1),i=function(){var t=u(r,s(arguments));return this instanceof i?h(e,t.length,t):e.apply(n,t)};return o(t)&&(i.prototype=t),i}},function(n,e,t){"use strict";var r=t(1),i=t(385).start;r({target:"String",proto:!0,forced:t(387)},{padStart:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){},function(n,e,t){},function(n,e,t){t(1)({target:"Object",stat:!0},{setPrototypeOf:t(71)})},function(n,e,t){var r=t(1),i=t(15),a=t(39),o=t(212),l=t(166),s=t(10),c=t(11),d=t(35),u=t(3),p=i("Reflect","construct"),m=Object.prototype,h=[].push,g=u((function(){function n(){}return!(p((function(){}),[],n)instanceof n)})),f=!u((function(){p((function(){}))})),v=g||f;r({target:"Reflect",stat:!0,forced:v,sham:v},{construct:function(n,e){l(n),s(e);var t=arguments.length<3?n:l(arguments[2]);if(f&&!g)return p(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var r=[null];return a(h,r,e),new(a(o,n,r))}var i=t.prototype,u=d(c(i)?i:m),v=a(n,u,e);return c(v)?v:u}})},function(n,e,t){var r=t(1),i=t(0),a=t(61);r({global:!0},{Reflect:{}}),a(i.Reflect,"Reflect",!0)},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(284),i=t(289),a=t(360),o=t(368),l=t(377),s=t(236),c=a((function(n){var e=s(n);return l(e)&&(e=void 0),o(r(n,1,l,!0),i(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,i=r.exec(t);if(!i)return t;var a="",o=0,l=0;for(o=i.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}l!==o&&(a+=t.substring(l,o)),l=o+1,a+=e}return l!==o?a+t.substring(l,o):a}},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(388),t(30)),a=Object(i.a)(r,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);t(33),t(6),t(34),t(44),t(31);var r={name:"CodeGroup",data:function(){return{codeTabs:[],activeCodeTabIndex:-1}},watch:{activeCodeTabIndex:function(n){this.codeTabs.forEach((function(n){n.elm.classList.remove("theme-code-block__active")})),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted:function(){var n=this;this.codeTabs=(this.$slots.default||[]).filter((function(n){return Boolean(n.componentOptions)})).map((function(e,t){return""===e.componentOptions.propsData.active&&(n.activeCodeTabIndex=t),{title:e.componentOptions.propsData.title,elm:e.elm}})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab:function(n){this.activeCodeTabIndex=n}}},i=(t(389),t(30)),a=Object(i.a)(r,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"theme-code-group"},[t("div",{staticClass:"theme-code-group__nav"},[t("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(e,r){return t("li",{key:e.title,staticClass:"theme-code-group__li"},[t("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(e.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?t("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=a.exports},function(n,e,t){"use strict";var r=t(8),i=t(0),a=t(2),o=t(106),l=t(14),s=t(9),c=t(150),d=t(36),u=t(66),p=t(159),m=t(3),h=t(60).f,g=t(38).f,f=t(13).f,v=t(384),b=t(153).trim,y=i.Number,x=y.prototype,T=i.TypeError,k=a("".slice),w=a("".charCodeAt),I=function(n){var e=p(n,"number");return"bigint"==typeof e?e:C(e)},C=function(n){var e,t,r,i,a,o,l,s,c=p(n,"number");if(u(c))throw T("Cannot convert a Symbol value to a number");if("string"==typeof c&&c.length>2)if(c=b(c),43===(e=w(c,0))||45===e){if(88===(t=w(c,2))||120===t)return NaN}else if(48===e){switch(w(c,1)){case 66:case 98:r=2,i=49;break;case 79:case 111:r=8,i=55;break;default:return+c}for(o=(a=k(c,2)).length,l=0;l<o;l++)if((s=w(a,l))<48||s>i)return NaN;return parseInt(a,r)}return+c};if(o("Number",!y(" 0o1")||!y("0b1")||y("+0x1"))){for(var S,E=function(n){var e=arguments.length<1?0:y(I(n)),t=this;return d(x,t)&&m((function(){v(t)}))?c(Object(e),t,E):e},_=r?h(y):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),z=0;_.length>z;z++)s(y,S=_[z])&&!s(E,S)&&f(E,S,g(y,S));E.prototype=x,x.constructor=E,l(i,"Number",E)}},function(n,e,t){var r=t(3),i=t(0).RegExp;n.exports=r((function(){var n=i(".","s");return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){"use strict";var r=t(164).IteratorPrototype,i=t(35),a=t(49),o=t(61),l=t(69),s=function(){return this};n.exports=function(n,e,t,c){var d=e+" Iterator";return n.prototype=i(r,{next:a(+!c,t)}),o(n,d,!1,!0),l[d]=s,n}},function(n,e,t){var r=t(14);n.exports=function(n,e,t){for(var i in e)r(n,i,e[i],t);return n}},function(n,e,t){"use strict";var r=t(15),i=t(13),a=t(5),o=t(8),l=a("species");n.exports=function(n){var e=r(n),t=i.f;o&&e&&!e[l]&&t(e,l,{configurable:!0,get:function(){return this}})}},function(n,e,t){var r=t(0),i=t(36),a=r.TypeError;n.exports=function(n,e){if(i(e,n))return n;throw a("Incorrect invocation")}},function(n,e,t){var r=t(1),i=t(8),a=t(163),o=t(21),l=t(38),s=t(56);r({target:"Object",stat:!0,sham:!i},{getOwnPropertyDescriptors:function(n){for(var e,t,r=o(n),i=l.f,c=a(r),d={},u=0;c.length>u;)void 0!==(t=i(r,e=c[u++]))&&s(d,e,t);return d}})},function(n,e,t){var r=t(3),i=t(0).RegExp;n.exports=r((function(){var n=i("(?<a>b)","g");return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e,t){var r=t(13).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var r=t(1),i=t(116).includes,a=t(141);r({target:"Array",proto:!0},{includes:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}}),a("includes")},function(n,e,t){"use strict";var r=t(1),i=t(2),a=t(179),o=t(18),l=t(12),s=t(180),c=i("".indexOf);r({target:"String",proto:!0,forced:!s("includes")},{includes:function(n){return!!~c(l(o(this)),l(a(n)),arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var r=t(1),i=t(153).trim;r({target:"String",proto:!0,forced:t(382)("trim")},{trim:function(){return i(this)}})},function(n,e,t){var r=t(7),i=t(9),a=t(36),o=t(188),l=RegExp.prototype;n.exports=function(n){var e=n.flags;return void 0!==e||"flags"in l||i(n,"flags")||!a(l,n)?e:r(o,n)}},function(n,e,t){var r=t(124),i=Math.floor,a=function(n,e){var t=n.length,s=i(t/2);return t<8?o(n,e):l(n,a(r(n,0,s),e),a(r(n,s),e),e)},o=function(n,e){for(var t,r,i=n.length,a=1;a<i;){for(r=a,t=n[a];r&&e(n[r-1],t)>0;)n[r]=n[--r];r!==a++&&(n[r]=t)}return n},l=function(n,e,t,r){for(var i=e.length,a=t.length,o=0,l=0;o<i||l<a;)n[o+l]=o<i&&l<a?r(e[o],t[l])<=0?e[o++]:t[l++]:o<i?e[o++]:t[l++];return n};n.exports=a},function(n,e,t){var r=t(0),i=t(8),a=t(110).MISSED_STICKY,o=t(23),l=t(13).f,s=t(37).get,c=RegExp.prototype,d=r.TypeError;i&&a&&l(c,"sticky",{configurable:!0,get:function(){if(this!==c){if("RegExp"===o(this))return!!s(this).sticky;throw d("Incompatible receiver, RegExp required")}}})},function(n,e,t){n.exports=t(399)},function(n,e,t){var r=t(0),i=t(7),a=t(4),o=t(11),l=r.TypeError;n.exports=function(n,e){var t,r;if("string"===e&&a(t=n.toString)&&!o(r=i(t,n)))return r;if(a(t=n.valueOf)&&!o(r=i(t,n)))return r;if("string"!==e&&a(t=n.toString)&&!o(r=i(t,n)))return r;throw l("Can't convert object to primitive value")}},function(n,e,t){var r=t(0),i=t(4),a=t(91),o=r.WeakMap;n.exports=i(o)&&/native code/.test(a(o))},function(n,e,t){var r=t(0),i=t(4),a=r.String,o=r.TypeError;n.exports=function(n){if("object"==typeof n||i(n))return n;throw o("Can't set "+a(n)+" as a prototype")}},function(n,e,t){t(246),t(253),t(254),t(255),t(256),t(257)},function(n,e,t){"use strict";var r,i,a,o=t(1),l=t(17),s=t(93),c=t(0),d=t(7),u=t(14),p=t(228),m=t(71),h=t(61),g=t(229),f=t(22),v=t(4),b=t(11),y=t(230),x=t(121),T=t(167).set,k=t(247),w=t(250),I=t(123),C=t(251),S=t(37),E=t(55),_=t(73),z=t(74),A=_.CONSTRUCTOR,P=_.REJECTION_EVENT,R=_.SUBCLASSING,B=S.getterFor("Promise"),j=S.set,D=E&&E.prototype,M=E,L=D,O=c.TypeError,q=c.document,F=c.process,U=z.f,N=U,H=!!(q&&q.createEvent&&c.dispatchEvent),$=function(n){var e;return!(!b(n)||!v(e=n.then))&&e},Q=function(n,e){var t,r,i,a=e.value,o=1==e.state,l=o?n.ok:n.fail,s=n.resolve,c=n.reject,u=n.domain;try{l?(o||(2===e.rejection&&J(e),e.rejection=1),!0===l?t=a:(u&&u.enter(),t=l(a),u&&(u.exit(),i=!0)),t===n.promise?c(O("Promise-chain cycle")):(r=$(t))?d(r,t,s,c):s(t)):c(a)}catch(n){u&&!i&&u.exit(),c(n)}},W=function(n,e){n.notified||(n.notified=!0,k((function(){for(var t,r=n.reactions;t=r.get();)Q(t,n);n.notified=!1,e&&!n.rejection&&K(n)})))},G=function(n,e,t){var r,i;H?((r=q.createEvent("Event")).promise=e,r.reason=t,r.initEvent(n,!1,!0),c.dispatchEvent(r)):r={promise:e,reason:t},!P&&(i=c["on"+n])?i(r):"unhandledrejection"===n&&w("Unhandled promise rejection",t)},K=function(n){d(T,c,(function(){var e,t=n.facade,r=n.value;if(V(n)&&(e=I((function(){s?F.emit("unhandledRejection",r,t):G("unhandledrejection",t,r)})),n.rejection=s||V(n)?2:1,e.error))throw e.value}))},V=function(n){return 1!==n.rejection&&!n.parent},J=function(n){d(T,c,(function(){var e=n.facade;s?F.emit("rejectionHandled",e):G("rejectionhandled",e,n.value)}))},Z=function(n,e,t){return function(r){n(e,r,t)}},X=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,W(n,!0))},Y=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw O("Promise can't be resolved itself");var r=$(e);r?k((function(){var t={done:!1};try{d(r,e,Z(Y,t,n),Z(X,t,n))}catch(e){X(t,e,n)}})):(n.value=e,n.state=1,W(n,!1))}catch(e){X({done:!1},e,n)}}};if(A&&(L=(M=function(n){y(this,L),f(n),d(r,this);var e=B(this);try{n(Z(Y,e),Z(X,e))}catch(n){X(e,n)}}).prototype,(r=function(n){j(this,{type:"Promise",done:!1,notified:!1,parent:!1,reactions:new C,rejection:!1,state:0,value:void 0})}).prototype=p(L,{then:function(n,e){var t=B(this),r=U(x(this,M));return t.parent=!0,r.ok=!v(n)||n,r.fail=v(e)&&e,r.domain=s?F.domain:void 0,0==t.state?t.reactions.add(r):k((function(){Q(r,t)})),r.promise}}),i=function(){var n=new r,e=B(n);this.promise=n,this.resolve=Z(Y,e),this.reject=Z(X,e)},z.f=U=function(n){return n===M||void 0===n?new i(n):N(n)},!l&&v(E)&&D!==Object.prototype)){a=D.then,R||u(D,"then",(function(n,e){var t=this;return new M((function(n,e){d(a,t,n,e)})).then(n,e)}),{unsafe:!0});try{delete D.constructor}catch(n){}m&&m(D,L)}o({global:!0,wrap:!0,forced:A},{Promise:M}),h(M,"Promise",!1,!0),g("Promise")},function(n,e,t){var r,i,a,o,l,s,c,d,u=t(0),p=t(58),m=t(38).f,h=t(167).set,g=t(168),f=t(248),v=t(249),b=t(93),y=u.MutationObserver||u.WebKitMutationObserver,x=u.document,T=u.process,k=u.Promise,w=m(u,"queueMicrotask"),I=w&&w.value;I||(r=function(){var n,e;for(b&&(n=T.domain)&&n.exit();i;){e=i.fn,i=i.next;try{e()}catch(n){throw i?o():a=void 0,n}}a=void 0,n&&n.enter()},g||b||v||!y||!x?!f&&k&&k.resolve?((c=k.resolve(void 0)).constructor=k,d=p(c.then,c),o=function(){d(r)}):b?o=function(){T.nextTick(r)}:(h=p(h,u),o=function(){h(r)}):(l=!0,s=x.createTextNode(""),new y(r).observe(s,{characterData:!0}),o=function(){s.data=l=!l})),n.exports=I||function(n){var e={fn:n,next:void 0};a&&(a.next=e),i||(i=e,o()),a=e}},function(n,e,t){var r=t(28),i=t(0);n.exports=/ipad|iphone|ipod/i.test(r)&&void 0!==i.Pebble},function(n,e,t){var r=t(28);n.exports=/web0s(?!.*chrome)/i.test(r)},function(n,e,t){var r=t(0);n.exports=function(n,e){var t=r.console;t&&t.error&&(1==arguments.length?t.error(n):t.error(n,e))}},function(n,e){var t=function(){this.head=null,this.tail=null};t.prototype={add:function(n){var e={item:n,next:null};this.head?this.tail.next=e:this.head=e,this.tail=e},get:function(){var n=this.head;if(n)return this.head=n.next,this.tail===n&&(this.tail=null),n.item}},n.exports=t},function(n,e){n.exports="object"==typeof window&&"object"!=typeof Deno},function(n,e,t){"use strict";var r=t(1),i=t(7),a=t(22),o=t(74),l=t(123),s=t(169);r({target:"Promise",stat:!0,forced:t(172)},{all:function(n){var e=this,t=o.f(e),r=t.resolve,c=t.reject,d=l((function(){var t=a(e.resolve),o=[],l=0,d=1;s(n,(function(n){var a=l++,s=!1;d++,i(t,e,n).then((function(n){s||(s=!0,o[a]=n,--d||r(o))}),c)})),--d||r(o)}));return d.error&&c(d.value),t.promise}})},function(n,e,t){"use strict";var r=t(1),i=t(17),a=t(73).CONSTRUCTOR,o=t(55),l=t(15),s=t(4),c=t(14),d=o&&o.prototype;if(r({target:"Promise",proto:!0,forced:a,real:!0},{catch:function(n){return this.then(void 0,n)}}),!i&&s(o)){var u=l("Promise").prototype.catch;d.catch!==u&&c(d,"catch",u,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(1),i=t(7),a=t(22),o=t(74),l=t(123),s=t(169);r({target:"Promise",stat:!0,forced:t(172)},{race:function(n){var e=this,t=o.f(e),r=t.reject,c=l((function(){var o=a(e.resolve);s(n,(function(n){i(o,e,n).then(t.resolve,r)}))}));return c.error&&r(c.value),t.promise}})},function(n,e,t){"use strict";var r=t(1),i=t(7),a=t(74);r({target:"Promise",stat:!0,forced:t(73).CONSTRUCTOR},{reject:function(n){var e=a.f(this);return i(e.reject,void 0,n),e.promise}})},function(n,e,t){"use strict";var r=t(1),i=t(15),a=t(17),o=t(55),l=t(73).CONSTRUCTOR,s=t(174),c=i("Promise"),d=a&&!l;r({target:"Promise",stat:!0,forced:a||l},{resolve:function(n){return s(d&&this===c?o:this,n)}})},function(n,e,t){var r=t(1),i=t(259);r({target:"Object",stat:!0,forced:Object.assign!==i},{assign:i})},function(n,e,t){"use strict";var r=t(8),i=t(2),a=t(7),o=t(3),l=t(88),s=t(92),c=t(118),d=t(16),u=t(64),p=Object.assign,m=Object.defineProperty,h=i([].concat);n.exports=!p||o((function(){if(r&&1!==p({b:1},p(m({},"a",{enumerable:!0,get:function(){m(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=p({},n)[t]||"abcdefghijklmnopqrst"!=l(p({},e)).join("")}))?function(n,e){for(var t=d(n),i=arguments.length,o=1,p=s.f,m=c.f;i>o;)for(var g,f=u(arguments[o++]),v=p?h(l(f),p(f)):l(f),b=v.length,y=0;b>y;)g=v[y++],r&&!a(m,f,g)||(t[g]=f[g]);return t}:p},function(n,e,t){"use strict";var r=t(1),i=t(17),a=t(55),o=t(3),l=t(15),s=t(4),c=t(121),d=t(174),u=t(14),p=a&&a.prototype;if(r({target:"Promise",proto:!0,real:!0,forced:!!a&&o((function(){p.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=c(this,l("Promise")),t=s(n);return this.then(t?function(t){return d(e,n()).then((function(){return t}))}:n,t?function(t){return d(e,n()).then((function(){throw t}))}:n)}}),!i&&s(a)){var m=l("Promise").prototype.finally;p.finally!==m&&u(p,"finally",m,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(122),i=t(82);n.exports=r?{}.toString:function(){return"[object "+i(this)+"]"}},function(n,e,t){var r=t(0),i=t(62),a=t(94),o=t(11),l=t(5)("species"),s=r.Array;n.exports=function(n){var e;return i(n)&&(e=n.constructor,(a(e)&&(e===s||i(e.prototype))||o(e)&&null===(e=e[l]))&&(e=void 0)),void 0===e?s:e}},function(n,e,t){"use strict";var r=t(1),i=t(264).left,a=t(47),o=t(53),l=t(93);r({target:"Array",proto:!0,forced:!a("reduce")||!l&&o>79&&o<83},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(0),i=t(22),a=t(16),o=t(64),l=t(20),s=r.TypeError,c=function(n){return function(e,t,r,c){i(t);var d=a(e),u=o(d),p=l(d),m=n?p-1:0,h=n?-1:1;if(r<2)for(;;){if(m in u){c=u[m],m+=h;break}if(m+=h,n?m<0:p<=m)throw s("Reduce of empty array with no initial value")}for(;n?m>=0:p>m;m+=h)m in u&&(c=t(c,u[m],m,d));return c}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var r,i=t(1),a=t(2),o=t(38).f,l=t(54),s=t(12),c=t(179),d=t(18),u=t(180),p=t(17),m=a("".startsWith),h=a("".slice),g=Math.min,f=u("startsWith");i({target:"String",proto:!0,forced:!!(p||f||(r=o(String.prototype,"startsWith"),!r||r.writable))&&!f},{startsWith:function(n){var e=s(d(this));c(n);var t=l(g(arguments.length>1?arguments[1]:void 0,e.length)),r=s(n);return m?m(e,r,t):h(e,t,t+r.length)===r}})},function(n,e,t){var r=t(1),i=t(182),a=t(3),o=t(11),l=t(267).onFreeze,s=Object.freeze;r({target:"Object",stat:!0,forced:a((function(){s(1)})),sham:!i},{freeze:function(n){return s&&o(n)?s(l(n)):n}})},function(n,e,t){var r=t(1),i=t(2),a=t(68),o=t(11),l=t(9),s=t(13).f,c=t(60),d=t(183),u=t(268),p=t(85),m=t(182),h=!1,g=p("meta"),f=0,v=function(n){s(n,g,{value:{objectID:"O"+f++,weakData:{}}})},b=n.exports={enable:function(){b.enable=function(){},h=!0;var n=c.f,e=i([].splice),t={};t[g]=1,n(t).length&&(c.f=function(t){for(var r=n(t),i=0,a=r.length;i<a;i++)if(r[i]===g){e(r,i,1);break}return r},r({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:d.f}))},fastKey:function(n,e){if(!o(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!l(n,g)){if(!u(n))return"F";if(!e)return"E";v(n)}return n[g].objectID},getWeakData:function(n,e){if(!l(n,g)){if(!u(n))return!0;if(!e)return!1;v(n)}return n[g].weakData},onFreeze:function(n){return m&&h&&u(n)&&!l(n,g)&&v(n),n}};a[g]=!0},function(n,e,t){var r=t(3),i=t(11),a=t(23),o=t(269),l=Object.isExtensible,s=r((function(){l(1)}));n.exports=s||o?function(n){return!!i(n)&&((!o||"ArrayBuffer"!=a(n))&&(!l||l(n)))}:l},function(n,e,t){var r=t(3);n.exports=r((function(){if("function"==typeof ArrayBuffer){var n=new ArrayBuffer(8);Object.isExtensible(n)&&Object.defineProperty(n,"a",{value:8})}}))},function(n,e,t){"use strict";var r=t(1),i=t(0),a=t(7),o=t(2),l=t(17),s=t(8),c=t(52),d=t(3),u=t(9),p=t(36),m=t(10),h=t(21),g=t(87),f=t(12),v=t(49),b=t(35),y=t(88),x=t(60),T=t(183),k=t(92),w=t(38),I=t(13),C=t(146),S=t(118),E=t(14),_=t(51),z=t(90),A=t(68),P=t(85),R=t(5),B=t(184),j=t(185),D=t(272),M=t(61),L=t(37),O=t(59).forEach,q=z("hidden"),F=L.set,U=L.getterFor("Symbol"),N=Object.prototype,H=i.Symbol,$=H&&H.prototype,Q=i.TypeError,W=i.QObject,G=w.f,K=I.f,V=T.f,J=S.f,Z=o([].push),X=_("symbols"),Y=_("op-symbols"),nn=_("wks"),en=!W||!W.prototype||!W.prototype.findChild,tn=s&&d((function(){return 7!=b(K({},"a",{get:function(){return K(this,"a",{value:7}).a}})).a}))?function(n,e,t){var r=G(N,e);r&&delete N[e],K(n,e,t),r&&n!==N&&K(N,e,r)}:K,rn=function(n,e){var t=X[n]=b($);return F(t,{type:"Symbol",tag:n,description:e}),s||(t.description=e),t},an=function(n,e,t){n===N&&an(Y,e,t),m(n);var r=g(e);return m(t),u(X,r)?(t.enumerable?(u(n,q)&&n[q][r]&&(n[q][r]=!1),t=b(t,{enumerable:v(0,!1)})):(u(n,q)||K(n,q,v(1,{})),n[q][r]=!0),tn(n,r,t)):K(n,r,t)},on=function(n,e){m(n);var t=h(e),r=y(t).concat(dn(t));return O(r,(function(e){s&&!a(ln,t,e)||an(n,e,t[e])})),n},ln=function(n){var e=g(n),t=a(J,this,e);return!(this===N&&u(X,e)&&!u(Y,e))&&(!(t||!u(this,e)||!u(X,e)||u(this,q)&&this[q][e])||t)},sn=function(n,e){var t=h(n),r=g(e);if(t!==N||!u(X,r)||u(Y,r)){var i=G(t,r);return!i||!u(X,r)||u(t,q)&&t[q][r]||(i.enumerable=!0),i}},cn=function(n){var e=V(h(n)),t=[];return O(e,(function(n){u(X,n)||u(A,n)||Z(t,n)})),t},dn=function(n){var e=n===N,t=V(e?Y:h(n)),r=[];return O(t,(function(n){!u(X,n)||e&&!u(N,n)||Z(r,X[n])})),r};c||(E($=(H=function(){if(p($,this))throw Q("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?f(arguments[0]):void 0,e=P(n),t=function(n){this===N&&a(t,Y,n),u(this,q)&&u(this[q],e)&&(this[q][e]=!1),tn(this,e,v(1,n))};return s&&en&&tn(N,e,{configurable:!0,set:t}),rn(e,n)}).prototype,"toString",(function(){return U(this).tag})),E(H,"withoutSetter",(function(n){return rn(P(n),n)})),S.f=ln,I.f=an,C.f=on,w.f=sn,x.f=T.f=cn,k.f=dn,B.f=function(n){return rn(R(n),n)},s&&(K($,"description",{configurable:!0,get:function(){return U(this).description}}),l||E(N,"propertyIsEnumerable",ln,{unsafe:!0}))),r({global:!0,wrap:!0,forced:!c,sham:!c},{Symbol:H}),O(y(nn),(function(n){j(n)})),r({target:"Symbol",stat:!0,forced:!c},{useSetter:function(){en=!0},useSimple:function(){en=!1}}),r({target:"Object",stat:!0,forced:!c,sham:!s},{create:function(n,e){return void 0===e?b(n):on(b(n),e)},defineProperty:an,defineProperties:on,getOwnPropertyDescriptor:sn}),r({target:"Object",stat:!0,forced:!c},{getOwnPropertyNames:cn}),D(),M(H,"Symbol"),A[q]=!0},function(n,e,t){var r=t(0);n.exports=r},function(n,e,t){var r=t(7),i=t(15),a=t(5),o=t(14);n.exports=function(){var n=i("Symbol"),e=n&&n.prototype,t=e&&e.valueOf,l=a("toPrimitive");e&&!e[l]&&o(e,l,(function(n){return r(t,this)}))}},function(n,e,t){var r=t(1),i=t(15),a=t(9),o=t(12),l=t(51),s=t(186),c=l("string-to-symbol-registry"),d=l("symbol-to-string-registry");r({target:"Symbol",stat:!0,forced:!s},{for:function(n){var e=o(n);if(a(c,e))return c[e];var t=i("Symbol")(e);return c[e]=t,d[t]=e,t}})},function(n,e,t){var r=t(1),i=t(9),a=t(66),o=t(67),l=t(51),s=t(186),c=l("symbol-to-string-registry");r({target:"Symbol",stat:!0,forced:!s},{keyFor:function(n){if(!a(n))throw TypeError(o(n)+" is not a symbol");if(i(c,n))return c[n]}})},function(n,e,t){var r=t(1),i=t(52),a=t(3),o=t(92),l=t(16);r({target:"Object",stat:!0,forced:!i||a((function(){o.f(1)}))},{getOwnPropertySymbols:function(n){var e=o.f;return e?e(l(n)):[]}})},function(n,e,t){"use strict";var r=t(0),i=t(58),a=t(7),o=t(16),l=t(277),s=t(170),c=t(94),d=t(20),u=t(56),p=t(148),m=t(107),h=r.Array;n.exports=function(n){var e=o(n),t=c(this),r=arguments.length,g=r>1?arguments[1]:void 0,f=void 0!==g;f&&(g=i(g,r>2?arguments[2]:void 0));var v,b,y,x,T,k,w=m(e),I=0;if(!w||this==h&&s(w))for(v=d(e),b=t?new this(v):h(v);v>I;I++)k=f?g(e[I],I):e[I],u(b,I,k);else for(T=(x=p(e,w)).next,b=t?new this:[];!(y=a(T,x)).done;I++)k=f?l(x,g,[y.value,I],!0):y.value,u(b,I,k);return b.length=I,b}},function(n,e,t){var r=t(10),i=t(171);n.exports=function(n,e,t,a){try{return a?e(r(t)[0],t[1]):e(t)}catch(e){i(n,"throw",e)}}},function(n,e,t){"use strict";var r=t(15),i=t(9),a=t(24),o=t(36),l=t(71),s=t(119),c=t(233),d=t(150),u=t(189),p=t(279),m=t(280),h=t(281),g=t(8),f=t(17);n.exports=function(n,e,t,v){var b=v?2:1,y=n.split("."),x=y[y.length-1],T=r.apply(null,y);if(T){var k=T.prototype;if(!f&&i(k,"cause")&&delete k.cause,!t)return T;var w=r("Error"),I=e((function(n,e){var t=u(v?e:n,void 0),r=v?new T(n):new T;return void 0!==t&&a(r,"message",t),h&&a(r,"stack",m(r.stack,2)),this&&o(k,this)&&d(r,this,I),arguments.length>b&&p(r,arguments[b]),r}));if(I.prototype=k,"Error"!==x?l?l(I,w):s(I,w,{name:!0}):g&&"stackTraceLimit"in T&&(c(I,T,"stackTraceLimit"),c(I,T,"prepareStackTrace")),s(I,T),!f)try{k.name!==x&&a(k,"name",x),k.constructor=I}catch(n){}return I}}},function(n,e,t){var r=t(11),i=t(24);n.exports=function(n,e){r(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){var r=t(2),i=Error,a=r("".replace),o=String(i("zxcasd").stack),l=/\n\s*at [^:]*:[^\n]*/,s=l.test(o);n.exports=function(n,e){if(s&&"string"==typeof n&&!i.prepareStackTrace)for(;e--;)n=a(n,l,"");return n}},function(n,e,t){var r=t(3),i=t(49);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var r=t(8),i=t(3),a=t(10),o=t(35),l=t(189),s=Error.prototype.toString,c=i((function(){if(r){var n=o(Object.defineProperty({},"name",{get:function(){return this===n}}));if("true"!==s.call(n))return!0}return"2: 1"!==s.call({message:1,name:2})||"Error"!==s.call({})}));n.exports=c?function(){var n=a(this),e=l(n.name,"Error"),t=l(n.message);return e?t?e+": "+t:e:t}:s},function(n,e,t){var r=t(2),i=t(16),a=Math.floor,o=r("".charAt),l=r("".replace),s=r("".slice),c=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,d=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,r,u,p){var m=t+n.length,h=r.length,g=d;return void 0!==u&&(u=i(u),g=c),l(p,g,(function(i,l){var c;switch(o(l,0)){case"$":return"$";case"&":return n;case"`":return s(e,0,t);case"'":return s(e,m);case"<":c=u[s(l,1,-1)];break;default:var d=+l;if(0===d)return i;if(d>h){var p=a(d/10);return 0===p?i:p<=h?void 0===r[p-1]?o(l,1):r[p-1]+o(l,1):i}c=r[d-1]}return void 0===c?"":c}))}},function(n,e,t){var r=t(191),i=t(285);n.exports=function n(e,t,a,o,l){var s=-1,c=e.length;for(a||(a=i),l||(l=[]);++s<c;){var d=e[s];t>0&&a(d)?t>1?n(d,t-1,a,o,l):r(l,d):o||(l[l.length]=d)}return l}},function(n,e,t){var r=t(76),i=t(128),a=t(27),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||i(n)||!!(o&&n&&n[o])}},function(n,e,t){var r=t(63),i=t(50);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(76),i=Object.prototype,a=i.hasOwnProperty,o=i.toString,l=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,l),t=n[l];try{n[l]=void 0;var r=!0}catch(n){}var i=o.call(n);return r&&(e?n[l]=t:delete n[l]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(290),i=t(346),a=t(136),o=t(27),l=t(357);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?o(n)?i(n[0],n[1]):r(n):l(n)}},function(n,e,t){var r=t(291),i=t(345),a=t(208);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(193),i=t(197);n.exports=function(n,e,t,a){var o=t.length,l=o,s=!a;if(null==n)return!l;for(n=Object(n);o--;){var c=t[o];if(s&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<l;){var d=(c=t[o])[0],u=n[d],p=c[1];if(s&&c[2]){if(void 0===u&&!(d in n))return!1}else{var m=new r;if(a)var h=a(u,p,d,n,e,m);if(!(void 0===h?i(p,u,3,a,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(99),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(99);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(99);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(99);n.exports=function(n,e){var t=this.__data__,i=r(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var r=t(98);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(98),i=t(129),a=t(131);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var o=t.__data__;if(!i||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(195),i=t(303),a=t(130),o=t(196),l=/^\[object .+?Constructor\]$/,s=Function.prototype,c=Object.prototype,d=s.toString,u=c.hasOwnProperty,p=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||i(n))&&(r(n)?p:l).test(o(n))}},function(n,e,t){var r,i=t(304),a=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(29)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(307),i=t(98),a=t(129);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||i),string:new r}}},function(n,e,t){var r=t(308),i=t(309),a=t(310),o=t(311),l=t(312);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}s.prototype.clear=r,s.prototype.delete=i,s.prototype.get=a,s.prototype.has=o,s.prototype.set=l,n.exports=s},function(n,e,t){var r=t(100);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(100),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(100),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var r=t(100);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(101);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(101);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(101);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(101);n.exports=function(n,e){var t=r(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var r=t(193),i=t(198),a=t(322),o=t(325),l=t(341),s=t(27),c=t(202),d=t(204),u="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,g){var f=s(n),v=s(e),b=f?"[object Array]":l(n),y=v?"[object Array]":l(e),x=(b="[object Arguments]"==b?u:b)==u,T=(y="[object Arguments]"==y?u:y)==u,k=b==y;if(k&&c(n)){if(!c(e))return!1;f=!0,x=!1}if(k&&!x)return g||(g=new r),f||d(n)?i(n,e,t,m,h,g):a(n,e,b,t,m,h,g);if(!(1&t)){var w=x&&p.call(n,"__wrapped__"),I=T&&p.call(e,"__wrapped__");if(w||I){var C=w?n.value():n,S=I?e.value():e;return g||(g=new r),h(C,S,t,m,g)}}return!!k&&(g||(g=new r),o(n,e,t,m,h,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(76),i=t(323),a=t(194),o=t(198),l=t(324),s=t(132),c=r?r.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,u,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=l;case"[object Set]":var h=1&r;if(m||(m=s),n.size!=e.size&&!h)return!1;var g=p.get(n);if(g)return g==e;r|=2,p.set(n,e);var f=o(m(n),m(e),r,c,u,p);return p.delete(n),f;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var r=t(29).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(326),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,o,l){var s=1&t,c=r(n),d=c.length;if(d!=r(e).length&&!s)return!1;for(var u=d;u--;){var p=c[u];if(!(s?p in e:i.call(e,p)))return!1}var m=l.get(n),h=l.get(e);if(m&&h)return m==e&&h==n;var g=!0;l.set(n,e),l.set(e,n);for(var f=s;++u<d;){var v=n[p=c[u]],b=e[p];if(a)var y=s?a(b,v,p,e,n,l):a(v,b,p,n,e,l);if(!(void 0===y?v===b||o(v,b,t,a,l):y)){g=!1;break}f||(f="constructor"==p)}if(g&&!f){var x=n.constructor,T=e.constructor;x==T||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof T&&T instanceof T||(g=!1)}return l.delete(n),l.delete(e),g}},function(n,e,t){var r=t(327),i=t(328),a=t(201);n.exports=function(n){return r(n,a,i)}},function(n,e,t){var r=t(191),i=t(27);n.exports=function(n,e,t){var a=e(n);return i(n)?a:r(a,t(n))}},function(n,e,t){var r=t(329),i=t(330),a=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,l=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(e){return a.call(n,e)})))}:i;n.exports=l},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=0,a=[];++t<r;){var o=n[t];e(o,t,n)&&(a[i++]=o)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(332),i=t(128),a=t(27),o=t(202),l=t(203),s=t(204),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),d=!t&&i(n),u=!t&&!d&&o(n),p=!t&&!d&&!u&&s(n),m=t||d||u||p,h=m?r(n.length,String):[],g=h.length;for(var f in n)!e&&!c.call(n,f)||m&&("length"==f||u&&("offset"==f||"parent"==f)||p&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||l(f,g))||h.push(f);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(63),i=t(133),a=t(50),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&i(n.length)&&!!o[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(192),i=e&&!e.nodeType&&e,a=i&&"object"==typeof n&&n&&!n.nodeType&&n,o=a&&a.exports===i&&r.process,l=function(){try{var n=a&&a.require&&a.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=l}).call(this,t(151)(n))},function(n,e,t){var r=t(338),i=t(339),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(340)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(342),i=t(129),a=t(343),o=t(206),l=t(344),s=t(63),c=t(196),d=c(r),u=c(i),p=c(a),m=c(o),h=c(l),g=s;(r&&"[object DataView]"!=g(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=g(new i)||a&&"[object Promise]"!=g(a.resolve())||o&&"[object Set]"!=g(new o)||l&&"[object WeakMap]"!=g(new l))&&(g=function(n){var e=s(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case d:return"[object DataView]";case u:return"[object Map]";case p:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var r=t(41)(t(29),"DataView");n.exports=r},function(n,e,t){var r=t(41)(t(29),"Promise");n.exports=r},function(n,e,t){var r=t(41)(t(29),"WeakMap");n.exports=r},function(n,e,t){var r=t(207),i=t(201);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var a=e[t],o=n[a];e[t]=[a,o,r(o)]}return e}},function(n,e,t){var r=t(197),i=t(347),a=t(354),o=t(134),l=t(207),s=t(208),c=t(102);n.exports=function(n,e){return o(n)&&l(e)?s(c(n),e):function(t){var o=i(t,n);return void 0===o&&o===e?a(t,n):r(e,o,3)}}},function(n,e,t){var r=t(209);n.exports=function(n,e,t){var i=null==n?void 0:r(n,e);return void 0===i?t:i}},function(n,e,t){var r=t(349),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,o=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,r,i){e.push(r?i.replace(a,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var r=t(350);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(131);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,i=e?e.apply(this,r):r[0],a=t.cache;if(a.has(i))return a.get(i);var o=n.apply(this,r);return t.cache=a.set(i,o)||a,o};return t.cache=new(i.Cache||r),t}i.Cache=r,n.exports=i},function(n,e,t){var r=t(352);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(76),i=t(353),a=t(27),o=t(135),l=r?r.prototype:void 0,s=l?l.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return i(e,n)+"";if(o(e))return s?s.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=Array(r);++t<r;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var r=t(355),i=t(356);n.exports=function(n,e){return null!=n&&i(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(210),i=t(128),a=t(27),o=t(203),l=t(133),s=t(102);n.exports=function(n,e,t){for(var c=-1,d=(e=r(e,n)).length,u=!1;++c<d;){var p=s(e[c]);if(!(u=null!=n&&t(n,p)))break;n=n[p]}return u||++c!=d?u:!!(d=null==n?0:n.length)&&l(d)&&o(p,d)&&(a(n)||i(n))}},function(n,e,t){var r=t(358),i=t(359),a=t(134),o=t(102);n.exports=function(n){return a(n)?r(o(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(209);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(136),i=t(361),a=t(363);n.exports=function(n,e){return a(i(n,e,r),n+"")}},function(n,e,t){var r=t(362),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var a=arguments,o=-1,l=i(a.length-e,0),s=Array(l);++o<l;)s[o]=a[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=a[o];return c[e]=t(s),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(364),i=t(367)(r);n.exports=i},function(n,e,t){var r=t(365),i=t(366),a=t(136),o=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(41),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var i=t(),a=16-(i-r);if(r=i,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(199),i=t(369),a=t(374),o=t(200),l=t(375),s=t(132);n.exports=function(n,e,t){var c=-1,d=i,u=n.length,p=!0,m=[],h=m;if(t)p=!1,d=a;else if(u>=200){var g=e?null:l(n);if(g)return s(g);p=!1,d=o,h=new r}else h=e?[]:m;n:for(;++c<u;){var f=n[c],v=e?e(f):f;if(f=t||0!==f?f:0,p&&v==v){for(var b=h.length;b--;)if(h[b]===v)continue n;e&&h.push(v),m.push(f)}else d(h,v,t)||(h!==m&&h.push(v),m.push(f))}return m}},function(n,e,t){var r=t(370);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(371),i=t(372),a=t(373);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,i,t)}},function(n,e){n.exports=function(n,e,t,r){for(var i=n.length,a=t+(r?1:-1);r?a--:++a<i;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,i=n.length;++r<i;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,i=null==n?0:n.length;++r<i;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(206),i=t(376),a=t(132),o=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(205),i=t(50);n.exports=function(n){return i(n)&&r(n)}},function(n,e,t){var r=t(1),i=t(0),a=t(211).setInterval;r({global:!0,bind:!0,forced:i.setInterval!==a},{setInterval:a})},function(n,e,t){var r=t(1),i=t(0),a=t(211).setTimeout;r({global:!0,bind:!0,forced:i.setTimeout!==a},{setTimeout:a})},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(70).PROPER,i=t(3),a=t(154);n.exports=function(n){return i((function(){return!!a[n]()||"​᠎"!=="​᠎"[n]()||r&&a[n].name!==n}))}},function(n,e,t){var r=t(1),i=t(212);r({target:"Function",proto:!0,forced:Function.bind!==i},{bind:i})},function(n,e,t){var r=t(2);n.exports=r(1..valueOf)},function(n,e,t){var r=t(2),i=t(54),a=t(12),o=t(386),l=t(18),s=r(o),c=r("".slice),d=Math.ceil,u=function(n){return function(e,t,r){var o,u,p=a(l(e)),m=i(t),h=p.length,g=void 0===r?" ":a(r);return m<=h||""==g?p:((u=s(g,d((o=m-h)/g.length))).length>o&&(u=c(u,0,o)),n?p+u:u+p)}};n.exports={start:u(!1),end:u(!0)}},function(n,e,t){"use strict";var r=t(0),i=t(46),a=t(12),o=t(18),l=r.RangeError;n.exports=function(n){var e=a(o(this)),t="",r=i(n);if(r<0||r==1/0)throw l("Wrong number of repetitions");for(;r>0;(r>>>=1)&&(e+=e))1&r&&(t+=e);return t}},function(n,e,t){var r=t(28);n.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(r)},function(n,e,t){"use strict";t(214)},function(n,e,t){"use strict";t(215)},function(n,e,t){"use strict";var r=t(1),i=t(2),a=t(22),o=t(16),l=t(20),s=t(12),c=t(3),d=t(239),u=t(47),p=t(391),m=t(392),h=t(53),g=t(393),f=[],v=i(f.sort),b=i(f.push),y=c((function(){f.sort(void 0)})),x=c((function(){f.sort(null)})),T=u("sort"),k=!c((function(){if(h)return h<70;if(!(p&&p>3)){if(m)return!0;if(g)return g<603;var n,e,t,r,i="";for(n=65;n<76;n++){switch(e=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:t=3;break;case 68:case 71:t=4;break;default:t=2}for(r=0;r<47;r++)f.push({k:e+r,v:t})}for(f.sort((function(n,e){return e.v-n.v})),r=0;r<f.length;r++)e=f[r].k.charAt(0),i.charAt(i.length-1)!==e&&(i+=e);return"DGBEFHACIJK"!==i}}));r({target:"Array",proto:!0,forced:y||!x||!T||!k},{sort:function(n){void 0!==n&&a(n);var e=o(this);if(k)return void 0===n?v(e):v(e,n);var t,r,i=[],c=l(e);for(r=0;r<c;r++)r in e&&b(i,e[r]);for(d(i,function(n){return function(e,t){return void 0===t?-1:void 0===e?1:void 0!==n?+n(e,t)||0:s(e)>s(t)?1:-1}}(n)),t=i.length,r=0;r<t;)e[r]=i[r++];for(;r<c;)delete e[r++];return e}})},function(n,e,t){var r=t(28).match(/firefox\/(\d+)/i);n.exports=!!r&&+r[1]},function(n,e,t){var r=t(28);n.exports=/MSIE|Trident/.test(r)},function(n,e,t){var r=t(28).match(/AppleWebKit\/(\d+)\./);n.exports=!!r&&+r[1]},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";var r=t(1),i=t(0),a=t(89),o=t(46),l=t(20),s=t(16),c=t(108),d=t(56),u=t(75)("splice"),p=i.TypeError,m=Math.max,h=Math.min;r({target:"Array",proto:!0,forced:!u},{splice:function(n,e){var t,r,i,u,g,f,v=s(this),b=l(v),y=a(n,b),x=arguments.length;if(0===x?t=r=0:1===x?(t=0,r=b-y):(t=x-2,r=h(m(o(e),0),b-y)),b+t-r>9007199254740991)throw p("Maximum allowed length exceeded");for(i=c(v,r),u=0;u<r;u++)(g=y+u)in v&&d(i,u,v[g]);if(i.length=r,t<r){for(u=y;u<b-r;u++)f=u+t,(g=u+r)in v?v[f]=v[g]:delete v[f];for(u=b;u>b-r+t;u--)delete v[u-1]}else if(t>r)for(u=b-r;u>y;u--)f=u+t-1,(g=u+r-1)in v?v[f]=v[g]:delete v[f];for(u=0;u<t;u++)v[u+y]=arguments[u+2];return v.length=b-r+t,i}})},function(n,e,t){"use strict";t(219)},function(n,e,t){"use strict";t(220)},function(n,e,t){"use strict";t.r(e);t(145),t(245),t(258),t(260);var r=t(95),i=(t(142),t(57),t(6),t(25),t(32),t(44),t(31),Object.freeze({}));function a(n){return null==n}function o(n){return null!=n}function l(n){return!0===n}function s(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function u(n){return"[object Object]"===d.call(n)}function p(n){return"[object RegExp]"===d.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function f(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),r=n.split(","),i=0;i<r.length;i++)t[r[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var b=v("key,ref,slot,slot-scope,is");function y(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var x=Object.prototype.hasOwnProperty;function T(n,e){return x.call(n,e)}function k(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var w=/-(\w)/g,I=k((function(n){return n.replace(w,(function(n,e){return e?e.toUpperCase():""}))})),C=k((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),S=/\B([A-Z])/g,E=k((function(n){return n.replace(S,"-$1").toLowerCase()}));var _=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function z(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function A(n,e){for(var t in e)n[t]=e[t];return n}function P(n){for(var e={},t=0;t<n.length;t++)n[t]&&A(e,n[t]);return e}function R(n,e,t){}var B=function(n,e,t){return!1},j=function(n){return n};function D(n,e){if(n===e)return!0;var t=c(n),r=c(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var i=Array.isArray(n),a=Array.isArray(e);if(i&&a)return n.length===e.length&&n.every((function(n,t){return D(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||a)return!1;var o=Object.keys(n),l=Object.keys(e);return o.length===l.length&&o.every((function(t){return D(n[t],e[t])}))}catch(n){return!1}}function M(n,e){for(var t=0;t<n.length;t++)if(D(n[t],e))return t;return-1}function L(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var O=["component","directive","filter"],q=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:B,isReservedAttr:B,isUnknownElement:B,getTagNamespace:R,parsePlatformTagName:j,mustUseProp:B,async:!0,_lifecycleHooks:q},U=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function N(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var H=new RegExp("[^"+U.source+".$_\\d]");var $,Q="__proto__"in{},W="undefined"!=typeof window,G="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,K=G&&WXEnvironment.platform.toLowerCase(),V=W&&window.navigator.userAgent.toLowerCase(),J=V&&/msie|trident/.test(V),Z=V&&V.indexOf("msie 9.0")>0,X=V&&V.indexOf("edge/")>0,Y=(V&&V.indexOf("android"),V&&/iphone|ipad|ipod|ios/.test(V)||"ios"===K),nn=(V&&/chrome\/\d+/.test(V),V&&/phantomjs/.test(V),V&&V.match(/firefox\/(\d+)/)),en={}.watch,tn=!1;if(W)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){tn=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var an=function(){return void 0===$&&($=!W&&!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),$},on=W&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var sn,cn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);sn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=R,un=0,pn=function(){this.id=un++,this.subs=[]};pn.prototype.addSub=function(n){this.subs.push(n)},pn.prototype.removeSub=function(n){y(this.subs,n)},pn.prototype.depend=function(){pn.target&&pn.target.addDep(this)},pn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},pn.target=null;var mn=[];function hn(n){mn.push(n),pn.target=n}function gn(){mn.pop(),pn.target=mn[mn.length-1]}var fn=function(n,e,t,r,i,a,o,l){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=i,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=l,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},vn={child:{configurable:!0}};vn.child.get=function(){return this.componentInstance},Object.defineProperties(fn.prototype,vn);var bn=function(n){void 0===n&&(n="");var e=new fn;return e.text=n,e.isComment=!0,e};function yn(n){return new fn(void 0,void 0,void 0,String(n))}function xn(n){var e=new fn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var Tn=Array.prototype,kn=Object.create(Tn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=Tn[n];N(kn,n,(function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];var i,a=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&o.observeArray(i),o.dep.notify(),a}))}));var wn=Object.getOwnPropertyNames(kn),In=!0;function Cn(n){In=n}var Sn=function(n){this.value=n,this.dep=new pn,this.vmCount=0,N(n,"__ob__",this),Array.isArray(n)?(Q?function(n,e){n.__proto__=e}(n,kn):function(n,e,t){for(var r=0,i=t.length;r<i;r++){var a=t[r];N(n,a,e[a])}}(n,kn,wn),this.observeArray(n)):this.walk(n)};function En(n,e){var t;if(c(n)&&!(n instanceof fn))return T(n,"__ob__")&&n.__ob__ instanceof Sn?t=n.__ob__:In&&!an()&&(Array.isArray(n)||u(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new Sn(n)),e&&t&&t.vmCount++,t}function _n(n,e,t,r,i){var a=new pn,o=Object.getOwnPropertyDescriptor(n,e);if(!o||!1!==o.configurable){var l=o&&o.get,s=o&&o.set;l&&!s||2!==arguments.length||(t=n[e]);var c=!i&&En(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=l?l.call(n):t;return pn.target&&(a.depend(),c&&(c.dep.depend(),Array.isArray(e)&&Pn(e))),e},set:function(e){var r=l?l.call(n):t;e===r||e!=e&&r!=r||l&&!s||(s?s.call(n,e):t=e,c=!i&&En(e),a.notify())}})}}function zn(n,e,t){if(Array.isArray(n)&&m(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(_n(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}function An(n,e){if(Array.isArray(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||T(n,e)&&(delete n[e],t&&t.dep.notify())}}function Pn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&Pn(e)}Sn.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)_n(n,e[t])},Sn.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)En(n[e])};var Rn=F.optionMergeStrategies;function Bn(n,e){if(!e)return n;for(var t,r,i,a=cn?Reflect.ownKeys(e):Object.keys(e),o=0;o<a.length;o++)"__ob__"!==(t=a[o])&&(r=n[t],i=e[t],T(n,t)?r!==i&&u(r)&&u(i)&&Bn(r,i):zn(n,t,i));return n}function jn(n,e,t){return t?function(){var r="function"==typeof e?e.call(t,t):e,i="function"==typeof n?n.call(t,t):n;return r?Bn(r,i):i}:e?n?function(){return Bn("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function Dn(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Mn(n,e,t,r){var i=Object.create(n||null);return e?A(i,e):i}Rn.data=function(n,e,t){return t?jn(n,e,t):e&&"function"!=typeof e?n:jn(n,e)},q.forEach((function(n){Rn[n]=Dn})),O.forEach((function(n){Rn[n+"s"]=Mn})),Rn.watch=function(n,e,t,r){if(n===en&&(n=void 0),e===en&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var a in A(i,n),e){var o=i[a],l=e[a];o&&!Array.isArray(o)&&(o=[o]),i[a]=o?o.concat(l):Array.isArray(l)?l:[l]}return i},Rn.props=Rn.methods=Rn.inject=Rn.computed=function(n,e,t,r){if(!n)return e;var i=Object.create(null);return A(i,n),e&&A(i,e),i},Rn.provide=jn;var Ln=function(n,e){return void 0===e?n:e};function On(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var r,i,a={};if(Array.isArray(t))for(r=t.length;r--;)"string"==typeof(i=t[r])&&(a[I(i)]={type:null});else if(u(t))for(var o in t)i=t[o],a[I(o)]=u(i)?i:{type:i};else 0;n.props=a}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(Array.isArray(t))for(var i=0;i<t.length;i++)r[t[i]]={from:t[i]};else if(u(t))for(var a in t){var o=t[a];r[a]=u(o)?A({from:a},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];"function"==typeof r&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=On(n,e.extends,t)),e.mixins))for(var r=0,i=e.mixins.length;r<i;r++)n=On(n,e.mixins[r],t);var a,o={};for(a in n)l(a);for(a in e)T(n,a)||l(a);function l(r){var i=Rn[r]||Ln;o[r]=i(n[r],e[r],t,r)}return o}function qn(n,e,t,r){if("string"==typeof t){var i=n[e];if(T(i,t))return i[t];var a=I(t);if(T(i,a))return i[a];var o=C(a);return T(i,o)?i[o]:i[t]||i[a]||i[o]}}function Fn(n,e,t,r){var i=e[n],a=!T(t,n),o=t[n],l=$n(Boolean,i.type);if(l>-1)if(a&&!T(i,"default"))o=!1;else if(""===o||o===E(n)){var s=$n(String,i.type);(s<0||l<s)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!T(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof r&&"Function"!==Nn(e.type)?r.call(n):r}(r,i,n);var c=In;Cn(!0),En(o),Cn(c)}return o}var Un=/^\s*function (\w+)/;function Nn(n){var e=n&&n.toString().match(Un);return e?e[1]:""}function Hn(n,e){return Nn(n)===Nn(e)}function $n(n,e){if(!Array.isArray(e))return Hn(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Hn(e[t],n))return t;return-1}function Qn(n,e,t){hn();try{if(e)for(var r=e;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var a=0;a<i.length;a++)try{if(!1===i[a].call(r,n,e,t))return}catch(n){Gn(n,r,"errorCaptured hook")}}Gn(n,e,t)}finally{gn()}}function Wn(n,e,t,r,i){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&h(a)&&!a._handled&&(a.catch((function(n){return Qn(n,r,i+" (Promise/async)")})),a._handled=!0)}catch(n){Qn(n,r,i)}return a}function Gn(n,e,t){if(F.errorHandler)try{return F.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Kn(e,null,"config.errorHandler")}Kn(n,e,t)}function Kn(n,e,t){if(!W&&!G||"undefined"==typeof console)throw n;console.error(n)}var Vn,Jn=!1,Zn=[],Xn=!1;function Yn(){Xn=!1;var n=Zn.slice(0);Zn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var ne=Promise.resolve();Vn=function(){ne.then(Yn),Y&&setTimeout(R)},Jn=!0}else if(J||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Vn="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Yn)}:function(){setTimeout(Yn,0)};else{var ee=1,te=new MutationObserver(Yn),re=document.createTextNode(String(ee));te.observe(re,{characterData:!0}),Vn=function(){ee=(ee+1)%2,re.data=String(ee)},Jn=!0}function ie(n,e){var t;if(Zn.push((function(){if(n)try{n.call(e)}catch(n){Qn(n,e,"nextTick")}else t&&t(e)})),Xn||(Xn=!0,Vn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var ae=new sn;function oe(n){!function n(e,t){var r,i,a=Array.isArray(e);if(!a&&!c(e)||Object.isFrozen(e)||e instanceof fn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(a)for(r=e.length;r--;)n(e[r],t);else for(i=Object.keys(e),r=i.length;r--;)n(e[i[r]],t)}(n,ae),ae.clear()}var le=k((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function se(n,e){function t(){var n=arguments,r=t.fns;if(!Array.isArray(r))return Wn(r,null,arguments,e,"v-on handler");for(var i=r.slice(),a=0;a<i.length;a++)Wn(i[a],null,n,e,"v-on handler")}return t.fns=n,t}function ce(n,e,t,r,i,o){var s,c,d,u;for(s in n)c=n[s],d=e[s],u=le(s),a(c)||(a(d)?(a(c.fns)&&(c=n[s]=se(c,o)),l(u.once)&&(c=n[s]=i(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,n[s]=d));for(s in e)a(n[s])&&r((u=le(s)).name,e[s],u.capture)}function de(n,e,t){var r;n instanceof fn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function s(){t.apply(this,arguments),y(r.fns,s)}a(i)?r=se([s]):o(i.fns)&&l(i.merged)?(r=i).fns.push(s):r=se([i,s]),r.merged=!0,n[e]=r}function ue(n,e,t,r,i){if(o(e)){if(T(e,t))return n[t]=e[t],i||delete e[t],!0;if(T(e,r))return n[t]=e[r],i||delete e[r],!0}return!1}function pe(n){return s(n)?[yn(n)]:Array.isArray(n)?function n(e,t){var r,i,c,d,u=[];for(r=0;r<e.length;r++)a(i=e[r])||"boolean"==typeof i||(c=u.length-1,d=u[c],Array.isArray(i)?i.length>0&&(me((i=n(i,(t||"")+"_"+r))[0])&&me(d)&&(u[c]=yn(d.text+i[0].text),i.shift()),u.push.apply(u,i)):s(i)?me(d)?u[c]=yn(d.text+i):""!==i&&u.push(yn(i)):me(i)&&me(d)?u[c]=yn(d.text+i.text):(l(e._isVList)&&o(i.tag)&&a(i.key)&&o(t)&&(i.key="__vlist"+t+"_"+r+"__"),u.push(i)));return u}(n):void 0}function me(n){return o(n)&&o(n.text)&&!1===n.isComment}function he(n,e){if(n){for(var t=Object.create(null),r=cn?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var a=r[i];if("__ob__"!==a){for(var o=n[a].from,l=e;l;){if(l._provided&&T(l._provided,o)){t[a]=l._provided[o];break}l=l.$parent}if(!l)if("default"in n[a]){var s=n[a].default;t[a]="function"==typeof s?s.call(e):s}else 0}}return t}}function ge(n,e){if(!n||!n.length)return{};for(var t={},r=0,i=n.length;r<i;r++){var a=n[r],o=a.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,a.context!==e&&a.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(a);else{var l=o.slot,s=t[l]||(t[l]=[]);"template"===a.tag?s.push.apply(s,a.children||[]):s.push(a)}}for(var c in t)t[c].every(fe)&&delete t[c];return t}function fe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ve(n){return n.isComment&&n.asyncFactory}function be(n,e,t){var r,a=Object.keys(e).length>0,o=n?!!n.$stable:!a,l=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&t&&t!==i&&l===t.$key&&!a&&!t.$hasNormal)return t;for(var s in r={},n)n[s]&&"$"!==s[0]&&(r[s]=ye(e,s,n[s]))}else r={};for(var c in e)c in r||(r[c]=xe(e,c));return n&&Object.isExtensible(n)&&(n._normalized=r),N(r,"$stable",o),N(r,"$key",l),N(r,"$hasNormal",a),r}function ye(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:pe(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!ve(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function xe(n,e){return function(){return n[e]}}function Te(n,e){var t,r,i,a,l;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),r=0,i=n.length;r<i;r++)t[r]=e(n[r],r);else if("number"==typeof n)for(t=new Array(n),r=0;r<n;r++)t[r]=e(r+1,r);else if(c(n))if(cn&&n[Symbol.iterator]){t=[];for(var s=n[Symbol.iterator](),d=s.next();!d.done;)t.push(e(d.value,t.length)),d=s.next()}else for(a=Object.keys(n),t=new Array(a.length),r=0,i=a.length;r<i;r++)l=a[r],t[r]=e(n[l],l,r);return o(t)||(t=[]),t._isVList=!0,t}function ke(n,e,t,r){var i,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=A(A({},r),t)),i=a(t)||("function"==typeof e?e():e)):i=this.$slots[n]||("function"==typeof e?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},i):i}function we(n){return qn(this.$options,"filters",n)||j}function Ie(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Ce(n,e,t,r,i){var a=F.keyCodes[e]||t;return i&&r&&!F.keyCodes[e]?Ie(i,r):a?Ie(a,n):r?E(r)!==e:void 0===n}function Se(n,e,t,r,i){if(t)if(c(t)){var a;Array.isArray(t)&&(t=P(t));var o=function(o){if("class"===o||"style"===o||b(o))a=n;else{var l=n.attrs&&n.attrs.type;a=r||F.mustUseProp(e,l,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var s=I(o),c=E(o);s in a||c in a||(a[o]=t[o],i&&((n.on||(n.on={}))["update:"+o]=function(n){t[o]=n}))};for(var l in t)o(l)}else;return n}function Ee(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||ze(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function _e(n,e,t){return ze(n,"__once__"+e+(t?"_"+t:""),!0),n}function ze(n,e,t){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Ae(n[r],e+"_"+r,t);else Ae(n,e,t)}function Ae(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Pe(n,e){if(e)if(u(e)){var t=n.on=n.on?A({},n.on):{};for(var r in e){var i=t[r],a=e[r];t[r]=i?[].concat(i,a):a}}else;return n}function Re(n,e,t,r){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var a=n[i];Array.isArray(a)?Re(a,e,t):a&&(a.proxy&&(a.fn.proxy=!0),e[a.key]=a.fn)}return r&&(e.$key=r),e}function Be(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function je(n,e){return"string"==typeof n?e+n:n}function De(n){n._o=_e,n._n=f,n._s=g,n._l=Te,n._t=ke,n._q=D,n._i=M,n._m=Ee,n._f=we,n._k=Ce,n._b=Se,n._v=yn,n._e=bn,n._u=Re,n._g=Pe,n._d=Be,n._p=je}function Me(n,e,t,r,a){var o,s=this,c=a.options;T(r,"_uid")?(o=Object.create(r))._original=r:(o=r,r=r._original);var d=l(c._compiled),u=!d;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||i,this.injections=he(c.inject,r),this.slots=function(){return s.$slots||be(n.scopedSlots,s.$slots=ge(t,r)),s.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return be(n.scopedSlots,this.slots())}}),d&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=be(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,i){var a=He(o,n,e,t,i,u);return a&&!Array.isArray(a)&&(a.fnScopeId=c._scopeId,a.fnContext=r),a}:this._c=function(n,e,t,r){return He(o,n,e,t,r,u)}}function Le(n,e,t,r,i){var a=xn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function Oe(n,e){for(var t in e)n[I(t)]=e[t]}De(Me.prototype);var qe={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;qe.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;o(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Xe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,a){0;var o=r.data.scopedSlots,l=n.$scopedSlots,s=!!(o&&!o.$stable||l!==i&&!l.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(a||n.$options._renderChildren||s);n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);if(n.$options._renderChildren=a,n.$attrs=r.data.attrs||i,n.$listeners=t||i,e&&n.$options.props){Cn(!1);for(var d=n._props,u=n.$options._propKeys||[],p=0;p<u.length;p++){var m=u[p],h=n.$options.props;d[m]=Fn(m,h,e,n)}Cn(!0),n.$options.propsData=e}t=t||i;var g=n.$options._parentListeners;n.$options._parentListeners=t,Ze(n,t,g),c&&(n.$slots=ge(a,r.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,tt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,it.push(e)):et(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,nt(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);tt(e,"deactivated")}}(e,!0):e.$destroy())}},Fe=Object.keys(qe);function Ue(n,e,t,r,s){if(!a(n)){var d=t.$options._base;if(c(n)&&(n=d.extend(n)),"function"==typeof n){var u;if(a(n.cid)&&void 0===(n=function(n,e){if(l(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=Qe;t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(l(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var r=n.owners=[t],i=!0,s=null,d=null;t.$on("hook:destroyed",(function(){return y(r,t)}));var u=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==s&&(clearTimeout(s),s=null),null!==d&&(clearTimeout(d),d=null))},p=L((function(t){n.resolved=We(t,e),i?r.length=0:u(!0)})),m=L((function(e){o(n.errorComp)&&(n.error=!0,u(!0))})),g=n(p,m);return c(g)&&(h(g)?a(n.resolved)&&g.then(p,m):h(g.component)&&(g.component.then(p,m),o(g.error)&&(n.errorComp=We(g.error,e)),o(g.loading)&&(n.loadingComp=We(g.loading,e),0===g.delay?n.loading=!0:s=setTimeout((function(){s=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,u(!1))}),g.delay||200)),o(g.timeout)&&(d=setTimeout((function(){d=null,a(n.resolved)&&m(null)}),g.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(u=n,d)))return function(n,e,t,r,i){var a=bn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:i},a}(u,e,t,r,s);e=e||{},It(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),a=i[r],l=e.model.callback;o(a)?(Array.isArray(a)?-1===a.indexOf(l):a!==l)&&(i[r]=[l].concat(a)):i[r]=l}(n.options,e);var p=function(n,e,t){var r=e.options.props;if(!a(r)){var i={},l=n.attrs,s=n.props;if(o(l)||o(s))for(var c in r){var d=E(c);ue(i,s,c,d,!0)||ue(i,l,c,d,!1)}return i}}(e,n);if(l(n.options.functional))return function(n,e,t,r,a){var l=n.options,s={},c=l.props;if(o(c))for(var d in c)s[d]=Fn(d,c,e||i);else o(t.attrs)&&Oe(s,t.attrs),o(t.props)&&Oe(s,t.props);var u=new Me(t,s,a,r,n),p=l.render.call(null,u._c,u);if(p instanceof fn)return Le(p,t,u.parent,l,u);if(Array.isArray(p)){for(var m=pe(p)||[],h=new Array(m.length),g=0;g<m.length;g++)h[g]=Le(m[g],t,u.parent,l,u);return h}}(n,p,e,t,r);var m=e.on;if(e.on=e.nativeOn,l(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Fe.length;t++){var r=Fe[t],i=e[r],a=qe[r];i===a||i&&i._merged||(e[r]=i?Ne(a,i):a)}}(e);var f=n.options.name||s;return new fn("vue-component-"+n.cid+(f?"-"+f:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:m,tag:s,children:r},u)}}}function Ne(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function He(n,e,t,r,i,d){return(Array.isArray(t)||s(t))&&(i=r,r=t,t=void 0),l(d)&&(i=2),function(n,e,t,r,i){if(o(t)&&o(t.__ob__))return bn();o(t)&&o(t.is)&&(e=t.is);if(!e)return bn();0;Array.isArray(r)&&"function"==typeof r[0]&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===i?r=pe(r):1===i&&(r=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var s,d;if("string"==typeof e){var u;d=n.$vnode&&n.$vnode.ns||F.getTagNamespace(e),s=F.isReservedTag(e)?new fn(F.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!o(u=qn(n.$options,"components",e))?new fn(e,t,r,void 0,void 0,n):Ue(u,t,n,r,e)}else s=Ue(e,t,n,r);return Array.isArray(s)?s:o(s)?(o(d)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(o(e.children))for(var i=0,s=e.children.length;i<s;i++){var c=e.children[i];o(c.tag)&&(a(c.ns)||l(r)&&"svg"!==c.tag)&&n(c,t,r)}}(s,d),o(t)&&function(n){c(n.style)&&oe(n.style);c(n.class)&&oe(n.class)}(t),s):bn()}(n,e,t,r,i)}var $e,Qe=null;function We(n,e){return(n.__esModule||cn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function Ge(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||ve(t)))return t}}function Ke(n,e){$e.$on(n,e)}function Ve(n,e){$e.$off(n,e)}function Je(n,e){var t=$e;return function r(){var i=e.apply(null,arguments);null!==i&&t.$off(n,r)}}function Ze(n,e,t){$e=n,ce(e,t||{},Ke,Ve,Je,n),$e=void 0}var Xe=null;function Ye(n){var e=Xe;return Xe=n,function(){Xe=e}}function nt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function et(n,e){if(e){if(n._directInactive=!1,nt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)et(n.$children[t]);tt(n,"activated")}}function tt(n,e){hn();var t=n.$options[e],r=e+" hook";if(t)for(var i=0,a=t.length;i<a;i++)Wn(t[i],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),gn()}var rt=[],it=[],at={},ot=!1,lt=!1,st=0;var ct=0,dt=Date.now;if(W&&!J){var ut=window.performance;ut&&"function"==typeof ut.now&&dt()>document.createEvent("Event").timeStamp&&(dt=function(){return ut.now()})}function pt(){var n,e;for(ct=dt(),lt=!0,rt.sort((function(n,e){return n.id-e.id})),st=0;st<rt.length;st++)(n=rt[st]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=it.slice(),r=rt.slice();st=rt.length=it.length=0,at={},ot=lt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,et(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r._watcher===t&&r._isMounted&&!r._isDestroyed&&tt(r,"updated")}}(r),on&&F.devtools&&on.emit("flush")}var mt=0,ht=function(n,e,t,r,i){this.vm=n,i&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++mt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new sn,this.newDepIds=new sn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!H.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=R)),this.value=this.lazy?void 0:this.get()};ht.prototype.get=function(){var n;hn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Qn(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&oe(n),gn(),this.cleanupDeps()}return n},ht.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},ht.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},ht.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==at[e]){if(at[e]=!0,lt){for(var t=rt.length-1;t>st&&rt[t].id>n.id;)t--;rt.splice(t+1,0,n)}else rt.push(n);ot||(ot=!0,ie(pt))}}(this)},ht.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Wn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},ht.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},ht.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},ht.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||y(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var gt={enumerable:!0,configurable:!0,get:R,set:R};function ft(n,e,t){gt.get=function(){return this[e][t]},gt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,gt)}function vt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props={},i=n.$options._propKeys=[];n.$parent&&Cn(!1);var a=function(a){i.push(a);var o=Fn(a,e,t,n);_n(r,a,o),a in n||ft(n,"_props",a)};for(var o in e)a(o);Cn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?R:_(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;u(e=n._data="function"==typeof e?function(n,e){hn();try{return n.call(e,e)}catch(n){return Qn(n,e,"data()"),{}}finally{gn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var a=t[i];0,r&&T(r,a)||(o=void 0,36!==(o=(a+"").charCodeAt(0))&&95!==o&&ft(n,"_data",a))}var o;En(e,!0)}(n):En(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=an();for(var i in e){var a=e[i],o="function"==typeof a?a:a.get;0,r||(t[i]=new ht(n,o||R,R,bt)),i in n||yt(n,i,a)}}(n,e.computed),e.watch&&e.watch!==en&&function(n,e){for(var t in e){var r=e[t];if(Array.isArray(r))for(var i=0;i<r.length;i++)kt(n,t,r[i]);else kt(n,t,r)}}(n,e.watch)}var bt={lazy:!0};function yt(n,e,t){var r=!an();"function"==typeof t?(gt.get=r?xt(e):Tt(t),gt.set=R):(gt.get=t.get?r&&!1!==t.cache?xt(e):Tt(t.get):R,gt.set=t.set||R),Object.defineProperty(n,e,gt)}function xt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),pn.target&&e.depend(),e.value}}function Tt(n){return function(){return n.call(this,this)}}function kt(n,e,t,r){return u(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var wt=0;function It(n){var e=n.options;if(n.super){var t=It(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var i in t)t[i]!==r[i]&&(e||(e={}),e[i]=t[i]);return e}(n);r&&A(n.extendOptions,r),(e=n.options=On(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Ct(n){this._init(n)}function St(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var a=n.name||t.options.name;var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=On(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)ft(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)yt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,O.forEach((function(n){o[n]=t[n]})),a&&(o.options.components[a]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=A({},o.options),i[r]=o,o}}function Et(n){return n&&(n.Ctor.options.name||n.tag)}function _t(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function zt(n,e){var t=n.cache,r=n.keys,i=n._vnode;for(var a in t){var o=t[a];if(o){var l=o.name;l&&!e(l)&&At(t,a,r,i)}}}function At(n,e,t,r){var i=n[e];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[e]=null,y(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=wt++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var i=r.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=On(It(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ze(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=ge(e._renderChildren,r),n.$scopedSlots=i,n._c=function(e,t,r,i){return He(n,e,t,r,i,!1)},n.$createElement=function(e,t,r,i){return He(n,e,t,r,i,!0)};var a=t&&t.data;_n(n,"$attrs",a&&a.attrs||i,null,!0),_n(n,"$listeners",e._parentListeners||i,null,!0)}(e),tt(e,"beforeCreate"),function(n){var e=he(n.$options.inject,n);e&&(Cn(!1),Object.keys(e).forEach((function(t){_n(n,t,e[t])})),Cn(!0))}(e),vt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),tt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Ct),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=zn,n.prototype.$delete=An,n.prototype.$watch=function(n,e,t){if(u(e))return kt(this,n,e,t);(t=t||{}).user=!0;var r=new ht(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'+r.expression+'"';hn(),Wn(e,this,[r.value],this,i),gn()}return function(){r.teardown()}}}(Ct),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(Array.isArray(n))for(var i=0,a=n.length;i<a;i++)r.$on(n[i],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var r=0,i=n.length;r<i;r++)t.$off(n[r],e);return t}var a,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var l=o.length;l--;)if((a=o[l])===e||a.fn===e){o.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?z(t):t;for(var r=z(arguments,1),i='event handler for "'+n+'"',a=0,o=t.length;a<o;a++)Wn(t[a],e,r,e,i)}return e}}(Ct),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,i=t._vnode,a=Ye(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){tt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),tt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Ct),function(n){De(n.prototype),n.prototype.$nextTick=function(n){return ie(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,i=t._parentVnode;i&&(e.$scopedSlots=be(i.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=i;try{Qe=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Qn(t,e,"render"),n=e._vnode}finally{Qe=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof fn||(n=bn()),n.parent=i,n}}(Ct);var Pt=[String,RegExp,Array],Rt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Pt,exclude:Pt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var i=t.tag,a=t.componentInstance,o=t.componentOptions;n[r]={name:Et(o),tag:i,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&At(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)At(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){zt(n,(function(n){return _t(e,n)}))})),this.$watch("exclude",(function(e){zt(n,(function(n){return!_t(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ge(n),t=e&&e.componentOptions;if(t){var r=Et(t),i=this.include,a=this.exclude;if(i&&(!r||!_t(i,r))||a&&r&&_t(a,r))return e;var o=this.cache,l=this.keys,s=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;o[s]?(e.componentInstance=o[s].componentInstance,y(l,s),l.push(s)):(this.vnodeToCache=e,this.keyToCache=s),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return F}};Object.defineProperty(n,"config",e),n.util={warn:dn,extend:A,mergeOptions:On,defineReactive:_n},n.set=zn,n.delete=An,n.nextTick=ie,n.observable=function(n){return En(n),n},n.options=Object.create(null),O.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,A(n.options.components,Rt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=z(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=On(this.options,n),this}}(n),St(n),function(n){O.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Ct),Object.defineProperty(Ct.prototype,"$isServer",{get:an}),Object.defineProperty(Ct.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Ct,"FunctionalRenderContext",{value:Me}),Ct.version="2.6.14";var Bt=v("style,class"),jt=v("input,textarea,option,select,progress"),Dt=v("contenteditable,draggable,spellcheck"),Mt=v("events,caret,typing,plaintext-only"),Lt=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Ot="http://www.w3.org/1999/xlink",qt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Ft=function(n){return qt(n)?n.slice(6,n.length):""},Ut=function(n){return null==n||!1===n};function Nt(n){for(var e=n.data,t=n,r=n;o(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=Ht(r.data,e));for(;o(t=t.parent);)t&&t.data&&(e=Ht(e,t.data));return function(n,e){if(o(n)||o(e))return $t(n,Qt(e));return""}(e.staticClass,e.class)}function Ht(n,e){return{staticClass:$t(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function $t(n,e){return n?e?n+" "+e:n:e||""}function Qt(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,i=n.length;r<i;r++)o(e=Qt(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Wt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Gt=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Kt=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Vt=function(n){return Gt(n)||Kt(n)};var Jt=Object.create(null);var Zt=v("text,number,password,search,email,tel,url");var Xt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Wt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Yt={create:function(n,e){nr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(nr(n,!0),nr(e))},destroy:function(n){nr(n,!0)}};function nr(n,e){var t=n.data.ref;if(o(t)){var r=n.context,i=n.componentInstance||n.elm,a=r.$refs;e?Array.isArray(a[t])?y(a[t],i):a[t]===i&&(a[t]=void 0):n.data.refInFor?Array.isArray(a[t])?a[t].indexOf(i)<0&&a[t].push(i):a[t]=[i]:a[t]=i}}var er=new fn("",{},[]),tr=["create","activate","update","remove","destroy"];function rr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=o(t=n.data)&&o(t=t.attrs)&&t.type,i=o(t=e.data)&&o(t=t.attrs)&&t.type;return r===i||Zt(r)&&Zt(i)}(n,e)||l(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function ir(n,e,t){var r,i,a={};for(r=e;r<=t;++r)o(i=n[r].key)&&(a[i]=r);return a}var ar={create:or,update:or,destroy:function(n){or(n,er)}};function or(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,i,a=n===er,o=e===er,l=sr(n.data.directives,n.context),s=sr(e.data.directives,e.context),c=[],d=[];for(t in s)r=l[t],i=s[t],r?(i.oldValue=r.value,i.oldArg=r.arg,dr(i,"update",e,n),i.def&&i.def.componentUpdated&&d.push(i)):(dr(i,"bind",e,n),i.def&&i.def.inserted&&c.push(i));if(c.length){var u=function(){for(var t=0;t<c.length;t++)dr(c[t],"inserted",e,n)};a?de(e,"insert",u):u()}d.length&&de(e,"postpatch",(function(){for(var t=0;t<d.length;t++)dr(d[t],"componentUpdated",e,n)}));if(!a)for(t in l)s[t]||dr(l[t],"unbind",n,n,o)}(n,e)}var lr=Object.create(null);function sr(n,e){var t,r,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=lr),i[cr(r)]=r,r.def=qn(e.$options,"directives",r.name);return i}function cr(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function dr(n,e,t,r,i){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,i)}catch(r){Qn(r,t.context,"directive "+n.name+" "+e+" hook")}}var ur=[Yt,ar];function pr(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,i,l=e.elm,s=n.data.attrs||{},c=e.data.attrs||{};for(r in o(c.__ob__)&&(c=e.data.attrs=A({},c)),c)i=c[r],s[r]!==i&&mr(l,r,i,e.data.pre);for(r in(J||X)&&c.value!==s.value&&mr(l,"value",c.value),s)a(c[r])&&(qt(r)?l.removeAttributeNS(Ot,Ft(r)):Dt(r)||l.removeAttribute(r))}}function mr(n,e,t,r){r||n.tagName.indexOf("-")>-1?hr(n,e,t):Lt(e)?Ut(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Dt(e)?n.setAttribute(e,function(n,e){return Ut(e)||"false"===e?"false":"contenteditable"===n&&Mt(e)?e:"true"}(e,t)):qt(e)?Ut(t)?n.removeAttributeNS(Ot,Ft(e)):n.setAttributeNS(Ot,e,t):hr(n,e,t)}function hr(n,e,t){if(Ut(t))n.removeAttribute(e);else{if(J&&!Z&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var gr={create:pr,update:pr};function fr(n,e){var t=e.elm,r=e.data,i=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(i)||a(i.staticClass)&&a(i.class)))){var l=Nt(e),s=t._transitionClasses;o(s)&&(l=$t(l,Qt(s))),l!==t._prevClass&&(t.setAttribute("class",l),t._prevClass=l)}}var vr,br={create:fr,update:fr};function yr(n,e,t){var r=vr;return function i(){var a=e.apply(null,arguments);null!==a&&kr(n,i,t,r)}}var xr=Jn&&!(nn&&Number(nn[1])<=53);function Tr(n,e,t,r){if(xr){var i=ct,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}vr.addEventListener(n,e,tn?{capture:t,passive:r}:t)}function kr(n,e,t,r){(r||vr).removeEventListener(n,e._wrapper||e,t)}function wr(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};vr=e.elm,function(n){if(o(n.__r)){var e=J?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),ce(t,r,Tr,kr,yr,e.context),vr=void 0}}var Ir,Cr={create:wr,update:wr};function Sr(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,i=e.elm,l=n.data.domProps||{},s=e.data.domProps||{};for(t in o(s.__ob__)&&(s=e.data.domProps=A({},s)),l)t in s||(i[t]="");for(t in s){if(r=s[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===l[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=r;var c=a(r)?"":String(r);Er(i,c)&&(i.value=c)}else if("innerHTML"===t&&Kt(i.tagName)&&a(i.innerHTML)){(Ir=Ir||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var d=Ir.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;d.firstChild;)i.appendChild(d.firstChild)}else if(r!==l[t])try{i[t]=r}catch(n){}}}}function Er(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(o(r)){if(r.number)return f(t)!==f(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var _r={create:Sr,update:Sr},zr=k((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Ar(n){var e=Pr(n.style);return n.staticStyle?A(n.staticStyle,e):e}function Pr(n){return Array.isArray(n)?P(n):"string"==typeof n?zr(n):n}var Rr,Br=/^--/,jr=/\s*!important$/,Dr=function(n,e,t){if(Br.test(e))n.style.setProperty(e,t);else if(jr.test(t))n.style.setProperty(E(e),t.replace(jr,""),"important");else{var r=Lr(e);if(Array.isArray(t))for(var i=0,a=t.length;i<a;i++)n.style[r]=t[i];else n.style[r]=t}},Mr=["Webkit","Moz","ms"],Lr=k((function(n){if(Rr=Rr||document.createElement("div").style,"filter"!==(n=I(n))&&n in Rr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Mr.length;t++){var r=Mr[t]+e;if(r in Rr)return r}}));function Or(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var i,l,s=e.elm,c=r.staticStyle,d=r.normalizedStyle||r.style||{},u=c||d,p=Pr(e.data.style)||{};e.data.normalizedStyle=o(p.__ob__)?A({},p):p;var m=function(n,e){var t,r={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=Ar(i.data))&&A(r,t);(t=Ar(n.data))&&A(r,t);for(var a=n;a=a.parent;)a.data&&(t=Ar(a.data))&&A(r,t);return r}(e,!0);for(l in u)a(m[l])&&Dr(s,l,"");for(l in m)(i=m[l])!==u[l]&&Dr(s,l,null==i?"":i)}}var qr={create:Or,update:Or},Fr=/\s+/;function Ur(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Fr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Nr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Fr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Hr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&A(e,$r(n.name||"v")),A(e,n),e}return"string"==typeof n?$r(n):void 0}}var $r=k((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Qr=W&&!Z,Wr="transition",Gr="transitionend",Kr="animation",Vr="animationend";Qr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Wr="WebkitTransition",Gr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Kr="WebkitAnimation",Vr="webkitAnimationEnd"));var Jr=W?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Zr(n){Jr((function(){Jr(n)}))}function Xr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Ur(n,e))}function Yr(n,e){n._transitionClasses&&y(n._transitionClasses,e),Nr(n,e)}function ni(n,e,t){var r=ti(n,e),i=r.type,a=r.timeout,o=r.propCount;if(!i)return t();var l="transition"===i?Gr:Vr,s=0,c=function(){n.removeEventListener(l,d),t()},d=function(e){e.target===n&&++s>=o&&c()};setTimeout((function(){s<o&&c()}),a+1),n.addEventListener(l,d)}var ei=/\b(transform|all)(,|$)/;function ti(n,e){var t,r=window.getComputedStyle(n),i=(r[Wr+"Delay"]||"").split(", "),a=(r[Wr+"Duration"]||"").split(", "),o=ri(i,a),l=(r[Kr+"Delay"]||"").split(", "),s=(r[Kr+"Duration"]||"").split(", "),c=ri(l,s),d=0,u=0;return"transition"===e?o>0&&(t="transition",d=o,u=a.length):"animation"===e?c>0&&(t="animation",d=c,u=s.length):u=(t=(d=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?a.length:s.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&ei.test(r[Wr+"Property"])}}function ri(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ii(e)+ii(n[t])})))}function ii(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ai(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=Hr(n.data.transition);if(!a(r)&&!o(t._enterCb)&&1===t.nodeType){for(var i=r.css,l=r.type,s=r.enterClass,d=r.enterToClass,u=r.enterActiveClass,p=r.appearClass,m=r.appearToClass,h=r.appearActiveClass,g=r.beforeEnter,v=r.enter,b=r.afterEnter,y=r.enterCancelled,x=r.beforeAppear,T=r.appear,k=r.afterAppear,w=r.appearCancelled,I=r.duration,C=Xe,S=Xe.$vnode;S&&S.parent;)C=S.context,S=S.parent;var E=!C._isMounted||!n.isRootInsert;if(!E||T||""===T){var _=E&&p?p:s,z=E&&h?h:u,A=E&&m?m:d,P=E&&x||g,R=E&&"function"==typeof T?T:v,B=E&&k||b,j=E&&w||y,D=f(c(I)?I.enter:I);0;var M=!1!==i&&!Z,O=si(R),q=t._enterCb=L((function(){M&&(Yr(t,A),Yr(t,z)),q.cancelled?(M&&Yr(t,_),j&&j(t)):B&&B(t),t._enterCb=null}));n.data.show||de(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),R&&R(t,q)})),P&&P(t),M&&(Xr(t,_),Xr(t,z),Zr((function(){Yr(t,_),q.cancelled||(Xr(t,A),O||(li(D)?setTimeout(q,D):ni(t,l,q)))}))),n.data.show&&(e&&e(),R&&R(t,q)),M||O||q()}}}function oi(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=Hr(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var i=r.css,l=r.type,s=r.leaveClass,d=r.leaveToClass,u=r.leaveActiveClass,p=r.beforeLeave,m=r.leave,h=r.afterLeave,g=r.leaveCancelled,v=r.delayLeave,b=r.duration,y=!1!==i&&!Z,x=si(m),T=f(c(b)?b.leave:b);0;var k=t._leaveCb=L((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(Yr(t,d),Yr(t,u)),k.cancelled?(y&&Yr(t,s),g&&g(t)):(e(),h&&h(t)),t._leaveCb=null}));v?v(w):w()}function w(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),y&&(Xr(t,s),Xr(t,u),Zr((function(){Yr(t,s),k.cancelled||(Xr(t,d),x||(li(T)?setTimeout(k,T):ni(t,l,k)))}))),m&&m(t,k),y||x||k())}}function li(n){return"number"==typeof n&&!isNaN(n)}function si(n){if(a(n))return!1;var e=n.fns;return o(e)?si(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function ci(n,e){!0!==e.data.show&&ai(e)}var di=function(n){var e,t,r={},i=n.modules,c=n.nodeOps;for(e=0;e<tr.length;++e)for(r[tr[e]]=[],t=0;t<i.length;++t)o(i[t][tr[e]])&&r[tr[e]].push(i[t][tr[e]]);function d(n){var e=c.parentNode(n);o(e)&&c.removeChild(e,n)}function u(n,e,t,i,a,s,d){if(o(n.elm)&&o(s)&&(n=s[d]=xn(n)),n.isRootInsert=!a,!function(n,e,t,i){var a=n.data;if(o(a)){var s=o(n.componentInstance)&&a.keepAlive;if(o(a=a.hook)&&o(a=a.init)&&a(n,!1),o(n.componentInstance))return p(n,e),m(t,n.elm,i),l(s)&&function(n,e,t,i){var a,l=n;for(;l.componentInstance;)if(l=l.componentInstance._vnode,o(a=l.data)&&o(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](er,l);e.push(l);break}m(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var u=n.data,g=n.children,v=n.tag;o(v)?(n.elm=n.ns?c.createElementNS(n.ns,v):c.createElement(v,n),b(n),h(n,g,e),o(u)&&f(n,e),m(t,n.elm,i)):l(n.isComment)?(n.elm=c.createComment(n.text),m(t,n.elm,i)):(n.elm=c.createTextNode(n.text),m(t,n.elm,i))}}function p(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(f(n,e),b(n)):(nr(n),e.push(n))}function m(n,e,t){o(n)&&(o(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function h(n,e,t){if(Array.isArray(e)){0;for(var r=0;r<e.length;++r)u(e[r],t,n.elm,null,!0,e,r)}else s(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function f(n,t){for(var i=0;i<r.create.length;++i)r.create[i](er,n);o(e=n.data.hook)&&(o(e.create)&&e.create(er,n),o(e.insert)&&t.push(n))}function b(n){var e;if(o(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;o(e=Xe)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function y(n,e,t,r,i,a){for(;r<=i;++r)u(t[r],a,n,e,!1,t,r)}function x(n){var e,t,i=n.data;if(o(i))for(o(e=i.hook)&&o(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function T(n,e,t){for(;e<=t;++e){var r=n[e];o(r)&&(o(r.tag)?(k(r),x(r)):d(r.elm))}}function k(n,e){if(o(e)||o(n.data)){var t,i=r.remove.length+1;for(o(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,i),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&k(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else d(n.elm)}function w(n,e,t,r){for(var i=t;i<r;i++){var a=e[i];if(o(a)&&rr(n,a))return i}}function I(n,e,t,i,s,d){if(n!==e){o(e.elm)&&o(i)&&(e=i[s]=xn(e));var p=e.elm=n.elm;if(l(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?E(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(l(e.isStatic)&&l(n.isStatic)&&e.key===n.key&&(l(e.isCloned)||l(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;o(h)&&o(m=h.hook)&&o(m=m.prepatch)&&m(n,e);var f=n.children,v=e.children;if(o(h)&&g(e)){for(m=0;m<r.update.length;++m)r.update[m](n,e);o(m=h.hook)&&o(m=m.update)&&m(n,e)}a(e.text)?o(f)&&o(v)?f!==v&&function(n,e,t,r,i){var l,s,d,p=0,m=0,h=e.length-1,g=e[0],f=e[h],v=t.length-1,b=t[0],x=t[v],k=!i;for(0;p<=h&&m<=v;)a(g)?g=e[++p]:a(f)?f=e[--h]:rr(g,b)?(I(g,b,r,t,m),g=e[++p],b=t[++m]):rr(f,x)?(I(f,x,r,t,v),f=e[--h],x=t[--v]):rr(g,x)?(I(g,x,r,t,v),k&&c.insertBefore(n,g.elm,c.nextSibling(f.elm)),g=e[++p],x=t[--v]):rr(f,b)?(I(f,b,r,t,m),k&&c.insertBefore(n,f.elm,g.elm),f=e[--h],b=t[++m]):(a(l)&&(l=ir(e,p,h)),a(s=o(b.key)?l[b.key]:w(b,e,p,h))?u(b,r,n,g.elm,!1,t,m):rr(d=e[s],b)?(I(d,b,r,t,m),e[s]=void 0,k&&c.insertBefore(n,d.elm,g.elm)):u(b,r,n,g.elm,!1,t,m),b=t[++m]);p>h?y(n,a(t[v+1])?null:t[v+1].elm,t,m,v,r):m>v&&T(e,p,h)}(p,f,v,t,d):o(v)?(o(n.text)&&c.setTextContent(p,""),y(p,null,v,0,v.length-1,t)):o(f)?T(f,0,f.length-1):o(n.text)&&c.setTextContent(p,""):n.text!==e.text&&c.setTextContent(p,e.text),o(h)&&o(m=h.hook)&&o(m=m.postpatch)&&m(n,e)}}}function C(n,e,t){if(l(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var S=v("attrs,class,staticClass,staticStyle,key");function E(n,e,t,r){var i,a=e.tag,s=e.data,c=e.children;if(r=r||s&&s.pre,e.elm=n,l(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(s)&&(o(i=s.hook)&&o(i=i.init)&&i(e,!0),o(i=e.componentInstance)))return p(e,t),!0;if(o(a)){if(o(c))if(n.hasChildNodes())if(o(i=s)&&o(i=i.domProps)&&o(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,m=0;m<c.length;m++){if(!u||!E(u,c[m],t,r)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else h(e,c,t);if(o(s)){var g=!1;for(var v in s)if(!S(v)){g=!0,f(e,t);break}!g&&s.class&&oe(s.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!a(e)){var s,d=!1,p=[];if(a(n))d=!0,u(e,p);else{var m=o(n.nodeType);if(!m&&rr(n,e))I(n,e,p,null,null,i);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),l(t)&&E(n,e,p))return C(e,p,!0),n;s=n,n=new fn(c.tagName(s).toLowerCase(),{},[],void 0,s)}var h=n.elm,f=c.parentNode(h);if(u(e,p,h._leaveCb?null:f,c.nextSibling(h)),o(e.parent))for(var v=e.parent,b=g(e);v;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](v);if(v.elm=e.elm,b){for(var k=0;k<r.create.length;++k)r.create[k](er,v);var w=v.data.hook.insert;if(w.merged)for(var S=1;S<w.fns.length;S++)w.fns[S]()}else nr(v);v=v.parent}o(f)?T([n],0,0):o(n.tag)&&x(n)}}return C(e,p,d),e.elm}o(n)&&x(n)}}({nodeOps:Xt,modules:[gr,br,Cr,_r,qr,W?{create:ci,activate:ci,remove:function(n,e){!0!==n.data.show?oi(n,e):e()}}:{}].concat(ur)});Z&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&bi(n,"input")}));var ui={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?de(t,"postpatch",(function(){ui.componentUpdated(n,e,t)})):pi(n,e,t.context),n._vOptions=[].map.call(n.options,gi)):("textarea"===t.tag||Zt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",fi),n.addEventListener("compositionend",vi),n.addEventListener("change",vi),Z&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){pi(n,e,t.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,gi);if(i.some((function(n,e){return!D(n,r[e])})))(n.multiple?e.value.some((function(n){return hi(n,i)})):e.value!==e.oldValue&&hi(e.value,i))&&bi(n,"change")}}};function pi(n,e,t){mi(n,e,t),(J||X)&&setTimeout((function(){mi(n,e,t)}),0)}function mi(n,e,t){var r=e.value,i=n.multiple;if(!i||Array.isArray(r)){for(var a,o,l=0,s=n.options.length;l<s;l++)if(o=n.options[l],i)a=M(r,gi(o))>-1,o.selected!==a&&(o.selected=a);else if(D(gi(o),r))return void(n.selectedIndex!==l&&(n.selectedIndex=l));i||(n.selectedIndex=-1)}}function hi(n,e){return e.every((function(e){return!D(e,n)}))}function gi(n){return"_value"in n?n._value:n.value}function fi(n){n.target.composing=!0}function vi(n){n.target.composing&&(n.target.composing=!1,bi(n.target,"input"))}function bi(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function yi(n){return!n.componentInstance||n.data&&n.data.transition?n:yi(n.componentInstance._vnode)}var xi={model:ui,show:{bind:function(n,e,t){var r=e.value,i=(t=yi(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(t.data.show=!0,ai(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=yi(t)).data&&t.data.transition?(t.data.show=!0,r?ai(t,(function(){n.style.display=n.__vOriginalDisplay})):oi(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},Ti={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ki(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?ki(Ge(e.children)):n}function wi(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var i=t._parentListeners;for(var a in i)e[I(a)]=i[a];return e}function Ii(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Ci=function(n){return n.tag||ve(n)},Si=function(n){return"show"===n.name},Ei={name:"transition",props:Ti,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Ci)).length){0;var r=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var a=ki(i);if(!a)return i;if(this._leaving)return Ii(n,i);var o="__transition-"+this._uid+"-";a.key=null==a.key?a.isComment?o+"comment":o+a.tag:s(a.key)?0===String(a.key).indexOf(o)?a.key:o+a.key:a.key;var l=(a.data||(a.data={})).transition=wi(this),c=this._vnode,d=ki(c);if(a.data.directives&&a.data.directives.some(Si)&&(a.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,d)&&!ve(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=A({},l);if("out-in"===r)return this._leaving=!0,de(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Ii(n,i);if("in-out"===r){if(ve(a))return c;var p,m=function(){p()};de(l,"afterEnter",m),de(l,"enterCancelled",m),de(u,"delayLeave",(function(n){p=n}))}}return i}}},_i=A({tag:String,moveClass:String},Ti);function zi(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ai(n){n.data.newPos=n.elm.getBoundingClientRect()}function Pi(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,i=e.top-t.top;if(r||i){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate("+r+"px,"+i+"px)",a.transitionDuration="0s"}}delete _i.mode;var Ri={Transition:Ei,TransitionGroup:{props:_i,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var i=Ye(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],a=this.children=[],o=wi(this),l=0;l<i.length;l++){var s=i[l];if(s.tag)if(null!=s.key&&0!==String(s.key).indexOf("__vlist"))a.push(s),t[s.key]=s,(s.data||(s.data={})).transition=o;else;}if(r){for(var c=[],d=[],u=0;u<r.length;u++){var p=r[u];p.data.transition=o,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?c.push(p):d.push(p)}this.kept=n(e,null,c),this.removed=d}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(zi),n.forEach(Ai),n.forEach(Pi),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;Xr(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Gr,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Gr,n),t._moveCb=null,Yr(t,e))})}})))},methods:{hasMove:function(n,e){if(!Qr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Nr(t,n)})),Ur(t,e),t.style.display="none",this.$el.appendChild(t);var r=ti(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};Ct.config.mustUseProp=function(n,e,t){return"value"===t&&jt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Ct.config.isReservedTag=Vt,Ct.config.isReservedAttr=Bt,Ct.config.getTagNamespace=function(n){return Kt(n)?"svg":"math"===n?"math":void 0},Ct.config.isUnknownElement=function(n){if(!W)return!0;if(Vt(n))return!1;if(n=n.toLowerCase(),null!=Jt[n])return Jt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Jt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Jt[n]=/HTMLUnknownElement/.test(e.toString())},A(Ct.options.directives,xi),A(Ct.options.components,Ri),Ct.prototype.__patch__=W?di:R,Ct.prototype.$mount=function(n,e){return function(n,e,t){var r;return n.$el=e,n.$options.render||(n.$options.render=bn),tt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new ht(n,r,R,{before:function(){n._isMounted&&!n._isDestroyed&&tt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,tt(n,"mounted")),n}(this,n=n&&W?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},W&&setTimeout((function(){F.devtools&&on&&on.emit("init",Ct)}),0);var Bi=Ct;
/*!
  * vue-router v3.5.3
  * (c) 2021 Evan You
  * @license MIT
  */function ji(n,e){for(var t in e)n[t]=e[t];return n}var Di=/[!'()*]/g,Mi=function(n){return"%"+n.charCodeAt(0).toString(16)},Li=/%2C/g,Oi=function(n){return encodeURIComponent(n).replace(Di,Mi).replace(Li,",")};function qi(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Fi=function(n){return null==n||"object"==typeof n?n:String(n)};function Ui(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=qi(t.shift()),i=t.length>0?qi(t.join("=")):null;void 0===e[r]?e[r]=i:Array.isArray(e[r])?e[r].push(i):e[r]=[e[r],i]})),e):e}function Ni(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Oi(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(Oi(e)):r.push(Oi(e)+"="+Oi(n)))})),r.join("&")}return Oi(e)+"="+Oi(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Hi=/\/?$/;function $i(n,e,t,r){var i=r&&r.options.stringifyQuery,a=e.query||{};try{a=Qi(a)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:Ki(e,i),matched:n?Gi(n):[]};return t&&(o.redirectedFrom=Ki(t,i)),Object.freeze(o)}function Qi(n){if(Array.isArray(n))return n.map(Qi);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=Qi(n[t]);return e}return n}var Wi=$i(null,{path:"/"});function Gi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Ki(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||Ni)(r)+i}function Vi(n,e,t){return e===Wi?n===e:!!e&&(n.path&&e.path?n.path.replace(Hi,"")===e.path.replace(Hi,"")&&(t||n.hash===e.hash&&Ji(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Ji(n.query,e.query)&&Ji(n.params,e.params))))}function Ji(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,i){var a=n[t];if(r[i]!==t)return!1;var o=e[t];return null==a||null==o?a===o:"object"==typeof a&&"object"==typeof o?Ji(a,o):String(a)===String(o)}))}function Zi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var i=t.instances[r],a=t.enteredCbs[r];if(i&&a){delete t.enteredCbs[r];for(var o=0;o<a.length;o++)i._isBeingDestroyed||a[o](i)}}}}var Xi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,i=e.parent,a=e.data;a.routerView=!0;for(var o=i.$createElement,l=t.name,s=i.$route,c=i._routerViewCache||(i._routerViewCache={}),d=0,u=!1;i&&i._routerRoot!==i;){var p=i.$vnode?i.$vnode.data:{};p.routerView&&d++,p.keepAlive&&i._directInactive&&i._inactive&&(u=!0),i=i.$parent}if(a.routerViewDepth=d,u){var m=c[l],h=m&&m.component;return h?(m.configProps&&Yi(h,a,m.route,m.configProps),o(h,a,r)):o()}var g=s.matched[d],f=g&&g.components[l];if(!g||!f)return c[l]=null,o();c[l]={component:f},a.registerRouteInstance=function(n,e){var t=g.instances[l];(e&&t!==n||!e&&t===n)&&(g.instances[l]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){g.instances[l]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[l]&&(g.instances[l]=n.componentInstance),Zi(s)};var v=g.props&&g.props[l];return v&&(ji(c[l],{route:s,configProps:v}),Yi(f,a,s,v)),o(f,a,r)}};function Yi(n,e,t,r){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(i){i=e.props=ji({},i);var a=e.attrs=e.attrs||{};for(var o in i)n.props&&o in n.props||(a[o]=i[o],delete i[o])}}function na(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var l=a[o];".."===l?i.pop():"."!==l&&i.push(l)}return""!==i[0]&&i.unshift(""),i.join("/")}function ea(n){return n.replace(/\/+/g,"/")}var ta=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ra=va,ia=ca,aa=function(n,e){return ua(ca(n,e),e)},oa=ua,la=fa,sa=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function ca(n,e){for(var t,r=[],i=0,a=0,o="",l=e&&e.delimiter||"/";null!=(t=sa.exec(n));){var s=t[0],c=t[1],d=t.index;if(o+=n.slice(a,d),a=d+s.length,c)o+=c[1];else{var u=n[a],p=t[2],m=t[3],h=t[4],g=t[5],f=t[6],v=t[7];o&&(r.push(o),o="");var b=null!=p&&null!=u&&u!==p,y="+"===f||"*"===f,x="?"===f||"*"===f,T=t[2]||l,k=h||g;r.push({name:m||i++,prefix:p||"",delimiter:T,optional:x,repeat:y,partial:b,asterisk:!!v,pattern:k?ma(k):v?".*":"[^"+pa(T)+"]+?"})}}return a<n.length&&(o+=n.substr(a)),o&&r.push(o),r}function da(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function ua(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",ga(e)));return function(e,r){for(var i="",a=e||{},o=(r||{}).pretty?da:encodeURIComponent,l=0;l<n.length;l++){var s=n[l];if("string"!=typeof s){var c,d=a[s.name];if(null==d){if(s.optional){s.partial&&(i+=s.prefix);continue}throw new TypeError('Expected "'+s.name+'" to be defined')}if(ta(d)){if(!s.repeat)throw new TypeError('Expected "'+s.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(s.optional)continue;throw new TypeError('Expected "'+s.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=o(d[u]),!t[l].test(c))throw new TypeError('Expected all "'+s.name+'" to match "'+s.pattern+'", but received `'+JSON.stringify(c)+"`");i+=(0===u?s.prefix:s.delimiter)+c}}else{if(c=s.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(d),!t[l].test(c))throw new TypeError('Expected "'+s.name+'" to match "'+s.pattern+'", but received "'+c+'"');i+=s.prefix+c}}else i+=s}return i}}function pa(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function ma(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function ha(n,e){return n.keys=e,n}function ga(n){return n&&n.sensitive?"":"i"}function fa(n,e,t){ta(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,i=!1!==t.end,a="",o=0;o<n.length;o++){var l=n[o];if("string"==typeof l)a+=pa(l);else{var s=pa(l.prefix),c="(?:"+l.pattern+")";e.push(l),l.repeat&&(c+="(?:"+s+c+")*"),a+=c=l.optional?l.partial?s+"("+c+")?":"(?:"+s+"("+c+"))?":s+"("+c+")"}}var d=pa(t.delimiter||"/"),u=a.slice(-d.length)===d;return r||(a=(u?a.slice(0,-d.length):a)+"(?:"+d+"(?=$))?"),a+=i?"$":r&&u?"":"(?="+d+"|$)",ha(new RegExp("^"+a,ga(t)),e)}function va(n,e,t){return ta(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return ha(n,e)}(n,e):ta(n)?function(n,e,t){for(var r=[],i=0;i<n.length;i++)r.push(va(n[i],e,t).source);return ha(new RegExp("(?:"+r.join("|")+")",ga(t)),e)}(n,e,t):function(n,e,t){return fa(ca(n,t),e,t)}(n,e,t)}ra.parse=ia,ra.compile=aa,ra.tokensToFunction=oa,ra.tokensToRegExp=la;var ba=Object.create(null);function ya(n,e,t){e=e||{};try{var r=ba[n]||(ba[n]=ra.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function xa(n,e,t,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var a=(i=ji({},n)).params;return a&&"object"==typeof a&&(i.params=ji({},a)),i}if(!i.path&&i.params&&e){(i=ji({},i))._normalized=!0;var o=ji(ji({},e.params),i.params);if(e.name)i.name=e.name,i.params=o;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;i.path=ya(l,o,e.path)}else 0;return i}var s=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),c=e&&e.path||"/",d=s.path?na(s.path,c,t||i.append):c,u=function(n,e,t){void 0===e&&(e={});var r,i=t||Ui;try{r=i(n||"")}catch(n){r={}}for(var a in e){var o=e[a];r[a]=Array.isArray(o)?o.map(Fi):Fi(o)}return r}(s.query,i.query,r&&r.options.parseQuery),p=i.hash||s.hash;return p&&"#"!==p.charAt(0)&&(p="#"+p),{_normalized:!0,path:d,query:u,hash:p}}var Ta,ka=function(){},wa={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,i=t.resolve(this.to,r,this.append),a=i.location,o=i.route,l=i.href,s={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,p=null==d?"router-link-exact-active":d,m=null==this.activeClass?u:this.activeClass,h=null==this.exactActiveClass?p:this.exactActiveClass,g=o.redirectedFrom?$i(null,xa(o.redirectedFrom),null,t):o;s[h]=Vi(r,g,this.exactPath),s[m]=this.exact||this.exactPath?s[h]:function(n,e){return 0===n.path.replace(Hi,"/").indexOf(e.path.replace(Hi,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,g);var f=s[h]?this.ariaCurrentValue:null,v=function(n){Ia(n)&&(e.replace?t.replace(a,ka):t.push(a,ka))},b={click:Ia};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var y={class:s},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:o,navigate:v,isActive:s[m],isExactActive:s[h]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:l,"aria-current":f};else{var T=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(T){T.isStatic=!1;var k=T.data=ji({},T.data);for(var w in k.on=k.on||{},k.on){var I=k.on[w];w in b&&(k.on[w]=Array.isArray(I)?I:[I])}for(var C in b)C in k.on?k.on[C].push(b[C]):k.on[C]=v;var S=T.data.attrs=ji({},T.data.attrs);S.href=l,S["aria-current"]=f}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Ia(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Ca="undefined"!=typeof window;function Sa(n,e,t,r,i){var a=e||[],o=t||Object.create(null),l=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,i,a,o){var l=i.path,s=i.name;0;var c=i.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ea(e.path+"/"+n)}(l,a,c.strict);"boolean"==typeof i.caseSensitive&&(c.sensitive=i.caseSensitive);var u={path:d,regex:Ea(d,c),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:s,parent:a,matchAs:o,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var a=o?ea(o+"/"+i.path):void 0;n(e,t,r,i,u,a)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==i.alias)for(var p=Array.isArray(i.alias)?i.alias:[i.alias],m=0;m<p.length;++m){0;var h={path:p[m],children:i.children};n(e,t,r,h,a,u.path||"/")}s&&(r[s]||(r[s]=u))}(a,o,l,n,i)}));for(var s=0,c=a.length;s<c;s++)"*"===a[s]&&(a.push(a.splice(s,1)[0]),c--,s--);return{pathList:a,pathMap:o,nameMap:l}}function Ea(n,e){return ra(n,[],e)}function _a(n,e){var t=Sa(n),r=t.pathList,i=t.pathMap,a=t.nameMap;function o(n,t,o){var l=xa(n,t,!1,e),c=l.name;if(c){var d=a[c];if(!d)return s(null,l);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof l.params&&(l.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in l.params)&&u.indexOf(p)>-1&&(l.params[p]=t.params[p]);return l.path=ya(d.path,l.params),s(d,l,o)}if(l.path){l.params={};for(var m=0;m<r.length;m++){var h=r[m],g=i[h];if(za(g.regex,l.path,l.params))return s(g,l,o)}}return s(null,l)}function l(n,t){var r=n.redirect,i="function"==typeof r?r($i(n,t,null,e)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return s(null,t);var l=i,c=l.name,d=l.path,u=t.query,p=t.hash,m=t.params;if(u=l.hasOwnProperty("query")?l.query:u,p=l.hasOwnProperty("hash")?l.hash:p,m=l.hasOwnProperty("params")?l.params:m,c){a[c];return o({_normalized:!0,name:c,query:u,hash:p,params:m},void 0,t)}if(d){var h=function(n,e){return na(n,e.parent?e.parent.path:"/",!0)}(d,n);return o({_normalized:!0,path:ya(h,m),query:u,hash:p},void 0,t)}return s(null,t)}function s(n,t,r){return n&&n.redirect?l(n,r||t):n&&n.matchAs?function(n,e,t){var r=o({_normalized:!0,path:ya(t,e.params)});if(r){var i=r.matched,a=i[i.length-1];return e.params=r.params,s(a,e)}return s(null,e)}(0,t,n.matchAs):$i(n,t,r,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Sa([e||n],r,i,a,t),t&&t.alias.length&&Sa(t.alias.map((function(n){return{path:n,children:[e]}})),r,i,a,t)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Sa(n,r,i,a)}}}function za(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var i=1,a=r.length;i<a;++i){var o=n.keys[i-1];o&&(t[o.name||"pathMatch"]="string"==typeof r[i]?qi(r[i]):r[i])}return!0}var Aa=Ca&&window.performance&&window.performance.now?window.performance:Date;function Pa(){return Aa.now().toFixed(3)}var Ra=Pa();function Ba(){return Ra}function ja(n){return Ra=n}var Da=Object.create(null);function Ma(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ji({},window.history.state);return t.key=Ba(),window.history.replaceState(t,"",e),window.addEventListener("popstate",qa),function(){window.removeEventListener("popstate",qa)}}function La(n,e,t,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var a=function(){var n=Ba();if(n)return Da[n]}(),o=i.call(n,e,t,r?a:null);o&&("function"==typeof o.then?o.then((function(n){$a(n,a)})).catch((function(n){0})):$a(o,a))}))}}function Oa(){var n=Ba();n&&(Da[n]={x:window.pageXOffset,y:window.pageYOffset})}function qa(n){Oa(),n.state&&n.state.key&&ja(n.state.key)}function Fa(n){return Na(n.x)||Na(n.y)}function Ua(n){return{x:Na(n.x)?n.x:window.pageXOffset,y:Na(n.y)?n.y:window.pageYOffset}}function Na(n){return"number"==typeof n}var Ha=/^#\d/;function $a(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=Ha.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(i,a={x:Na((t=a).x)?t.x:0,y:Na(t.y)?t.y:0})}else Fa(n)&&(e=Ua(n))}else r&&Fa(n)&&(e=Ua(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var Qa,Wa=Ca&&((-1===(Qa=window.navigator.userAgent).indexOf("Android 2.")&&-1===Qa.indexOf("Android 4.0")||-1===Qa.indexOf("Mobile Safari")||-1!==Qa.indexOf("Chrome")||-1!==Qa.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Ga(n,e){Oa();var t=window.history;try{if(e){var r=ji({},t.state);r.key=Ba(),t.replaceState(r,"",n)}else t.pushState({key:ja(Pa())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Ka(n){Ga(n,!0)}function Va(n,e,t){var r=function(i){i>=n.length?t():n[i]?e(n[i],(function(){r(i+1)})):r(i+1)};r(0)}var Ja={redirected:2,aborted:4,cancelled:8,duplicated:16};function Za(n,e){return Ya(n,e,Ja.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return no.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Xa(n,e){return Ya(n,e,Ja.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Ya(n,e,t,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var no=["params","query","hash"];function eo(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function to(n,e){return eo(n)&&n._isRouter&&(null==e||n.type===e)}function ro(n){return function(e,t,r){var i=!1,a=0,o=null;io(n,(function(n,e,t,l){if("function"==typeof n&&void 0===n.cid){i=!0,a++;var s,c=lo((function(e){var i;((i=e).__esModule||oo&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ta.extend(e),t.components[l]=e,--a<=0&&r()})),d=lo((function(n){var e="Failed to resolve async component "+l+": "+n;o||(o=eo(n)?n:new Error(e),r(o))}));try{s=n(c,d)}catch(n){d(n)}if(s)if("function"==typeof s.then)s.then(c,d);else{var u=s.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),i||r()}}function io(n,e){return ao(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function ao(n){return Array.prototype.concat.apply([],n)}var oo="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function lo(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var so=function(n,e){this.router=n,this.base=function(n){if(!n)if(Ca){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Wi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function co(n,e,t,r){var i=io(n,(function(n,r,i,a){var o=function(n,e){"function"!=typeof n&&(n=Ta.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,r,i,a)})):t(o,r,i,a)}));return ao(r?i.reverse():i)}function uo(n,e){if(e)return function(){return n.apply(e,arguments)}}so.prototype.listen=function(n){this.cb=n},so.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},so.prototype.onError=function(n){this.errorCbs.push(n)},so.prototype.transitionTo=function(n,e,t){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),e&&e(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,a)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!i.ready&&(to(n,Ja.redirected)&&a===Wi||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},so.prototype.confirmTransition=function(n,e,t){var r=this,i=this.current;this.pending=n;var a,o,l=function(n){!to(n)&&eo(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},s=n.matched.length-1,c=i.matched.length-1;if(Vi(n,i)&&s===c&&n.matched[s]===i.matched[c])return this.ensureURL(),n.hash&&La(this.router,i,n,!1),l(((o=Ya(a=i,n,Ja.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",o));var d=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,p=d.deactivated,m=d.activated,h=[].concat(function(n){return co(n,"beforeRouteLeave",uo,!0)}(p),this.router.beforeHooks,function(n){return co(n,"beforeRouteUpdate",uo)}(u),m.map((function(n){return n.beforeEnter})),ro(m)),g=function(e,t){if(r.pending!==n)return l(Xa(i,n));try{e(n,i,(function(e){!1===e?(r.ensureURL(!0),l(function(n,e){return Ya(n,e,Ja.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):eo(e)?(r.ensureURL(!0),l(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(l(Za(i,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){l(n)}};Va(h,g,(function(){Va(function(n){return co(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,i,a){return n(r,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),g,(function(){if(r.pending!==n)return l(Xa(i,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){Zi(n)}))}))}))},so.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},so.prototype.setupListeners=function(){},so.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Wi,this.pending=null};var po=function(n){function e(e,t){n.call(this,e,t),this._startLocation=mo(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=Wa&&t;r&&this.listeners.push(Ma());var i=function(){var t=n.current,i=mo(n.base);n.current===Wi&&i===n._startLocation||n.transitionTo(i,(function(n){r&&La(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Ga(ea(r.base+n.fullPath)),La(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Ka(ea(r.base+n.fullPath)),La(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(mo(this.base)!==this.current.fullPath){var e=ea(this.base+this.current.fullPath);n?Ga(e):Ka(e)}},e.prototype.getCurrentLocation=function(){return mo(this.base)},e}(so);function mo(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(ea(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var ho=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=mo(n);if(!/^\/#/.test(e))return window.location.replace(ea(n+"/#"+e)),!0}(this.base)||go()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Wa&&e;t&&this.listeners.push(Ma());var r=function(){var e=n.current;go()&&n.transitionTo(fo(),(function(r){t&&La(n.router,r,e,!0),Wa||yo(r.fullPath)}))},i=Wa?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){bo(n.fullPath),La(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){yo(n.fullPath),La(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;fo()!==e&&(n?bo(e):yo(e))},e.prototype.getCurrentLocation=function(){return fo()},e}(so);function go(){var n=fo();return"/"===n.charAt(0)||(yo("/"+n),!1)}function fo(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function vo(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function bo(n){Wa?Ga(vo(n)):window.location.hash=n}function yo(n){Wa?Ka(vo(n)):window.location.replace(vo(n))}var xo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){to(n,Ja.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(so),To=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=_a(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Wa&&!1!==n.fallback,this.fallback&&(e="hash"),Ca||(e="abstract"),this.mode=e,e){case"history":this.history=new po(this,n.base);break;case"hash":this.history=new ho(this,n.base,this.fallback);break;case"abstract":this.history=new xo(this,n.base);break;default:0}},ko={currentRoute:{configurable:!0}};function wo(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}To.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},ko.currentRoute.get=function(){return this.history&&this.history.current},To.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof po||t instanceof ho){var r=function(n){t.setupListeners(),function(n){var r=t.current,i=e.options.scrollBehavior;Wa&&i&&"fullPath"in n&&La(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},To.prototype.beforeEach=function(n){return wo(this.beforeHooks,n)},To.prototype.beforeResolve=function(n){return wo(this.resolveHooks,n)},To.prototype.afterEach=function(n){return wo(this.afterHooks,n)},To.prototype.onReady=function(n,e){this.history.onReady(n,e)},To.prototype.onError=function(n){this.history.onError(n)},To.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},To.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},To.prototype.go=function(n){this.history.go(n)},To.prototype.back=function(){this.go(-1)},To.prototype.forward=function(){this.go(1)},To.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},To.prototype.resolve=function(n,e,t){var r=xa(n,e=e||this.history.current,t,this),i=this.match(r,e),a=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?ea(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:i}},To.prototype.getRoutes=function(){return this.matcher.getRoutes()},To.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Wi&&this.history.transitionTo(this.history.getCurrentLocation())},To.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Wi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(To.prototype,ko),To.install=function n(e){if(!n.installed||Ta!==e){n.installed=!0,Ta=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Xi),e.component("RouterLink",wa);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},To.version="3.5.3",To.isNavigationFailure=to,To.NavigationFailureType=Ja,To.START_LOCATION=Wi,Ca&&window.Vue&&window.Vue.use(To);var Io=To;t(231),t(178),t(263),t(105),t(265),t(33),t(34),t(266);function Co(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}t(83),t(96),t(126);function So(n){return(So="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}var Eo=t(77),_o=(t(190),t(19),t(45),t(234),t(235),t(40),t(26),{NotFound:function(){return Promise.all([t.e(0),t.e(4)]).then(t.bind(null,492))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,491))}}),zo={"v-7f042c4c":function(){return t.e(5).then(t.bind(null,493))},"v-55ab495b":function(){return t.e(6).then(t.bind(null,494))},"v-7f4fa8ff":function(){return t.e(7).then(t.bind(null,495))},"v-26f88fff":function(){return t.e(8).then(t.bind(null,496))},"v-1e2a0709":function(){return t.e(9).then(t.bind(null,497))},"v-7a3f894c":function(){return t.e(10).then(t.bind(null,498))},"v-adecc362":function(){return t.e(11).then(t.bind(null,499))},"v-63a49f52":function(){return t.e(12).then(t.bind(null,500))},"v-1e5e3fdf":function(){return t.e(13).then(t.bind(null,501))},"v-fea1ca6c":function(){return t.e(14).then(t.bind(null,502))},"v-dc1b4da6":function(){return t.e(15).then(t.bind(null,503))},"v-265d3d7e":function(){return t.e(16).then(t.bind(null,504))},"v-4239add5":function(){return t.e(17).then(t.bind(null,505))},"v-932f2d58":function(){return t.e(18).then(t.bind(null,506))},"v-6097cc9c":function(){return t.e(19).then(t.bind(null,507))},"v-6395f8b6":function(){return t.e(20).then(t.bind(null,508))},"v-11101d84":function(){return t.e(21).then(t.bind(null,509))},"v-190803ce":function(){return t.e(22).then(t.bind(null,510))},"v-6655d46f":function(){return t.e(23).then(t.bind(null,511))},"v-510eccb8":function(){return t.e(24).then(t.bind(null,512))},"v-491fd7ec":function(){return t.e(25).then(t.bind(null,513))},"v-b75e4ec2":function(){return t.e(26).then(t.bind(null,514))},"v-21ce6260":function(){return t.e(27).then(t.bind(null,515))},"v-6ef572de":function(){return t.e(28).then(t.bind(null,516))},"v-47519682":function(){return t.e(29).then(t.bind(null,517))},"v-67c5593b":function(){return t.e(30).then(t.bind(null,518))},"v-0bf2fe55":function(){return t.e(31).then(t.bind(null,519))},"v-1cd4c4a0":function(){return t.e(32).then(t.bind(null,520))},"v-af744166":function(){return t.e(33).then(t.bind(null,521))},"v-5a6ba150":function(){return t.e(34).then(t.bind(null,522))},"v-278d74e8":function(){return t.e(35).then(t.bind(null,523))},"v-6091d31b":function(){return t.e(36).then(t.bind(null,524))},"v-1af69402":function(){return t.e(37).then(t.bind(null,525))},"v-f52afa76":function(){return t.e(38).then(t.bind(null,526))},"v-255354da":function(){return t.e(39).then(t.bind(null,527))},"v-0349074a":function(){return t.e(40).then(t.bind(null,528))},"v-65b0509c":function(){return t.e(41).then(t.bind(null,529))},"v-30f4df2d":function(){return t.e(42).then(t.bind(null,530))},"v-686da33c":function(){return t.e(43).then(t.bind(null,531))},"v-03ef00cc":function(){return t.e(44).then(t.bind(null,532))},"v-7f83aac5":function(){return t.e(45).then(t.bind(null,533))},"v-35aeaf87":function(){return t.e(46).then(t.bind(null,534))},"v-6c538cc0":function(){return t.e(47).then(t.bind(null,535))},"v-056e1262":function(){return t.e(48).then(t.bind(null,536))},"v-ecdbd4a2":function(){return t.e(49).then(t.bind(null,537))},"v-27b2649e":function(){return t.e(50).then(t.bind(null,538))},"v-55732b48":function(){return t.e(51).then(t.bind(null,539))},"v-12aaaa7d":function(){return t.e(52).then(t.bind(null,540))},"v-6dbfe670":function(){return t.e(53).then(t.bind(null,541))},"v-43c755b4":function(){return t.e(54).then(t.bind(null,542))},"v-2b866fe8":function(){return t.e(55).then(t.bind(null,543))},"v-bad396a0":function(){return t.e(56).then(t.bind(null,544))},"v-33b23c84":function(){return t.e(57).then(t.bind(null,545))},"v-13d9f031":function(){return t.e(58).then(t.bind(null,546))},"v-a097a3be":function(){return t.e(59).then(t.bind(null,547))},"v-3a239cb0":function(){return t.e(60).then(t.bind(null,548))},"v-1bdc9712":function(){return t.e(61).then(t.bind(null,549))},"v-68de8656":function(){return t.e(62).then(t.bind(null,550))},"v-72ea5972":function(){return t.e(63).then(t.bind(null,551))},"v-b5457c16":function(){return t.e(64).then(t.bind(null,552))},"v-0569b6f8":function(){return t.e(65).then(t.bind(null,553))},"v-4e6d8200":function(){return t.e(66).then(t.bind(null,554))},"v-2c19e87c":function(){return t.e(67).then(t.bind(null,555))},"v-25c50554":function(){return t.e(68).then(t.bind(null,556))},"v-6e2d857c":function(){return t.e(69).then(t.bind(null,557))},"v-51d6ac9c":function(){return t.e(70).then(t.bind(null,558))},"v-f82d5ee0":function(){return t.e(71).then(t.bind(null,559))},"v-e65aab34":function(){return t.e(72).then(t.bind(null,560))},"v-637f7ff4":function(){return t.e(73).then(t.bind(null,561))},"v-07d9254f":function(){return t.e(74).then(t.bind(null,562))},"v-cc527b5a":function(){return t.e(75).then(t.bind(null,563))},"v-04ae6228":function(){return t.e(76).then(t.bind(null,564))},"v-1a6137e8":function(){return t.e(77).then(t.bind(null,565))},"v-ca584e06":function(){return t.e(78).then(t.bind(null,566))},"v-f0251290":function(){return t.e(79).then(t.bind(null,567))},"v-0f7af49e":function(){return t.e(80).then(t.bind(null,568))},"v-1457855d":function(){return t.e(81).then(t.bind(null,569))},"v-3f96c8d8":function(){return t.e(82).then(t.bind(null,570))},"v-0893d5c3":function(){return t.e(83).then(t.bind(null,571))},"v-79c78335":function(){return t.e(84).then(t.bind(null,572))},"v-c5ef3042":function(){return t.e(85).then(t.bind(null,573))},"v-ce0e8fd4":function(){return t.e(86).then(t.bind(null,574))},"v-38d3c9ce":function(){return t.e(87).then(t.bind(null,575))},"v-5d9b4816":function(){return t.e(88).then(t.bind(null,576))},"v-3a98d9f2":function(){return t.e(89).then(t.bind(null,577))},"v-45cada9f":function(){return t.e(90).then(t.bind(null,578))},"v-612a002e":function(){return t.e(91).then(t.bind(null,579))},"v-179f8f74":function(){return t.e(92).then(t.bind(null,580))},"v-02e2a776":function(){return t.e(93).then(t.bind(null,581))},"v-20b770b6":function(){return t.e(94).then(t.bind(null,582))},"v-0480d1c5":function(){return t.e(95).then(t.bind(null,583))},"v-7e5bbd14":function(){return t.e(96).then(t.bind(null,584))}};function Ao(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var Po=/-(\w)/g,Ro=Ao((function(n){return n.replace(Po,(function(n,e){return e?e.toUpperCase():""}))})),Bo=/\B([A-Z])/g,jo=Ao((function(n){return n.replace(Bo,"-$1").toLowerCase()})),Do=Ao((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function Mo(n,e){if(e)return n(e)?n(e):e.includes("-")?n(Do(Ro(e))):n(Do(e))||n(jo(e))}var Lo=Object.assign({},_o,zo),Oo=function(n){return Lo[n]},qo=function(n){return zo[n]},Fo=function(n){return _o[n]},Uo=function(n){return Bi.component(n)};function No(n){return Mo(qo,n)}function Ho(n){return Mo(Fo,n)}function $o(n){return Mo(Oo,n)}function Qo(n){return Mo(Uo,n)}function Wo(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(r.a)(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(Qo(e)||!$o(e)){n.next=5;break}return n.next=3,$o(e)();case 3:t=n.sent,Bi.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function Go(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var Ko=t(137),Vo=(t(125),t(113),t(79),t(221)),Jo=t.n(Vo),Zo=t(222),Xo=t.n(Zo),Yo={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(Ko.a)(n,1)[0]})).map((function(n){var e=Object(Ko.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(Xo()(n[t]),'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=el(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(Eo.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=tl(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Jo()([{name:"description",content:this.$description}],n,this.siteMeta,rl)},updateCanonicalLink:function(){nl(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",el(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){tl(null,this.currentMetaTags),nl()}};function nl(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function el(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function tl(n,e){if(e&&Object(Eo.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function rl(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var r=t[e];if(n.hasOwnProperty(r))return n[r]+r}return JSON.stringify(n)}t(139);var il=t(152),al={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(il)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),r=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),i=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+r,o=0;o<t.length;o++){var l=t[o],s=t[o+1],c=0===o&&0===r||r>=l.parentElement.offsetTop+10&&(!s||r<s.parentElement.offsetTop-10),d=decodeURIComponent(this.$route.hash);if(c&&d!==decodeURIComponent(l.hash)){var u=l;if(a===i)for(var p=o+1;p<t.length;p++)if(d===decodeURIComponent(t[p].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(u.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},ol=(t(109),t(104)),ll=t.n(ol),sl={mounted:function(){var n=this;ll.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||Bi.component(n.name)||ll.a.start(),t()})),this.$router.afterEach((function(){ll.a.done(),n.isSidebarOpen=!1}))}};t(81),t(42),t(84),t(380);function cl(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(143);function dl(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function ul(n,e,t){return e&&dl(n.prototype,e),t&&dl(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}t(381);var pl=function(){function n(){cl(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return ul(n,[{key:"show",value:function(n){var e=this,t=n.text,r=void 0===t?"":t,i=n.duration,a=void 0===i?3e3:i,o=document.createElement("div");o.className="message move-in",o.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(r,"</div>\n    "),this.containerEl.appendChild(o),a>0&&setTimeout((function(){e.close(o)}),a)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),ml={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(e){document.querySelectorAll(e).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var e=this;if(!n.classList.contains("codecopy-enabled")){var t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Copy to clipboard",t.addEventListener("click",(function(){e.copyToClipboard(n.innerText)})),n.appendChild(t),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),(new pl).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};t(237),t(80),t(138),t(140),t(383);!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===t&&r.firstChild?r.insertBefore(i,r.firstChild):r.appendChild(i),i.styleSheet?i.styleSheet.cssText=n:i.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var hl={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},gl={},fl=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},vl=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:hl[n]},bl=function n(e,t,r){var i=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))i[n]=t[n];else{var e=n.replace("data","");i.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,a=e.children;i.appendChild(n(t,r,a))})),i},yl=function(n,e,t){var r,i=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==i.length||t?i:i[0]},xl=function(n,e){var t,r,i=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),l={css:i&&i[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};l.htmlTpl=fl(l.html),l.jsTpl=(t=l.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),l.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),i=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,a=[eval][0](i);return a.template=e,a}(l.js,l.html);var s=vl("vue");return l.jsLib.unshift(s),l},Tl=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),o={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},kl=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function wl(){var n=yl(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=yl(n,"vuepress-plugin-demo-block__code"),t=yl(n,"vuepress-plugin-demo-block__display"),r=yl(n,"vuepress-plugin-demo-block__footer"),i=yl(t,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),l=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var s=e.querySelector("div").clientHeight,c="react"===l?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),i=new Function("return ".concat(r))(),a={js:i,css:i.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:kl(n),htmlTpl:fl("")},o=vl("react"),l=vl("reactDOM");return a.jsLib.unshift(o,l),a}(a,o):"vanilla"===l?Tl(a,o):xl(a,o),d=bl("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(d),d.addEventListener("click",Il.bind(null,d,s,e,r)),vl("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,i=n.jsLib,a=n.cssLib,o=i.concat(a).concat(vl("cssLib")).concat(vl("jsLib")).join(",");return bl("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),vl("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,i=n.jsLib,a=n.cssLib,o=JSON.stringify({css:e,html:t,js:r,js_external:i.concat(vl("jsLib")).join(";"),css_external:a.concat(vl("cssLib")).join(";"),layout:vl("codepenLayout"),js_pre_processor:vl("codepenJsProcessor"),editors:vl("codepenEditors")});return bl("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:vl("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!gl[n]){var e=bl("style",{innerHTML:n});document.body.appendChild(e),gl[n]=!0}}(c.css),"react"===l)ReactDOM.render(React.createElement(c.js),i);else if("vue"===l){var p=(new(Vue.extend(c.script))).$mount();i.appendChild(p.$el)}else"vanilla"===l&&(i.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){wl()}),300)}function Il(n,e,t,r){var i="1"!==n.dataset.isExpand;t.style.height=i?"".concat(e,"px"):0,i?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=i?"1":"0"}var Cl={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},wl()},updated:function(){wl()}},Sl=(t(225),"auto"),El="zoom-in",_l="zoom-out",zl="grab",Al="move";function Pl(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};r?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function Rl(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Bl(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function jl(n,e,t){!function(n){var e=Dl,t=Ml;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var r=n.style,i={};for(var a in e)t&&(i[a]=r[a]||""),r[a]=e[a];return i}var Dl="transition",Ml="transform",Ll="transform",Ol="transitionend";var ql=function(){},Fl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:ql,onClose:ql,onGrab:ql,onMove:ql,onRelease:ql,onBeforeOpen:ql,onBeforeClose:ql,onBeforeGrab:ql,onBeforeRelease:ql,onImageLoading:ql,onImageLoaded:ql},Ul={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Hl(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(i)>=a||Math.abs(r)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Nl(n)&&!Hl(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Nl(n)&&!Hl(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Nl(n){return 0===n.button}function Hl(n){return n.metaKey||n.ctrlKey}var $l={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,jl(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Pl(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){jl(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Ql="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Wl=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),Gl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},Kl={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Bl(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?zl:_l,transition:Ll+"\n        "+r+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=jl(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,jl(this.el,{transform:"none"})},grab:function(n,e,t){var r=Vl(),i=r.x-n,a=r.y-e;jl(this.el,{cursor:Al,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=Vl(),i=r.x-n,a=r.y-e;jl(this.el,{transition:Ll,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){jl(this.el,this.styleClose)},restoreOpenStyle:function(){jl(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Vl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,i=r.customSize,a=r.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":Ql(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var o=this.rect.width/2,l=this.rect.height/2,s=Vl(),c={x:s.x-o,y:s.y-l},d=c.x/o,u=c.y/l,p=a+Math.min(d,u);if(i&&"string"==typeof i){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,g=parseFloat(i)*m/(100*this.rect.width),f=parseFloat(i)*h/(100*this.rect.height);if(p>g||p>f)return{x:g,y:f}}return{x:p,y:p}}};function Vl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Jl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Pl(n,r,e[r],t)}))}var Zl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Kl),this.overlay=Object.create($l),this.handler=Object.create(Ul),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Gl({},Fl,e),this.overlay.init(this),this.handler.init(this)}return Wl(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=El,Pl(n,"click",this.handler.click),this.options.preloadImage&&Rl(Bl(n)));return this}},{key:"config",value:function(n){return n?(Gl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(r),Rl(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Pl(document,"scroll",this.handler.scroll),Pl(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Pl(window,"resize",this.handler.resizeWindow);var a=function n(){Pl(r,Ol,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Jl(document,e.handler,!0),t(r)};return Pl(r,Ol,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Sl,this.overlay.fadeOut(),this.target.zoomOut(),Pl(document,"scroll",this.handler.scroll,!1),Pl(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Pl(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Pl(t,Ol,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Jl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Pl(t,Ol,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var a=function n(){Pl(i,Ol,n,!1),r(i)};return Pl(i,Ol,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Al,this.target.move(n,e,t);var i=this.target.el,a=function n(){Pl(i,Ol,n,!1),r(i)};return Pl(i,Ol,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Sl,this.target.restoreOpenStyle();var r=function r(){Pl(t,Ol,r,!1),n.lock=!1,n.released=!0,e(t)};return Pl(t,Ol,r),this}}}]),n}(),Xl=".theme-vdoing-content img:not(.no-zoom)",Yl=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ns=Number("500"),es=function(){function n(){cl(this,n),this.instance=new Zl(Yl)}return ul(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Xl;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Xl,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ns;setTimeout((function(){return n.update(e)}),t)}}]),n}(),ts=[Yo,al,sl,ml,Cl,{watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new es,this.$vuepress.zooming.updateDelay()}}],rs={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Go("layout",n),Bi.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},is=t(30),as=Object(is.a)(rs,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var r;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(r=n[e]).push.apply(r,Object(Eo.a)(t));break;default:throw new Error("Unknown option name.")}}(as,"mixins",ts);var os=[{name:"v-7f042c4c",path:"/pages/51af24/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-7f042c4c").then(t)}},{path:"/pages/51af24/index.html",redirect:"/pages/51af24/"},{path:"/01.架构/01.系统架构面试.html",redirect:"/pages/51af24/"},{name:"v-55ab495b",path:"/pages/c083ab/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-55ab495b").then(t)}},{path:"/pages/c083ab/index.html",redirect:"/pages/c083ab/"},{path:"/01.架构/01.解决方案/Cinchcast的架构.html",redirect:"/pages/c083ab/"},{name:"v-7f4fa8ff",path:"/pages/f54c7b/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-7f4fa8ff").then(t)}},{path:"/pages/f54c7b/index.html",redirect:"/pages/f54c7b/"},{path:"/01.架构/01.解决方案/",redirect:"/pages/f54c7b/"},{name:"v-26f88fff",path:"/pages/008eff/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-26f88fff").then(t)}},{path:"/pages/008eff/index.html",redirect:"/pages/008eff/"},{path:"/01.架构/01.解决方案/亚马逊的架构.html",redirect:"/pages/008eff/"},{name:"v-1e2a0709",path:"/pages/b8e814/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-1e2a0709").then(t)}},{path:"/pages/b8e814/index.html",redirect:"/pages/b8e814/"},{path:"/01.架构/01.解决方案/低代码平台.html",redirect:"/pages/b8e814/"},{name:"v-7a3f894c",path:"/pages/1ed7ae/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-7a3f894c").then(t)}},{path:"/pages/1ed7ae/index.html",redirect:"/pages/1ed7ae/"},{path:"/01.架构/01.解决方案/海量数据处理.html",redirect:"/pages/1ed7ae/"},{name:"v-adecc362",path:"/pages/49a2bd/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-adecc362").then(t)}},{path:"/pages/49a2bd/index.html",redirect:"/pages/49a2bd/"},{path:"/01.架构/01.解决方案/电商.html",redirect:"/pages/49a2bd/"},{name:"v-63a49f52",path:"/pages/cb2119/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-63a49f52").then(t)}},{path:"/pages/cb2119/index.html",redirect:"/pages/cb2119/"},{path:"/01.架构/01.解决方案/短地址服务.html",redirect:"/pages/cb2119/"},{name:"v-1e5e3fdf",path:"/pages/d86624/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-1e5e3fdf").then(t)}},{path:"/pages/d86624/index.html",redirect:"/pages/d86624/"},{path:"/01.架构/01.解决方案/秒杀系统设计.html",redirect:"/pages/d86624/"},{name:"v-fea1ca6c",path:"/pages/0c680e/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-fea1ca6c").then(t)}},{path:"/pages/0c680e/index.html",redirect:"/pages/0c680e/"},{path:"/01.架构/02.安全/01.认证和授权.html",redirect:"/pages/0c680e/"},{name:"v-dc1b4da6",path:"/pages/292687/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-dc1b4da6").then(t)}},{path:"/pages/292687/index.html",redirect:"/pages/292687/"},{path:"/01.架构/02.安全/02.OAuth2.0.html",redirect:"/pages/292687/"},{name:"v-265d3d7e",path:"/pages/ce2da4/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-265d3d7e").then(t)}},{path:"/pages/ce2da4/index.html",redirect:"/pages/ce2da4/"},{path:"/01.架构/02.系统架构概述.html",redirect:"/pages/ce2da4/"},{name:"v-4239add5",path:"/pages/41c2c7/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-4239add5").then(t)}},{path:"/pages/41c2c7/index.html",redirect:"/pages/41c2c7/"},{path:"/01.架构/03.系统高性能架构.html",redirect:"/pages/41c2c7/"},{name:"v-932f2d58",path:"/pages/ad5762/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-932f2d58").then(t)}},{path:"/pages/ad5762/index.html",redirect:"/pages/ad5762/"},{path:"/01.架构/04.系统高可用架构.html",redirect:"/pages/ad5762/"},{name:"v-6097cc9c",path:"/pages/ed2a88/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-6097cc9c").then(t)}},{path:"/pages/ed2a88/index.html",redirect:"/pages/ed2a88/"},{path:"/01.架构/05.系统伸缩性架构.html",redirect:"/pages/ed2a88/"},{name:"v-6395f8b6",path:"/pages/1580de/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-6395f8b6").then(t)}},{path:"/pages/1580de/index.html",redirect:"/pages/1580de/"},{path:"/01.架构/06.系统扩展性架构.html",redirect:"/pages/1580de/"},{name:"v-11101d84",path:"/pages/039552/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-11101d84").then(t)}},{path:"/pages/039552/index.html",redirect:"/pages/039552/"},{path:"/01.架构/07.系统安全性架构.html",redirect:"/pages/039552/"},{name:"v-190803ce",path:"/pages/eb0425/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-190803ce").then(t)}},{path:"/pages/eb0425/index.html",redirect:"/pages/eb0425/"},{path:"/01.架构/08.大型系统核心技术.html",redirect:"/pages/eb0425/"},{name:"v-6655d46f",path:"/pages/4dfb51/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-6655d46f").then(t)}},{path:"/pages/4dfb51/index.html",redirect:"/pages/4dfb51/"},{path:"/01.架构/09.领域驱动设计.html",redirect:"/pages/4dfb51/"},{name:"v-510eccb8",path:"/pages/cbf9f8/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-510eccb8").then(t)}},{path:"/pages/cbf9f8/index.html",redirect:"/pages/cbf9f8/"},{path:"/01.架构/",redirect:"/pages/cbf9f8/"},{name:"v-491fd7ec",path:"/pages/3d05e6/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-491fd7ec").then(t)}},{path:"/pages/3d05e6/index.html",redirect:"/pages/3d05e6/"},{path:"/01.架构/如何设计系统.html",redirect:"/pages/3d05e6/"},{name:"v-b75e4ec2",path:"/pages/45e366/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-b75e4ec2").then(t)}},{path:"/pages/45e366/index.html",redirect:"/pages/45e366/"},{path:"/01.架构/系统测试架构.html",redirect:"/pages/45e366/"},{name:"v-21ce6260",path:"/pages/cd56bb/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-21ce6260").then(t)}},{path:"/pages/cd56bb/index.html",redirect:"/pages/cd56bb/"},{path:"/02.分布式/01.分布式综合/01.分布式面试总结.html",redirect:"/pages/cd56bb/"},{name:"v-6ef572de",path:"/pages/367308/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-6ef572de").then(t)}},{path:"/pages/367308/index.html",redirect:"/pages/367308/"},{path:"/02.分布式/02.分布式理论/01.分布式理论.html",redirect:"/pages/367308/"},{name:"v-47519682",path:"/pages/874539/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-47519682").then(t)}},{path:"/pages/874539/index.html",redirect:"/pages/874539/"},{path:"/02.分布式/02.分布式理论/02.分布式算法Paxos.html",redirect:"/pages/874539/"},{name:"v-67c5593b",path:"/pages/e40812/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-67c5593b").then(t)}},{path:"/pages/e40812/index.html",redirect:"/pages/e40812/"},{path:"/02.分布式/02.分布式理论/03.分布式算法Raft.html",redirect:"/pages/e40812/"},{name:"v-0bf2fe55",path:"/pages/d15993/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-0bf2fe55").then(t)}},{path:"/pages/d15993/index.html",redirect:"/pages/d15993/"},{path:"/02.分布式/02.分布式理论/04.分布式算法Gossip.html",redirect:"/pages/d15993/"},{name:"v-1cd4c4a0",path:"/pages/282676/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-1cd4c4a0").then(t)}},{path:"/pages/282676/index.html",redirect:"/pages/282676/"},{path:"/02.分布式/03.分布式关键技术/01.流量调度/01.流量控制.html",redirect:"/pages/282676/"},{name:"v-af744166",path:"/pages/b7ca44/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-af744166").then(t)}},{path:"/pages/b7ca44/index.html",redirect:"/pages/b7ca44/"},{path:"/02.分布式/03.分布式关键技术/01.流量调度/02.负载均衡.html",redirect:"/pages/b7ca44/"},{name:"v-5a6ba150",path:"/pages/d04ece/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-5a6ba150").then(t)}},{path:"/pages/d04ece/index.html",redirect:"/pages/d04ece/"},{path:"/02.分布式/03.分布式关键技术/01.流量调度/03.服务路由.html",redirect:"/pages/d04ece/"},{name:"v-278d74e8",path:"/pages/3e66c2/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-278d74e8").then(t)}},{path:"/pages/3e66c2/index.html",redirect:"/pages/3e66c2/"},{path:"/02.分布式/03.分布式关键技术/01.流量调度/10.分布式会话.html",redirect:"/pages/3e66c2/"},{name:"v-6091d31b",path:"/pages/471208/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-6091d31b").then(t)}},{path:"/pages/471208/index.html",redirect:"/pages/471208/"},{path:"/02.分布式/03.分布式关键技术/02.数据调度/01.数据缓存.html",redirect:"/pages/471208/"},{name:"v-1af69402",path:"/pages/7da6ca/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-1af69402").then(t)}},{path:"/pages/7da6ca/index.html",redirect:"/pages/7da6ca/"},{path:"/02.分布式/03.分布式关键技术/02.数据调度/02.读写分离.html",redirect:"/pages/7da6ca/"},{name:"v-f52afa76",path:"/pages/103382/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-f52afa76").then(t)}},{path:"/pages/103382/index.html",redirect:"/pages/103382/"},{path:"/02.分布式/03.分布式关键技术/02.数据调度/03.分库分表.html",redirect:"/pages/103382/"},{name:"v-255354da",path:"/pages/0b2e59/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-255354da").then(t)}},{path:"/pages/0b2e59/index.html",redirect:"/pages/0b2e59/"},{path:"/02.分布式/03.分布式关键技术/02.数据调度/04.分布式ID.html",redirect:"/pages/0b2e59/"},{name:"v-0349074a",path:"/pages/910bad/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-0349074a").then(t)}},{path:"/pages/910bad/index.html",redirect:"/pages/910bad/"},{path:"/02.分布式/03.分布式关键技术/02.数据调度/05.分布式事务.html",redirect:"/pages/910bad/"},{name:"v-65b0509c",path:"/pages/69360c/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-65b0509c").then(t)}},{path:"/pages/69360c/index.html",redirect:"/pages/69360c/"},{path:"/02.分布式/03.分布式关键技术/02.数据调度/06.分布式锁.html",redirect:"/pages/69360c/"},{name:"v-30f4df2d",path:"/pages/4bba35/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-30f4df2d").then(t)}},{path:"/pages/4bba35/index.html",redirect:"/pages/4bba35/"},{path:"/02.分布式/03.分布式关键技术/04.通信/01.消息队列.html",redirect:"/pages/4bba35/"},{name:"v-686da33c",path:"/pages/516f3b/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-686da33c").then(t)}},{path:"/pages/516f3b/index.html",redirect:"/pages/516f3b/"},{path:"/02.分布式/03.分布式关键技术/05.服务治理/01.服务注册和发现.html",redirect:"/pages/516f3b/"},{name:"v-03ef00cc",path:"/pages/4c0174/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-03ef00cc").then(t)}},{path:"/pages/4c0174/index.html",redirect:"/pages/4c0174/"},{path:"/02.分布式/03.分布式关键技术/05.服务治理/02.服务监控.html",redirect:"/pages/4c0174/"},{name:"v-7f83aac5",path:"/pages/f918df/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-7f83aac5").then(t)}},{path:"/pages/f918df/index.html",redirect:"/pages/f918df/"},{path:"/02.分布式/03.分布式关键技术/05.服务治理/03.服务链路监控.html",redirect:"/pages/f918df/"},{name:"v-35aeaf87",path:"/pages/28bda8/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-35aeaf87").then(t)}},{path:"/pages/28bda8/index.html",redirect:"/pages/28bda8/"},{path:"/02.分布式/03.分布式关键技术/05.服务治理/04.服务容错.html",redirect:"/pages/28bda8/"},{name:"v-6c538cc0",path:"/pages/5b6d71/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-6c538cc0").then(t)}},{path:"/pages/5b6d71/index.html",redirect:"/pages/5b6d71/"},{path:"/02.分布式/04.分布式应用/01.微服务/01.微服务基本原理.html",redirect:"/pages/5b6d71/"},{name:"v-056e1262",path:"/pages/f13c06/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-056e1262").then(t)}},{path:"/pages/f13c06/index.html",redirect:"/pages/f13c06/"},{path:"/02.分布式/04.分布式应用/01.微服务/01.微服务简介.html",redirect:"/pages/f13c06/"},{name:"v-ecdbd4a2",path:"/pages/ebf86b/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-ecdbd4a2").then(t)}},{path:"/pages/ebf86b/index.html",redirect:"/pages/ebf86b/"},{path:"/02.分布式/04.分布式应用/01.微服务/02.RPC.html",redirect:"/pages/ebf86b/"},{name:"v-27b2649e",path:"/pages/3c87eb/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-27b2649e").then(t)}},{path:"/pages/3c87eb/index.html",redirect:"/pages/3c87eb/"},{path:"/02.分布式/04.分布式应用/01.微服务/22.Kong.html",redirect:"/pages/3c87eb/"},{name:"v-55732b48",path:"/pages/7e2fd1/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-55732b48").then(t)}},{path:"/pages/7e2fd1/index.html",redirect:"/pages/7e2fd1/"},{path:"/02.分布式/04.分布式应用/01.微服务/",redirect:"/pages/7e2fd1/"},{name:"v-12aaaa7d",path:"/pages/3cb60a/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-12aaaa7d").then(t)}},{path:"/pages/3cb60a/index.html",redirect:"/pages/3cb60a/"},{path:"/02.分布式/",redirect:"/pages/3cb60a/"},{name:"v-6dbfe670",path:"/pages/eae6a0/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-6dbfe670").then(t)}},{path:"/pages/eae6a0/index.html",redirect:"/pages/eae6a0/"},{path:"/03.设计/01.UML/01.UML快速入门.html",redirect:"/pages/eae6a0/"},{name:"v-43c755b4",path:"/pages/97f796/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-43c755b4").then(t)}},{path:"/pages/97f796/index.html",redirect:"/pages/97f796/"},{path:"/03.设计/01.UML/02.UML结构建模图.html",redirect:"/pages/97f796/"},{name:"v-2b866fe8",path:"/pages/dba425/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-2b866fe8").then(t)}},{path:"/pages/dba425/index.html",redirect:"/pages/dba425/"},{path:"/03.设计/01.UML/03.UML行为建模图.html",redirect:"/pages/dba425/"},{name:"v-bad396a0",path:"/pages/8f04b3/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-bad396a0").then(t)}},{path:"/pages/8f04b3/index.html",redirect:"/pages/8f04b3/"},{path:"/03.设计/01.UML/",redirect:"/pages/8f04b3/"},{name:"v-33b23c84",path:"/pages/dad9fd/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-33b23c84").then(t)}},{path:"/pages/dad9fd/index.html",redirect:"/pages/dad9fd/"},{path:"/03.设计/02.设计模式/00.设计模式概述.html",redirect:"/pages/dad9fd/"},{name:"v-13d9f031",path:"/pages/4244b2/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-13d9f031").then(t)}},{path:"/pages/4244b2/index.html",redirect:"/pages/4244b2/"},{path:"/03.设计/02.设计模式/01.简单工厂模式.html",redirect:"/pages/4244b2/"},{name:"v-a097a3be",path:"/pages/58cd12/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-a097a3be").then(t)}},{path:"/pages/58cd12/index.html",redirect:"/pages/58cd12/"},{path:"/03.设计/02.设计模式/02.工厂方法模式.html",redirect:"/pages/58cd12/"},{name:"v-3a239cb0",path:"/pages/d40cbb/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-3a239cb0").then(t)}},{path:"/pages/d40cbb/index.html",redirect:"/pages/d40cbb/"},{path:"/03.设计/02.设计模式/03.抽象工厂模式.html",redirect:"/pages/d40cbb/"},{name:"v-1bdc9712",path:"/pages/cb480c/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-1bdc9712").then(t)}},{path:"/pages/cb480c/index.html",redirect:"/pages/cb480c/"},{path:"/03.设计/02.设计模式/04.建造者模式.html",redirect:"/pages/cb480c/"},{name:"v-68de8656",path:"/pages/c5ff69/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-68de8656").then(t)}},{path:"/pages/c5ff69/index.html",redirect:"/pages/c5ff69/"},{path:"/03.设计/02.设计模式/05.原型模式.html",redirect:"/pages/c5ff69/"},{name:"v-72ea5972",path:"/pages/b271ff/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-72ea5972").then(t)}},{path:"/pages/b271ff/index.html",redirect:"/pages/b271ff/"},{path:"/03.设计/02.设计模式/06.单例模式.html",redirect:"/pages/b271ff/"},{name:"v-b5457c16",path:"/pages/2c4733/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-b5457c16").then(t)}},{path:"/pages/2c4733/index.html",redirect:"/pages/2c4733/"},{path:"/03.设计/02.设计模式/07.适配器模式.html",redirect:"/pages/2c4733/"},{name:"v-0569b6f8",path:"/pages/9f520d/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-0569b6f8").then(t)}},{path:"/pages/9f520d/index.html",redirect:"/pages/9f520d/"},{path:"/03.设计/02.设计模式/08.桥接模式.html",redirect:"/pages/9f520d/"},{name:"v-4e6d8200",path:"/pages/b18a73/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-4e6d8200").then(t)}},{path:"/pages/b18a73/index.html",redirect:"/pages/b18a73/"},{path:"/03.设计/02.设计模式/09.组合模式.html",redirect:"/pages/b18a73/"},{name:"v-2c19e87c",path:"/pages/12897e/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-2c19e87c").then(t)}},{path:"/pages/12897e/index.html",redirect:"/pages/12897e/"},{path:"/03.设计/02.设计模式/10.装饰模式.html",redirect:"/pages/12897e/"},{name:"v-25c50554",path:"/pages/427347/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-25c50554").then(t)}},{path:"/pages/427347/index.html",redirect:"/pages/427347/"},{path:"/03.设计/02.设计模式/11.外观模式.html",redirect:"/pages/427347/"},{name:"v-6e2d857c",path:"/pages/265866/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-6e2d857c").then(t)}},{path:"/pages/265866/index.html",redirect:"/pages/265866/"},{path:"/03.设计/02.设计模式/12.享元模式.html",redirect:"/pages/265866/"},{name:"v-51d6ac9c",path:"/pages/2937c1/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-51d6ac9c").then(t)}},{path:"/pages/2937c1/index.html",redirect:"/pages/2937c1/"},{path:"/03.设计/02.设计模式/13.代理模式.html",redirect:"/pages/2937c1/"},{name:"v-f82d5ee0",path:"/pages/604ebc/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-f82d5ee0").then(t)}},{path:"/pages/604ebc/index.html",redirect:"/pages/604ebc/"},{path:"/03.设计/02.设计模式/14.模板方法模式.html",redirect:"/pages/604ebc/"},{name:"v-e65aab34",path:"/pages/6389ed/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-e65aab34").then(t)}},{path:"/pages/6389ed/index.html",redirect:"/pages/6389ed/"},{path:"/03.设计/02.设计模式/15.命令模式.html",redirect:"/pages/6389ed/"},{name:"v-637f7ff4",path:"/pages/d2026d/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-637f7ff4").then(t)}},{path:"/pages/d2026d/index.html",redirect:"/pages/d2026d/"},{path:"/03.设计/02.设计模式/16.迭代器模式.html",redirect:"/pages/d2026d/"},{name:"v-07d9254f",path:"/pages/87fbaa/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-07d9254f").then(t)}},{path:"/pages/87fbaa/index.html",redirect:"/pages/87fbaa/"},{path:"/03.设计/02.设计模式/17.观察者模式.html",redirect:"/pages/87fbaa/"},{name:"v-cc527b5a",path:"/pages/1e0eff/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-cc527b5a").then(t)}},{path:"/pages/1e0eff/index.html",redirect:"/pages/1e0eff/"},{path:"/03.设计/02.设计模式/18.解释器模式.html",redirect:"/pages/1e0eff/"},{name:"v-04ae6228",path:"/pages/b5886f/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-04ae6228").then(t)}},{path:"/pages/b5886f/index.html",redirect:"/pages/b5886f/"},{path:"/03.设计/02.设计模式/19.中介者模式.html",redirect:"/pages/b5886f/"},{name:"v-1a6137e8",path:"/pages/a92964/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-1a6137e8").then(t)}},{path:"/pages/a92964/index.html",redirect:"/pages/a92964/"},{path:"/03.设计/02.设计模式/20.职责链模式.html",redirect:"/pages/a92964/"},{name:"v-ca584e06",path:"/pages/e3cd5d/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-ca584e06").then(t)}},{path:"/pages/e3cd5d/index.html",redirect:"/pages/e3cd5d/"},{path:"/03.设计/02.设计模式/21.备忘录模式.html",redirect:"/pages/e3cd5d/"},{name:"v-f0251290",path:"/pages/e5bb92/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-f0251290").then(t)}},{path:"/pages/e5bb92/index.html",redirect:"/pages/e5bb92/"},{path:"/03.设计/02.设计模式/22.策略模式.html",redirect:"/pages/e5bb92/"},{name:"v-0f7af49e",path:"/pages/6e8ebc/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-0f7af49e").then(t)}},{path:"/pages/6e8ebc/index.html",redirect:"/pages/6e8ebc/"},{path:"/03.设计/02.设计模式/23.访问者模式.html",redirect:"/pages/6e8ebc/"},{name:"v-1457855d",path:"/pages/6420d5/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-1457855d").then(t)}},{path:"/pages/6420d5/index.html",redirect:"/pages/6420d5/"},{path:"/03.设计/02.设计模式/24.状态模式.html",redirect:"/pages/6420d5/"},{name:"v-3f96c8d8",path:"/pages/b3c94e/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-3f96c8d8").then(t)}},{path:"/pages/b3c94e/index.html",redirect:"/pages/b3c94e/"},{path:"/03.设计/02.设计模式/25.面向对象原则.html",redirect:"/pages/b3c94e/"},{name:"v-0893d5c3",path:"/pages/4b9193/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-0893d5c3").then(t)}},{path:"/pages/4b9193/index.html",redirect:"/pages/4b9193/"},{path:"/03.设计/02.设计模式/",redirect:"/pages/4b9193/"},{name:"v-79c78335",path:"/pages/89848c/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-79c78335").then(t)}},{path:"/pages/89848c/index.html",redirect:"/pages/89848c/"},{path:"/03.设计/03.重构/01.代码的坏味道和重构.html",redirect:"/pages/89848c/"},{name:"v-c5ef3042",path:"/pages/82f4c8/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-c5ef3042").then(t)}},{path:"/pages/82f4c8/index.html",redirect:"/pages/82f4c8/"},{path:"/03.设计/03.重构/02.代码坏味道之代码臃肿.html",redirect:"/pages/82f4c8/"},{name:"v-ce0e8fd4",path:"/pages/9ae679/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-ce0e8fd4").then(t)}},{path:"/pages/9ae679/index.html",redirect:"/pages/9ae679/"},{path:"/03.设计/03.重构/03.代码坏味道之滥用面向对象.html",redirect:"/pages/9ae679/"},{name:"v-38d3c9ce",path:"/pages/76e1cc/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-38d3c9ce").then(t)}},{path:"/pages/76e1cc/index.html",redirect:"/pages/76e1cc/"},{path:"/03.设计/03.重构/04.代码坏味道之变革的障碍.html",redirect:"/pages/76e1cc/"},{name:"v-5d9b4816",path:"/pages/dff53d/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-5d9b4816").then(t)}},{path:"/pages/dff53d/index.html",redirect:"/pages/dff53d/"},{path:"/03.设计/03.重构/05.代码坏味道之非必要的.html",redirect:"/pages/dff53d/"},{name:"v-3a98d9f2",path:"/pages/595d03/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-3a98d9f2").then(t)}},{path:"/pages/595d03/index.html",redirect:"/pages/595d03/"},{path:"/03.设计/03.重构/06.代码坏味道之耦合.html",redirect:"/pages/595d03/"},{name:"v-45cada9f",path:"/pages/156570/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-45cada9f").then(t)}},{path:"/pages/156570/index.html",redirect:"/pages/156570/"},{path:"/03.设计/03.重构/",redirect:"/pages/156570/"},{name:"v-612a002e",path:"/pages/dc158b/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-612a002e").then(t)}},{path:"/pages/dc158b/index.html",redirect:"/pages/dc158b/"},{path:"/03.设计/04.编程范式/01.错误处理.html",redirect:"/pages/dc158b/"},{name:"v-179f8f74",path:"/pages/9e0f8e/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-179f8f74").then(t)}},{path:"/pages/9e0f8e/index.html",redirect:"/pages/9e0f8e/"},{path:"/03.设计/04.编程范式/",redirect:"/pages/9e0f8e/"},{name:"v-02e2a776",path:"/archives/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-02e2a776").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-20b770b6",path:"/categories/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-20b770b6").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-0480d1c5",path:"/tags/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-0480d1c5").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-7e5bbd14",path:"/",component:as,beforeEnter:function(n,e,t){Wo("Layout","v-7e5bbd14").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:as}],ls={title:"DESIGN",description:"Design 是个人的架构设计心得",base:"/design/",headTags:[["link",{rel:"icon",href:"/design/img/favicon.ico"}],["meta",{name:"keywords",content:"vuepress,theme,blog,vdoing"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"系统架构面试",frontmatter:{title:"系统架构面试",date:"2020-08-10T10:59:18.000Z",categories:["架构"],tags:["架构","面试"],permalink:"/pages/51af24/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/01.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E9%9D%A2%E8%AF%95.html",relativePath:"01.架构/01.系统架构面试.md",key:"v-7f042c4c",path:"/pages/51af24/",headers:[{level:2,title:"1. 如何设计一个秒杀系统？",slug:"_1-如何设计一个秒杀系统",normalizedTitle:"1. 如何设计一个秒杀系统？",charIndex:13},{level:3,title:"1.1. 秒杀系统的挑战",slug:"_1-1-秒杀系统的挑战",normalizedTitle:"1.1. 秒杀系统的挑战",charIndex:32},{level:3,title:"1.2. 秒杀系统的解决思路",slug:"_1-2-秒杀系统的解决思路",normalizedTitle:"1.2. 秒杀系统的解决思路",charIndex:119},{level:3,title:"1.3. 秒杀系统的解决方案",slug:"_1-3-秒杀系统的解决方案",normalizedTitle:"1.3. 秒杀系统的解决方案",charIndex:372},{level:2,title:"2. 参考资料",slug:"_2-参考资料",normalizedTitle:"2. 参考资料",charIndex:1056}],headersStr:"1. 如何设计一个秒杀系统？ 1.1. 秒杀系统的挑战 1.2. 秒杀系统的解决思路 1.3. 秒杀系统的解决方案 2. 参考资料",content:'# 系统架构面试\n\n\n# 1. 如何设计一个秒杀系统？\n\n\n# 1.1. 秒杀系统的挑战\n\n秒杀的核心问题就是极高并发处理，由于系统要在瞬时承受平时数十倍甚至上百倍的流量，这往往超出系统上限，因此处理秒杀的核心思路是限流和缓存。\n\n\n# 1.2. 秒杀系统的解决思路\n\n * 系统上有拦截流量：尽可能在上游拦截和限制请求，限制流入后端的量，保证后端系统正常。 因为无论多少人参与秒杀，实际成交往往是有限的，而且远小于参加秒杀的人数，因此可以通过前端系统进行拦截，限制最终流入系统的请求数量，来保证系统正常进行。\n * 充分利用缓存：这是一个典型的读多写少的应用场景（一趟火车其实只有 2000 张票，200w 个人来买，最多 2000 个人下单成功，其他人都是查询库存，写比例只有 0.1%，读比例占 99.9%），非常适合使用缓存。\n\n\n# 1.3. 秒杀系统的解决方案\n\n秒杀系统具体方案如下：\n\n（1）浏览器、客户端拦截重复请求\n\n * 用户点击查询或购买按钮后，禁用按钮，避免用户重复提交请求。\n * JS 代码中限制用户在限定时间内只允许提交一次请求\n\n基于此，大部分流量已被拦截。\n\n（2）应用层拦截请求\n\n浏览器、客户端拦截重复请求只能应付通过浏览器访问的用户。如果有人通过程序发送 http 请求，则无法拦截。针对这种情况的方案是：\n\n以页面缓存的方式，针对短时间内的同一个访问源（如同一个 IP、同一个 Session、同一个用户 ID 多次发送 HTTP 请求）或同样的查询请求（如大量请求都是查询某类商品的库存），都返回相同的展示页面。\n\n如此限流，又有大部分的流量被拦截\n\n（3）服务层请求拦截与数据缓存\n\n加入有黑客，控制了 10w 台肉鸡（并且假设买票不需要实名认证），前面的的限制都不起作用了。这时应该怎么办？\n\n * 读请求（查库存） - 对于读请求，直接使用缓存即可，一般缓存服务器单机处理每秒 10w 个请求应该没什么问题。\n\n * 写请求（下单） - 由于服务层清楚的知道库存数量，所以完全可以根据库存数量进行限流。具体来说，就是把所有下单请求都丢该消息队列中，每次只取有限的写请求去数据层处理。当这些写请求处理完，更新一下缓存中的库存数，再去取下一批写请求，如果库存数不够，则消息队列的写请求全部返回"已售罄"的结果。\n\n> 参考：\n> \n>  * 如何设计秒杀系统？ - 阿里云云栖社区的回答 - 知乎\n>  * 如何设计秒杀系统？ - 网易云的回答 - 知乎\n\n\n# 2. 参考资料\n\n * 如何设计秒杀系统？ - 阿里云云栖社区的回答 - 知乎\n * 如何设计秒杀系统？ - 网易云的回答 - 知乎',normalizedContent:'# 系统架构面试\n\n\n# 1. 如何设计一个秒杀系统？\n\n\n# 1.1. 秒杀系统的挑战\n\n秒杀的核心问题就是极高并发处理，由于系统要在瞬时承受平时数十倍甚至上百倍的流量，这往往超出系统上限，因此处理秒杀的核心思路是限流和缓存。\n\n\n# 1.2. 秒杀系统的解决思路\n\n * 系统上有拦截流量：尽可能在上游拦截和限制请求，限制流入后端的量，保证后端系统正常。 因为无论多少人参与秒杀，实际成交往往是有限的，而且远小于参加秒杀的人数，因此可以通过前端系统进行拦截，限制最终流入系统的请求数量，来保证系统正常进行。\n * 充分利用缓存：这是一个典型的读多写少的应用场景（一趟火车其实只有 2000 张票，200w 个人来买，最多 2000 个人下单成功，其他人都是查询库存，写比例只有 0.1%，读比例占 99.9%），非常适合使用缓存。\n\n\n# 1.3. 秒杀系统的解决方案\n\n秒杀系统具体方案如下：\n\n（1）浏览器、客户端拦截重复请求\n\n * 用户点击查询或购买按钮后，禁用按钮，避免用户重复提交请求。\n * js 代码中限制用户在限定时间内只允许提交一次请求\n\n基于此，大部分流量已被拦截。\n\n（2）应用层拦截请求\n\n浏览器、客户端拦截重复请求只能应付通过浏览器访问的用户。如果有人通过程序发送 http 请求，则无法拦截。针对这种情况的方案是：\n\n以页面缓存的方式，针对短时间内的同一个访问源（如同一个 ip、同一个 session、同一个用户 id 多次发送 http 请求）或同样的查询请求（如大量请求都是查询某类商品的库存），都返回相同的展示页面。\n\n如此限流，又有大部分的流量被拦截\n\n（3）服务层请求拦截与数据缓存\n\n加入有黑客，控制了 10w 台肉鸡（并且假设买票不需要实名认证），前面的的限制都不起作用了。这时应该怎么办？\n\n * 读请求（查库存） - 对于读请求，直接使用缓存即可，一般缓存服务器单机处理每秒 10w 个请求应该没什么问题。\n\n * 写请求（下单） - 由于服务层清楚的知道库存数量，所以完全可以根据库存数量进行限流。具体来说，就是把所有下单请求都丢该消息队列中，每次只取有限的写请求去数据层处理。当这些写请求处理完，更新一下缓存中的库存数，再去取下一批写请求，如果库存数不够，则消息队列的写请求全部返回"已售罄"的结果。\n\n> 参考：\n> \n>  * 如何设计秒杀系统？ - 阿里云云栖社区的回答 - 知乎\n>  * 如何设计秒杀系统？ - 网易云的回答 - 知乎\n\n\n# 2. 参考资料\n\n * 如何设计秒杀系统？ - 阿里云云栖社区的回答 - 知乎\n * 如何设计秒杀系统？ - 网易云的回答 - 知乎',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"Cinchcast 的架构",frontmatter:{title:"Cinchcast 的架构",date:"2021-11-08T08:15:33.000Z",categories:["架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/c083ab/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/01.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/Cinchcast%E7%9A%84%E6%9E%B6%E6%9E%84.html",relativePath:"01.架构/01.解决方案/Cinchcast的架构.md",key:"v-55ab495b",path:"/pages/c083ab/",headers:[{level:2,title:"统计数据",slug:"统计数据",normalizedTitle:"统计数据",charIndex:231},{level:2,title:"数据中心",slug:"数据中心",normalizedTitle:"数据中心",charIndex:417},{level:2,title:"硬件",slug:"硬件",normalizedTitle:"硬件",charIndex:408},{level:2,title:"开发工具",slug:"开发工具",normalizedTitle:"开发工具",charIndex:626},{level:2,title:"软件和使用的技术",slug:"软件和使用的技术",normalizedTitle:"软件和使用的技术",charIndex:839},{level:2,title:"监测",slug:"监测",normalizedTitle:"监测",charIndex:1083},{level:2,title:"我们的原则",slug:"我们的原则",normalizedTitle:"我们的原则",charIndex:1238},{level:2,title:"架构",slug:"架构",normalizedTitle:"架构",charIndex:13},{level:2,title:"经验教训",slug:"经验教训",normalizedTitle:"经验教训",charIndex:1748},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2152}],headersStr:"统计数据 数据中心 硬件 开发工具 软件和使用的技术 监测 我们的原则 架构 经验教训 参考资料",content:"# Cinchcast 的架构\n\nCinchcast 提供的解决方案允许公司创建、共享、衡量和货币化音频内容，以接触和吸引对其业务最重要的人。我们的技术将会议桥接器与实时音频流相结合，以简化在线活动并增强参与者的参与度。 Cinchcast 技术还用于为全球最大的音频社交网络 Blogtalkradio 提供动力。今天，我们的平台每天制作和分发超过 1,500 小时的原创内容。在本文中，我们描述了我们为扩展平台以支持这种规模的数据而做出的工程决策。\n\n\n# 统计数据\n\n * 浏览量每月超过 5000 万\n * 创建了 50000 小时的音频内容\n * 1500 万个流媒体\n * 175,000,000 次广告展示\n * 峰值每秒 40000 并发请求\n * MSSQL、Redis、ElasticSearch 集群中存储的数据达到每天数 TB，\n * 10 人工程师团队\n * 生产环境大概有 100 左右的硬件节点\n\n\n# 数据中心\n\n线上网站部署在布鲁克林的数据中心。但 QA 和 Staging 环境则使用了 Amazon EC2 云实例。\n\n——考虑到数据安全，大部分公司不愿意把真实数据部署在云端。\n\n\n# 硬件\n\n * 大概有 50 台 Web 服务器\n * 15 台 MS SQL 数据库服务器\n * 2 台 Redis 的 NoSQL 的键值服务器\n * 2 台 NodeJS 服务器\n * 2 台 弹性搜索集群服务器\n\n\n# 开发工具\n\n * NET 4 C#：ASP.NET 和 MVC3\n * IDE 用的是 Visual Studio 2010 Team Suite\n * 用 StyleCop、ReSharper 来强化代码标准\n * 使用敏捷。其中大的功能用 Scrum，小任务则通过看板任务墙管理\n * 测试和持续集成使用 Jenkins + Nunit\n * 自动化测试则是 Selenium 和 Sauce On Demand\n\n\n# 软件和使用的技术\n\n * Windows Server 2008 R2 的 64 位操作系统\n * 基于微软 Windows Server 2008 Web 服务器下运行的 SQL Server 2005\n * 负载均衡是 EQL(Equalizer load balancers)\n * Redis 作为分布式缓存层和消息分发队列\n * NodeJS 用来进行实时分析和更新仪表盘\n * 搜索用得是 ElasticSearch，日志分析是通过 Sawmill+自定义分析器脚本\n\n\n# 监测\n\n * NewRelic：性能监控\n * 性能对 KPI（转换率，页面浏览量）的影响：Chartbeat：\n * Gomez，WhatsupGold，Nagios 等用来各种预警和报警\n * SQL Server monitoring 的监控：来自 Red Gate 的 SQL Monitor\n\n\n# 我们的原则\n\n * 尊重他人的时间。不要带着问题来，要拿出解决办法。\n * 不要去追逐当下的热点技术，先实现基本功能，然后再做锦上添花的。务实是最重要的。\n * 成为一个“如何做”的团队而不是总是说“不”的团队\n * 预先处理总比亡羊补牢要好，把安全植入到软件开发生命周期中，通过培训开发人员如何写出安全的软件并把它从一开始就作为业务优先考虑之处。\n\n\n# 架构\n\n * 所有 Javascript、CSS 和图像都缓存在 CDN 级别。 DNS 指向一个 CDN，它将请求传递给源服务器。我们使用 Cotendo 是因为它允许在 CDN 上做出 L7 路由决策。\n * 单独的 Web 服务器集群用于为普通用户和广告用户的请求提供服务，通过 cookie 进行区分。\n * 我们正在转向面向服务的架构，其中系统的关键部分，例如搜索、身份验证、缓存，都是以各种语言实现的 RESTFUL 服务。这些服务还提供了一个缓存层。\n * REDIS NOSQL 键值存储（redis.io）用作数据库调用之前的缓存层。\n * Scaleout 用于在网络服务器集群中维护会话状态。但是，我们正在考虑切换到 REDIS。\n\n\n# 经验教训\n\n * SQL Server 数据库中的文本搜索不好用，经常出现 CPU 阻塞，所以 Cinchcast 切换到 ElasticSearch，一个 Lucene 的衍生工具。\n * 微软内置的会话模块容易出现死锁，他们用 AngiesList 会话模块取代了它，并把数据存储到 Redis。\n * 日志是发现问题的关键。\n * 重新发明轮子，有时候也可以是一件好事。例如，在一个供应商的提供的 JS / CSS 的产品导致性能问题的时候，他们通过重写显著改善了网站的性能。\n * 并不是所有的数据都是关系型的。\n * 在开发中不使用指标检测就像在风暴中不参考高度表来降落飞机，因此整个开发过程中，一定要通过网站吞吐量，解决错误的时间、代码覆盖率，等指标来衡量你的效率。 总的来说，对于日 PV 百万级的网站来说，Cinchcast 的架构、研发、运维等层面的技术选型和经验值得学习和参考。\n\n\n# 参考资料\n\n * 每天产生 1500 小时的音频",normalizedContent:"# cinchcast 的架构\n\ncinchcast 提供的解决方案允许公司创建、共享、衡量和货币化音频内容，以接触和吸引对其业务最重要的人。我们的技术将会议桥接器与实时音频流相结合，以简化在线活动并增强参与者的参与度。 cinchcast 技术还用于为全球最大的音频社交网络 blogtalkradio 提供动力。今天，我们的平台每天制作和分发超过 1,500 小时的原创内容。在本文中，我们描述了我们为扩展平台以支持这种规模的数据而做出的工程决策。\n\n\n# 统计数据\n\n * 浏览量每月超过 5000 万\n * 创建了 50000 小时的音频内容\n * 1500 万个流媒体\n * 175,000,000 次广告展示\n * 峰值每秒 40000 并发请求\n * mssql、redis、elasticsearch 集群中存储的数据达到每天数 tb，\n * 10 人工程师团队\n * 生产环境大概有 100 左右的硬件节点\n\n\n# 数据中心\n\n线上网站部署在布鲁克林的数据中心。但 qa 和 staging 环境则使用了 amazon ec2 云实例。\n\n——考虑到数据安全，大部分公司不愿意把真实数据部署在云端。\n\n\n# 硬件\n\n * 大概有 50 台 web 服务器\n * 15 台 ms sql 数据库服务器\n * 2 台 redis 的 nosql 的键值服务器\n * 2 台 nodejs 服务器\n * 2 台 弹性搜索集群服务器\n\n\n# 开发工具\n\n * net 4 c#：asp.net 和 mvc3\n * ide 用的是 visual studio 2010 team suite\n * 用 stylecop、resharper 来强化代码标准\n * 使用敏捷。其中大的功能用 scrum，小任务则通过看板任务墙管理\n * 测试和持续集成使用 jenkins + nunit\n * 自动化测试则是 selenium 和 sauce on demand\n\n\n# 软件和使用的技术\n\n * windows server 2008 r2 的 64 位操作系统\n * 基于微软 windows server 2008 web 服务器下运行的 sql server 2005\n * 负载均衡是 eql(equalizer load balancers)\n * redis 作为分布式缓存层和消息分发队列\n * nodejs 用来进行实时分析和更新仪表盘\n * 搜索用得是 elasticsearch，日志分析是通过 sawmill+自定义分析器脚本\n\n\n# 监测\n\n * newrelic：性能监控\n * 性能对 kpi（转换率，页面浏览量）的影响：chartbeat：\n * gomez，whatsupgold，nagios 等用来各种预警和报警\n * sql server monitoring 的监控：来自 red gate 的 sql monitor\n\n\n# 我们的原则\n\n * 尊重他人的时间。不要带着问题来，要拿出解决办法。\n * 不要去追逐当下的热点技术，先实现基本功能，然后再做锦上添花的。务实是最重要的。\n * 成为一个“如何做”的团队而不是总是说“不”的团队\n * 预先处理总比亡羊补牢要好，把安全植入到软件开发生命周期中，通过培训开发人员如何写出安全的软件并把它从一开始就作为业务优先考虑之处。\n\n\n# 架构\n\n * 所有 javascript、css 和图像都缓存在 cdn 级别。 dns 指向一个 cdn，它将请求传递给源服务器。我们使用 cotendo 是因为它允许在 cdn 上做出 l7 路由决策。\n * 单独的 web 服务器集群用于为普通用户和广告用户的请求提供服务，通过 cookie 进行区分。\n * 我们正在转向面向服务的架构，其中系统的关键部分，例如搜索、身份验证、缓存，都是以各种语言实现的 restful 服务。这些服务还提供了一个缓存层。\n * redis nosql 键值存储（redis.io）用作数据库调用之前的缓存层。\n * scaleout 用于在网络服务器集群中维护会话状态。但是，我们正在考虑切换到 redis。\n\n\n# 经验教训\n\n * sql server 数据库中的文本搜索不好用，经常出现 cpu 阻塞，所以 cinchcast 切换到 elasticsearch，一个 lucene 的衍生工具。\n * 微软内置的会话模块容易出现死锁，他们用 angieslist 会话模块取代了它，并把数据存储到 redis。\n * 日志是发现问题的关键。\n * 重新发明轮子，有时候也可以是一件好事。例如，在一个供应商的提供的 js / css 的产品导致性能问题的时候，他们通过重写显著改善了网站的性能。\n * 并不是所有的数据都是关系型的。\n * 在开发中不使用指标检测就像在风暴中不参考高度表来降落飞机，因此整个开发过程中，一定要通过网站吞吐量，解决错误的时间、代码覆盖率，等指标来衡量你的效率。 总的来说，对于日 pv 百万级的网站来说，cinchcast 的架构、研发、运维等层面的技术选型和经验值得学习和参考。\n\n\n# 参考资料\n\n * 每天产生 1500 小时的音频",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"README",frontmatter:{title:"README",date:"2021-11-08T08:15:33.000Z",categories:["架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/f54c7b/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/01.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/",relativePath:"01.架构/01.解决方案/README.md",key:"v-7f4fa8ff",path:"/pages/f54c7b/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:11},{level:3,title:"知名系统架构",slug:"知名系统架构",normalizedTitle:"知名系统架构",charIndex:21},{level:3,title:"我上我也行系列",slug:"我上我也行系列",normalizedTitle:"我上我也行系列",charIndex:1665},{level:4,title:"设计一个短地址服务",slug:"设计一个短地址服务",normalizedTitle:"设计一个短地址服务",charIndex:1676},{level:4,title:"设计一个低代码平台",slug:"设计一个低代码平台",normalizedTitle:"设计一个低代码平台",charIndex:1689},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:1703},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:1713}],headersStr:"📖 内容 知名系统架构 我上我也行系列 设计一个短地址服务 设计一个低代码平台 📚 资料 🚪 传送",content:"# 解决方案\n\n\n# 📖 内容\n\n\n# 知名系统架构\n\n类型                细分类型    系统                                      资料\nData processing           MapReduce - Google 的分布式数据处理             research.google.com\nData processing           Spark - Databricks 的分布式数据处理             slideshare.net\nData processing           Storm - Twitter 的分布式数据处理                slideshare.net\n                                                                  \n分布式存储             Nosql   Bigtable - Google 的列式数据库                harvard.edu\n分布式存储             Nosql   HBase - Bigtable 的开源实现                  slideshare.net\n分布式存储             Nosql   Cassandra - Facebook 的列式数据库             slideshare.net\n分布式存储             Nosql   DynamoDB - Amazon 的文档数据库                harvard.edu\n分布式存储             Nosql   MongoDB - 文档数据库                         MongoDB\n分布式存储             Nosql   Spanner - Google 的全球分布数据库               research.google.com\n分布式存储             Nosql   Memcached - 分布式内存缓存系统                   slideshare.net\n分布式存储             Nosql   Redis - 能够持久化及具有值类型的分布式内存缓存系统           Redis\n分布式存储             文件系统    Google File System (GFS) - 分布式文件系统      research.google.com\n分布式存储             文件系统    Hadoop File System (HDFS) - GFS 的开源实现   apache.org\n                                                                  \n分布式中间件                    Chubby - Google 的分布式系统的低耦合锁服务           research.google.com\n分布式中间件                    Dapper - 分布式系统跟踪基础设施                    research.google.com\n分布式中间件            MQ      Kafka - LinkedIn 的发布订阅消息系统              Kafka\n分布式中间件            分布式协调   Zookeeper - 集中的基础架构和协调服务                ZooKeeper\n                                                                  \n\n\n# 我上我也行系列\n\n# 设计一个短地址服务\n\n# 设计一个低代码平台\n\n\n# 📚 资料\n\n\n# 🚪 传送\n\n◾ 🏠 DESIGN 首页 ◾ 🎯 我的博客 ◾",normalizedContent:"# 解决方案\n\n\n# 📖 内容\n\n\n# 知名系统架构\n\n类型                细分类型    系统                                      资料\ndata processing           mapreduce - google 的分布式数据处理             research.google.com\ndata processing           spark - databricks 的分布式数据处理             slideshare.net\ndata processing           storm - twitter 的分布式数据处理                slideshare.net\n                                                                  \n分布式存储             nosql   bigtable - google 的列式数据库                harvard.edu\n分布式存储             nosql   hbase - bigtable 的开源实现                  slideshare.net\n分布式存储             nosql   cassandra - facebook 的列式数据库             slideshare.net\n分布式存储             nosql   dynamodb - amazon 的文档数据库                harvard.edu\n分布式存储             nosql   mongodb - 文档数据库                         mongodb\n分布式存储             nosql   spanner - google 的全球分布数据库               research.google.com\n分布式存储             nosql   memcached - 分布式内存缓存系统                   slideshare.net\n分布式存储             nosql   redis - 能够持久化及具有值类型的分布式内存缓存系统           redis\n分布式存储             文件系统    google file system (gfs) - 分布式文件系统      research.google.com\n分布式存储             文件系统    hadoop file system (hdfs) - gfs 的开源实现   apache.org\n                                                                  \n分布式中间件                    chubby - google 的分布式系统的低耦合锁服务           research.google.com\n分布式中间件                    dapper - 分布式系统跟踪基础设施                    research.google.com\n分布式中间件            mq      kafka - linkedin 的发布订阅消息系统              kafka\n分布式中间件            分布式协调   zookeeper - 集中的基础架构和协调服务                zookeeper\n                                                                  \n\n\n# 我上我也行系列\n\n# 设计一个短地址服务\n\n# 设计一个低代码平台\n\n\n# 📚 资料\n\n\n# 🚪 传送\n\n◾ 🏠 design 首页 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"亚马逊的架构",frontmatter:{title:"亚马逊的架构",date:"2021-11-08T08:15:33.000Z",categories:["架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/008eff/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/01.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%9A%84%E6%9E%B6%E6%9E%84.html",relativePath:"01.架构/01.解决方案/亚马逊的架构.md",key:"v-26f88fff",path:"/pages/008eff/",headers:[{level:2,title:"摘录的要点",slug:"摘录的要点",normalizedTitle:"摘录的要点",charIndex:13},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:178}],headersStr:"摘录的要点 参考资料",content:"# 亚马逊的架构\n\n\n# 摘录的要点\n\n可扩展：添加资源，性能成正比提升\n\n分布式、去中心化\n\n隔离性：面向服务，聚合数以百计的服务，对外统一提供服务\n\n同时支持 REST 和 SOAP\n\n团队在精不在多，节省沟通成本\n\n状态管理是大规模系统的核心问题，如分布式 Session 等\n\n设计应尽量简单，很多问题可以用业务逻辑去解决，而不是通过技术\n\n\n# 参考资料\n\n * Amazon 的架构",normalizedContent:"# 亚马逊的架构\n\n\n# 摘录的要点\n\n可扩展：添加资源，性能成正比提升\n\n分布式、去中心化\n\n隔离性：面向服务，聚合数以百计的服务，对外统一提供服务\n\n同时支持 rest 和 soap\n\n团队在精不在多，节省沟通成本\n\n状态管理是大规模系统的核心问题，如分布式 session 等\n\n设计应尽量简单，很多问题可以用业务逻辑去解决，而不是通过技术\n\n\n# 参考资料\n\n * amazon 的架构",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"低代码平台",frontmatter:{title:"低代码平台",date:"2021-05-06T16:57:48.000Z",categories:["架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/b8e814/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/01.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BD%8E%E4%BB%A3%E7%A0%81%E5%B9%B3%E5%8F%B0.html",relativePath:"01.架构/01.解决方案/低代码平台.md",key:"v-1e2a0709",path:"/pages/b8e814/",headers:[{level:2,title:"业务分析",slug:"业务分析",normalizedTitle:"业务分析",charIndex:76},{level:3,title:"低代码平台是什么",slug:"低代码平台是什么",normalizedTitle:"低代码平台是什么",charIndex:85},{level:3,title:"技术路线",slug:"技术路线",normalizedTitle:"技术路线",charIndex:287},{level:4,title:"基于 IDE 框架的快速开发平台",slug:"基于-ide-框架的快速开发平台",normalizedTitle:"基于 ide 框架的快速开发平台",charIndex:295},{level:4,title:"基于模型驱动的应用平台",slug:"基于模型驱动的应用平台",normalizedTitle:"基于模型驱动的应用平台",charIndex:556},{level:3,title:"核心要素",slug:"核心要素",normalizedTitle:"核心要素",charIndex:783},{level:4,title:"数据模型",slug:"数据模型",normalizedTitle:"数据模型",charIndex:356},{level:4,title:"业务流程",slug:"业务流程",normalizedTitle:"业务流程",charIndex:986},{level:4,title:"用户权限",slug:"用户权限",normalizedTitle:"用户权限",charIndex:991},{level:4,title:"统计图表",slug:"统计图表",normalizedTitle:"统计图表",charIndex:996},{level:3,title:"流行产品",slug:"流行产品",normalizedTitle:"流行产品",charIndex:1776},{level:4,title:"OutSystems",slug:"outsystems",normalizedTitle:"outsystems",charIndex:1784},{level:4,title:"Mendix",slug:"mendix",normalizedTitle:"mendix",charIndex:1923},{level:2,title:"顶层设计",slug:"顶层设计",normalizedTitle:"顶层设计",charIndex:2064},{level:2,title:"组件设计",slug:"组件设计",normalizedTitle:"组件设计",charIndex:2452},{level:3,title:"列表页",slug:"列表页",normalizedTitle:"列表页",charIndex:2461},{level:4,title:"搜索栏",slug:"搜索栏",normalizedTitle:"搜索栏",charIndex:2468},{level:4,title:"操作栏",slug:"操作栏",normalizedTitle:"操作栏",charIndex:2475},{level:4,title:"表格",slug:"表格",normalizedTitle:"表格",charIndex:2482},{level:4,title:"分页",slug:"分页",normalizedTitle:"分页",charIndex:2488},{level:3,title:"表单页",slug:"表单页",normalizedTitle:"表单页",charIndex:2495},{level:4,title:"表单组件",slug:"表单组件",normalizedTitle:"表单组件",charIndex:2502},{level:4,title:"校验器",slug:"校验器",normalizedTitle:"校验器",charIndex:2510},{level:2,title:"扩展设计",slug:"扩展设计",normalizedTitle:"扩展设计",charIndex:2518},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2527}],headersStr:"业务分析 低代码平台是什么 技术路线 基于 IDE 框架的快速开发平台 基于模型驱动的应用平台 核心要素 数据模型 业务流程 用户权限 统计图表 流行产品 OutSystems Mendix 顶层设计 组件设计 列表页 搜索栏 操作栏 表格 分页 表单页 表单组件 校验器 扩展设计 参考资料",content:"# 设计一个低代码平台\n\n> 本文目标是设计一个用于提高开发人员开发效率的低代码平台，这里会采用系统解决方案设计的一般思路来逐步探寻设计方案。\n\n\n# 业务分析\n\n\n# 低代码平台是什么\n\n广义上的低代码平台包括低代码平台和零代码平台，它们都属于 APaaS（Application Platform as a Service 应用平台即服务），两者的主要区别在于对代码的依赖程度：\n\n * 低代码平台：通过自动代码生成和可视化编程，只需要少量代码，即可快速搭建各种应用。\n * 零代码平台：零开发经验的业务人员通过拖拽等方式，无需编写代码，即可快速搭建各种应用。\n\n\n# 技术路线\n\n# 基于 IDE 框架的快速开发平台\n\n该方案将传统的集成开发环境（IDE）充分可视化，开发者对前端界面组件、数据源绑定方式、数据模型、业务逻辑和工作流等都可以自由定义，平台将自动生成代码，开发者也可以添加自己的代码，对程序具有较强的控制能力，因此该方案具备更高的灵活性，可以设计出定制化程度高、逻辑复杂的软件。\n\n由于该方案仍涉及代码开发、部署等技术工作，所以它仍然是一个技术开发平台，需要较高的学习成本，主要价值是提高开发效率，减少重复劳动。\n\nOutsystems 就是采用该方案的典型产品，如下为产品截图：\n\n\n\n# 基于模型驱动的应用平台\n\n用户通过可视化方式构建数据模型、视图、权限、工作流等，即可在平台提供的环境中运行，无需编译部署，更像一种傻瓜式的应用搭建平台。平台对各类组件、业务逻辑做了较高层级的封装，因此用户无法随心所欲修改界面风格、交互方式、处理逻辑等。\n\n该方案可以实现完全零代码，对使用者技术要求不高，但需要具备业务抽象、建模能力。主要价值是降低开发门槛、快速适应变化。\n\n明道云、伙伴云等都是此类方案的典型产品，如下为明道云的产品截图：\n\n\n\n\n# 核心要素\n\n绝大部分的企业软件由以下四个部分组成：\n\n * 业务实体：即操作对象，如客户、订单\n * 业务活动：即进行何种操作，如采购申请、合同审批\n * 业务权限：即何种人拥有何种权限，包括数据查看权限和数据操作权限，如部门经理可以管理所有下属的客户信息，而员工只能管理自己的客户信息\n * 统计报表：即从哪些方面量化企业活动情况，如客户增长率、各月销售额趋势\n\n低代码平台将以上进行抽象，支持数据模型、业务流程、用户权限、统计图表，因此可以作为更通用的企业软件解决方案，这四类能力也是任何一个低代码平台都必须具备的核心要素。\n\n# 数据模型\n\n建立数据模型就是提取业务实体的数据特征，抽象为数据表，建立表间关系。制作 ER 图的过程就是数据建模。市面上常见的低代码平台均提供了丰富的控件，可以拖拽完成数据模型搭建。此外，数据模型搭建与表单展示合二为一，每完成一个数据表的创建，就自动生成了该表的增删改查功能及相关页面，进而隐藏了数据库设计、前端开发这些专业技术。其实，这也就是我们常说的表单引擎。\n\n这里顺便提一下，虽然很多低代码平台将数据建模与表单展示合二为一，但通过这种方式自动生成的表单只能实现最基础的增删改查页面，用户对界面展示内容及形式的控制程度很低，无法满足大部分企业软件的需求，所以低代码平台一般还会提供自定义页面功能，用户可根据需要在页面上配置按钮、图表等元素，满足个性化需求。\n\n# 业务流程\n\n业务流程指为了实现某项目标，由多人合作，按照一定的规则、顺序进行的一系列活动，在软件中，业务流程的参与者可以是人，也可以是程序。低代码平台实现了可视化流程配置，用户对触发条件、处理节点、节点参与者进行配置，实现自定义业务流程。\n\n# 用户权限\n\n大部分的低代码平台都采用了非常经典的 RBAC（Role-Based Access Control ）模型管理用户权限，简单来说就是将拥有相同权限的用户添加为相同角色，通过为角色分配权限，实现了“用户——角色——权限”的授权模式。由于企业是一个组织，一般都会有部门的概念，所以也可以将部门添加到某个角色，实现“用户——部门——角色——权限”的授权模式。\n\n# 统计图表\n\n统计图表可以类比 Excel 中的透视图，统计图表由数据源、统计规则、展示形式定义，低代码平台也正是遵循这种方式，实现统计图表的可视化配置。\n\n\n# 流行产品\n\n# OutSystems\n\nOutSystems 是快速应用开发的头号低代码平台，并且是 2018 年 Gartner 高生产力平台的领导者。OutSystems 号称将低代码功能与高级移动功能相结合的唯一解决方案，它支持整个应用程序组合的可视化开发，可轻松与现有系统集成。\n\n# Mendix\n\nMendix 帮助企业改善创新方式。通过使用可视化模型，在 Mendix 上构建应用程序非常简单，快速且直观，可使开发人员和业务分析人员等众多人员构建强大的应用程序，而无需编写代码。借助模型驱动开发，业务领导者和 IT 部门可以共享语言来快速构建应用程序。\n\n\n# 顶层设计\n\n由于系统的用户群体是有一定技术基础的开发人员。所以，系统定位是低代码平台，而非零代码平台。\n\n其次，由于系统主要是用于简化基本的页面开发，所以技术路线应该选择：基于模型驱动的应用平台。\n\n最后，由于生成的代码是应用于 Java Web 框架。生成的后端代码是 java 代码；前端代码是基于 vue + element-ui 生态的前端代码。\n\n\n\n代码生成规则对应的数据建模：\n\n\n\n自动生成前后端代码。\n\n * 后端代码\n   * Controller\n   * Service\n   * ServiceImpl\n   * Daomybatis\n   * DaoImpl\n   * Mapper\n   * Query\n   * Dto\n   * Entity\n   * xml\n * 前端代码\n   * List\n   * Form\n   * Api\n\n\n# 组件设计\n\n\n# 列表页\n\n# 搜索栏\n\n# 操作栏\n\n# 表格\n\n# 分页\n\n\n# 表单页\n\n# 表单组件\n\n# 校验器\n\n\n# 扩展设计\n\n\n# 参考资料\n\n * 低代码平台：10 分钟从入门到原理\n * 浅谈低代码平台涉及的一些技术选型",normalizedContent:"# 设计一个低代码平台\n\n> 本文目标是设计一个用于提高开发人员开发效率的低代码平台，这里会采用系统解决方案设计的一般思路来逐步探寻设计方案。\n\n\n# 业务分析\n\n\n# 低代码平台是什么\n\n广义上的低代码平台包括低代码平台和零代码平台，它们都属于 apaas（application platform as a service 应用平台即服务），两者的主要区别在于对代码的依赖程度：\n\n * 低代码平台：通过自动代码生成和可视化编程，只需要少量代码，即可快速搭建各种应用。\n * 零代码平台：零开发经验的业务人员通过拖拽等方式，无需编写代码，即可快速搭建各种应用。\n\n\n# 技术路线\n\n# 基于 ide 框架的快速开发平台\n\n该方案将传统的集成开发环境（ide）充分可视化，开发者对前端界面组件、数据源绑定方式、数据模型、业务逻辑和工作流等都可以自由定义，平台将自动生成代码，开发者也可以添加自己的代码，对程序具有较强的控制能力，因此该方案具备更高的灵活性，可以设计出定制化程度高、逻辑复杂的软件。\n\n由于该方案仍涉及代码开发、部署等技术工作，所以它仍然是一个技术开发平台，需要较高的学习成本，主要价值是提高开发效率，减少重复劳动。\n\noutsystems 就是采用该方案的典型产品，如下为产品截图：\n\n\n\n# 基于模型驱动的应用平台\n\n用户通过可视化方式构建数据模型、视图、权限、工作流等，即可在平台提供的环境中运行，无需编译部署，更像一种傻瓜式的应用搭建平台。平台对各类组件、业务逻辑做了较高层级的封装，因此用户无法随心所欲修改界面风格、交互方式、处理逻辑等。\n\n该方案可以实现完全零代码，对使用者技术要求不高，但需要具备业务抽象、建模能力。主要价值是降低开发门槛、快速适应变化。\n\n明道云、伙伴云等都是此类方案的典型产品，如下为明道云的产品截图：\n\n\n\n\n# 核心要素\n\n绝大部分的企业软件由以下四个部分组成：\n\n * 业务实体：即操作对象，如客户、订单\n * 业务活动：即进行何种操作，如采购申请、合同审批\n * 业务权限：即何种人拥有何种权限，包括数据查看权限和数据操作权限，如部门经理可以管理所有下属的客户信息，而员工只能管理自己的客户信息\n * 统计报表：即从哪些方面量化企业活动情况，如客户增长率、各月销售额趋势\n\n低代码平台将以上进行抽象，支持数据模型、业务流程、用户权限、统计图表，因此可以作为更通用的企业软件解决方案，这四类能力也是任何一个低代码平台都必须具备的核心要素。\n\n# 数据模型\n\n建立数据模型就是提取业务实体的数据特征，抽象为数据表，建立表间关系。制作 er 图的过程就是数据建模。市面上常见的低代码平台均提供了丰富的控件，可以拖拽完成数据模型搭建。此外，数据模型搭建与表单展示合二为一，每完成一个数据表的创建，就自动生成了该表的增删改查功能及相关页面，进而隐藏了数据库设计、前端开发这些专业技术。其实，这也就是我们常说的表单引擎。\n\n这里顺便提一下，虽然很多低代码平台将数据建模与表单展示合二为一，但通过这种方式自动生成的表单只能实现最基础的增删改查页面，用户对界面展示内容及形式的控制程度很低，无法满足大部分企业软件的需求，所以低代码平台一般还会提供自定义页面功能，用户可根据需要在页面上配置按钮、图表等元素，满足个性化需求。\n\n# 业务流程\n\n业务流程指为了实现某项目标，由多人合作，按照一定的规则、顺序进行的一系列活动，在软件中，业务流程的参与者可以是人，也可以是程序。低代码平台实现了可视化流程配置，用户对触发条件、处理节点、节点参与者进行配置，实现自定义业务流程。\n\n# 用户权限\n\n大部分的低代码平台都采用了非常经典的 rbac（role-based access control ）模型管理用户权限，简单来说就是将拥有相同权限的用户添加为相同角色，通过为角色分配权限，实现了“用户——角色——权限”的授权模式。由于企业是一个组织，一般都会有部门的概念，所以也可以将部门添加到某个角色，实现“用户——部门——角色——权限”的授权模式。\n\n# 统计图表\n\n统计图表可以类比 excel 中的透视图，统计图表由数据源、统计规则、展示形式定义，低代码平台也正是遵循这种方式，实现统计图表的可视化配置。\n\n\n# 流行产品\n\n# outsystems\n\noutsystems 是快速应用开发的头号低代码平台，并且是 2018 年 gartner 高生产力平台的领导者。outsystems 号称将低代码功能与高级移动功能相结合的唯一解决方案，它支持整个应用程序组合的可视化开发，可轻松与现有系统集成。\n\n# mendix\n\nmendix 帮助企业改善创新方式。通过使用可视化模型，在 mendix 上构建应用程序非常简单，快速且直观，可使开发人员和业务分析人员等众多人员构建强大的应用程序，而无需编写代码。借助模型驱动开发，业务领导者和 it 部门可以共享语言来快速构建应用程序。\n\n\n# 顶层设计\n\n由于系统的用户群体是有一定技术基础的开发人员。所以，系统定位是低代码平台，而非零代码平台。\n\n其次，由于系统主要是用于简化基本的页面开发，所以技术路线应该选择：基于模型驱动的应用平台。\n\n最后，由于生成的代码是应用于 java web 框架。生成的后端代码是 java 代码；前端代码是基于 vue + element-ui 生态的前端代码。\n\n\n\n代码生成规则对应的数据建模：\n\n\n\n自动生成前后端代码。\n\n * 后端代码\n   * controller\n   * service\n   * serviceimpl\n   * daomybatis\n   * daoimpl\n   * mapper\n   * query\n   * dto\n   * entity\n   * xml\n * 前端代码\n   * list\n   * form\n   * api\n\n\n# 组件设计\n\n\n# 列表页\n\n# 搜索栏\n\n# 操作栏\n\n# 表格\n\n# 分页\n\n\n# 表单页\n\n# 表单组件\n\n# 校验器\n\n\n# 扩展设计\n\n\n# 参考资料\n\n * 低代码平台：10 分钟从入门到原理\n * 浅谈低代码平台涉及的一些技术选型",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"海量数据处理",frontmatter:{title:"海量数据处理",date:"2021-08-19T22:15:16.000Z",categories:["架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/1ed7ae/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/01.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.html",relativePath:"01.架构/01.解决方案/海量数据处理.md",key:"v-7a3f894c",path:"/pages/1ed7ae/",headers:[{level:2,title:"如何从海量的 URL 中找出相同的 URL？",slug:"如何从海量的-url-中找出相同的-url",normalizedTitle:"如何从海量的 url 中找出相同的 url？",charIndex:13},{level:3,title:"问题描述",slug:"问题描述",normalizedTitle:"问题描述",charIndex:40},{level:3,title:"解决思路",slug:"解决思路",normalizedTitle:"解决思路",charIndex:120},{level:3,title:"方案总结",slug:"方案总结",normalizedTitle:"方案总结",charIndex:748},{level:2,title:"如何从海量数据中找出高频词？",slug:"如何从海量数据中找出高频词",normalizedTitle:"如何从海量数据中找出高频词？",charIndex:798},{level:3,title:"问题描述",slug:"问题描述-2",normalizedTitle:"问题描述",charIndex:40},{level:3,title:"解决思路",slug:"解决思路-2",normalizedTitle:"解决思路",charIndex:120},{level:3,title:"方案总结",slug:"方案总结-2",normalizedTitle:"方案总结",charIndex:748},{level:2,title:"如何找出某一天访问百度网站最多的 IP？",slug:"如何找出某一天访问百度网站最多的-ip",normalizedTitle:"如何找出某一天访问百度网站最多的 ip？",charIndex:1564},{level:3,title:"问题描述",slug:"问题描述-3",normalizedTitle:"问题描述",charIndex:40},{level:3,title:"解决思路",slug:"解决思路-3",normalizedTitle:"解决思路",charIndex:120},{level:3,title:"方法总结",slug:"方法总结",normalizedTitle:"方法总结",charIndex:1852},{level:2,title:"如何在大量的数据中找出不重复的整数？",slug:"如何在大量的数据中找出不重复的整数",normalizedTitle:"如何在大量的数据中找出不重复的整数？",charIndex:1938},{level:3,title:"问题描述",slug:"问题描述-4",normalizedTitle:"问题描述",charIndex:40},{level:3,title:"解决思路",slug:"解决思路-4",normalizedTitle:"解决思路",charIndex:120},{level:4,title:"方法一：分治法",slug:"方法一-分治法",normalizedTitle:"方法一：分治法",charIndex:2021},{level:4,title:"方法二：位图法",slug:"方法二-位图法",normalizedTitle:"方法二：位图法",charIndex:2113},{level:3,title:"方法总结",slug:"方法总结-2",normalizedTitle:"方法总结",charIndex:1852},{level:2,title:"如何在大量的数据中判断一个数是否存在？",slug:"如何在大量的数据中判断一个数是否存在",normalizedTitle:"如何在大量的数据中判断一个数是否存在？",charIndex:2959},{level:3,title:"题目描述",slug:"题目描述",normalizedTitle:"题目描述",charIndex:2983},{level:3,title:"解答思路",slug:"解答思路",normalizedTitle:"解答思路",charIndex:3062},{level:4,title:"方法一：分治法",slug:"方法一-分治法-2",normalizedTitle:"方法一：分治法",charIndex:2021},{level:4,title:"方法二：位图法",slug:"方法二-位图法-2",normalizedTitle:"方法二：位图法",charIndex:2113},{level:3,title:"方法总结",slug:"方法总结-3",normalizedTitle:"方法总结",charIndex:1852},{level:2,title:"如何查询最热门的查询串？",slug:"如何查询最热门的查询串",normalizedTitle:"如何查询最热门的查询串？",charIndex:3311},{level:3,title:"题目描述",slug:"题目描述-2",normalizedTitle:"题目描述",charIndex:2983},{level:3,title:"解答思路",slug:"解答思路-2",normalizedTitle:"解答思路",charIndex:3062},{level:4,title:"方法一：分治法",slug:"方法一-分治法-3",normalizedTitle:"方法一：分治法",charIndex:2021},{level:4,title:"方法二：HashMap 法",slug:"方法二-hashmap-法",normalizedTitle:"方法二：hashmap 法",charIndex:3732},{level:4,title:"方法三：前缀树法（字典树）",slug:"方法三-前缀树法-字典树",normalizedTitle:"方法三：前缀树法（字典树）",charIndex:4079},{level:3,title:"方法总结",slug:"方法总结-4",normalizedTitle:"方法总结",charIndex:1852},{level:2,title:"如何统计不同电话号码的个数？",slug:"如何统计不同电话号码的个数",normalizedTitle:"如何统计不同电话号码的个数？",charIndex:4350},{level:3,title:"题目描述",slug:"题目描述-3",normalizedTitle:"题目描述",charIndex:2983},{level:3,title:"解答思路",slug:"解答思路-3",normalizedTitle:"解答思路",charIndex:3062},{level:3,title:"方法总结",slug:"方法总结-5",normalizedTitle:"方法总结",charIndex:1852},{level:2,title:"如何从 5 亿个数中找出中位数？",slug:"如何从-5-亿个数中找出中位数",normalizedTitle:"如何从 5 亿个数中找出中位数？",charIndex:4703},{level:3,title:"题目描述",slug:"题目描述-4",normalizedTitle:"题目描述",charIndex:2983},{level:3,title:"解答思路",slug:"解答思路-4",normalizedTitle:"解答思路",charIndex:3062},{level:4,title:"方法一：双堆法",slug:"方法一-双堆法",normalizedTitle:"方法一：双堆法",charIndex:4914},{level:4,title:"方法二：分治法",slug:"方法二-分治法",normalizedTitle:"方法二：分治法",charIndex:6276},{level:3,title:"方法总结",slug:"方法总结-6",normalizedTitle:"方法总结",charIndex:1852},{level:2,title:"如何找出排名前 500 的数？",slug:"如何找出排名前-500-的数",normalizedTitle:"如何找出排名前 500 的数？",charIndex:6794},{level:3,title:"题目描述",slug:"题目描述-5",normalizedTitle:"题目描述",charIndex:2983},{level:3,title:"解答思路",slug:"解答思路-5",normalizedTitle:"解答思路",charIndex:3062},{level:3,title:"方法总结",slug:"方法总结-7",normalizedTitle:"方法总结",charIndex:1852},{level:2,title:"如何按照 query 的频度排序？",slug:"如何按照-query-的频度排序",normalizedTitle:"如何按照 query 的频度排序？",charIndex:9132},{level:3,title:"题目描述",slug:"题目描述-6",normalizedTitle:"题目描述",charIndex:2983},{level:3,title:"解答思路",slug:"解答思路-6",normalizedTitle:"解答思路",charIndex:3062},{level:4,title:"方法一：HashMap 法",slug:"方法一-hashmap-法",normalizedTitle:"方法一：hashmap 法",charIndex:9353},{level:4,title:"方法二：分治法",slug:"方法二-分治法-2",normalizedTitle:"方法二：分治法",charIndex:6276},{level:3,title:"方法总结",slug:"方法总结-8",normalizedTitle:"方法总结",charIndex:1852}],headersStr:"如何从海量的 URL 中找出相同的 URL？ 问题描述 解决思路 方案总结 如何从海量数据中找出高频词？ 问题描述 解决思路 方案总结 如何找出某一天访问百度网站最多的 IP？ 问题描述 解决思路 方法总结 如何在大量的数据中找出不重复的整数？ 问题描述 解决思路 方法一：分治法 方法二：位图法 方法总结 如何在大量的数据中判断一个数是否存在？ 题目描述 解答思路 方法一：分治法 方法二：位图法 方法总结 如何查询最热门的查询串？ 题目描述 解答思路 方法一：分治法 方法二：HashMap 法 方法三：前缀树法（字典树） 方法总结 如何统计不同电话号码的个数？ 题目描述 解答思路 方法总结 如何从 5 亿个数中找出中位数？ 题目描述 解答思路 方法一：双堆法 方法二：分治法 方法总结 如何找出排名前 500 的数？ 题目描述 解答思路 方法总结 如何按照 query 的频度排序？ 题目描述 解答思路 方法一：HashMap 法 方法二：分治法 方法总结",content:"# 海量数据处理\n\n\n# 如何从海量的 URL 中找出相同的 URL？\n\n\n# 问题描述\n\n给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL。\n\n\n# 解决思路\n\n每个 URL 占 64B，那么 50 亿个 URL 占用的空间大小约为 320GB。\n\n> $$5,000,000,000 * 64 B ≈ 5 GB * 64 = 320 GB$$\n\n由于内存大小只有 4G，因此，我们不可能一次性把所有 URL 加载到内存中处理。对于这种类型的题目，一般采用分治策略，即：把一个文件中的 URL 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4G，这样就可以把这个小文件读到内存中进行处理了。\n\n思路如下：\n\n首先遍历文件 a，对遍历到的 URL 求 hash(URL) % 1000，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, ..., a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, ..., b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, ..., a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。\n\n接着遍历 ai( i∈[0,999])，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。\n\n\n# 方案总结\n\n * 分而治之，进行哈希取余；\n * 对每个子文件进行 HashSet 统计。\n\n\n# 如何从海量数据中找出高频词？\n\n\n# 问题描述\n\n有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)。\n\n\n# 解决思路\n\n由于内存限制，无法直接将大文件的所有词一次读到内存中。因此，可以采用分治策略，把一个大文件分解成多个小文件，保证每个文件的大小小于 1MB，进而直接将单个小文件读取到内存中进行处理。\n\n思路如下：\n\n首先遍历大文件，对遍历到的每个词 x，执行 hash(x) % 5000，将结果为 i 的词存放到文件 Ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。\n\n接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 map.put(x, 1) 若存在，则执行 map.put(x, map.get(x)+1)，将该词频数加 1。\n\n上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个小顶堆来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个小顶堆，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为小顶堆，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。\n\n\n# 方案总结\n\n * 分而治之，进行哈希取余；\n * 使用 HashMap 统计频数；\n * 求解最大的 TopN 个，用小顶堆；求解最小的 TopN 个，用大顶堆。\n\n\n# 如何找出某一天访问百度网站最多的 IP？\n\n\n# 问题描述\n\n现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。\n\n\n# 解决思路\n\n这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用 HashMap 统计重复 IP 的次数，最后计算出重复次数最多的 IP。\n\n> 注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。\n\n\n# 方法总结\n\n * 分而治之，进行哈希取余；\n * 使用 HashMap 统计频数；\n * 求解最大的 TopN 个，用小顶堆；求解最小的 TopN 个，用大顶堆。\n\n\n# 如何在大量的数据中找出不重复的整数？\n\n\n# 问题描述\n\n在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。\n\n\n# 解决思路\n\n# 方法一：分治法\n\n与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 HashSet/HashMap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。\n\n# 方法二：位图法\n\n位图，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。\n\n位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。\n\n假设我们要对 [0,7] 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：\n\n0 0 0 0 0 0 0 0\n\n\n然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：\n\n0 0 0 0 1 0 1 0\n\n\n依次遍历，结束后，位数组是这样的：\n\n0 1 1 0 1 1 1 0\n\n\n每个为 1 的位，它的下标都表示了一个数：\n\nfor i in range(8):\n    if bits[i] == 1:\n        print(i)\n\n\n这样我们其实就已经实现了排序。\n\n对于整数相关的算法的求解，位图法是一种非常实用的算法。假设 int 整数占用 4B，即 32bit，那么我们可以表示的整数的个数为 232。\n\n那么对于这道题，我们用 2 个 bit 来表示各个数字的状态：\n\n * 00 表示这个数字没出现过；\n * 01 表示这个数字出现过一次（即为题目所找的不重复整数）；\n * 10 表示这个数字出现了多次。\n\n那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：\n\n遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。\n\n\n# 方法总结\n\n判断数字是否重复的问题，位图法是一种非常高效的方法。\n\n\n# 如何在大量的数据中判断一个数是否存在？\n\n\n# 题目描述\n\n给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？\n\n\n# 解答思路\n\n# 方法一：分治法\n\n依然可以用分治法解决，方法与前面类似，就不再次赘述了。\n\n# 方法二：位图法\n\n40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b≈512M。\n\n我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。\n\n\n# 方法总结\n\n判断数字是否存在、判断数字是否重复的问题，位图法是一种非常高效的方法。\n\n\n# 如何查询最热门的查询串？\n\n\n# 题目描述\n\n搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询串的长度不超过 255 字节。\n\n假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）\n\n\n# 解答思路\n\n每个查询串最长为 255B，1000w 个串需要占用 约 2.55G 内存，因此，我们无法将所有字符串全部读入到内存中处理。\n\n# 方法一：分治法\n\n分治法依然是一个非常实用的方法。\n\n划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。\n\n方法可行，但不是最好，下面介绍其他方法。\n\n# 方法二：HashMap 法\n\n虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4 表示整数占用的 4 个字节）。由此可见，1G 的内存空间完全够用。\n\n思路如下：\n\n首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 O(N)。\n\n接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。\n\n遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 O(Nlog10)。\n\n# 方法三：前缀树法（字典树）\n\n方法二使用了 HashMap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。\n\n思路如下：\n\n在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。\n\n最后依然使用小顶堆来对字符串的出现次数进行排序。\n\n\n# 方法总结\n\n前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。\n\n\n# 如何统计不同电话号码的个数？\n\n\n# 题目描述\n\n已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。\n\n\n# 解答思路\n\n这道题本质还是求解数据重复的问题，对于这类问题，一般首先考虑位图法。\n\n对于本题，8 位电话号码可以表示的号码个数为 $$10^8$$ 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。\n\n思路如下：\n\n申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。\n\n\n# 方法总结\n\n求解数据重复问题，记得考虑位图法。\n\n\n# 如何从 5 亿个数中找出中位数？\n\n\n# 题目描述\n\n从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 (N+1)/2 个数；当样本数为偶数时，中位数为 第 N/2 个数与第 1+N/2 个数的均值。\n\n\n# 解答思路\n\n如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 O(NlogN)。这里使用其他方法。\n\n# 方法一：双堆法\n\n维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数小于等于小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。\n\n若数据总数为偶数，当这两个堆建好之后，中位数就是这两个堆顶元素的平均值。当数据总数为奇数时，根据两个堆的大小，中位数一定在数据多的堆的堆顶。\n\nclass MedianFinder {\n\n    private PriorityQueue<Integer> maxHeap;\n    private PriorityQueue<Integer> minHeap;\n\n    /** initialize your data structure here. */\n    public MedianFinder() {\n        maxHeap = new PriorityQueue<>(Comparator.reverseOrder());\n        minHeap = new PriorityQueue<>(Integer::compareTo);\n    }\n\n    public void addNum(int num) {\n        if (maxHeap.isEmpty() || maxHeap.peek() > num) {\n            maxHeap.offer(num);\n        } else {\n            minHeap.offer(num);\n        }\n\n        int size1 = maxHeap.size();\n        int size2 = minHeap.size();\n        if (size1 - size2 > 1) {\n            minHeap.offer(maxHeap.poll());\n        } else if (size2 - size1 > 1) {\n            maxHeap.offer(minHeap.poll());\n        }\n    }\n\n    public double findMedian() {\n        int size1 = maxHeap.size();\n        int size2 = minHeap.size();\n\n        return size1 == size2\n            ? (maxHeap.peek() + minHeap.peek()) * 1.0 / 2\n            : (size1 > size2 ? maxHeap.peek() : minHeap.peek());\n    }\n}\n\n\n> 见 LeetCode No.295：https://leetcode.com/problems/find-median-from-data-stream/\n\n以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法适用于数据量较小的情况。5 亿个数，每个数字占用 4B，总共需要 2G 内存。如果可用内存不足 2G，就不能使用这种方法了，下面介绍另一种方法。\n\n# 方法二：分治法\n\n分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。\n\n对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。\n\n划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。\n\n> 提示，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。\n\n对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。\n\n> 注意，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。\n\n\n# 方法总结\n\n分治法，真香！\n\n\n# 如何找出排名前 500 的数？\n\n\n# 题目描述\n\n有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？\n\n\n# 解答思路\n\n对于 TopK 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：\n\n首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。\n\n接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。\n\n重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。\n\n> 为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。\n\nimport lombok.Data;\n\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\n/**\n * @author https://github.com/yanglbme\n */\n@Data\npublic class DataWithSource implements Comparable<DataWithSource> {\n    /**\n     * 数值\n     */\n    private int value;\n\n    /**\n     * 记录数值来源的数组\n     */\n    private int source;\n\n    /**\n     * 记录数值在数组中的索引\n     */\n    private int index;\n\n    public DataWithSource(int value, int source, int index) {\n        this.value = value;\n        this.source = source;\n        this.index = index;\n    }\n\n    /**\n     *\n     * 由于 PriorityQueue 使用小顶堆来实现，这里通过修改\n     * 两个整数的比较逻辑来让 PriorityQueue 变成大顶堆\n     */\n    @Override\n    public int compareTo(DataWithSource o) {\n        return Integer.compare(o.getValue(), this.value);\n    }\n}\n\n\nclass Test {\n    public static int[] getTop(int[][] data) {\n        int rowSize = data.length;\n        int columnSize = data[0].length;\n\n        // 创建一个columnSize大小的数组，存放结果\n        int[] result = new int[columnSize];\n\n        PriorityQueue<DataWithSource> maxHeap = new PriorityQueue<>();\n        for (int i = 0; i < rowSize; ++i) {\n            // 将每个数组的最大一个元素放入堆中\n            DataWithSource d = new DataWithSource(data[i][0], i, 0);\n            maxHeap.add(d);\n        }\n\n        int num = 0;\n        while (num < columnSize) {\n            // 删除堆顶元素\n            DataWithSource d = maxHeap.poll();\n            result[num++] = d.getValue();\n            if (num >= columnSize) {\n                break;\n            }\n\n            d.setValue(data[d.getSource()][d.getIndex() + 1]);\n            d.setIndex(d.getIndex() + 1);\n            maxHeap.add(d);\n        }\n        return result;\n\n    }\n\n    public static void main(String[] args) {\n        int[][] data = {\n                {29, 17, 14, 2, 1},\n                {19, 17, 16, 15, 6},\n                {30, 25, 20, 14, 5},\n        };\n\n        int[] top = getTop(data);\n        System.out.println(Arrays.toString(top)); // [30, 29, 25, 20, 19]\n    }\n}\n\n\n\n# 方法总结\n\n求 TopK，不妨考虑一下堆排序？\n\n\n# 如何按照 query 的频度排序？\n\n\n# 题目描述\n\n有 10 个文件，每个文件大小为 1G，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。\n\n\n# 解答思路\n\n如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。\n\n# 方法一：HashMap 法\n\n如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 HashMap 中。接着就可以按照 query 出现的次数进行排序。\n\n# 方法二：分治法\n\n分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 Hash 函数 hash(query) % 10 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 HashMap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。\n\n接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。\n\n\n# 方法总结\n\n * 内存若够，直接读入进行排序；\n * 内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。",normalizedContent:"# 海量数据处理\n\n\n# 如何从海量的 url 中找出相同的 url？\n\n\n# 问题描述\n\n给定 a、b 两个文件，各存放 50 亿个 url，每个 url 各占 64b，内存限制是 4g。请找出 a、b 两个文件共同的 url。\n\n\n# 解决思路\n\n每个 url 占 64b，那么 50 亿个 url 占用的空间大小约为 320gb。\n\n> $$5,000,000,000 * 64 b ≈ 5 gb * 64 = 320 gb$$\n\n由于内存大小只有 4g，因此，我们不可能一次性把所有 url 加载到内存中处理。对于这种类型的题目，一般采用分治策略，即：把一个文件中的 url 按照某个特征划分为多个小文件，使得每个小文件大小不超过 4g，这样就可以把这个小文件读到内存中进行处理了。\n\n思路如下：\n\n首先遍历文件 a，对遍历到的 url 求 hash(url) % 1000，根据计算结果把遍历到的 url 存储到 a0, a1, a2, ..., a999，这样每个大小约为 300mb。使用同样的方法遍历文件 b，把文件 b 中的 url 分别存储到文件 b0, b1, b2, ..., b999 中。这样处理过后，所有可能相同的 url 都在对应的小文件中，即 a0 对应 b0, ..., a999 对应 b999，不对应的小文件不可能有相同的 url。那么接下来，我们只需要求出这 1000 对小文件中相同的 url 就好了。\n\n接着遍历 ai( i∈[0,999])，把 url 存储到一个 hashset 集合中。然后遍历 bi 中每个 url，看在 hashset 集合中是否存在，若存在，说明这就是共同的 url，可以把这个 url 保存到一个单独的文件中。\n\n\n# 方案总结\n\n * 分而治之，进行哈希取余；\n * 对每个子文件进行 hashset 统计。\n\n\n# 如何从海量数据中找出高频词？\n\n\n# 问题描述\n\n有一个 1gb 大小的文件，文件里每一行是一个词，每个词的大小不超过 16b，内存大小限制是 1mb，要求返回频数最高的 100 个词(top 100)。\n\n\n# 解决思路\n\n由于内存限制，无法直接将大文件的所有词一次读到内存中。因此，可以采用分治策略，把一个大文件分解成多个小文件，保证每个文件的大小小于 1mb，进而直接将单个小文件读取到内存中进行处理。\n\n思路如下：\n\n首先遍历大文件，对遍历到的每个词 x，执行 hash(x) % 5000，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200kb 左右。如果有的小文件大小仍然超过 1mb，则采用同样的方式继续进行分解。\n\n接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 hashmap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 map.put(x, 1) 若存在，则执行 map.put(x, map.get(x)+1)，将该词频数加 1。\n\n上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个小顶堆来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个小顶堆，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为小顶堆，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。\n\n\n# 方案总结\n\n * 分而治之，进行哈希取余；\n * 使用 hashmap 统计频数；\n * 求解最大的 topn 个，用小顶堆；求解最小的 topn 个，用大顶堆。\n\n\n# 如何找出某一天访问百度网站最多的 ip？\n\n\n# 问题描述\n\n现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 ip。\n\n\n# 解决思路\n\n这道题只关心某一天访问百度最多的 ip，因此，可以首先对文件进行一次遍历，把这一天访问百度 ip 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 ip 进行哈希映射，接着使用 hashmap 统计重复 ip 的次数，最后计算出重复次数最多的 ip。\n\n> 注：这里只需要找出出现次数最多的 ip，可以不必使用堆，直接用一个变量 max 即可。\n\n\n# 方法总结\n\n * 分而治之，进行哈希取余；\n * 使用 hashmap 统计频数；\n * 求解最大的 topn 个，用小顶堆；求解最小的 topn 个，用大顶堆。\n\n\n# 如何在大量的数据中找出不重复的整数？\n\n\n# 问题描述\n\n在 2.5 亿个整数中找出不重复的整数。注意：内存不足以容纳这 2.5 亿个整数。\n\n\n# 解决思路\n\n# 方法一：分治法\n\n与前面的题目方法类似，先将 2.5 亿个数划分到多个小文件，用 hashset/hashmap 找出每个小文件中不重复的整数，再合并每个子结果，即为最终结果。\n\n# 方法二：位图法\n\n位图，就是用一个或多个 bit 来标记某个元素对应的值，而键就是该元素。采用位作为单位来存储数据，可以大大节省存储空间。\n\n位图通过使用位数组来表示某些元素是否存在。它可以用于快速查找，判重，排序等。不是很清楚？我先举个小例子。\n\n假设我们要对 [0,7] 中的 5 个元素 (6, 4, 2, 1, 5) 进行排序，可以采用位图法。0~7 范围总共有 8 个数，只需要 8bit，即 1 个字节。首先将每个位都置 0：\n\n0 0 0 0 0 0 0 0\n\n\n然后遍历 5 个元素，首先遇到 6，那么将下标为 6 的位的 0 置为 1；接着遇到 4，把下标为 4 的位 的 0 置为 1：\n\n0 0 0 0 1 0 1 0\n\n\n依次遍历，结束后，位数组是这样的：\n\n0 1 1 0 1 1 1 0\n\n\n每个为 1 的位，它的下标都表示了一个数：\n\nfor i in range(8):\n    if bits[i] == 1:\n        print(i)\n\n\n这样我们其实就已经实现了排序。\n\n对于整数相关的算法的求解，位图法是一种非常实用的算法。假设 int 整数占用 4b，即 32bit，那么我们可以表示的整数的个数为 232。\n\n那么对于这道题，我们用 2 个 bit 来表示各个数字的状态：\n\n * 00 表示这个数字没出现过；\n * 01 表示这个数字出现过一次（即为题目所找的不重复整数）；\n * 10 表示这个数字出现了多次。\n\n那么这 232 个整数，总共所需内存为 232*2b=1gb。因此，当可用内存超过 1gb 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：\n\n遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。\n\n\n# 方法总结\n\n判断数字是否重复的问题，位图法是一种非常高效的方法。\n\n\n# 如何在大量的数据中判断一个数是否存在？\n\n\n# 题目描述\n\n给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中？\n\n\n# 解答思路\n\n# 方法一：分治法\n\n依然可以用分治法解决，方法与前面类似，就不再次赘述了。\n\n# 方法二：位图法\n\n40 亿个不重复整数，我们用 40 亿个 bit 来表示，初始位均为 0，那么总共需要内存：4,000,000,000b≈512m。\n\n我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。\n\n\n# 方法总结\n\n判断数字是否存在、判断数字是否重复的问题，位图法是一种非常高效的方法。\n\n\n# 如何查询最热门的查询串？\n\n\n# 题目描述\n\n搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询串的长度不超过 255 字节。\n\n假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1g。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）\n\n\n# 解答思路\n\n每个查询串最长为 255b，1000w 个串需要占用 约 2.55g 内存，因此，我们无法将所有字符串全部读入到内存中处理。\n\n# 方法一：分治法\n\n分治法依然是一个非常实用的方法。\n\n划分为多个小文件，保证单个小文件中的字符串能被直接加载到内存中处理，然后求出每个文件中出现次数最多的 10 个字符串；最后通过一个小顶堆统计出所有文件中出现最多的 10 个字符串。\n\n方法可行，但不是最好，下面介绍其他方法。\n\n# 方法二：hashmap 法\n\n虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 hashmap 中，所占用的空间为 300w*(255+4)≈777m（其中，4 表示整数占用的 4 个字节）。由此可见，1g 的内存空间完全够用。\n\n思路如下：\n\n首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 o(n)。\n\n接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。\n\n遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 o(nlog10)。\n\n# 方法三：前缀树法（字典树）\n\n方法二使用了 hashmap 来统计次数，当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。\n\n思路如下：\n\n在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。\n\n最后依然使用小顶堆来对字符串的出现次数进行排序。\n\n\n# 方法总结\n\n前缀树经常被用来统计字符串的出现次数。它的另外一个大的用途是字符串查找，判断是否有重复的字符串等。\n\n\n# 如何统计不同电话号码的个数？\n\n\n# 题目描述\n\n已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。\n\n\n# 解答思路\n\n这道题本质还是求解数据重复的问题，对于这类问题，一般首先考虑位图法。\n\n对于本题，8 位电话号码可以表示的号码个数为 $$10^8$$ 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100m。\n\n思路如下：\n\n申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。\n\n\n# 方法总结\n\n求解数据重复问题，记得考虑位图法。\n\n\n# 如何从 5 亿个数中找出中位数？\n\n\n# 题目描述\n\n从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 (n+1)/2 个数；当样本数为偶数时，中位数为 第 n/2 个数与第 1+n/2 个数的均值。\n\n\n# 解答思路\n\n如果这道题没有内存大小限制，则可以把所有数读到内存中排序后找出中位数。但是最好的排序算法的时间复杂度都为 o(nlogn)。这里使用其他方法。\n\n# 方法一：双堆法\n\n维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数小于等于小顶堆中最小的数；保证这两个堆中的元素个数的差不超过 1。\n\n若数据总数为偶数，当这两个堆建好之后，中位数就是这两个堆顶元素的平均值。当数据总数为奇数时，根据两个堆的大小，中位数一定在数据多的堆的堆顶。\n\nclass medianfinder {\n\n    private priorityqueue<integer> maxheap;\n    private priorityqueue<integer> minheap;\n\n    /** initialize your data structure here. */\n    public medianfinder() {\n        maxheap = new priorityqueue<>(comparator.reverseorder());\n        minheap = new priorityqueue<>(integer::compareto);\n    }\n\n    public void addnum(int num) {\n        if (maxheap.isempty() || maxheap.peek() > num) {\n            maxheap.offer(num);\n        } else {\n            minheap.offer(num);\n        }\n\n        int size1 = maxheap.size();\n        int size2 = minheap.size();\n        if (size1 - size2 > 1) {\n            minheap.offer(maxheap.poll());\n        } else if (size2 - size1 > 1) {\n            maxheap.offer(minheap.poll());\n        }\n    }\n\n    public double findmedian() {\n        int size1 = maxheap.size();\n        int size2 = minheap.size();\n\n        return size1 == size2\n            ? (maxheap.peek() + minheap.peek()) * 1.0 / 2\n            : (size1 > size2 ? maxheap.peek() : minheap.peek());\n    }\n}\n\n\n> 见 leetcode no.295：https://leetcode.com/problems/find-median-from-data-stream/\n\n以上这种方法，需要把所有数据都加载到内存中。当数据量很大时，就不能这样了，因此，这种方法适用于数据量较小的情况。5 亿个数，每个数字占用 4b，总共需要 2g 内存。如果可用内存不足 2g，就不能使用这种方法了，下面介绍另一种方法。\n\n# 方法二：分治法\n\n分治法的思想是把一个大的问题逐渐转换为规模较小的问题来求解。\n\n对于这道题，顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。\n\n划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。\n\n> 提示，5 亿数的中位数是第 2.5 亿与右边相邻一个数求平均值。若 f1 有一亿个数，那么中位数就是 f0 中从第 1.5 亿个数开始的两个数求得的平均值。\n\n对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。\n\n> 注意，当数据总数为偶数，如果划分后两个文件中的数据有相同个数，那么中位数就是数据较小的文件中的最大值与数据较大的文件中的最小值的平均值。\n\n\n# 方法总结\n\n分治法，真香！\n\n\n# 如何找出排名前 500 的数？\n\n\n# 题目描述\n\n有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？\n\n\n# 解答思路\n\n对于 topk 问题，最常用的方法是使用堆排序。对本题而言，假设数组降序排列，可以采用以下方法：\n\n首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。\n\n接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。\n\n重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。\n\n> 为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。\n\nimport lombok.data;\n\nimport java.util.arrays;\nimport java.util.priorityqueue;\n\n/**\n * @author https://github.com/yanglbme\n */\n@data\npublic class datawithsource implements comparable<datawithsource> {\n    /**\n     * 数值\n     */\n    private int value;\n\n    /**\n     * 记录数值来源的数组\n     */\n    private int source;\n\n    /**\n     * 记录数值在数组中的索引\n     */\n    private int index;\n\n    public datawithsource(int value, int source, int index) {\n        this.value = value;\n        this.source = source;\n        this.index = index;\n    }\n\n    /**\n     *\n     * 由于 priorityqueue 使用小顶堆来实现，这里通过修改\n     * 两个整数的比较逻辑来让 priorityqueue 变成大顶堆\n     */\n    @override\n    public int compareto(datawithsource o) {\n        return integer.compare(o.getvalue(), this.value);\n    }\n}\n\n\nclass test {\n    public static int[] gettop(int[][] data) {\n        int rowsize = data.length;\n        int columnsize = data[0].length;\n\n        // 创建一个columnsize大小的数组，存放结果\n        int[] result = new int[columnsize];\n\n        priorityqueue<datawithsource> maxheap = new priorityqueue<>();\n        for (int i = 0; i < rowsize; ++i) {\n            // 将每个数组的最大一个元素放入堆中\n            datawithsource d = new datawithsource(data[i][0], i, 0);\n            maxheap.add(d);\n        }\n\n        int num = 0;\n        while (num < columnsize) {\n            // 删除堆顶元素\n            datawithsource d = maxheap.poll();\n            result[num++] = d.getvalue();\n            if (num >= columnsize) {\n                break;\n            }\n\n            d.setvalue(data[d.getsource()][d.getindex() + 1]);\n            d.setindex(d.getindex() + 1);\n            maxheap.add(d);\n        }\n        return result;\n\n    }\n\n    public static void main(string[] args) {\n        int[][] data = {\n                {29, 17, 14, 2, 1},\n                {19, 17, 16, 15, 6},\n                {30, 25, 20, 14, 5},\n        };\n\n        int[] top = gettop(data);\n        system.out.println(arrays.tostring(top)); // [30, 29, 25, 20, 19]\n    }\n}\n\n\n\n# 方法总结\n\n求 topk，不妨考虑一下堆排序？\n\n\n# 如何按照 query 的频度排序？\n\n\n# 题目描述\n\n有 10 个文件，每个文件大小为 1g，每个文件的每一行存放的都是用户的 query，每个文件的 query 都可能重复。要求按照 query 的频度排序。\n\n\n# 解答思路\n\n如果 query 的重复度比较大，可以考虑一次性把所有 query 读入内存中处理；如果 query 的重复率不高，那么可用内存不足以容纳所有的 query，这时候就需要采用分治法或其他的方法来解决。\n\n# 方法一：hashmap 法\n\n如果 query 重复率高，说明不同 query 总数比较小，可以考虑把所有的 query 都加载到内存中的 hashmap 中。接着就可以按照 query 出现的次数进行排序。\n\n# 方法二：分治法\n\n分治法需要根据数据量大小以及可用内存的大小来确定问题划分的规模。对于这道题，可以顺序遍历 10 个文件中的 query，通过 hash 函数 hash(query) % 10 把这些 query 划分到 10 个小文件中。之后对每个小文件使用 hashmap 统计 query 出现次数，根据次数排序并写入到零外一个单独文件中。\n\n接着对所有文件按照 query 的次数进行排序，这里可以使用归并排序（由于无法把所有 query 都读入内存，因此需要使用外排序）。\n\n\n# 方法总结\n\n * 内存若够，直接读入进行排序；\n * 内存不够，先划分为小文件，小文件排好序后，整理使用外排序进行归并。",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"电商",frontmatter:{title:"电商",date:"2021-08-05T23:42:12.000Z",categories:["架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/49a2bd/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/01.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%94%B5%E5%95%86.html",relativePath:"01.架构/01.解决方案/电商.md",key:"v-adecc362",path:"/pages/49a2bd/",headers:[{level:2,title:"基本业务架构",slug:"基本业务架构",normalizedTitle:"基本业务架构",charIndex:9},{level:3,title:"订单",slug:"订单",normalizedTitle:"订单",charIndex:22},{level:4,title:"订单信息管理",slug:"订单信息管理",normalizedTitle:"订单信息管理",charIndex:80},{level:4,title:"优惠券",slug:"优惠券",normalizedTitle:"优惠券",charIndex:134},{level:2,title:"典型问题",slug:"典型问题",normalizedTitle:"典型问题",charIndex:142}],headersStr:"基本业务架构 订单 订单信息管理 优惠券 典型问题",content:"# 电商\n\n\n# 基本业务架构\n\n\n\n\n# 订单\n\n订单服务一般不主动调用其他服务\n\n订单服务不负责和第三方集成\n\n订单服务不提供优惠计算或成本分摊逻辑\n\n# 订单信息管理\n\n * 用户\n * 商品\n * 收货人\n * 收货地址\n * 收货时间\n * 订单状态\n\n# 优惠券\n\n\n# 典型问题\n\n秒杀活动\n\n超卖",normalizedContent:"# 电商\n\n\n# 基本业务架构\n\n\n\n\n# 订单\n\n订单服务一般不主动调用其他服务\n\n订单服务不负责和第三方集成\n\n订单服务不提供优惠计算或成本分摊逻辑\n\n# 订单信息管理\n\n * 用户\n * 商品\n * 收货人\n * 收货地址\n * 收货时间\n * 订单状态\n\n# 优惠券\n\n\n# 典型问题\n\n秒杀活动\n\n超卖",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"短地址服务",frontmatter:{title:"短地址服务",date:"2021-11-08T08:15:33.000Z",categories:["架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/cb2119/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/01.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%9F%AD%E5%9C%B0%E5%9D%80%E6%9C%8D%E5%8A%A1.html",relativePath:"01.架构/01.解决方案/短地址服务.md",key:"v-63a49f52",path:"/pages/cb2119/",headers:[{level:2,title:"步骤一、需求分析",slug:"步骤一、需求分析",normalizedTitle:"步骤一、需求分析",charIndex:199},{level:3,title:"用例",slug:"用例",normalizedTitle:"用例",charIndex:233},{level:4,title:"问题范围",slug:"问题范围",normalizedTitle:"问题范围",charIndex:258},{level:4,title:"超出范畴的用例",slug:"超出范畴的用例",normalizedTitle:"超出范畴的用例",charIndex:464},{level:3,title:"约束和假设",slug:"约束和假设",normalizedTitle:"约束和假设",charIndex:567},{level:4,title:"状态假设",slug:"状态假设",normalizedTitle:"状态假设",charIndex:576},{level:4,title:"性能估算",slug:"性能估算",normalizedTitle:"性能估算",charIndex:717},{level:2,title:"步骤二、顶层设计",slug:"步骤二、顶层设计",normalizedTitle:"步骤二、顶层设计",charIndex:1211},{level:2,title:"步骤三、核心组件设计",slug:"步骤三、核心组件设计",normalizedTitle:"步骤三、核心组件设计",charIndex:1249},{level:3,title:"用例：用户输入一段文本，然后得到一个随机生成的链接",slug:"用例-用户输入一段文本-然后得到一个随机生成的链接",normalizedTitle:"用例：用户输入一段文本，然后得到一个随机生成的链接",charIndex:1280},{level:3,title:"用例：用户输入一个 paste 的 url 后可以看到它存储的内容",slug:"用例-用户输入一个-paste-的-url-后可以看到它存储的内容",normalizedTitle:"用例：用户输入一个 paste 的 url 后可以看到它存储的内容",charIndex:3061},{level:3,title:"用例： 服务跟踪分析页面",slug:"用例-服务跟踪分析页面",normalizedTitle:"用例： 服务跟踪分析页面",charIndex:3483},{level:3,title:"用例： 服务删除过期的 pastes",slug:"用例-服务删除过期的-pastes",normalizedTitle:"用例： 服务删除过期的 pastes",charIndex:4334},{level:2,title:"步骤四、扩展设计",slug:"步骤四、扩展设计",normalizedTitle:"步骤四、扩展设计",charIndex:4439},{level:2,title:"额外的话题",slug:"额外的话题",normalizedTitle:"额外的话题",charIndex:5365},{level:3,title:"NoSQL",slug:"nosql",normalizedTitle:"nosql",charIndex:1417},{level:3,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:4896},{level:3,title:"异步和微服务",slug:"异步和微服务",normalizedTitle:"异步和微服务",charIndex:5627},{level:3,title:"通信",slug:"通信",normalizedTitle:"通信",charIndex:3043},{level:3,title:"安全",slug:"安全",normalizedTitle:"安全",charIndex:5753},{level:3,title:"延迟数字",slug:"延迟数字",normalizedTitle:"延迟数字",charIndex:5767},{level:3,title:"持续进行",slug:"持续进行",normalizedTitle:"持续进行",charIndex:5794}],headersStr:"步骤一、需求分析 用例 问题范围 超出范畴的用例 约束和假设 状态假设 性能估算 步骤二、顶层设计 步骤三、核心组件设计 用例：用户输入一段文本，然后得到一个随机生成的链接 用例：用户输入一个 paste 的 url 后可以看到它存储的内容 用例： 服务跟踪分析页面 用例： 服务删除过期的 pastes 步骤四、扩展设计 额外的话题 NoSQL 缓存 异步和微服务 通信 安全 延迟数字 持续进行",content:'# 设计 Pastebin.com (或者 Bit.ly)\n\n> 本文搬运自 设计 Pastebin.com (或者 Bit.ly)\n\n注意: 为了避免重复，当前文档会直接链接到系统设计主题的相关区域，请参考链接内容以获得综合的讨论点、权衡和替代方案。\n\n设计 Bit.ly - 是一个类似的问题，区别是 pastebin 需要存储的是 paste 的内容，而不是原始的未短化的 url。\n\n\n# 步骤一、需求分析\n\n> 收集这个问题的需求和范畴。 问相关问题来明确用例和约束。 讨论一些假设。\n\n\n# 用例\n\n# 问题范围\n\n * 用户 输入一段文本，然后得到一个随机生成的链接\n   * 过期设置\n     * 默认的设置是不会过期的\n     * 可以选择设置一个过期的时间\n * 用户 输入一个 paste 的 url 后，可以看到它存储的内容\n * 用户 是匿名的\n * Service 跟踪页面分析\n   * 一个月的访问统计\n * Service 删除过期的 pastes\n * Service 需要高可用\n\n# 超出范畴的用例\n\n * 用户 可以注册一个账户\n   * 用户 通过验证邮箱\n * 用户 可以用注册的账户登录\n   * 用户 可以编辑文档\n * 用户 可以设置可见性\n * 用户 可以设置短链接\n\n\n# 约束和假设\n\n# 状态假设\n\n * 访问流量不是均匀分布的\n * 打开一个短链接应该是很快的\n * pastes 只能是文本\n * 页面访问分析数据可以不用实时\n * 一千万的用户量\n * 每个月一千万的 paste 写入量\n * 每个月一亿的 paste 读取量\n * 读写比例在 10:1\n\n# 性能估算\n\n * 每个 paste 的大小\n   * 每一个 paste 1 KB\n   * shortlink - 7 bytes\n   * expiration_length_in_minutes - 4 bytes\n   * created_at - 5 bytes\n   * paste_path - 255 bytes\n   * 总共 = ~1.27 KB\n * 每个月新的 paste 内容在 12.7GB\n   * (1.27 * 10000000)KB / 月的 paste\n   * 三年内将近 450GB 的新 paste 内容\n   * 三年内 3.6 亿短链接\n   * 假设大部分都是新的 paste，而不是需要更新已存在的 paste\n * 平均 4paste/s 的写入速度\n * 平均 40paste/s 的读取速度\n\n简单的转换指南:\n\n * 2.5 百万 req/s\n * 1 req/s = 2.5 百万 req/month\n * 40 req/s = 1 亿 req/month\n * 400 req/s = 10 亿 req/month\n\n\n# 步骤二、顶层设计\n\n> 概述一个包括所有重要的组件的高层次设计\n\n\n\n\n# 步骤三、核心组件设计\n\n> 深入每一个核心组件的细节\n\n\n# 用例：用户输入一段文本，然后得到一个随机生成的链接\n\n我们可以用一个 关系型数据库作为一个大的哈希表，用来把生成的 url 映射到一个包含 paste 文件的文件服务器和路径上。\n\n为了避免托管一个文件服务器，我们可以用一个托管的对象存储，比如 Amazon 的 S3 或者NoSQL 文档类型存储。\n\n作为一个大的哈希表的关系型数据库的替代方案，我们可以用NoSQL 键值存储。我们需要讨论选择 SQL 或 NoSQL 之间的权衡。下面的讨论是使用关系型数据库方法。\n\n * 客户端 发送一个创建 paste 的请求到作为一个反向代理启动的 Web 服务器。\n * Web 服务器 转发请求给 写接口 服务器\n * 写接口 服务器执行如下操作：\n   * 生成一个唯一的 url\n     * 检查这个 url 在 SQL 数据库 里面是否是唯一的\n     * 如果这个 url 不是唯一的，生成另外一个 url\n     * 如果我们支持自定义 url，我们可以使用用户提供的 url（也需要检查是否重复）\n   * 把生成的 url 存储到 SQL 数据库 的 pastes 表里面\n   * 存储 paste 的内容数据到 对象存储 里面\n   * 返回生成的 url\n\n向面试官阐明你需要写多少代码\n\npastes 表可以有如下结构：\n\nshortlink char(7) NOT NULL\nexpiration_length_in_minutes int NOT NULL\ncreated_at datetime NOT NULL\npaste_path varchar(255) NOT NULL\nPRIMARY KEY(shortlink)\n\n\n我们将在 shortlink 字段和 created_at 字段上创建一个数据库索引，用来提高查询的速度（避免因为扫描全表导致的长时间查询）并将数据保存在内存中，从内存里面顺序读取 1MB 的数据需要大概 250 微秒，而从 SSD 上读取则需要花费 4 倍的时间，从硬盘上则需要花费 80 倍的时间。 1\n\n为了生成唯一的 url，我们可以：\n\n * 使用 MD5 来哈希用户的 IP 地址 + 时间戳\n   * MD5 是一个普遍用来生成一个 128-bit 长度的哈希值的一种哈希方法\n   * MD5 是一致分布的\n   * 或者我们也可以用 MD5 哈希一个随机生成的数据\n * 用 Base 62 编码 MD5 哈希值\n   * 对于 urls，使用 Base 62 编码 [a-zA-Z0-9] 是比较合适的\n   * 对于每一个原始输入只会有一个 hash 结果，Base 62 是确定的（不涉及随机性）\n   * Base 64 是另外一个流行的编码方案，但是对于 urls，会因为额外的 + 和 - 字符串而产生一些问题\n   * 以下 Base 62 伪代码 执行的时间复杂度是 O(k)，k 是数字的数量 = 7：\n\ndef base_encode(num, base=62):\n    digits = []\n    while num > 0\n      remainder = modulo(num, base)\n      digits.push(remainder)\n      num = divide(num, base)\n    digits = digits.reverse\n\n\n * 取输出的前 7 个字符，结果会有 62^7 个可能的值，应该足以满足在 3 年内处理 3.6 亿个短链接的约束：\n\nurl = base_encode(md5(ip_address+timestamp))[:URL_LENGTH]\n\n\n我们将会用一个公开的 REST 风格接口：\n\n$ curl -X POST --data \'{"expiration_length_in_minutes":"60", \\"paste_contents":"Hello World!"}\' https://pastebin.com/api/v1/paste\n\n\nResponse:\n\n{\n  "shortlink": "foobar"\n}\n\n\n用于内部通信，我们可以用 RPC。\n\n\n# 用例：用户输入一个 paste 的 url 后可以看到它存储的内容\n\n * 客户端 发送一个获取 paste 请求到 Web Server\n * Web Server 转发请求给 读取接口 服务器\n * 读取接口 服务器执行如下操作：\n   * 在 SQL 数据库 检查这个生成的 url\n     * 如果这个 url 在 SQL 数据库 里面，则从 对象存储 获取这个 paste 的内容\n     * 否则，返回一个错误页面给用户\n\nREST API：\n\ncurl https://pastebin.com/api/v1/paste?shortlink=foobar\n\n\nResponse:\n\n{\n  "paste_contents": "Hello World",\n  "created_at": "YYYY-MM-DD HH:MM:SS",\n  "expiration_length_in_minutes": "60"\n}\n\n\n\n# 用例： 服务跟踪分析页面\n\n因为实时分析不是必须的，所以我们可以简单的 MapReduce Web Server 的日志，用来生成点击次数。\n\nclass HitCounts(MRJob):\n\n    def extract_url(self, line):\n        """Extract the generated url from the log line."""\n        ...\n\n    def extract_year_month(self, line):\n        """Return the year and month portions of the timestamp."""\n        ...\n\n    def mapper(self, _, line):\n        """Parse each log line, extract and transform relevant lines.\n\n        Emit key value pairs of the form:\n\n        (2016-01, url0), 1\n        (2016-01, url0), 1\n        (2016-01, url1), 1\n        """\n        url = self.extract_url(line)\n        period = self.extract_year_month(line)\n        yield (period, url), 1\n\n    def reducer(self, key, values):\n        """Sum values for each key.\n\n        (2016-01, url0), 2\n        (2016-01, url1), 1\n        """\n        yield key, sum(values)\n\n\n\n# 用例： 服务删除过期的 pastes\n\n为了删除过期的 pastes，我们可以直接搜索 SQL 数据库 中所有的过期时间比当前时间更早的记录， 所有过期的记录将从这张表里面删除（或者将其标记为过期）。\n\n\n# 步骤四、扩展设计\n\n> 给定约束条件，识别和解决瓶颈。\n\n\n\n重要提示: 不要简单的从最初的设计直接跳到最终的设计\n\n说明您将迭代地执行这样的操作：1)Benchmark/Load 测试，2)Profile 出瓶颈，3)在评估替代方案和权衡时解决瓶颈，4)重复前面，可以参考在 AWS 上设计一个可以支持百万用户的系统这个用来解决如何迭代地扩展初始设计的例子。\n\n重要的是讨论在初始设计中可能遇到的瓶颈，以及如何解决每个瓶颈。比如，在多个 Web 服务器 上添加 负载平衡器 可以解决哪些问题？ CDN 解决哪些问题？Master-Slave Replicas 解决哪些问题? 替代方案是什么和怎么对每一个替代方案进行权衡比较？\n\n我们将介绍一些组件来完成设计，并解决可伸缩性问题。内部的负载平衡器并不能减少杂乱。\n\n为了避免重复的讨论， 参考以下系统设计主题获取主要讨论要点、权衡和替代方案：\n\n * DNS\n * CDN\n * 负载均衡器\n * 水平扩展\n * 反向代理（web 服务器）\n * 应用层\n * 缓存\n * 关系型数据库管理系统 (RDBMS)\n * SQL write master-slave failover\n * 主从复制\n * 一致性模式\n * 可用性模式\n\n分析存储数据库 可以用比如 Amazon Redshift 或者 Google BigQuery 这样的数据仓库解决方案。\n\n一个像 Amazon S3 这样的 对象存储，可以轻松处理每月 12.7 GB 的新内容约束。\n\n要处理 平均 每秒 40 读请求(峰值更高)，其中热点内容的流量应该由 内存缓存 处理，而不是数据库。内存缓存 对于处理分布不均匀的流量和流量峰值也很有用。只要副本没有陷入复制写的泥潭，SQL Read Replicas 应该能够处理缓存丢失。\n\n对于单个 SQL Write Master-Slave，平均 每秒 4paste 写入 (峰值更高) 应该是可以做到的。否则，我们需要使用额外的 SQL 扩展模式:\n\n * 联合\n * 分片\n * 非规范化\n * SQL 调优\n\n我们还应该考虑将一些数据移动到 NoSQL 数据库。\n\n\n# 额外的话题\n\n> 是否更深入探讨额外主题，取决于问题的范围和面试剩余的时间。\n\n\n# NoSQL\n\n * 键值存储\n * 文档存储\n * 列型存储\n * 图数据库\n * sql 还是 nosql\n\n\n# 缓存\n\n * 在哪缓存\n   * 客户端缓存\n   * CDN 缓存\n   * Web 服务器缓存\n   * 数据库缓存\n   * 应用缓存\n * 缓存什么\n   * 数据库查询级别的缓存\n   * 对象级别的缓存\n * 何时更新缓存\n   * 缓存模式\n   * 直写模式\n   * 回写模式\n   * 刷新\n\n\n# 异步和微服务\n\n * 消息队列\n * 任务队列\n * 背压\n * 微服务\n\n\n# 通信\n\n * 讨论权衡:\n   * 跟客户端之间的外部通信 - HTTP APIs following REST\n   * 内部通信 - RPC\n * 服务发现\n\n\n# 安全\n\n参考安全。\n\n\n# 延迟数字\n\n见每个程序员都应该知道的延迟数。\n\n\n# 持续进行\n\n * 继续对系统进行基准测试和监控，以在瓶颈出现时解决它们\n * 扩展是一个迭代的过程',normalizedContent:'# 设计 pastebin.com (或者 bit.ly)\n\n> 本文搬运自 设计 pastebin.com (或者 bit.ly)\n\n注意: 为了避免重复，当前文档会直接链接到系统设计主题的相关区域，请参考链接内容以获得综合的讨论点、权衡和替代方案。\n\n设计 bit.ly - 是一个类似的问题，区别是 pastebin 需要存储的是 paste 的内容，而不是原始的未短化的 url。\n\n\n# 步骤一、需求分析\n\n> 收集这个问题的需求和范畴。 问相关问题来明确用例和约束。 讨论一些假设。\n\n\n# 用例\n\n# 问题范围\n\n * 用户 输入一段文本，然后得到一个随机生成的链接\n   * 过期设置\n     * 默认的设置是不会过期的\n     * 可以选择设置一个过期的时间\n * 用户 输入一个 paste 的 url 后，可以看到它存储的内容\n * 用户 是匿名的\n * service 跟踪页面分析\n   * 一个月的访问统计\n * service 删除过期的 pastes\n * service 需要高可用\n\n# 超出范畴的用例\n\n * 用户 可以注册一个账户\n   * 用户 通过验证邮箱\n * 用户 可以用注册的账户登录\n   * 用户 可以编辑文档\n * 用户 可以设置可见性\n * 用户 可以设置短链接\n\n\n# 约束和假设\n\n# 状态假设\n\n * 访问流量不是均匀分布的\n * 打开一个短链接应该是很快的\n * pastes 只能是文本\n * 页面访问分析数据可以不用实时\n * 一千万的用户量\n * 每个月一千万的 paste 写入量\n * 每个月一亿的 paste 读取量\n * 读写比例在 10:1\n\n# 性能估算\n\n * 每个 paste 的大小\n   * 每一个 paste 1 kb\n   * shortlink - 7 bytes\n   * expiration_length_in_minutes - 4 bytes\n   * created_at - 5 bytes\n   * paste_path - 255 bytes\n   * 总共 = ~1.27 kb\n * 每个月新的 paste 内容在 12.7gb\n   * (1.27 * 10000000)kb / 月的 paste\n   * 三年内将近 450gb 的新 paste 内容\n   * 三年内 3.6 亿短链接\n   * 假设大部分都是新的 paste，而不是需要更新已存在的 paste\n * 平均 4paste/s 的写入速度\n * 平均 40paste/s 的读取速度\n\n简单的转换指南:\n\n * 2.5 百万 req/s\n * 1 req/s = 2.5 百万 req/month\n * 40 req/s = 1 亿 req/month\n * 400 req/s = 10 亿 req/month\n\n\n# 步骤二、顶层设计\n\n> 概述一个包括所有重要的组件的高层次设计\n\n\n\n\n# 步骤三、核心组件设计\n\n> 深入每一个核心组件的细节\n\n\n# 用例：用户输入一段文本，然后得到一个随机生成的链接\n\n我们可以用一个 关系型数据库作为一个大的哈希表，用来把生成的 url 映射到一个包含 paste 文件的文件服务器和路径上。\n\n为了避免托管一个文件服务器，我们可以用一个托管的对象存储，比如 amazon 的 s3 或者nosql 文档类型存储。\n\n作为一个大的哈希表的关系型数据库的替代方案，我们可以用nosql 键值存储。我们需要讨论选择 sql 或 nosql 之间的权衡。下面的讨论是使用关系型数据库方法。\n\n * 客户端 发送一个创建 paste 的请求到作为一个反向代理启动的 web 服务器。\n * web 服务器 转发请求给 写接口 服务器\n * 写接口 服务器执行如下操作：\n   * 生成一个唯一的 url\n     * 检查这个 url 在 sql 数据库 里面是否是唯一的\n     * 如果这个 url 不是唯一的，生成另外一个 url\n     * 如果我们支持自定义 url，我们可以使用用户提供的 url（也需要检查是否重复）\n   * 把生成的 url 存储到 sql 数据库 的 pastes 表里面\n   * 存储 paste 的内容数据到 对象存储 里面\n   * 返回生成的 url\n\n向面试官阐明你需要写多少代码\n\npastes 表可以有如下结构：\n\nshortlink char(7) not null\nexpiration_length_in_minutes int not null\ncreated_at datetime not null\npaste_path varchar(255) not null\nprimary key(shortlink)\n\n\n我们将在 shortlink 字段和 created_at 字段上创建一个数据库索引，用来提高查询的速度（避免因为扫描全表导致的长时间查询）并将数据保存在内存中，从内存里面顺序读取 1mb 的数据需要大概 250 微秒，而从 ssd 上读取则需要花费 4 倍的时间，从硬盘上则需要花费 80 倍的时间。 1\n\n为了生成唯一的 url，我们可以：\n\n * 使用 md5 来哈希用户的 ip 地址 + 时间戳\n   * md5 是一个普遍用来生成一个 128-bit 长度的哈希值的一种哈希方法\n   * md5 是一致分布的\n   * 或者我们也可以用 md5 哈希一个随机生成的数据\n * 用 base 62 编码 md5 哈希值\n   * 对于 urls，使用 base 62 编码 [a-za-z0-9] 是比较合适的\n   * 对于每一个原始输入只会有一个 hash 结果，base 62 是确定的（不涉及随机性）\n   * base 64 是另外一个流行的编码方案，但是对于 urls，会因为额外的 + 和 - 字符串而产生一些问题\n   * 以下 base 62 伪代码 执行的时间复杂度是 o(k)，k 是数字的数量 = 7：\n\ndef base_encode(num, base=62):\n    digits = []\n    while num > 0\n      remainder = modulo(num, base)\n      digits.push(remainder)\n      num = divide(num, base)\n    digits = digits.reverse\n\n\n * 取输出的前 7 个字符，结果会有 62^7 个可能的值，应该足以满足在 3 年内处理 3.6 亿个短链接的约束：\n\nurl = base_encode(md5(ip_address+timestamp))[:url_length]\n\n\n我们将会用一个公开的 rest 风格接口：\n\n$ curl -x post --data \'{"expiration_length_in_minutes":"60", \\"paste_contents":"hello world!"}\' https://pastebin.com/api/v1/paste\n\n\nresponse:\n\n{\n  "shortlink": "foobar"\n}\n\n\n用于内部通信，我们可以用 rpc。\n\n\n# 用例：用户输入一个 paste 的 url 后可以看到它存储的内容\n\n * 客户端 发送一个获取 paste 请求到 web server\n * web server 转发请求给 读取接口 服务器\n * 读取接口 服务器执行如下操作：\n   * 在 sql 数据库 检查这个生成的 url\n     * 如果这个 url 在 sql 数据库 里面，则从 对象存储 获取这个 paste 的内容\n     * 否则，返回一个错误页面给用户\n\nrest api：\n\ncurl https://pastebin.com/api/v1/paste?shortlink=foobar\n\n\nresponse:\n\n{\n  "paste_contents": "hello world",\n  "created_at": "yyyy-mm-dd hh:mm:ss",\n  "expiration_length_in_minutes": "60"\n}\n\n\n\n# 用例： 服务跟踪分析页面\n\n因为实时分析不是必须的，所以我们可以简单的 mapreduce web server 的日志，用来生成点击次数。\n\nclass hitcounts(mrjob):\n\n    def extract_url(self, line):\n        """extract the generated url from the log line."""\n        ...\n\n    def extract_year_month(self, line):\n        """return the year and month portions of the timestamp."""\n        ...\n\n    def mapper(self, _, line):\n        """parse each log line, extract and transform relevant lines.\n\n        emit key value pairs of the form:\n\n        (2016-01, url0), 1\n        (2016-01, url0), 1\n        (2016-01, url1), 1\n        """\n        url = self.extract_url(line)\n        period = self.extract_year_month(line)\n        yield (period, url), 1\n\n    def reducer(self, key, values):\n        """sum values for each key.\n\n        (2016-01, url0), 2\n        (2016-01, url1), 1\n        """\n        yield key, sum(values)\n\n\n\n# 用例： 服务删除过期的 pastes\n\n为了删除过期的 pastes，我们可以直接搜索 sql 数据库 中所有的过期时间比当前时间更早的记录， 所有过期的记录将从这张表里面删除（或者将其标记为过期）。\n\n\n# 步骤四、扩展设计\n\n> 给定约束条件，识别和解决瓶颈。\n\n\n\n重要提示: 不要简单的从最初的设计直接跳到最终的设计\n\n说明您将迭代地执行这样的操作：1)benchmark/load 测试，2)profile 出瓶颈，3)在评估替代方案和权衡时解决瓶颈，4)重复前面，可以参考在 aws 上设计一个可以支持百万用户的系统这个用来解决如何迭代地扩展初始设计的例子。\n\n重要的是讨论在初始设计中可能遇到的瓶颈，以及如何解决每个瓶颈。比如，在多个 web 服务器 上添加 负载平衡器 可以解决哪些问题？ cdn 解决哪些问题？master-slave replicas 解决哪些问题? 替代方案是什么和怎么对每一个替代方案进行权衡比较？\n\n我们将介绍一些组件来完成设计，并解决可伸缩性问题。内部的负载平衡器并不能减少杂乱。\n\n为了避免重复的讨论， 参考以下系统设计主题获取主要讨论要点、权衡和替代方案：\n\n * dns\n * cdn\n * 负载均衡器\n * 水平扩展\n * 反向代理（web 服务器）\n * 应用层\n * 缓存\n * 关系型数据库管理系统 (rdbms)\n * sql write master-slave failover\n * 主从复制\n * 一致性模式\n * 可用性模式\n\n分析存储数据库 可以用比如 amazon redshift 或者 google bigquery 这样的数据仓库解决方案。\n\n一个像 amazon s3 这样的 对象存储，可以轻松处理每月 12.7 gb 的新内容约束。\n\n要处理 平均 每秒 40 读请求(峰值更高)，其中热点内容的流量应该由 内存缓存 处理，而不是数据库。内存缓存 对于处理分布不均匀的流量和流量峰值也很有用。只要副本没有陷入复制写的泥潭，sql read replicas 应该能够处理缓存丢失。\n\n对于单个 sql write master-slave，平均 每秒 4paste 写入 (峰值更高) 应该是可以做到的。否则，我们需要使用额外的 sql 扩展模式:\n\n * 联合\n * 分片\n * 非规范化\n * sql 调优\n\n我们还应该考虑将一些数据移动到 nosql 数据库。\n\n\n# 额外的话题\n\n> 是否更深入探讨额外主题，取决于问题的范围和面试剩余的时间。\n\n\n# nosql\n\n * 键值存储\n * 文档存储\n * 列型存储\n * 图数据库\n * sql 还是 nosql\n\n\n# 缓存\n\n * 在哪缓存\n   * 客户端缓存\n   * cdn 缓存\n   * web 服务器缓存\n   * 数据库缓存\n   * 应用缓存\n * 缓存什么\n   * 数据库查询级别的缓存\n   * 对象级别的缓存\n * 何时更新缓存\n   * 缓存模式\n   * 直写模式\n   * 回写模式\n   * 刷新\n\n\n# 异步和微服务\n\n * 消息队列\n * 任务队列\n * 背压\n * 微服务\n\n\n# 通信\n\n * 讨论权衡:\n   * 跟客户端之间的外部通信 - http apis following rest\n   * 内部通信 - rpc\n * 服务发现\n\n\n# 安全\n\n参考安全。\n\n\n# 延迟数字\n\n见每个程序员都应该知道的延迟数。\n\n\n# 持续进行\n\n * 继续对系统进行基准测试和监控，以在瓶颈出现时解决它们\n * 扩展是一个迭代的过程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"秒杀系统设计",frontmatter:{title:"秒杀系统设计",date:"2018-07-05T15:11:00.000Z",categories:["架构","解决方案"],tags:["架构","解决方案"],permalink:"/pages/d86624/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/01.%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.html",relativePath:"01.架构/01.解决方案/秒杀系统设计.md",key:"v-1e5e3fdf",path:"/pages/d86624/",headers:[{level:2,title:"秒杀系统的难点",slug:"秒杀系统的难点",normalizedTitle:"秒杀系统的难点",charIndex:36},{level:2,title:"秒杀系统的思考",slug:"秒杀系统的思考",normalizedTitle:"秒杀系统的思考",charIndex:443},{level:3,title:"稳准快",slug:"稳准快",normalizedTitle:"稳准快",charIndex:455},{level:2,title:"前端优化",slug:"前端优化",normalizedTitle:"前端优化",charIndex:589},{level:3,title:"静态页面",slug:"静态页面",normalizedTitle:"静态页面",charIndex:598},{level:3,title:"按钮控制",slug:"按钮控制",normalizedTitle:"按钮控制",charIndex:790},{level:2,title:"后端优化",slug:"后端优化",normalizedTitle:"后端优化",charIndex:849},{level:3,title:"隔离",slug:"隔离",normalizedTitle:"隔离",charIndex:858},{level:3,title:"限流、熔断、降级、隔离",slug:"限流、熔断、降级、隔离",normalizedTitle:"限流、熔断、降级、隔离",charIndex:947},{level:3,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:647},{level:3,title:"流量削峰",slug:"流量削峰",normalizedTitle:"流量削峰",charIndex:1141},{level:3,title:"减库存",slug:"减库存",normalizedTitle:"减库存",charIndex:527},{level:4,title:"恶意下单",slug:"恶意下单",normalizedTitle:"恶意下单",charIndex:1282},{level:4,title:"避免超卖",slug:"避免超卖",normalizedTitle:"避免超卖",charIndex:1361},{level:3,title:"URL 动态化",slug:"url-动态化",normalizedTitle:"url 动态化",charIndex:1776},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1843}],headersStr:"秒杀系统的难点 秒杀系统的思考 稳准快 前端优化 静态页面 按钮控制 后端优化 隔离 限流、熔断、降级、隔离 缓存 流量削峰 减库存 恶意下单 避免超卖 URL 动态化 参考资料",content:"# 秒杀系统设计\n\n秒杀系统所要应对的场景就是：瞬时海量请求。\n\n\n# 秒杀系统的难点\n\n * 高并发：秒杀系统是极致的高并场景发自不用说。其高并发可以细分为二：\n   * 并发读：主要是读取剩余库存量以及商品信息\n   * 并发写：主要是下单后，系统写入订单记录\n * 超卖：秒杀系统中售卖的商品一般都是性价比很高，不怎么赚钱，甚至赔钱赚哟喝的商品。一旦出现超卖现象，会给商家带来巨大的经济损失。从系统层面来看，比如某秒杀商品本来库存 100 件，但是在高并发场景下，瞬时下单量超过 100 件，处理不当，让这些下单都成功了，就会出现超卖。\n * 恶意请求：有些人为了低价购入秒杀商品，通过在多台机器上跑脚本，模拟大量用户抢商品的请求（走自己的路，让别人无路可走）。\n * 数据库崩溃：海量请求下，如果没有 MQ 削峰，没有过载保护，让所有请求都打到数据库，那么数据库基本就挂了。数据库如果挂了，也会波及其他业务，从而可能让整个系统、网站陷入瘫痪。\n * 对现有业务造成冲击\n\n\n# 秒杀系统的思考\n\n\n# 稳准快\n\n秒杀系统架构的思考角度可以概括为：稳、准、快\n\n * 稳（高可用）：系统架构要满足高可用，系统要能撑住活动。\n * 准（一致性）：商品减库存方式非常关键，不能出现超卖。\n * 快（高性能）：整个请求链路，从前端到后端，依赖组件都要做到协同优化。\n\n\n\n\n# 前端优化\n\n\n# 静态页面\n\n把秒杀商品页面静态化，减少查数据库的 IO 开销。然后，可以将这些静态页面做 CDN 缓存，如果项目是前后端分离的，还可以在反向代理服务器侧设置静态缓存。\n\n如每个商品都由 ID 来标识，那么 http://item.xxx.com/item.htm?id=xxxx 就可以作为唯一的 URL 标识。相应的页面可以提前做前端缓存，这样就不需要向后台查询商品信息。\n\n\n# 按钮控制\n\n在秒杀活动开启时间前，下单按钮禁用。\n\n此外，按钮一旦点击之后，禁用一段时间，防止有人疯狂输出。\n\n\n# 后端优化\n\n\n# 隔离\n\n秒杀活动，本质上还是一个营销活动，性质和打折、促销一样。\n\n秒杀系统设计底线原则，是不应该影响现有业务。所以，为了避免防不胜防，百密一疏的情况下，秒杀系统崩了。\n\n\n# 限流、熔断、降级、隔离\n\n * 隔离：将秒杀系统、数据与其他正常业务隔离。彼此隔离，自然互不影响。\n\n * 限流：设置阈值，超过阈值，拒绝请求。防止数据库被打死。\n\n * 降级：保证核心业务继续工作，非核心业务各安天命。\n\n * 熔断：不要影响别的系统。\n\n\n# 缓存\n\n缓存要预热，避免瞬间流量冲击。\n\n此外，防止雪崩、穿透、击穿问题的常规处理要做好。\n\n缓存也要保证高可用。\n\n\n# 流量削峰\n\n削峰的思路：排队、答题、分层过滤。\n\n * 排队：用消息队列来缓冲瞬时流量的方案。但是，消息队列自身也有上限，如果积压过多，也会处理不了。\n * 答题（摇一摇）：可以限制秒杀器并延缓请求。\n * 分层过滤：采用漏斗式的设计尽可能拦截无效请求。\n\n\n\n\n# 减库存\n\n# 恶意下单\n\n恶意下单的解决方案还是要结合安全和反作弊措施来制止：\n\n * 识别频繁下单不付款或重复下单不付款的卖家，阻断其下单。\n * 限制个人购买数\n\n# 避免超卖\n\n减库存在数据一致性上，主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决方案：一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错；再有一种就是使用 CASE WHEN 判断语句，例如这样的 SQL 语句：\n\nUPDATE item SET inventory = CASE WHEN inventory >= xxx THEN inventory-xxx ELSE inventory END\n\n\n在交易环节中，“库存”是个关键数据，也是个热点数据，因为交易的各个环节中都可能涉及对库存的查询。但是，我在前面介绍分层过滤时提到过，秒杀中并不需要对库存有精确的一致性读，把库存数据放到缓存（Cache）中，可以大大提升读性能。\n\n\n# URL 动态化\n\n通过 MD5 之类的加密算法加密随机的字符串去做 url，然后通过前端代码获取 url 后台校验才能通过。\n\n\n# 参考资料\n\n * 如何设计一个秒杀系统\n * 一个秒杀系统的设计思考",normalizedContent:"# 秒杀系统设计\n\n秒杀系统所要应对的场景就是：瞬时海量请求。\n\n\n# 秒杀系统的难点\n\n * 高并发：秒杀系统是极致的高并场景发自不用说。其高并发可以细分为二：\n   * 并发读：主要是读取剩余库存量以及商品信息\n   * 并发写：主要是下单后，系统写入订单记录\n * 超卖：秒杀系统中售卖的商品一般都是性价比很高，不怎么赚钱，甚至赔钱赚哟喝的商品。一旦出现超卖现象，会给商家带来巨大的经济损失。从系统层面来看，比如某秒杀商品本来库存 100 件，但是在高并发场景下，瞬时下单量超过 100 件，处理不当，让这些下单都成功了，就会出现超卖。\n * 恶意请求：有些人为了低价购入秒杀商品，通过在多台机器上跑脚本，模拟大量用户抢商品的请求（走自己的路，让别人无路可走）。\n * 数据库崩溃：海量请求下，如果没有 mq 削峰，没有过载保护，让所有请求都打到数据库，那么数据库基本就挂了。数据库如果挂了，也会波及其他业务，从而可能让整个系统、网站陷入瘫痪。\n * 对现有业务造成冲击\n\n\n# 秒杀系统的思考\n\n\n# 稳准快\n\n秒杀系统架构的思考角度可以概括为：稳、准、快\n\n * 稳（高可用）：系统架构要满足高可用，系统要能撑住活动。\n * 准（一致性）：商品减库存方式非常关键，不能出现超卖。\n * 快（高性能）：整个请求链路，从前端到后端，依赖组件都要做到协同优化。\n\n\n\n\n# 前端优化\n\n\n# 静态页面\n\n把秒杀商品页面静态化，减少查数据库的 io 开销。然后，可以将这些静态页面做 cdn 缓存，如果项目是前后端分离的，还可以在反向代理服务器侧设置静态缓存。\n\n如每个商品都由 id 来标识，那么 http://item.xxx.com/item.htm?id=xxxx 就可以作为唯一的 url 标识。相应的页面可以提前做前端缓存，这样就不需要向后台查询商品信息。\n\n\n# 按钮控制\n\n在秒杀活动开启时间前，下单按钮禁用。\n\n此外，按钮一旦点击之后，禁用一段时间，防止有人疯狂输出。\n\n\n# 后端优化\n\n\n# 隔离\n\n秒杀活动，本质上还是一个营销活动，性质和打折、促销一样。\n\n秒杀系统设计底线原则，是不应该影响现有业务。所以，为了避免防不胜防，百密一疏的情况下，秒杀系统崩了。\n\n\n# 限流、熔断、降级、隔离\n\n * 隔离：将秒杀系统、数据与其他正常业务隔离。彼此隔离，自然互不影响。\n\n * 限流：设置阈值，超过阈值，拒绝请求。防止数据库被打死。\n\n * 降级：保证核心业务继续工作，非核心业务各安天命。\n\n * 熔断：不要影响别的系统。\n\n\n# 缓存\n\n缓存要预热，避免瞬间流量冲击。\n\n此外，防止雪崩、穿透、击穿问题的常规处理要做好。\n\n缓存也要保证高可用。\n\n\n# 流量削峰\n\n削峰的思路：排队、答题、分层过滤。\n\n * 排队：用消息队列来缓冲瞬时流量的方案。但是，消息队列自身也有上限，如果积压过多，也会处理不了。\n * 答题（摇一摇）：可以限制秒杀器并延缓请求。\n * 分层过滤：采用漏斗式的设计尽可能拦截无效请求。\n\n\n\n\n# 减库存\n\n# 恶意下单\n\n恶意下单的解决方案还是要结合安全和反作弊措施来制止：\n\n * 识别频繁下单不付款或重复下单不付款的卖家，阻断其下单。\n * 限制个人购买数\n\n# 避免超卖\n\n减库存在数据一致性上，主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决方案：一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 sql 语句来报错；再有一种就是使用 case when 判断语句，例如这样的 sql 语句：\n\nupdate item set inventory = case when inventory >= xxx then inventory-xxx else inventory end\n\n\n在交易环节中，“库存”是个关键数据，也是个热点数据，因为交易的各个环节中都可能涉及对库存的查询。但是，我在前面介绍分层过滤时提到过，秒杀中并不需要对库存有精确的一致性读，把库存数据放到缓存（cache）中，可以大大提升读性能。\n\n\n# url 动态化\n\n通过 md5 之类的加密算法加密随机的字符串去做 url，然后通过前端代码获取 url 后台校验才能通过。\n\n\n# 参考资料\n\n * 如何设计一个秒杀系统\n * 一个秒杀系统的设计思考",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"认证和授权",frontmatter:{title:"认证和授权",date:"2021-11-08T08:15:33.000Z",categories:["架构","安全"],tags:["架构","安全","认证","授权"],permalink:"/pages/0c680e/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/02.%E5%AE%89%E5%85%A8/01.%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83.html",relativePath:"01.架构/02.安全/01.认证和授权.md",key:"v-fea1ca6c",path:"/pages/0c680e/",headers:[{level:2,title:"基本概念",slug:"基本概念",normalizedTitle:"基本概念",charIndex:46},{level:3,title:"认证",slug:"认证",normalizedTitle:"认证",charIndex:2},{level:3,title:"授权",slug:"授权",normalizedTitle:"授权",charIndex:5},{level:3,title:"鉴权",slug:"鉴权",normalizedTitle:"鉴权",charIndex:1107},{level:3,title:"权限控制",slug:"权限控制",normalizedTitle:"权限控制",charIndex:1534},{level:3,title:"认证、授权、鉴权和权限控制的关系",slug:"认证、授权、鉴权和权限控制的关系",normalizedTitle:"认证、授权、鉴权和权限控制的关系",charIndex:2139},{level:2,title:"JWT",slug:"jwt",normalizedTitle:"jwt",charIndex:38},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2623}],headersStr:"基本概念 认证 授权 鉴权 权限控制 认证、授权、鉴权和权限控制的关系 JWT 参考资料",content:"# 认证和授权\n\n> 关键词：SSO、Oauth 2.0、CAS、RABC、JWT\n\n\n# 基本概念\n\n\n# 认证\n\n认证是指根据声明者所特有的识别信息，确认声明者的身份。认证在英文中对应于 identification 这个单词。\n\n最常见的认证实现方式是通过用户名和密码，但认证方式不限于此。下面都是当前常见到的认证技术：\n\n * 身份证\n * 用户名和密码认证\n * 用户手机认证：手机短信、手机二维码扫描、手势密码\n * 用户邮箱认证\n * 基于时间序列和用户相关的一次性口令\n * 用户的生物学特征认证：指纹、语音、眼睛虹膜\n * 用户的大数据识别认证\n * 等等\n\n为了确认用户的身份，防止伪造，在安全要求高的场合，经常会使用组合认证（或者叫多因素认证），也就是同时使用多个认证方式对用户的身份进行校验。\n\n\n# 授权\n\n简单来说，授权一般是指获取用户的委派权限。在英文中对应于 authorization 这个单词。\n\n在信息安全领域，授权是指资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便执行者代理执行对资源的相关操作。这里面包含有如下四个重要概念，\n\n * 资源所有者：拥有资源的所有权利，一般就是资源的拥有者。\n * 资源执行者：被委派去执行资源的相关操作。\n * 操作权限：可以对资源进行的某种操作。\n * 资源：有价值的信息或数据等，受到安全保护。\n\n需要说明的是，资源所有者和执行者可以是自然人，就是普通用户，但不限于自然人。在信息安全领域，资源所有者和执行者，很多时候是应用程序或者机器。比如用户在浏览器上登录一个网站，那么这个浏览器就成为一个执行者，它在用户登录后获取了用户的授权，代表着用户执行各种指令，进行购物、下单、付钱、转账等等操作。\n\n同时，资源所有者和执行者可以是分开的不同实体，也可以是同一个。若是分开的两者，则资源执行者是以资源所有者的代理形式而存在。\n\n授权的实现方式非常多也很广泛，我们常见的银行卡、门禁卡、钥匙、公证书，这些都是现实生活中授权的实现方式。其实现方式主要通过一个共信的媒介完成，这个媒介不可被篡改，不可随意伪造，很多时候需要受保护，防止被窃取。\n\n在互联网应用开发领域，授权所用到的授信媒介主要包括如下几种，\n\n * 通过 web 服务器的 session 机制，一个访问会话保持着用户的授权信息\n * 通过 web 浏览器的 cookie 机制，一个网站的 cookie 保持着用户的授权信息\n * 颁发授权令牌（token），一个合法有效的令牌中保持着用户的授权信息\n\n前面两者常见于 web 开发，需要有浏览器的支持。\n\n\n# 鉴权\n\n鉴权是指对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程。在英文中对应于 authentication 这个单词。\n\n鉴权主要是对声明者所声明的真实性进行校验。若从授权出发，则会更加容易理解鉴权。授权和鉴权是两个上下游相匹配的关系，先授权，后鉴权。授权和鉴权两个词中的“权”，是同一个概念，就是所委派的权利，在实现上即为授信媒介的表达形式。\n\n因此，鉴权的实现方式是和授权方式有一一对应关系。对授权所颁发授信媒介进行解析，确认其真实性。下面是鉴权的一些实现方式，\n\n * 门禁卡：通过门禁卡识别器\n * 钥匙：通过相匹配的锁\n * 银行卡：通过银行卡识别器\n * 互联网 web 开发领域的 session/cookie/token：校验 session/cookie/token 的合法性和有效性\n\n鉴权是一个承上启下的一个环节，上游它接受授权的输出，校验其真实性后，然后获取权限（permission），这个将会为下一步的权限控制做好准备。\n\n\n# 权限控制\n\n权限控制是指对可执行的各种操作组合配置为权限列表，然后根据执行者的权限，若其操作在权限范围内，则允许执行，否则禁止。权限控制在英文中对应于 access/permission control。\n\n对于权限控制，可以分为两部分进行理解：一个是权限，另一个是控制。权限是抽象的逻辑概念，而控制是具体的实现方式。\n\n先看权限（Permission），这是一个抽象的概念，一般预先定义和配置好，以便控制的具体实现。权限的定义，若简单点，可以直接对应于一个可执行的操作集合。而一般情况下，会有基于角色的方式来定义权限，由角色来封装可执行的操作集合。\n\n若以门禁卡的权限实现为例，上述两种定义方式则可以各自表达为，\n\n * 这是一个门禁卡，拥有开公司所有的门的权限\n * 这是一个门禁卡，拥有管理员角色的权限，因而可以开公司所有的门\n\n可以看到，权限作为一个抽象的概念，将执行者和可具体执行的操作相分离。\n\n在上文的讨论中，鉴权的输出是权限（Permission）。一旦有了权限，便知道了可执行的操作，接下来就是控制的事情了。\n\n对于控制，是根据执行者的权限，对其所执行的操作进行判断，决定允许或禁止当前操作的执行。现实生活中控制的实现方式，多种多样，\n\n * 门禁：控制门的开关\n * 自行车锁：控制车轮\n * 互联网 web 后端服务：控制接口访问，允许或拒绝访问请求\n\n\n# 认证、授权、鉴权和权限控制的关系\n\n认证、授权、鉴权和权限控制这四个环节是一个前后依次发生、上下游的关系，\n\n认证--\x3e授权--\x3e鉴权--\x3e权限控制\n\n需要说明的是，这四个环节在有些时候会同时发生。 例如在下面的几个场景，\n\n * 使用门禁卡开门：认证、授权、鉴权、权限控制四个环节一气呵成，在瞬间同时发生\n * 用户的网站登录：用户在使用用户名和密码进行登录时，认证和授权两个环节一同完成，而鉴权和权限控制则发生在后续的请求访问中，比如在选购物品或支付时。\n\n无论怎样，若从时间顺序方面来看，这四个环节是按时间前后、依次相继发生的关系。\n\n认证和鉴权的关系：\n\n这两个概念在很多时候是被混淆最多的概念。被混淆的主要原因，如上文所述，很多时候认证、授权、鉴权和权限控制一同发生，以至于被误解为，认证就是鉴权，鉴权就是认证。\n\n其实两者是不一样的概念，两者都有对身份的确认过程，但是两者的主要区别在于，\n\n * 认证是确认声明者的本身身份，其作为授权的上游衔接而存在\n * 鉴权是对声明者所声明的真实性进行确认的过程，其作为授权的下游衔接而存在\n\n\n# JWT\n\n\n# 参考资料\n\n理解 OAuth 2.0",normalizedContent:"# 认证和授权\n\n> 关键词：sso、oauth 2.0、cas、rabc、jwt\n\n\n# 基本概念\n\n\n# 认证\n\n认证是指根据声明者所特有的识别信息，确认声明者的身份。认证在英文中对应于 identification 这个单词。\n\n最常见的认证实现方式是通过用户名和密码，但认证方式不限于此。下面都是当前常见到的认证技术：\n\n * 身份证\n * 用户名和密码认证\n * 用户手机认证：手机短信、手机二维码扫描、手势密码\n * 用户邮箱认证\n * 基于时间序列和用户相关的一次性口令\n * 用户的生物学特征认证：指纹、语音、眼睛虹膜\n * 用户的大数据识别认证\n * 等等\n\n为了确认用户的身份，防止伪造，在安全要求高的场合，经常会使用组合认证（或者叫多因素认证），也就是同时使用多个认证方式对用户的身份进行校验。\n\n\n# 授权\n\n简单来说，授权一般是指获取用户的委派权限。在英文中对应于 authorization 这个单词。\n\n在信息安全领域，授权是指资源所有者委派执行者，赋予执行者指定范围的资源操作权限，以便执行者代理执行对资源的相关操作。这里面包含有如下四个重要概念，\n\n * 资源所有者：拥有资源的所有权利，一般就是资源的拥有者。\n * 资源执行者：被委派去执行资源的相关操作。\n * 操作权限：可以对资源进行的某种操作。\n * 资源：有价值的信息或数据等，受到安全保护。\n\n需要说明的是，资源所有者和执行者可以是自然人，就是普通用户，但不限于自然人。在信息安全领域，资源所有者和执行者，很多时候是应用程序或者机器。比如用户在浏览器上登录一个网站，那么这个浏览器就成为一个执行者，它在用户登录后获取了用户的授权，代表着用户执行各种指令，进行购物、下单、付钱、转账等等操作。\n\n同时，资源所有者和执行者可以是分开的不同实体，也可以是同一个。若是分开的两者，则资源执行者是以资源所有者的代理形式而存在。\n\n授权的实现方式非常多也很广泛，我们常见的银行卡、门禁卡、钥匙、公证书，这些都是现实生活中授权的实现方式。其实现方式主要通过一个共信的媒介完成，这个媒介不可被篡改，不可随意伪造，很多时候需要受保护，防止被窃取。\n\n在互联网应用开发领域，授权所用到的授信媒介主要包括如下几种，\n\n * 通过 web 服务器的 session 机制，一个访问会话保持着用户的授权信息\n * 通过 web 浏览器的 cookie 机制，一个网站的 cookie 保持着用户的授权信息\n * 颁发授权令牌（token），一个合法有效的令牌中保持着用户的授权信息\n\n前面两者常见于 web 开发，需要有浏览器的支持。\n\n\n# 鉴权\n\n鉴权是指对于一个声明者所声明的身份权利，对其所声明的真实性进行鉴别确认的过程。在英文中对应于 authentication 这个单词。\n\n鉴权主要是对声明者所声明的真实性进行校验。若从授权出发，则会更加容易理解鉴权。授权和鉴权是两个上下游相匹配的关系，先授权，后鉴权。授权和鉴权两个词中的“权”，是同一个概念，就是所委派的权利，在实现上即为授信媒介的表达形式。\n\n因此，鉴权的实现方式是和授权方式有一一对应关系。对授权所颁发授信媒介进行解析，确认其真实性。下面是鉴权的一些实现方式，\n\n * 门禁卡：通过门禁卡识别器\n * 钥匙：通过相匹配的锁\n * 银行卡：通过银行卡识别器\n * 互联网 web 开发领域的 session/cookie/token：校验 session/cookie/token 的合法性和有效性\n\n鉴权是一个承上启下的一个环节，上游它接受授权的输出，校验其真实性后，然后获取权限（permission），这个将会为下一步的权限控制做好准备。\n\n\n# 权限控制\n\n权限控制是指对可执行的各种操作组合配置为权限列表，然后根据执行者的权限，若其操作在权限范围内，则允许执行，否则禁止。权限控制在英文中对应于 access/permission control。\n\n对于权限控制，可以分为两部分进行理解：一个是权限，另一个是控制。权限是抽象的逻辑概念，而控制是具体的实现方式。\n\n先看权限（permission），这是一个抽象的概念，一般预先定义和配置好，以便控制的具体实现。权限的定义，若简单点，可以直接对应于一个可执行的操作集合。而一般情况下，会有基于角色的方式来定义权限，由角色来封装可执行的操作集合。\n\n若以门禁卡的权限实现为例，上述两种定义方式则可以各自表达为，\n\n * 这是一个门禁卡，拥有开公司所有的门的权限\n * 这是一个门禁卡，拥有管理员角色的权限，因而可以开公司所有的门\n\n可以看到，权限作为一个抽象的概念，将执行者和可具体执行的操作相分离。\n\n在上文的讨论中，鉴权的输出是权限（permission）。一旦有了权限，便知道了可执行的操作，接下来就是控制的事情了。\n\n对于控制，是根据执行者的权限，对其所执行的操作进行判断，决定允许或禁止当前操作的执行。现实生活中控制的实现方式，多种多样，\n\n * 门禁：控制门的开关\n * 自行车锁：控制车轮\n * 互联网 web 后端服务：控制接口访问，允许或拒绝访问请求\n\n\n# 认证、授权、鉴权和权限控制的关系\n\n认证、授权、鉴权和权限控制这四个环节是一个前后依次发生、上下游的关系，\n\n认证--\x3e授权--\x3e鉴权--\x3e权限控制\n\n需要说明的是，这四个环节在有些时候会同时发生。 例如在下面的几个场景，\n\n * 使用门禁卡开门：认证、授权、鉴权、权限控制四个环节一气呵成，在瞬间同时发生\n * 用户的网站登录：用户在使用用户名和密码进行登录时，认证和授权两个环节一同完成，而鉴权和权限控制则发生在后续的请求访问中，比如在选购物品或支付时。\n\n无论怎样，若从时间顺序方面来看，这四个环节是按时间前后、依次相继发生的关系。\n\n认证和鉴权的关系：\n\n这两个概念在很多时候是被混淆最多的概念。被混淆的主要原因，如上文所述，很多时候认证、授权、鉴权和权限控制一同发生，以至于被误解为，认证就是鉴权，鉴权就是认证。\n\n其实两者是不一样的概念，两者都有对身份的确认过程，但是两者的主要区别在于，\n\n * 认证是确认声明者的本身身份，其作为授权的上游衔接而存在\n * 鉴权是对声明者所声明的真实性进行确认的过程，其作为授权的下游衔接而存在\n\n\n# jwt\n\n\n# 参考资料\n\n理解 oauth 2.0",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"OAuth 2.0",frontmatter:{title:"OAuth 2.0",date:"2021-11-08T08:15:33.000Z",categories:["架构","安全"],tags:["架构","安全","认证","授权","OAuth 2.0"],permalink:"/pages/292687/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/02.%E5%AE%89%E5%85%A8/02.OAuth2.0.html",relativePath:"01.架构/02.安全/02.OAuth2.0.md",key:"v-dc1b4da6",path:"/pages/292687/",headers:[{level:2,title:"授权码模式",slug:"授权码模式",normalizedTitle:"授权码模式",charIndex:251},{level:2,title:"隐藏模式",slug:"隐藏模式",normalizedTitle:"隐藏模式",charIndex:538},{level:2,title:"密码模式",slug:"密码模式",normalizedTitle:"密码模式",charIndex:298},{level:2,title:"客户端凭证模式",slug:"客户端凭证模式",normalizedTitle:"客户端凭证模式",charIndex:757},{level:2,title:"令牌的使用",slug:"令牌的使用",normalizedTitle:"令牌的使用",charIndex:796},{level:2,title:"令牌的更新",slug:"令牌的更新",normalizedTitle:"令牌的更新",charIndex:806},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1029}],headersStr:"授权码模式 隐藏模式 密码模式 客户端凭证模式 令牌的使用 令牌的更新 参考资料",content:'# OAuth 2.0\n\n> OAuth 是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是 2.0 版。\n\n简单来说，OAuth 是一种授权机制。资源的所有者告诉系统，同意授权第三方应用进入系统，访问这些资源。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。\n\n客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。\n\nOAuth 2.0 定义了四种授权方式。\n\n * 授权码模式（authorization code）\n * 简化模式（implicit）\n * 密码模式（resource owner password credentials）\n * 客户端模式（client credentials）\n\n\n# 授权码模式\n\n授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该授权码获取令牌。\n\n这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。\n\n\n# 隐藏模式\n\n有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）"隐藏式"（implicit）。\n\n\n# 密码模式\n\n如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为"密码式"（password）。\n\n\n# 客户端凭证模式\n\n适用于没有前端的命令行应用，即在命令行下请求令牌。\n\n\n# 令牌的使用\n\n\n# 令牌的更新\n\n如果用户访问的时候，客户端的"访问令牌"已经过期，则需要使用"更新令牌"申请一个新的访问令牌。\n\n客户端发出更新令牌的 HTTP 请求，包含以下参数：\n\n * granttype：表示使用的授权模式，此处的值固定为"refreshtoken"，必选项。\n * refresh_token：表示早前收到的更新令牌，必选项。\n * scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致\n\n\n# 参考资料\n\n * RFC 6749\n * OAuth 2.0 的一个简单解释\n * 理解 OAuth 2.0\n * The Simplest Guide To OAuth 2.0',normalizedContent:'# oauth 2.0\n\n> oauth 是一个关于授权（authorization）的开放网络标准，在全世界得到广泛应用，目前的版本是 2.0 版。\n\n简单来说，oauth 是一种授权机制。资源的所有者告诉系统，同意授权第三方应用进入系统，访问这些资源。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。\n\n客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。\n\noauth 2.0 定义了四种授权方式。\n\n * 授权码模式（authorization code）\n * 简化模式（implicit）\n * 密码模式（resource owner password credentials）\n * 客户端模式（client credentials）\n\n\n# 授权码模式\n\n授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该授权码获取令牌。\n\n这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。\n\n\n# 隐藏模式\n\n有些 web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。rfc 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）"隐藏式"（implicit）。\n\n\n# 密码模式\n\n如果你高度信任某个应用，rfc 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为"密码式"（password）。\n\n\n# 客户端凭证模式\n\n适用于没有前端的命令行应用，即在命令行下请求令牌。\n\n\n# 令牌的使用\n\n\n# 令牌的更新\n\n如果用户访问的时候，客户端的"访问令牌"已经过期，则需要使用"更新令牌"申请一个新的访问令牌。\n\n客户端发出更新令牌的 http 请求，包含以下参数：\n\n * granttype：表示使用的授权模式，此处的值固定为"refreshtoken"，必选项。\n * refresh_token：表示早前收到的更新令牌，必选项。\n * scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致\n\n\n# 参考资料\n\n * rfc 6749\n * oauth 2.0 的一个简单解释\n * 理解 oauth 2.0\n * the simplest guide to oauth 2.0',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"系统架构概述",frontmatter:{title:"系统架构概述",date:"2018-07-05T15:11:00.000Z",categories:["架构"],tags:["架构"],permalink:"/pages/ce2da4/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/02.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0.html",relativePath:"01.架构/02.系统架构概述.md",key:"v-265d3d7e",path:"/pages/ce2da4/",headers:[{level:2,title:"1. 大型系统架构演化",slug:"_1-大型系统架构演化",normalizedTitle:"1. 大型系统架构演化",charIndex:13},{level:3,title:"1.1. 单机架构",slug:"_1-1-单机架构",normalizedTitle:"1.1. 单机架构",charIndex:253},{level:3,title:"1.2. 应用服务和数据服务分离",slug:"_1-2-应用服务和数据服务分离",normalizedTitle:"1.2. 应用服务和数据服务分离",charIndex:440},{level:3,title:"1.3. 使用缓存改善性能",slug:"_1-3-使用缓存改善性能",normalizedTitle:"1.3. 使用缓存改善性能",charIndex:679},{level:3,title:"1.4. 负载均衡",slug:"_1-4-负载均衡",normalizedTitle:"1.4. 负载均衡",charIndex:949},{level:3,title:"1.5. 数据库读写分离",slug:"_1-5-数据库读写分离",normalizedTitle:"1.5. 数据库读写分离",charIndex:1151},{level:3,title:"1.6. 多级缓存",slug:"_1-6-多级缓存",normalizedTitle:"1.6. 多级缓存",charIndex:1509},{level:3,title:"1.7. 业务拆分",slug:"_1-7-业务拆分",normalizedTitle:"1.7. 业务拆分",charIndex:1766},{level:3,title:"1.8. 分库分表",slug:"_1-8-分库分表",normalizedTitle:"1.8. 分库分表",charIndex:2120},{level:3,title:"1.9. 分布式组件",slug:"_1-9-分布式组件",normalizedTitle:"1.9. 分布式组件",charIndex:2299},{level:3,title:"1.10. 微服务",slug:"_1-10-微服务",normalizedTitle:"1.10. 微服务",charIndex:2457},{level:2,title:"2. 架构设计的考量",slug:"_2-架构设计的考量",normalizedTitle:"2. 架构设计的考量",charIndex:2695},{level:3,title:"2.1. 什么是架构",slug:"_2-1-什么是架构",normalizedTitle:"2.1. 什么是架构",charIndex:2766},{level:3,title:"2.2. 架构设计的目标",slug:"_2-2-架构设计的目标",normalizedTitle:"2.2. 架构设计的目标",charIndex:2938},{level:3,title:"2.3. 架构设计的原则",slug:"_2-3-架构设计的原则",normalizedTitle:"2.3. 架构设计的原则",charIndex:3386},{level:4,title:"2.3.1. 合适原则",slug:"_2-3-1-合适原则",normalizedTitle:"2.3.1. 合适原则",charIndex:3428},{level:4,title:"2.3.2. 简单原则",slug:"_2-3-2-简单原则",normalizedTitle:"2.3.2. 简单原则",charIndex:3538},{level:4,title:"2.3.3. 演化原则",slug:"_2-3-3-演化原则",normalizedTitle:"2.3.3. 演化原则",charIndex:3585},{level:4,title:"2.3.4. 墨菲定律",slug:"_2-3-4-墨菲定律",normalizedTitle:"2.3.4. 墨菲定律",charIndex:3634},{level:4,title:"2.3.5. 康威定律",slug:"_2-3-5-康威定律",normalizedTitle:"2.3.5. 康威定律",charIndex:3730},{level:4,title:"2.3.6. 二八定律",slug:"_2-3-6-二八定律",normalizedTitle:"2.3.6. 二八定律",charIndex:3823},{level:3,title:"2.4. 高性能",slug:"_2-4-高性能",normalizedTitle:"2.4. 高性能",charIndex:3839},{level:4,title:"2.4.1. 性能指标",slug:"_2-4-1-性能指标",normalizedTitle:"2.4.1. 性能指标",charIndex:3901},{level:4,title:"2.4.2. 性能提升手段",slug:"_2-4-2-性能提升手段",normalizedTitle:"2.4.2. 性能提升手段",charIndex:4096},{level:3,title:"2.5. 高可用",slug:"_2-5-高可用",normalizedTitle:"2.5. 高可用",charIndex:4496},{level:4,title:"2.5.1. 无状态应用的高可用",slug:"_2-5-1-无状态应用的高可用",normalizedTitle:"2.5.1. 无状态应用的高可用",charIndex:4670},{level:4,title:"2.5.2. 有状态应用的高可用",slug:"_2-5-2-有状态应用的高可用",normalizedTitle:"2.5.2. 有状态应用的高可用",charIndex:4971},{level:4,title:"2.5.3. 高可用手段",slug:"_2-5-3-高可用手段",normalizedTitle:"2.5.3. 高可用手段",charIndex:5158},{level:3,title:"2.6. 扩展性",slug:"_2-6-扩展性",normalizedTitle:"2.6. 扩展性",charIndex:5688},{level:3,title:"2.7. 伸缩性",slug:"_2-7-伸缩性",normalizedTitle:"2.7. 伸缩性",charIndex:6661},{level:3,title:"2.8. 安全性",slug:"_2-8-安全性",normalizedTitle:"2.8. 安全性",charIndex:7142},{level:2,title:"3. 常见架构模型",slug:"_3-常见架构模型",normalizedTitle:"3. 常见架构模型",charIndex:7379},{level:3,title:"3.1. 分层架构",slug:"_3-1-分层架构",normalizedTitle:"3.1. 分层架构",charIndex:7393},{level:3,title:"3.2. 事件驱动架构",slug:"_3-2-事件驱动架构",normalizedTitle:"3.2. 事件驱动架构",charIndex:7882},{level:3,title:"3.3. 微核架构",slug:"_3-3-微核架构",normalizedTitle:"3.3. 微核架构",charIndex:8404},{level:3,title:"3.4. 微服务架构",slug:"_3-4-微服务架构",normalizedTitle:"3.4. 微服务架构",charIndex:8784},{level:3,title:"3.5. 云架构",slug:"_3-5-云架构",normalizedTitle:"3.5. 云架构",charIndex:9489},{level:2,title:"4. 参考资料",slug:"_4-参考资料",normalizedTitle:"4. 参考资料",charIndex:10216}],headersStr:"1. 大型系统架构演化 1.1. 单机架构 1.2. 应用服务和数据服务分离 1.3. 使用缓存改善性能 1.4. 负载均衡 1.5. 数据库读写分离 1.6. 多级缓存 1.7. 业务拆分 1.8. 分库分表 1.9. 分布式组件 1.10. 微服务 2. 架构设计的考量 2.1. 什么是架构 2.2. 架构设计的目标 2.3. 架构设计的原则 2.3.1. 合适原则 2.3.2. 简单原则 2.3.3. 演化原则 2.3.4. 墨菲定律 2.3.5. 康威定律 2.3.6. 二八定律 2.4. 高性能 2.4.1. 性能指标 2.4.2. 性能提升手段 2.5. 高可用 2.5.1. 无状态应用的高可用 2.5.2. 有状态应用的高可用 2.5.3. 高可用手段 2.6. 扩展性 2.7. 伸缩性 2.8. 安全性 3. 常见架构模型 3.1. 分层架构 3.2. 事件驱动架构 3.3. 微核架构 3.4. 微服务架构 3.5. 云架构 4. 参考资料",content:'# 系统架构概述\n\n\n# 1. 大型系统架构演化\n\n一个大型系统的架构是一个渐进的演化过程。罗马不是一天建成的，同理，微信、淘宝等大型系统绝不是一蹴而就的。随着业务的不断发展，用户体量的增加，系统的复杂度势必不断攀升，最终迫使系统架构进化，以应对挑战。\n\n了解大型系统架构的演化过程，有利于我们了解架构进化的发展规律和业界一些成熟的应对方案。帮助我们在实际工作中，如何去思考架构，如何去凝练解决方案。\n\n大型系统架构演化比较具有代表性的就是大型网站的演化过程。这里介绍一下大型网站演化的一般规律。\n\n\n# 1.1. 单机架构\n\n * 问题：网站运营初期，访问用户少，一台服务器绰绰有余。\n * 特征：应用程序、数据库、文件等所有的资源都在一台服务器上。\n * 描述：通常服务器操作系统使用 linux，应用程序使用 PHP 开发，然后部署在 Apache 上，数据库使用 Mysql，通俗称为 LAMP。汇集各种免费开源软件以及一台廉价服务器就可以开始系统的发展之路了。\n\n\n# 1.2. 应用服务和数据服务分离\n\n * 问题：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足，一台服务器已不足以支撑。\n * 特征：应用服务器、数据库服务器、文件服务器分别独立部署。\n * 描述：三台服务器对性能要求各不相同：\n   * 应用服务器要处理大量业务逻辑，因此需要更快更强大的 CPU；\n   * 数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的硬盘和更大的内存；\n   * 文件服务器需要存储大量文件，因此需要更大容量的硬盘。\n\n\n# 1.3. 使用缓存改善性能\n\n * 问题：随着用户逐渐增多，数据库压力太大导致访问延迟。\n * 特征：由于网站访问和财富分配一样遵循二八定律：80% 的业务访问集中在 20% 的数据上。将数据库中访问较集中的少部分数据缓存在内存中，可以减少数据库的访问次数，降低数据库的访问压力。\n * 描述：缓存分为两种：应用服务器上的本地缓存和分布式缓存服务器上的远程缓存。\n   * 本地缓存访问速度更快，但缓存数据量有限，同时存在与应用程序争用内存的情况。\n   * 分布式缓存可以采用集群方式，理论上可以做到不受内存容量限制的缓存服务。\n\n\n# 1.4. 负载均衡\n\n * 问题：使用缓存后，数据库访问压力得到有效缓解。但是单一应用服务器能够处理的请求连接有限，在访问高峰期，成为瓶颈。\n * 特征：多台服务器通过负载均衡同时向外部提供服务，解决单一服务器处理能力和存储空间不足的问题。\n * 描述：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。\n\n\n# 1.5. 数据库读写分离\n\n * 问题：网站使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作和全部的写操作需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。\n * 特征：目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到一台服务器上。网站利用数据库的主从热备功能，实现数据库读写分离，从而改善数据库负载压力。\n * 描述：应用服务器在写操作的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库。这样当应用服务器在读操作的时候，访问从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离的对应用透明。\n\n\n# 1.6. 多级缓存\n\n * 问题：中国网络环境复杂，不同地区的用户访问网站时，速度差别也极大。\n * 特征：采用 CDN 和反向代理加快系统的静态资源访问速度。\n * 描述：CDN 和反向代理的基本原理都是缓存，区别在于：\n   * CDN 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；\n   * 而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器时反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。\n\n\n# 1.7. 业务拆分\n\n * 问题：大型网站的业务场景日益复杂，分为多个产品线。\n * 特征：采用分而治之的手段将整个网站业务分成不同的产品线。系统上按照业务进行拆分改造，应用服务器按照业务区分进行分别部署。\n * 描述：应用之间可以通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。\n   * 纵向拆分：将一个大应用拆分为多个小应用，如果新业务较为独立，那么就直接将其设计部署为一个独立的 Web 应用系统。纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。\n   * 横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。\n\n\n# 1.8. 分库分表\n\n * 问题：随着大型网站业务持续增长，数据库经过读写分离，从一台服务器拆分为两台服务器，依然不能满足需求。\n * 特征：数据库采用分布式数据库。\n * 描述：分布式数据库是数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用。不到不得已时，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。\n\n\n# 1.9. 分布式组件\n\n * 问题：随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂。\n * 特征：系统引入 NoSQL 数据库及搜索引擎。\n * 描述：NoSQL 数据库及搜索引擎对可伸缩的分布式特性具有更好的支持。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。\n\n\n# 1.10. 微服务\n\n * 问题：随着业务越拆越小，存储系统越来越庞大，应用系统整体复杂程度呈指数级上升，部署维护越来越困难。由于所有应用要和所有数据库系统连接，最终导致数据库连接资源不足，拒绝服务。\n * 特征：公共业务提取出来，独立部署。由这些可复用的业务连接数据库，通过分布式服务提供共用业务服务。\n * 描述：大型网站的架构演化到这里，基本上大多数的技术问题都得以解决，诸如跨数据中心的实时数据同步和具体网站业务相关的问题也都可以组合改进现有技术架构来解决。\n\n\n# 2. 架构设计的考量\n\n> 每一个模式描述了一个不但重复发生的问题及该问题解决方案的核心。这样，就可以不断复用该方案而减少重复工作。\n\n\n# 2.1. 什么是架构\n\n架构是一个非常抽象的概念，每个人由于技术的深度、思维的视角等差异，对于架构的理解，各不相同。\n\n这里摘抄网上某段比较精髓的定义：\n\n * 架构是软件系统的顶层设计。\n * 框架是面向编程或配置的半成品。\n * 组件是从技术维度上的复用。\n * 模块是从业务维度上职责的划分。\n * 系统是相互协同可运行的实体。\n\n\n# 2.2. 架构设计的目标\n\n架构设计的主要目的是为了解决软件系统复杂度带来的问题。\n\n架构设计应该按需设计。任何网站都是随着业务逐步发展，不断演化而成，不要指望一劳永逸。\n\n关于架构设计的目的，常见的误区有：\n\n * 因为架构很重要，所以要做架构设计\n * 为了高性能、高可用、可扩展，所以要做架构设计\n * 大厂都是这么做的，所以我们也这么做\n * 这种新技术很牛逼，我们也一定要引入\n\n架构的原则：\n\n * 架构设计应该按需设计。任何网站都是随着业务逐步发展，不断演化而成，不要指望一劳永逸。\n * 驱动技术发展的主要力量是业务发展。\n * 不要盲目跟风大公司的解决方案。\n * 不要盲目追求流行技术，而脱离了业务发展的实际情况。\n * 不要把所有问题都丢给技术。现实中，有很多案例告诉我们，很多问题不一定需要通过技术来解决。归根结底，技术始终都是业务的辅助，业务问题究竟是通过技术来解决还是直接通过业务来解决，需要根据实际情况去分析判断。这就需要对业务领域有比较深入的理解和思考。\n\n\n# 2.3. 架构设计的原则\n\n> 合适优于先进>演化优于一步到位>简单优于复杂\n\n# 2.3.1. 合适原则\n\n没那么多人，却想干那么多活，是失败的第一个主要原因。\n\n没有那么多积累，却想一步登天，是失败的第二个主要原因。\n\n没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因。\n\n# 2.3.2. 简单原则\n\n再高大上的解决方案如果不能落地，也是白扯。\n\n所以，应对需求\n\n# 2.3.3. 演化原则\n\n演化优于一步到位。\n\n不要妄图设计一个一步到位，永久不变的架构。\n\n# 2.3.4. 墨菲定律\n\n * 任何事都没有表面看起来那么简单；\n * 所有的事都会比你预计的时间长；\n * 会出错的事总会出错；\n * 如果你担心某种情况发生，那么它就更有可能发生。\n\n# 2.3.5. 康威定律\n\n系统设计(产品结构)等同组织形式，每个设计系统的组织，其产生的设计等同于组织之间的沟通结构（简单点说就是，系统的设计受限于设计系统的组织的人员架构形式。\n\n# 2.3.6. 二八定律\n\n\n# 2.4. 高性能\n\n> 性能是软件系统的重要衡量标准。很多扩展性、伸缩性、可用性的问题，是为了解决性能问题而引入的。\n\n# 2.4.1. 性能指标\n\n响应延时、并发处理能力、内存、CPU、IO 开销等都可以视为系统的性能指标。\n\n分析用户体量、日访问量的峰值，估算出为了平稳应对峰值访问流量所需的并发量、吞吐量。如果是应用型系统，性能够用就好，没必要一味追求高性能。比如：用户体量可能还不过万，一天总访问量可能也就一两千 PV，峰值也就几百 QPS，这样的系统如果要考虑每秒几万的 QPS，显然有些多虑了。\n\n# 2.4.2. 性能提升手段\n\n常见的性能提升手段有：\n\n * 前端\n   * 浏览器缓存\n   * 静态资源压缩\n   * 合理布局页面\n   * 减少 cookie 传输\n   * CDN\n * 应用服务\n   * 负载均衡和反向代理\n   * 本地缓存\n   * 分布式缓存\n   * 异步消息队列\n   * 集群\n   * 代码层面：使用多线程、改善内存管理\n * 数据库\n   * 索引\n   * 数据库缓存\n   * SQL 优化\n\n> 注意：缓存是改善软件性能的第一手段。缓存除了可以加快数据访问速度以外，还可以减轻后端应用和数据存储的负载压力。所以，如果要提升系统性能，应该第一时间想到缓存。\n> \n> 使用缓存有两个前提：\n> \n>  * 数据访问热点不均匀，频繁访问的数据应该放在缓存中。\n>  * 数据在某个时间段有效，不过很快过期，否则缓存数据会因已经失效而产生脏读。\n\n\n# 2.5. 高可用\n\n> 系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。\n\n高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。\n\n单点系统，是无法保证高可用的。系统自身故障、断电、硬件故障、网络等等，都可能导致服务不可用。高可用方案五花八门，本质上都是通过“冗余”来实现高可用。\n\n# 2.5.1. 无状态应用的高可用\n\n无状态应用一般具有幂等性，即**无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的。**所以，计算在任意节点服务器上执行，结果都一样。\n\n无状态应用的高可用：\n\n * 需要增加一个任务分配器，选择合适的任务分配器也是一件复杂的事情，需要综合考虑性能、成本、可维护性、可用性等各方面因素。\n * 任务分配器和真正的业务服务器之间有连接和交互，需要选择合适的连接方式，并且对连接进行管理。例如，连接建立、连接检测、连接中断后如何处理等。\n * 任务分配器需要增加分配算法。例如，常见的双机算法有主备、主主，主备方案又可以细分为冷备、温备、热备。\n\n# 2.5.2. 有状态应用的高可用\n\n有状态应用，是指需要存储数据的系统，比如各种分布式存储。和无状态应用相比，有一个本质上的区别：各节点需要通过同步保持数据一致。分布式领域里面有一个著名的 CAP 定理，从理论上论证了存储高可用的复杂度。也就是说，存储高可用不可能同时满足“一致性、可用性、分区容错性”，最多满足其中两个，这就要求我们在做架构设计时结合业务进行取舍。\n\n# 2.5.3. 高可用手段\n\n高可用的常用手段：\n\n * 负载均衡 - 通过负载均衡设备建立集群共同对外提供服务。\n * 备份 - 数据存储在多台服务器，互相备份。即使访问和负载很小的服务也必须部署至少两台服务器，构成一个集群，目的就是通过冗余实现服务的高可用。\n   * 冷备份 - 数据应该定期备份；\n   * 热备份 - 为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步 。\n   * 灾备 - 为了抵御地震、海啸等不可抗因素导致的网站完全瘫痪，某些大型网站会对整个数据中心进行备份，全球范围内部署 灾备数据中心。网站程序和数据实时同步到多个灾备数据中心。\n * 自动化 - 自动化是指，大型系统有必要通过预发布验证、自动化测试、自动化发布、灰度发布等手段，减少将故障引入线上环境的可能。常见自动化手段有：\n   * 发布过程自动化\n     * 自动化代码管理\n     * 自动化测试\n     * 自动化安全监测\n     * 自动化部署\n   * 运维自动化\n     * 自动化监控\n     * 自动化报警\n     * 自动化失效转移\n     * 自动化失效恢复\n     * 自动化降级\n     * 自动化分配资源\n\n\n# 2.6. 扩展性\n\n> 可扩展性指系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。\n> \n> 衡量扩展性的标准就是增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或很少改动，既有功能就可以上线新产品。\n> \n> 软件发展的一个重要目标和驱动力是降低软件耦合性。事物之间直接关系越少，彼此影响就越小，也就更容易独立发展，即扩展性好。\n\n主要手段有：\n\n * 分层 - 分层是扩展性设计的最基本手段。通过分层，可以将一个的软件系统切分为不同的部分，便于分工合作开发和维护；各层间具有一定的独立性。\n   \n   * 分层架构的约束：禁止跨层次的调用及逆向调用。\n   * 即使系统规模很小，也应该考虑采用分层的架构，这样便于以后扩展。\n\n * 分割 - 将不同的功能和服务分割开来，包装成高内聚、低耦合的模块单元。这有助于软件的开发和维护，便于不同模块的分布式部署，提高系统的并发处理能力和功能扩展能力。\n\n * 异步 - 业务间的消息传递不是同步调用，而是将一个业务操作拆分成多阶段，每个阶段间通过共享数据的方式异步执行进行协作。\n   \n   * 在单一服务器内部可通过多线程共享内存队列的方式实现异步，处在业务操作前面的线程将操作输出到队列，后面的线程从队列中读取数据进行处理；\n   * 在分布式系统中，多个服务器集群通过分布式消息队列实现异步。\n\n * 分布式 - 将业务和可复用服务分离，通过分布式服务框架调用。分布式是指多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。着意味着服务可以用更多的机器工作，即扩展 CPU、内存、IO 等资源，从而提高系统整体的吞吐量和并发处理能力。\n   \n   * 常用的分布式方案：\n     * 分布式应用和服务\n     * 分布式静态资源\n     * 分布式数据和存储\n     * 分布式计算\n   * 分布式也引入了一些问题：\n     * 服务调用必须通过网络，网络延迟会影响性能。\n     * 服务器越多，宕机概率也越大，导致可用性降低。\n     * 数据一致性非常困难，分布式事务也难以保证。\n     * 网站依赖错综复杂，开发管理维护困难。\n\n\n# 2.7. 伸缩性\n\n> 衡量伸缩的标准就是是否可以用多台服务器构建集群，是否容易向集群中增删服务器节点。增删服务器节点后是否可以提供和之前无差别的服务。集群中可容纳的总服务器数是否有限制。\n\n伸缩性是指通过增/减服务器节点数，来灵活的提高/降低系统处理能力。\n\n主要手段有:\n\n * 应用服务器集群 - 只要服务器上保存数据，则所有服务器都是对等的，通过负载均衡设备向集群中不断加入服务器即可\n * 缓存服务器集群 - 加入新的服务器可能会导致缓存路由失效，进而导致集群中的大部分缓存数据都无法访问。虽然缓存数据可以通过数据库重新加载，但是如果应用严重依赖缓存，可能会导致网站崩溃。需要改进缓存路由算法保证缓存数据的可访问性。\n * 关系型数据库集群 - 关系型数据库虽然支持数据复制，主从热备等机制，但是很难做到大规模集群的可伸缩性，因此关系型数据库的集群伸缩性方案必须在数据库之外实现，通过路由分区等手段将部署有多个数据库的服务器组成一个集群。\n * Nosql 数据库集群 - 由于先天就是为了应对海量数据而产生，因此对伸缩性的支持通常都非常好。\n\n\n# 2.8. 安全性\n\n安全是指系统应该对恶意攻击有一定的抵抗能力，保护重要数据不被窃取。\n\n * 密码 和 手机校验码 进行身份认证\n * 登录、交易等重要操作需要对网络通信进行 加密，存储的敏感数据如用户信息等也进行加密处理\n * 防止机器人程序攻击网站，使用 验证码 进行识别\n * 对常见用于 攻击 网站的 XSS 攻击、SQL 注入、进行编码转换等相应处理\n * 对垃圾信息、敏感信息进行 过滤\n * 对交易转账等重要操作根据交易模式和交易信息进行 风险控制\n\n\n# 3. 常见架构模型\n\n\n# 3.1. 分层架构\n\n分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。\n\n这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。\n\n四层的结构最常见。\n\n\n * 表现层（presentation）：用户界面，负责视觉和用户互动\n * 业务层（business）：实现业务逻辑\n * 持久层（persistence）：提供数据，SQL 语句就放在这一层\n * 数据库（database） ：保存数据\n\n优点\n\n * 结构简单，容易理解和开发\n * 不同技能的程序员可以分工，负责不同的层，天然适合大多数软件公司的组织架构\n * 每一层都可以独立测试，其他层的接口通过模拟解决\n\n缺点\n\n * 一旦环境变化，需要代码调整或增加功能时，通常比较麻烦和费时\n * 部署比较麻烦，即使只修改一个小地方，往往需要整个软件重新部署，不容易做持续发布\n * 软件升级时，可能需要整个服务暂停\n * 扩展性差。用户请求大量增加时，必须依次扩展每一层，由于每一层内部是耦合的，扩展会很困难\n\n\n# 3.2. 事件驱动架构\n\n事件（event）是状态发生变化时，软件发出的通知。\n\n事件驱动架构（event-driven architecture）就是通过事件进行通信的软件架构。它分成四个部分。\n\n\n * 事件队列（event queue）：接收事件的入口\n * 分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元\n * 事件通道（event channel）：分发器与处理器之间的联系渠道\n * 事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作\n\n对于简单的项目，事件队列、分发器和事件通道，可以合为一体，整个软件就分成事件代理和事件处理器两部分。\n\n\n\n优点\n\n * 分布式的异步架构，事件处理器之间高度解耦，软件的扩展性好\n * 适用性广，各种类型的项目都可以用\n * 性能较好，因为事件的异步本质，软件不易产生堵塞\n * 事件处理器可以独立地加载和卸载，容易部署\n\n缺点\n\n * 涉及异步编程（要考虑远程通信、失去响应等情况），开发相对复杂\n * 难以支持原子性操作，因为事件通过会涉及多个处理器，很难回滚\n * 分布式和异步特性导致这个架构较难测试\n\n\n# 3.3. 微核架构\n\n微核架构（microkernel architecture）又称为"插件架构"（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。\n\n内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。\n\n\n\n优点\n\n * 良好的功能延伸性（extensibility），需要什么功能，开发一个插件即可\n * 功能之间是隔离的，插件可以独立的加载和卸载，使得它比较容易部署，\n * 可定制性高，适应不同的开发需要\n * 可以渐进式地开发，逐步增加功能\n\n缺点\n\n * 扩展性（scalability）差，内核通常是一个独立单元，不容易做成分布式\n * 开发难度相对较高，因为涉及到插件与内核的通信，以及内部的插件登记机制\n\n\n# 3.4. 微服务架构\n\n微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。\n\n每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如 REST、SOAP）联系。\n\n\n\n微服务架构分成三种实现模式。\n\n * RESTful API 模式：服务通过 API 提供，云服务就属于这一类\n * RESTful 应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部\n * 集中消息模式：采用消息代理（message broker），可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群\n\n优点\n\n * 扩展性好，各个服务之间低耦合\n * 容易部署，软件从单一可部署单元，被拆成了多个服务，每个服务都是可部署单元\n * 容易开发，每个组件都可以进行持续集成式的开发，可以做到实时部署，不间断地升级\n * 易于测试，可以单独测试每一个服务\n\n缺点\n\n * 由于强调互相独立和低耦合，服务可能会拆分得很细。这导致系统依赖大量的微服务，变得很凌乱和笨重，性能也会不佳。\n * 一旦服务之间需要通信（即一个服务要用到另一个服务），整个架构就会变得复杂。典型的例子就是一些通用的 Utility 类，一种解决方案是把它们拷贝到每一个服务中去，用冗余换取架构的简单性。\n * 分布式的本质使得这种架构很难实现原子性操作，交易回滚会比较困难。\n\n\n# 3.5. 云架构\n\n云结构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。\n\n它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。\n\n\n\n这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。\n\n * 处理单元：实现业务逻辑\n * 虚拟中间件：负责通信、保持 sessions、数据复制、分布式处理、处理单元的部署。\n\n虚拟中间件又包含四个组件。\n\n>  * 消息中间件（Messaging Grid）：管理用户请求和 session，当一个请求进来以后，决定分配给哪一个处理单元。\n>  * 数据中间件（Data Grid）：将数据复制到每一个处理单元，即数据同步。保证某个处理单元都得到同样的数据。\n>  * 处理中间件（Processing Grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元\n>  * 部署中间件（Deployment Manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动处理单元，负载减少，就关闭处理单元。\n\n优点\n\n * 高负载，高扩展性\n * 动态部署\n\n缺点\n\n * 实现复杂，成本较高\n * 主要适合网站类应用，不合适大量数据吞吐的大型数据库应用\n * 较难测试\n\n\n# 4. 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * 《从 0 开始学架构》\n * 软件架构入门- 阮一峰的网络日志',normalizedContent:'# 系统架构概述\n\n\n# 1. 大型系统架构演化\n\n一个大型系统的架构是一个渐进的演化过程。罗马不是一天建成的，同理，微信、淘宝等大型系统绝不是一蹴而就的。随着业务的不断发展，用户体量的增加，系统的复杂度势必不断攀升，最终迫使系统架构进化，以应对挑战。\n\n了解大型系统架构的演化过程，有利于我们了解架构进化的发展规律和业界一些成熟的应对方案。帮助我们在实际工作中，如何去思考架构，如何去凝练解决方案。\n\n大型系统架构演化比较具有代表性的就是大型网站的演化过程。这里介绍一下大型网站演化的一般规律。\n\n\n# 1.1. 单机架构\n\n * 问题：网站运营初期，访问用户少，一台服务器绰绰有余。\n * 特征：应用程序、数据库、文件等所有的资源都在一台服务器上。\n * 描述：通常服务器操作系统使用 linux，应用程序使用 php 开发，然后部署在 apache 上，数据库使用 mysql，通俗称为 lamp。汇集各种免费开源软件以及一台廉价服务器就可以开始系统的发展之路了。\n\n\n# 1.2. 应用服务和数据服务分离\n\n * 问题：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足，一台服务器已不足以支撑。\n * 特征：应用服务器、数据库服务器、文件服务器分别独立部署。\n * 描述：三台服务器对性能要求各不相同：\n   * 应用服务器要处理大量业务逻辑，因此需要更快更强大的 cpu；\n   * 数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的硬盘和更大的内存；\n   * 文件服务器需要存储大量文件，因此需要更大容量的硬盘。\n\n\n# 1.3. 使用缓存改善性能\n\n * 问题：随着用户逐渐增多，数据库压力太大导致访问延迟。\n * 特征：由于网站访问和财富分配一样遵循二八定律：80% 的业务访问集中在 20% 的数据上。将数据库中访问较集中的少部分数据缓存在内存中，可以减少数据库的访问次数，降低数据库的访问压力。\n * 描述：缓存分为两种：应用服务器上的本地缓存和分布式缓存服务器上的远程缓存。\n   * 本地缓存访问速度更快，但缓存数据量有限，同时存在与应用程序争用内存的情况。\n   * 分布式缓存可以采用集群方式，理论上可以做到不受内存容量限制的缓存服务。\n\n\n# 1.4. 负载均衡\n\n * 问题：使用缓存后，数据库访问压力得到有效缓解。但是单一应用服务器能够处理的请求连接有限，在访问高峰期，成为瓶颈。\n * 特征：多台服务器通过负载均衡同时向外部提供服务，解决单一服务器处理能力和存储空间不足的问题。\n * 描述：使用集群是系统解决高并发、海量数据问题的常用手段。通过向集群中追加资源，提升系统的并发处理能力，使得服务器的负载压力不再成为整个系统的瓶颈。\n\n\n# 1.5. 数据库读写分离\n\n * 问题：网站使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但是仍有一部分读操作和全部的写操作需要访问数据库，在网站的用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。\n * 特征：目前大部分的主流数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库服务器的数据更新同步到一台服务器上。网站利用数据库的主从热备功能，实现数据库读写分离，从而改善数据库负载压力。\n * 描述：应用服务器在写操作的时候，访问主数据库，主数据库通过主从复制机制将数据更新同步到从数据库。这样当应用服务器在读操作的时候，访问从数据库获得数据。为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离的对应用透明。\n\n\n# 1.6. 多级缓存\n\n * 问题：中国网络环境复杂，不同地区的用户访问网站时，速度差别也极大。\n * 特征：采用 cdn 和反向代理加快系统的静态资源访问速度。\n * 描述：cdn 和反向代理的基本原理都是缓存，区别在于：\n   * cdn 部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据；\n   * 而反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器时反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。\n\n\n# 1.7. 业务拆分\n\n * 问题：大型网站的业务场景日益复杂，分为多个产品线。\n * 特征：采用分而治之的手段将整个网站业务分成不同的产品线。系统上按照业务进行拆分改造，应用服务器按照业务区分进行分别部署。\n * 描述：应用之间可以通过超链接建立关系，也可以通过消息队列进行数据分发，当然更多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。\n   * 纵向拆分：将一个大应用拆分为多个小应用，如果新业务较为独立，那么就直接将其设计部署为一个独立的 web 应用系统。纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离即可。\n   * 横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务横向拆分需要识别可复用的业务，设计服务接口，规范服务依赖关系。\n\n\n# 1.8. 分库分表\n\n * 问题：随着大型网站业务持续增长，数据库经过读写分离，从一台服务器拆分为两台服务器，依然不能满足需求。\n * 特征：数据库采用分布式数据库。\n * 描述：分布式数据库是数据库拆分的最后方法，只有在单表数据规模非常庞大的时候才使用。不到不得已时，更常用的数据库拆分手段是业务分库，将不同的业务数据库部署在不同的物理服务器上。\n\n\n# 1.9. 分布式组件\n\n * 问题：随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂。\n * 特征：系统引入 nosql 数据库及搜索引擎。\n * 描述：nosql 数据库及搜索引擎对可伸缩的分布式特性具有更好的支持。应用服务器通过统一数据访问模块访问各种数据，减轻应用程序管理诸多数据源的麻烦。\n\n\n# 1.10. 微服务\n\n * 问题：随着业务越拆越小，存储系统越来越庞大，应用系统整体复杂程度呈指数级上升，部署维护越来越困难。由于所有应用要和所有数据库系统连接，最终导致数据库连接资源不足，拒绝服务。\n * 特征：公共业务提取出来，独立部署。由这些可复用的业务连接数据库，通过分布式服务提供共用业务服务。\n * 描述：大型网站的架构演化到这里，基本上大多数的技术问题都得以解决，诸如跨数据中心的实时数据同步和具体网站业务相关的问题也都可以组合改进现有技术架构来解决。\n\n\n# 2. 架构设计的考量\n\n> 每一个模式描述了一个不但重复发生的问题及该问题解决方案的核心。这样，就可以不断复用该方案而减少重复工作。\n\n\n# 2.1. 什么是架构\n\n架构是一个非常抽象的概念，每个人由于技术的深度、思维的视角等差异，对于架构的理解，各不相同。\n\n这里摘抄网上某段比较精髓的定义：\n\n * 架构是软件系统的顶层设计。\n * 框架是面向编程或配置的半成品。\n * 组件是从技术维度上的复用。\n * 模块是从业务维度上职责的划分。\n * 系统是相互协同可运行的实体。\n\n\n# 2.2. 架构设计的目标\n\n架构设计的主要目的是为了解决软件系统复杂度带来的问题。\n\n架构设计应该按需设计。任何网站都是随着业务逐步发展，不断演化而成，不要指望一劳永逸。\n\n关于架构设计的目的，常见的误区有：\n\n * 因为架构很重要，所以要做架构设计\n * 为了高性能、高可用、可扩展，所以要做架构设计\n * 大厂都是这么做的，所以我们也这么做\n * 这种新技术很牛逼，我们也一定要引入\n\n架构的原则：\n\n * 架构设计应该按需设计。任何网站都是随着业务逐步发展，不断演化而成，不要指望一劳永逸。\n * 驱动技术发展的主要力量是业务发展。\n * 不要盲目跟风大公司的解决方案。\n * 不要盲目追求流行技术，而脱离了业务发展的实际情况。\n * 不要把所有问题都丢给技术。现实中，有很多案例告诉我们，很多问题不一定需要通过技术来解决。归根结底，技术始终都是业务的辅助，业务问题究竟是通过技术来解决还是直接通过业务来解决，需要根据实际情况去分析判断。这就需要对业务领域有比较深入的理解和思考。\n\n\n# 2.3. 架构设计的原则\n\n> 合适优于先进>演化优于一步到位>简单优于复杂\n\n# 2.3.1. 合适原则\n\n没那么多人，却想干那么多活，是失败的第一个主要原因。\n\n没有那么多积累，却想一步登天，是失败的第二个主要原因。\n\n没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因。\n\n# 2.3.2. 简单原则\n\n再高大上的解决方案如果不能落地，也是白扯。\n\n所以，应对需求\n\n# 2.3.3. 演化原则\n\n演化优于一步到位。\n\n不要妄图设计一个一步到位，永久不变的架构。\n\n# 2.3.4. 墨菲定律\n\n * 任何事都没有表面看起来那么简单；\n * 所有的事都会比你预计的时间长；\n * 会出错的事总会出错；\n * 如果你担心某种情况发生，那么它就更有可能发生。\n\n# 2.3.5. 康威定律\n\n系统设计(产品结构)等同组织形式，每个设计系统的组织，其产生的设计等同于组织之间的沟通结构（简单点说就是，系统的设计受限于设计系统的组织的人员架构形式。\n\n# 2.3.6. 二八定律\n\n\n# 2.4. 高性能\n\n> 性能是软件系统的重要衡量标准。很多扩展性、伸缩性、可用性的问题，是为了解决性能问题而引入的。\n\n# 2.4.1. 性能指标\n\n响应延时、并发处理能力、内存、cpu、io 开销等都可以视为系统的性能指标。\n\n分析用户体量、日访问量的峰值，估算出为了平稳应对峰值访问流量所需的并发量、吞吐量。如果是应用型系统，性能够用就好，没必要一味追求高性能。比如：用户体量可能还不过万，一天总访问量可能也就一两千 pv，峰值也就几百 qps，这样的系统如果要考虑每秒几万的 qps，显然有些多虑了。\n\n# 2.4.2. 性能提升手段\n\n常见的性能提升手段有：\n\n * 前端\n   * 浏览器缓存\n   * 静态资源压缩\n   * 合理布局页面\n   * 减少 cookie 传输\n   * cdn\n * 应用服务\n   * 负载均衡和反向代理\n   * 本地缓存\n   * 分布式缓存\n   * 异步消息队列\n   * 集群\n   * 代码层面：使用多线程、改善内存管理\n * 数据库\n   * 索引\n   * 数据库缓存\n   * sql 优化\n\n> 注意：缓存是改善软件性能的第一手段。缓存除了可以加快数据访问速度以外，还可以减轻后端应用和数据存储的负载压力。所以，如果要提升系统性能，应该第一时间想到缓存。\n> \n> 使用缓存有两个前提：\n> \n>  * 数据访问热点不均匀，频繁访问的数据应该放在缓存中。\n>  * 数据在某个时间段有效，不过很快过期，否则缓存数据会因已经失效而产生脏读。\n\n\n# 2.5. 高可用\n\n> 系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。\n\n高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。\n\n单点系统，是无法保证高可用的。系统自身故障、断电、硬件故障、网络等等，都可能导致服务不可用。高可用方案五花八门，本质上都是通过“冗余”来实现高可用。\n\n# 2.5.1. 无状态应用的高可用\n\n无状态应用一般具有幂等性，即**无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的。**所以，计算在任意节点服务器上执行，结果都一样。\n\n无状态应用的高可用：\n\n * 需要增加一个任务分配器，选择合适的任务分配器也是一件复杂的事情，需要综合考虑性能、成本、可维护性、可用性等各方面因素。\n * 任务分配器和真正的业务服务器之间有连接和交互，需要选择合适的连接方式，并且对连接进行管理。例如，连接建立、连接检测、连接中断后如何处理等。\n * 任务分配器需要增加分配算法。例如，常见的双机算法有主备、主主，主备方案又可以细分为冷备、温备、热备。\n\n# 2.5.2. 有状态应用的高可用\n\n有状态应用，是指需要存储数据的系统，比如各种分布式存储。和无状态应用相比，有一个本质上的区别：各节点需要通过同步保持数据一致。分布式领域里面有一个著名的 cap 定理，从理论上论证了存储高可用的复杂度。也就是说，存储高可用不可能同时满足“一致性、可用性、分区容错性”，最多满足其中两个，这就要求我们在做架构设计时结合业务进行取舍。\n\n# 2.5.3. 高可用手段\n\n高可用的常用手段：\n\n * 负载均衡 - 通过负载均衡设备建立集群共同对外提供服务。\n * 备份 - 数据存储在多台服务器，互相备份。即使访问和负载很小的服务也必须部署至少两台服务器，构成一个集群，目的就是通过冗余实现服务的高可用。\n   * 冷备份 - 数据应该定期备份；\n   * 热备份 - 为了保证在线业务高可用，还需要对数据库进行主从分离，实时同步 。\n   * 灾备 - 为了抵御地震、海啸等不可抗因素导致的网站完全瘫痪，某些大型网站会对整个数据中心进行备份，全球范围内部署 灾备数据中心。网站程序和数据实时同步到多个灾备数据中心。\n * 自动化 - 自动化是指，大型系统有必要通过预发布验证、自动化测试、自动化发布、灰度发布等手段，减少将故障引入线上环境的可能。常见自动化手段有：\n   * 发布过程自动化\n     * 自动化代码管理\n     * 自动化测试\n     * 自动化安全监测\n     * 自动化部署\n   * 运维自动化\n     * 自动化监控\n     * 自动化报警\n     * 自动化失效转移\n     * 自动化失效恢复\n     * 自动化降级\n     * 自动化分配资源\n\n\n# 2.6. 扩展性\n\n> 可扩展性指系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。\n> \n> 衡量扩展性的标准就是增加新的业务产品时，是否可以实现对现有产品透明无影响，不需要任何改动或很少改动，既有功能就可以上线新产品。\n> \n> 软件发展的一个重要目标和驱动力是降低软件耦合性。事物之间直接关系越少，彼此影响就越小，也就更容易独立发展，即扩展性好。\n\n主要手段有：\n\n * 分层 - 分层是扩展性设计的最基本手段。通过分层，可以将一个的软件系统切分为不同的部分，便于分工合作开发和维护；各层间具有一定的独立性。\n   \n   * 分层架构的约束：禁止跨层次的调用及逆向调用。\n   * 即使系统规模很小，也应该考虑采用分层的架构，这样便于以后扩展。\n\n * 分割 - 将不同的功能和服务分割开来，包装成高内聚、低耦合的模块单元。这有助于软件的开发和维护，便于不同模块的分布式部署，提高系统的并发处理能力和功能扩展能力。\n\n * 异步 - 业务间的消息传递不是同步调用，而是将一个业务操作拆分成多阶段，每个阶段间通过共享数据的方式异步执行进行协作。\n   \n   * 在单一服务器内部可通过多线程共享内存队列的方式实现异步，处在业务操作前面的线程将操作输出到队列，后面的线程从队列中读取数据进行处理；\n   * 在分布式系统中，多个服务器集群通过分布式消息队列实现异步。\n\n * 分布式 - 将业务和可复用服务分离，通过分布式服务框架调用。分布式是指多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。着意味着服务可以用更多的机器工作，即扩展 cpu、内存、io 等资源，从而提高系统整体的吞吐量和并发处理能力。\n   \n   * 常用的分布式方案：\n     * 分布式应用和服务\n     * 分布式静态资源\n     * 分布式数据和存储\n     * 分布式计算\n   * 分布式也引入了一些问题：\n     * 服务调用必须通过网络，网络延迟会影响性能。\n     * 服务器越多，宕机概率也越大，导致可用性降低。\n     * 数据一致性非常困难，分布式事务也难以保证。\n     * 网站依赖错综复杂，开发管理维护困难。\n\n\n# 2.7. 伸缩性\n\n> 衡量伸缩的标准就是是否可以用多台服务器构建集群，是否容易向集群中增删服务器节点。增删服务器节点后是否可以提供和之前无差别的服务。集群中可容纳的总服务器数是否有限制。\n\n伸缩性是指通过增/减服务器节点数，来灵活的提高/降低系统处理能力。\n\n主要手段有:\n\n * 应用服务器集群 - 只要服务器上保存数据，则所有服务器都是对等的，通过负载均衡设备向集群中不断加入服务器即可\n * 缓存服务器集群 - 加入新的服务器可能会导致缓存路由失效，进而导致集群中的大部分缓存数据都无法访问。虽然缓存数据可以通过数据库重新加载，但是如果应用严重依赖缓存，可能会导致网站崩溃。需要改进缓存路由算法保证缓存数据的可访问性。\n * 关系型数据库集群 - 关系型数据库虽然支持数据复制，主从热备等机制，但是很难做到大规模集群的可伸缩性，因此关系型数据库的集群伸缩性方案必须在数据库之外实现，通过路由分区等手段将部署有多个数据库的服务器组成一个集群。\n * nosql 数据库集群 - 由于先天就是为了应对海量数据而产生，因此对伸缩性的支持通常都非常好。\n\n\n# 2.8. 安全性\n\n安全是指系统应该对恶意攻击有一定的抵抗能力，保护重要数据不被窃取。\n\n * 密码 和 手机校验码 进行身份认证\n * 登录、交易等重要操作需要对网络通信进行 加密，存储的敏感数据如用户信息等也进行加密处理\n * 防止机器人程序攻击网站，使用 验证码 进行识别\n * 对常见用于 攻击 网站的 xss 攻击、sql 注入、进行编码转换等相应处理\n * 对垃圾信息、敏感信息进行 过滤\n * 对交易转账等重要操作根据交易模式和交易信息进行 风险控制\n\n\n# 3. 常见架构模型\n\n\n# 3.1. 分层架构\n\n分层架构（layered architecture）是最常见的软件架构，也是事实上的标准架构。\n\n这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。\n\n四层的结构最常见。\n\n\n * 表现层（presentation）：用户界面，负责视觉和用户互动\n * 业务层（business）：实现业务逻辑\n * 持久层（persistence）：提供数据，sql 语句就放在这一层\n * 数据库（database） ：保存数据\n\n优点\n\n * 结构简单，容易理解和开发\n * 不同技能的程序员可以分工，负责不同的层，天然适合大多数软件公司的组织架构\n * 每一层都可以独立测试，其他层的接口通过模拟解决\n\n缺点\n\n * 一旦环境变化，需要代码调整或增加功能时，通常比较麻烦和费时\n * 部署比较麻烦，即使只修改一个小地方，往往需要整个软件重新部署，不容易做持续发布\n * 软件升级时，可能需要整个服务暂停\n * 扩展性差。用户请求大量增加时，必须依次扩展每一层，由于每一层内部是耦合的，扩展会很困难\n\n\n# 3.2. 事件驱动架构\n\n事件（event）是状态发生变化时，软件发出的通知。\n\n事件驱动架构（event-driven architecture）就是通过事件进行通信的软件架构。它分成四个部分。\n\n\n * 事件队列（event queue）：接收事件的入口\n * 分发器（event mediator）：将不同的事件分发到不同的业务逻辑单元\n * 事件通道（event channel）：分发器与处理器之间的联系渠道\n * 事件处理器（event processor）：实现业务逻辑，处理完成后会发出事件，触发下一步操作\n\n对于简单的项目，事件队列、分发器和事件通道，可以合为一体，整个软件就分成事件代理和事件处理器两部分。\n\n\n\n优点\n\n * 分布式的异步架构，事件处理器之间高度解耦，软件的扩展性好\n * 适用性广，各种类型的项目都可以用\n * 性能较好，因为事件的异步本质，软件不易产生堵塞\n * 事件处理器可以独立地加载和卸载，容易部署\n\n缺点\n\n * 涉及异步编程（要考虑远程通信、失去响应等情况），开发相对复杂\n * 难以支持原子性操作，因为事件通过会涉及多个处理器，很难回滚\n * 分布式和异步特性导致这个架构较难测试\n\n\n# 3.3. 微核架构\n\n微核架构（microkernel architecture）又称为"插件架构"（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。\n\n内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。\n\n\n\n优点\n\n * 良好的功能延伸性（extensibility），需要什么功能，开发一个插件即可\n * 功能之间是隔离的，插件可以独立的加载和卸载，使得它比较容易部署，\n * 可定制性高，适应不同的开发需要\n * 可以渐进式地开发，逐步增加功能\n\n缺点\n\n * 扩展性（scalability）差，内核通常是一个独立单元，不容易做成分布式\n * 开发难度相对较高，因为涉及到插件与内核的通信，以及内部的插件登记机制\n\n\n# 3.4. 微服务架构\n\n微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 soa）的升级。\n\n每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如 rest、soap）联系。\n\n\n\n微服务架构分成三种实现模式。\n\n * restful api 模式：服务通过 api 提供，云服务就属于这一类\n * restful 应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部\n * 集中消息模式：采用消息代理（message broker），可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群\n\n优点\n\n * 扩展性好，各个服务之间低耦合\n * 容易部署，软件从单一可部署单元，被拆成了多个服务，每个服务都是可部署单元\n * 容易开发，每个组件都可以进行持续集成式的开发，可以做到实时部署，不间断地升级\n * 易于测试，可以单独测试每一个服务\n\n缺点\n\n * 由于强调互相独立和低耦合，服务可能会拆分得很细。这导致系统依赖大量的微服务，变得很凌乱和笨重，性能也会不佳。\n * 一旦服务之间需要通信（即一个服务要用到另一个服务），整个架构就会变得复杂。典型的例子就是一些通用的 utility 类，一种解决方案是把它们拷贝到每一个服务中去，用冗余换取架构的简单性。\n * 分布式的本质使得这种架构很难实现原子性操作，交易回滚会比较困难。\n\n\n# 3.5. 云架构\n\n云结构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。\n\n它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。\n\n\n\n这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。\n\n * 处理单元：实现业务逻辑\n * 虚拟中间件：负责通信、保持 sessions、数据复制、分布式处理、处理单元的部署。\n\n虚拟中间件又包含四个组件。\n\n>  * 消息中间件（messaging grid）：管理用户请求和 session，当一个请求进来以后，决定分配给哪一个处理单元。\n>  * 数据中间件（data grid）：将数据复制到每一个处理单元，即数据同步。保证某个处理单元都得到同样的数据。\n>  * 处理中间件（processing grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元\n>  * 部署中间件（deployment manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动处理单元，负载减少，就关闭处理单元。\n\n优点\n\n * 高负载，高扩展性\n * 动态部署\n\n缺点\n\n * 实现复杂，成本较高\n * 主要适合网站类应用，不合适大量数据吞吐的大型数据库应用\n * 较难测试\n\n\n# 4. 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * 《从 0 开始学架构》\n * 软件架构入门- 阮一峰的网络日志',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"系统高性能架构",frontmatter:{title:"系统高性能架构",date:"2018-07-05T15:11:00.000Z",categories:["架构"],tags:["架构","性能"],permalink:"/pages/41c2c7/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/03.%E7%B3%BB%E7%BB%9F%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84.html",relativePath:"01.架构/03.系统高性能架构.md",key:"v-4239add5",path:"/pages/41c2c7/",headers:[{level:2,title:"性能简介",slug:"性能简介",normalizedTitle:"性能简介",charIndex:14},{level:3,title:"计算机资源",slug:"计算机资源",normalizedTitle:"计算机资源",charIndex:173},{level:3,title:"性能指标",slug:"性能指标",normalizedTitle:"性能指标",charIndex:92},{level:4,title:"响应时间",slug:"响应时间",normalizedTitle:"响应时间",charIndex:299},{level:4,title:"并发数",slug:"并发数",normalizedTitle:"并发数",charIndex:307},{level:4,title:"吞吐量",slug:"吞吐量",normalizedTitle:"吞吐量",charIndex:314},{level:4,title:"资源分配使用率",slug:"资源分配使用率",normalizedTitle:"资源分配使用率",charIndex:339},{level:3,title:"性能测试",slug:"性能测试",normalizedTitle:"性能测试",charIndex:283},{level:3,title:"性能优化策略",slug:"性能优化策略",normalizedTitle:"性能优化策略",charIndex:1321},{level:2,title:"应用服务性能优化",slug:"应用服务性能优化",normalizedTitle:"应用服务性能优化",charIndex:1487},{level:3,title:"缓存",slug:"缓存",normalizedTitle:"缓存",charIndex:1092},{level:3,title:"并发模型",slug:"并发模型",normalizedTitle:"并发模型",charIndex:1747},{level:4,title:"PPC",slug:"ppc",normalizedTitle:"ppc",charIndex:2013},{level:4,title:"prefork",slug:"prefork",normalizedTitle:"prefork",charIndex:2287},{level:4,title:"TPC",slug:"tpc",normalizedTitle:"tpc",charIndex:2868},{level:4,title:"prethread",slug:"prethread",normalizedTitle:"prethread",charIndex:3579},{level:4,title:"Reactor",slug:"reactor",normalizedTitle:"reactor",charIndex:4164},{level:3,title:"异步操作",slug:"异步操作",normalizedTitle:"异步操作",charIndex:4692},{level:3,title:"负载均衡",slug:"负载均衡",normalizedTitle:"负载均衡",charIndex:4849},{level:3,title:"代码优化",slug:"代码优化",normalizedTitle:"代码优化",charIndex:5021},{level:4,title:"多线程",slug:"多线程",normalizedTitle:"多线程",charIndex:2005},{level:5,title:"线程安全问题",slug:"线程安全问题",normalizedTitle:"线程安全问题",charIndex:5304},{level:4,title:"资源复用",slug:"资源复用",normalizedTitle:"资源复用",charIndex:5463},{level:4,title:"数据结构",slug:"数据结构",normalizedTitle:"数据结构",charIndex:5547},{level:4,title:"垃圾回收",slug:"垃圾回收",normalizedTitle:"垃圾回收",charIndex:5574},{level:2,title:"存储性能优化",slug:"存储性能优化",normalizedTitle:"存储性能优化",charIndex:5673},{level:3,title:"数据库",slug:"数据库",normalizedTitle:"数据库",charIndex:262},{level:4,title:"数据库读写分离",slug:"数据库读写分离",normalizedTitle:"数据库读写分离",charIndex:5691},{level:4,title:"数据库分库分表",slug:"数据库分库分表",normalizedTitle:"数据库分库分表",charIndex:5749},{level:4,title:"Nosql",slug:"nosql",normalizedTitle:"nosql",charIndex:5836},{level:3,title:"文件存储",slug:"文件存储",normalizedTitle:"文件存储",charIndex:6402},{level:4,title:"机械键盘和固态硬盘",slug:"机械键盘和固态硬盘",normalizedTitle:"机械键盘和固态硬盘",charIndex:6410},{level:4,title:"B+数和 LSM 树",slug:"b-数和-lsm-树",normalizedTitle:"b+数和 lsm 树",charIndex:6451},{level:4,title:"RAID 和 HDFS",slug:"raid-和-hdfs",normalizedTitle:"raid 和 hdfs",charIndex:6733},{level:2,title:"前端性能优化",slug:"前端性能优化",normalizedTitle:"前端性能优化",charIndex:1480},{level:3,title:"浏览器访问优化",slug:"浏览器访问优化",normalizedTitle:"浏览器访问优化",charIndex:7045},{level:3,title:"CDN",slug:"cdn",normalizedTitle:"cdn",charIndex:7606},{level:3,title:"反向代理",slug:"反向代理",normalizedTitle:"反向代理",charIndex:7691},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7924}],headersStr:"性能简介 计算机资源 性能指标 响应时间 并发数 吞吐量 资源分配使用率 性能测试 性能优化策略 应用服务性能优化 缓存 并发模型 PPC prefork TPC prethread Reactor 异步操作 负载均衡 代码优化 多线程 线程安全问题 资源复用 数据结构 垃圾回收 存储性能优化 数据库 数据库读写分离 数据库分库分表 Nosql 文件存储 机械键盘和固态硬盘 B+数和 LSM 树 RAID 和 HDFS 前端性能优化 浏览器访问优化 CDN 反向代理 参考资料",content:"# 系统高性能架构\n\n\n# 性能简介\n\n要设计高性能的系统架构，应该有以下的思维步骤：\n\n首先，要明确影响性能的因素有哪些？性能的指标有哪些？——做到有的放矢。\n\n其次，要了解如何测试性能指标？性能优化，必须要有前后的效果对比，才能证明性能确实有改善。\n\n接下来，学习针对不同场景下，不同性指标的优化策略以及具体实施方案。——见招拆招。\n\n\n# 计算机资源\n\n了解性能指标前，需要先知道哪些计算机资源会影响性能。一般来说，影响性能的计算机资源包括：\n\n * CPU\n * 内存\n * 磁盘 I/O\n * 网络 I/O\n * 数据库\n * 锁竞争\n\n\n# 性能指标\n\n性能测试的主要指标有：\n\n * 响应时间\n * 并发数\n * 吞吐量\n   * QPS\n   * TPS\n * 资源分配使用率\n\n# 响应时间\n\n响应时间(RT)是指从客户端发一个请求开始计时，到客户端接收到从服务器端返回的响应结果结束所经历的时间，响应时间由请求发送时间、网络传输时间和服务器处理时间三部分组成。\n\n响应时间越短，性能越好，一般一个接口的响应时间是在毫秒级。\n\n响应时间可以进一步细分：\n\n * 客户端响应时间\n * 网络响应时间\n * 服务端响应时间\n * 数据库响应时间\n\n# 并发数\n\n并发数是指系统能同时处理的请求、事务数。\n\n系统自身的 CPU 处理能力、内存、以及系统自身的线程复用、锁竞争等都会影响并发数。\n\n# 吞吐量\n\n吞吐量计算公式：\n\n吞吐量 = 并发数 / 平均响应时间\n\n\n吞吐量越大，性能越好。\n\n一般，系统呈现给外部的最常见的吞吐量指标，就是：\n\n * QPS(每秒查询数) - 即系统每秒可以处理的读请求。\n * TPS(每秒事务数) - 即系统每秒可以处理的写请求。\n\n而在系统内部，存在以下吞吐量：\n\n * 磁盘吞吐量 - 体现了磁盘随机读写的性能。\n * 网络吞吐量 - 除了受限于网络带宽，CPU 的处理能力、网卡、防火墙、外部接口以及 I/O、系统 IO 算法都会影响到网络吞吐量。\n\n# 资源分配使用率\n\n通常由 CPU 占用率、内存使用率、磁盘 I/O、网络 I/O 、对象与线程数来表示资源使用率。这些指标也是系统监控的重要参数。\n\n\n# 性能测试\n\n性能测试手段：\n\n * 性能测试\n * 负载测试\n * 压力测试\n * 稳定性测试\n\n对于 Java 应用而言，最简单的，可以使用 Jmeter 进行性能测试。\n\n性能测试报告示例：\n\n\n#### 性能测试的问题\n\n性能测试时，需要注意一些问题：\n\n * 热身问题 - 系统刚开始运行时，自身可能加载缓存，JVM 可能会优化热点代码等，这些行为都可能使得前后有较大的性能差异。所以，性能测试时，应该先跳过一段热身时间，等趋于稳定后，再开始性能测试。\n * 测试结果不稳定 - 性能测试中，有很多不稳定的因素，如环境、网络等，几乎不可能每次都是一样的结果。所以应该多次测试，求平均值。\n * 多 JVM 情况下的影响 - 应尽量避免一台机器部署多个 JVM 的情况。因为任意一个 JVM 都拥有整个系统的资源使用权，所以在性能测试时，可能会彼此干扰。\n\n\n# 性能优化策略\n\n 1. 性能分析 - 如果请求响应慢，存在性能问题。需要对请求经历的各个环节逐一分析，排查可能出现性能瓶颈的地方，定位问题。检查监控数据，分析影响性能的主要因素：内存、磁盘、网络、CPU，可能是代码或架构设计不合理，又或者是系统资源确实不足。\n 2. 性能优化 - 性能优化根据网站分层架构，大致可分为前端性能优化、应用服务性能优化、存储服务性能优化。\n\n\n# 应用服务性能优化\n\n\n# 缓存\n\n网站性能优化第一定律：第一优先考虑使用缓存提升性能。\n\n缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。\n\n * 单点应用可以使用进程内缓存（如：ConcurrentHashMap、Caffeine）；\n * 分布式应用可以使用分布式缓存（如：Redis、Memcached），或进程缓存+分布式缓存的多级缓存方案。\n\n> 缓存解决方案请参考：缓存基本原理\n\n\n# 并发模型\n\n高并发需要根据两个条件划分：连接数量，请求数量。\n\n * 海量连接（成千上万）海量请求：例如抢购，双十一等\n * 常量连接（几十上百）海量请求：例如中间件\n * 海量连接常量请求：例如门户网站\n * 常量连接常量请求：例如内部运营系统，管理系统\n\n单服务器高性能的关键之一就是服务器采取的并发模型\n\n * 服务器如何管理连接。\n * 服务器如何处理请求。\n\n以上两个设计点最终都和操作系统的 I/O 模型及进程模型相关。\n\n * I/O 模型：阻塞、非阻塞、同步、异步。\n * 进程模型：单进程、多进程、多线程。\n\n# PPC\n\nPPC 是 Process Per Connection 的缩写，其含义是指每次有新的连接就新建一个进程去专门处理这个连接的请求，这是传统的 UNIX 网络服务器所采用的模型。基本的流程图是：\n\n\n\n * 父进程接受连接（图中 accept）。\n * 父进程“fork”子进程（图中 fork）。\n * 子进程处理连接的读写请求（图中子进程 read、业务处理、write）。\n * 子进程关闭连接（图中子进程中的 close）。\n\n这种模式的缺点：\n\n * fork 代价高\n * 父子进程通信复杂\n * 支持的并发连接数量有限\n\n# prefork\n\nPPC 模式中，当连接进来时才 fork 新进程来处理连接请求，由于 fork 进程代价高，用户访问时可能感觉比较慢，prefork 模式的出现就是为了解决这个问题。\n\n顾名思义，prefork 就是提前创建进程（pre-fork）。系统在启动的时候就预先创建好进程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去 fork 进程的操作，让用户访问更快、体验更好。prefork 的基本示意图是：\n\n\n\nprefork 的实现关键就是多个子进程都 accept 同一个 socket，当有新的连接进入时，操作系统保证只有一个进程能最后 accept 成功。但这里也存在一个小小的问题：“惊群”现象，就是指虽然只有一个子进程能 accept 成功，但所有阻塞在 accept 上的子进程都会被唤醒，这样就导致了不必要的进程调度和上下文切换了。幸运的是，操作系统可以解决这个问题，例如 Linux 2.6 版本后内核已经解决了 accept 惊群问题。\n\nprefork 模式和 PPC 一样，还是存在父子进程通信复杂、支持的并发连接数量有限的问题，因此目前实际应用也不多。Apache 服务器提供了 MPM prefork 模式，推荐在需要可靠性或者与旧软件兼容的站点时采用这种模式，默认情况下最大支持 256 个并发连接。\n\n# TPC\n\nTPC 是 Thread Per Connection 的缩写，其含义是指每次有新的连接就新建一个线程去专门处理这个连接的请求。与进程相比，线程更轻量级，创建线程的消耗比进程要少得多；同时多线程是共享进程内存空间的，线程通信相比进程通信更简单。因此，TPC 实际上是解决或者弱化了 PPC fork 代价高的问题和父子进程通信复杂的问题。\n\nTPC 的基本流程是：\n\n\n\n * 父进程接受连接（图中 accept）。\n * 父进程创建子线程（图中 pthread）。\n * 子线程处理连接的读写请求（图中子线程 read、业务处理、write）。\n * 子线程关闭连接（图中子线程中的 close）。\n\n注意，和 PPC 相比，主进程不用“close”连接了。原因是在于子线程是共享主进程的进程空间的，连接的文件描述符并没有被复制，因此只需要一次 close 即可。\n\nTPC 虽然解决了 fork 代价高和进程通信复杂的问题，但是也引入了新的问题，具体表现在：\n\n * 创建线程虽然比创建进程代价低，但并不是没有代价，高并发时（例如每秒上万连接）还是有性能问题。\n * 无须进程间通信，但是线程间的互斥和共享又引入了复杂度，可能一不小心就导致了死锁问题。\n * 多线程会出现互相影响的情况，某个线程出现异常时，可能导致整个进程退出（例如内存越界）。\n\n除了引入了新的问题，TPC 还是存在 CPU 线程调度和切换代价的问题。因此，TPC 方案本质上和 PPC 方案基本类似，在并发几百连接的场景下，反而更多地是采用 PPC 的方案，因为 PPC 方案不会有死锁的风险，也不会多进程互相影响，稳定性更高。\n\n# prethread\n\nTPC 模式中，当连接进来时才创建新的线程来处理连接请求，虽然创建线程比创建进程要更加轻量级，但还是有一定的代价，而 prethread 模式就是为了解决这个问题。\n\n和 prefork 类似，prethread 模式会预先创建线程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去创建线程的操作，让用户感觉更快、体验更好。\n\n由于多线程之间数据共享和通信比较方便，因此实际上 prethread 的实现方式相比 prefork 要灵活一些，常见的实现方式有下面几种：\n\n * 主进程 accept，然后将连接交给某个线程处理。\n * 子线程都尝试去 accept，最终只有一个线程 accept 成功，方案的基本示意图如下：\n\n\n\nApache 服务器的 MPM worker 模式本质上就是一种 prethread 方案，但稍微做了改进。Apache 服务器会首先创建多个进程，每个进程里面再创建多个线程，这样做主要是为了考虑稳定性，即：即使某个子进程里面的某个线程异常导致整个子进程退出，还会有其他子进程继续提供服务，不会导致整个服务器全部挂掉。\n\nprethread 理论上可以比 prefork 支持更多的并发连接，Apache 服务器 MPM worker 模式默认支持 16 × 25 = 400 个并发处理线程。\n\n# Reactor\n\nI/O 多路复用技术归纳起来有两个关键实现点：\n\n * 当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须再轮询所有连接，常见的实现方式有 select、epoll、kqueue 等。\n * 当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理。\n\nI/O 多路复用结合线程池，完美地解决了 PPC 和 TPC 的问题\n\nReactor 模式的核心组成部分包括 Reactor 和处理资源池（进程池或线程池），其中 Reactor 负责监听和分配事件，处理资源池负责处理事件。初看 Reactor 的实现是比较简单的，但实际上结合不同的业务场景，Reactor 模式的具体实现方案灵活多变，主要体现在：\n\n * Reactor 的数量可以变化：可以是一个 Reactor，也可以是多个 Reactor。\n * 资源池的数量可以变化：以进程为例，可以是单个进程，也可以是多个进程（线程类似）。\n\n最终 Reactor 模式有这三种典型的实现方案：\n\n * 单 Reactor 单进程 / 线程。\n * 单 Reactor 多线程。\n * 多 Reactor 多进程 / 线程。\n\n\n# 异步操作\n\n异步处理不仅可以减少系统服务间的耦合度，提高扩展性，事实上，它还可以提高系统的性能。异步处理可以有效减少响应等待时间，从而提高响应速度。\n\n异步处理一般是通过分布式消息队列的方式。\n\n异步处理可以解决以下问题：\n\n * 异步响应\n * 应用解耦\n * 流量削锋\n * 日志处理\n * 消息通讯\n\n\n# 负载均衡\n\n在高并发场景下，使用负载均衡技术为一个应用构建一个由多台服务器组成的服务器集群，将并发访问请求分发到多台服务器上处理，避免单一服务器因负载压力过大而响应缓慢，使用户请求具有更好的响应延迟特性。\n\n高性能集群的复杂性主要体现在需要增加一个任务分配器，以及为任务选择一个合适的任务分配算法。\n\n> 缓存解决方案请参考：负载均衡\n\n\n# 代码优化\n\n# 多线程\n\n从资源利用的角度看，使用多线程的原因主要有两个：IO 阻塞和多 CPU。\n\n线程数并非越多越好，那么启动多少线程合适呢？\n\n有个参考公式：\n\n启动线程数 = (任务执行时间 / (任务执行时间 - IO 等待时间)) * CPU 内核数\n\n\n最佳启动线程数和 CPU 内核数成正比，和 IO 阻塞时间成反比。\n\n * 如果任务都是 CPU 计算型任务，那么线程数最多不要超过 CPU 内核数，因为启动再多线程，CPU 也来不及调度；\n * 相反，如果是任务需要等待磁盘操作，网络响应，那么多启动线程有助于任务并罚赌，提高系统吞吐量。\n\n# 线程安全问题\n\n线程安全问题时指多个线程并发访问某个资源，导致数据混乱。\n\n解决手段有：\n\n * 将对象设计为无状态对象 - 典型应用：Servlet 就是无状态对象，可以被服务器多线程并发调用处理用户请求。\n * 使用局部对象\n * 并发访问资源时使用锁 - 但是引入锁会产生性能开销，应尽量使用轻量级的锁。\n\n# 资源复用\n\n应该尽量减少那些开销很大的系统资源的创建和销毁，如数据库连接、网络通信连接、线程、复杂对象等。从编程角度，资源复用主要有两种模式：单例模式和对象池。\n\n# 数据结构\n\n根据具体场景，选择合适的数据结构。\n\n# 垃圾回收\n\n如果 Web 应用运行在 JVM 等具有垃圾回收功能的环境中，那么垃圾回收可能会对系统的性能特性产生巨大影响。立即垃圾回收机制有助于程序优化和参数调优，以及编写内存安全的代码。\n\n\n# 存储性能优化\n\n\n# 数据库\n\n# 数据库读写分离\n\n读写分离的基本原理是将数据库读写操作分散到不同的节点上\n\n> 详细解决方案参考：分布式存储\n\n# 数据库分库分表\n\n数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。\n\n> 详细解决方案参考：分布式存储\n\n# Nosql\n\n关系型数据库的优势在于：存储结构化数据，有利于进行各种复杂查询。\n\n但是，它也存在一些缺点：\n\n * 关系数据库存储的是行记录，无法存储数据结构\n * 关系数据库的 schema 扩展很不方便\n * 关系数据库在大数据场景下 I/O 较高\n * 关系数据库的全文搜索功能比较弱\n\n为了解决上述问题，分别诞生了解决不同问题的 Nosql 数据库。\n\n常见的 NoSQL 数据库可以分为四类：\n\n * K-V 数据库：KV 存储非常适合存储不涉及过多数据关系业务关系的数据，同时能有效减少读写磁盘的次数，比 SQL 数据库存储拥有更好的读写性能，能够解决关系型数据库无法存储数据结构的问题。以 Redis 为代表。\n * 列式数据库：适合于批量数据处理和即时查询，解决关系数据库大数据场景下的 I/O 问题。以 HBase 为代表。\n * 文档数据库：文档数据库（也称为文档型数据库）是旨在将半结构化数据存储为文档的一种数据库，它可以解决关系型数据库表结构 schema 扩展不方便的问题。文档数据库通常以 JSON 或 XML 格式存储数据。以 MongoDB 为代表。\n * 全文搜索引擎：解决关系型数据库全文搜索功能较弱的问题。以 Elasticsearch 为代表。\n\n> 详情参考：Nosql 技术选型\n\n\n# 文件存储\n\n# 机械键盘和固态硬盘\n\n考虑使用固态硬盘替代机械键盘，因为它的读写速度更快。\n\n# B+数和 LSM 树\n\n传统关系数据库的数据库索引一般都使用两级索引的 B+ 树 结构，树的层次最多三层。因此可能需要 5 次磁盘访问才能更新一条记录（三次磁盘访问获得数据索引及行 ID，然后再进行一次数据文件读操作及一次数据文件写操作）。\n\n由于磁盘访问是随机的，传统机械键盘在数据随机访问时性能较差，每次数据访问都需要多次访问磁盘影响数据访问性能。\n\n许多 Nosql 数据库中的索引采用 LSM 树 作为主要数据结构。LSM 树可视为一个 N 阶合并树。数据写操作都在内存中进行。在 LSM 树上进行一次数据更新不需要磁盘访问，速度远快于 B+ 树。\n\n# RAID 和 HDFS\n\nRAID 是 Redundant Array of Independent Disks 的缩写，中文简称为独立冗余磁盘阵列。\n\nRAID 是一种把多块独立的硬盘（物理硬盘）按不同的方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据备份技术。\n\nHDFS(分布式文件系统) 更被大型网站所青睐。它可以配合 MapReduce 并发计算任务框架进行大数据处理，可以在整个集群上并发访问所有磁盘，无需 RAID 支持。\n\nHDFS 对数据存储空间的管理以数据块（Block）为单位，默认为 64 MB。所以，HDFS 更适合存储较大的文件。\n\n\n# 前端性能优化\n\n\n# 浏览器访问优化\n\n 1. 减少 HTTP 请求 - HTTP 请求需要建立通信链路，进行数据传输，开销高昂，所以减少 HTTP 请求数可以有效提高访问性能。减少 HTTP 的主要手段是合并 Css、JavaScript、图片。\n 2. 使用浏览器缓存 - 因为静态资源文件更新频率低，可以缓存浏览器中以提高性能。设置 HTTP 头中的 Cache-Control 和 Expires 属性，可设定浏览器缓存。\n 3. 启用压缩 - 在服务器端压缩静态资源文件，在浏览器端解压缩，可以有效减少传输的数据量。由于文本文件压缩率可达 80% 以上，所以可以对静态资源，如 Html、Css、JavaScrip 进行压缩。\n 4. CSS 放在页面最上面，JavaScript 放在页面最下面 - 浏览器会在下载完全部的 Css 后才对整个页面进行渲染，所以最好的做法是将 Css 放在页面最上面，让浏览器尽快下载 Css；JavaScript 则相反，浏览器加载 JavaScript 后立即执行，可能会阻塞整个页面，造成页面显示缓慢，因此 JavaScript 最好放在页面最下面。\n 5. 减少 Cookie 传输 - Cookie 包含在 HTTP 每次的请求和响应中，太大的 Cookie 会严重影响数据传输。\n\n\n# CDN\n\nCDN 一般缓存的是静态资源。\n\nCDN 的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户已最快速度获取数据，即所谓网络访问第一跳。\n\n\n\n\n# 反向代理\n\n传统代理服务器位于浏览器一侧，代理浏览器将 HTTP 请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站服务器接收 HTTP 请求。\n\n\n\n反向代理服务器可以配置缓存功能加速 Web 请求，当用户第一次访问静态内容时，静态内容就会被缓存在反向代理服务器上。\n\n反向代理还可以实现负载均衡，通过负载均衡构建的集群可以提高系统总体处理能力。\n\n因为所有请求都必须先经过反向代理服务器，所以可以屏蔽一些攻击 IP，达到保护网站安全的作用。\n\n\n# 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * Java 性能调优实战",normalizedContent:"# 系统高性能架构\n\n\n# 性能简介\n\n要设计高性能的系统架构，应该有以下的思维步骤：\n\n首先，要明确影响性能的因素有哪些？性能的指标有哪些？——做到有的放矢。\n\n其次，要了解如何测试性能指标？性能优化，必须要有前后的效果对比，才能证明性能确实有改善。\n\n接下来，学习针对不同场景下，不同性指标的优化策略以及具体实施方案。——见招拆招。\n\n\n# 计算机资源\n\n了解性能指标前，需要先知道哪些计算机资源会影响性能。一般来说，影响性能的计算机资源包括：\n\n * cpu\n * 内存\n * 磁盘 i/o\n * 网络 i/o\n * 数据库\n * 锁竞争\n\n\n# 性能指标\n\n性能测试的主要指标有：\n\n * 响应时间\n * 并发数\n * 吞吐量\n   * qps\n   * tps\n * 资源分配使用率\n\n# 响应时间\n\n响应时间(rt)是指从客户端发一个请求开始计时，到客户端接收到从服务器端返回的响应结果结束所经历的时间，响应时间由请求发送时间、网络传输时间和服务器处理时间三部分组成。\n\n响应时间越短，性能越好，一般一个接口的响应时间是在毫秒级。\n\n响应时间可以进一步细分：\n\n * 客户端响应时间\n * 网络响应时间\n * 服务端响应时间\n * 数据库响应时间\n\n# 并发数\n\n并发数是指系统能同时处理的请求、事务数。\n\n系统自身的 cpu 处理能力、内存、以及系统自身的线程复用、锁竞争等都会影响并发数。\n\n# 吞吐量\n\n吞吐量计算公式：\n\n吞吐量 = 并发数 / 平均响应时间\n\n\n吞吐量越大，性能越好。\n\n一般，系统呈现给外部的最常见的吞吐量指标，就是：\n\n * qps(每秒查询数) - 即系统每秒可以处理的读请求。\n * tps(每秒事务数) - 即系统每秒可以处理的写请求。\n\n而在系统内部，存在以下吞吐量：\n\n * 磁盘吞吐量 - 体现了磁盘随机读写的性能。\n * 网络吞吐量 - 除了受限于网络带宽，cpu 的处理能力、网卡、防火墙、外部接口以及 i/o、系统 io 算法都会影响到网络吞吐量。\n\n# 资源分配使用率\n\n通常由 cpu 占用率、内存使用率、磁盘 i/o、网络 i/o 、对象与线程数来表示资源使用率。这些指标也是系统监控的重要参数。\n\n\n# 性能测试\n\n性能测试手段：\n\n * 性能测试\n * 负载测试\n * 压力测试\n * 稳定性测试\n\n对于 java 应用而言，最简单的，可以使用 jmeter 进行性能测试。\n\n性能测试报告示例：\n\n\n#### 性能测试的问题\n\n性能测试时，需要注意一些问题：\n\n * 热身问题 - 系统刚开始运行时，自身可能加载缓存，jvm 可能会优化热点代码等，这些行为都可能使得前后有较大的性能差异。所以，性能测试时，应该先跳过一段热身时间，等趋于稳定后，再开始性能测试。\n * 测试结果不稳定 - 性能测试中，有很多不稳定的因素，如环境、网络等，几乎不可能每次都是一样的结果。所以应该多次测试，求平均值。\n * 多 jvm 情况下的影响 - 应尽量避免一台机器部署多个 jvm 的情况。因为任意一个 jvm 都拥有整个系统的资源使用权，所以在性能测试时，可能会彼此干扰。\n\n\n# 性能优化策略\n\n 1. 性能分析 - 如果请求响应慢，存在性能问题。需要对请求经历的各个环节逐一分析，排查可能出现性能瓶颈的地方，定位问题。检查监控数据，分析影响性能的主要因素：内存、磁盘、网络、cpu，可能是代码或架构设计不合理，又或者是系统资源确实不足。\n 2. 性能优化 - 性能优化根据网站分层架构，大致可分为前端性能优化、应用服务性能优化、存储服务性能优化。\n\n\n# 应用服务性能优化\n\n\n# 缓存\n\n网站性能优化第一定律：第一优先考虑使用缓存提升性能。\n\n缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。\n\n * 单点应用可以使用进程内缓存（如：concurrenthashmap、caffeine）；\n * 分布式应用可以使用分布式缓存（如：redis、memcached），或进程缓存+分布式缓存的多级缓存方案。\n\n> 缓存解决方案请参考：缓存基本原理\n\n\n# 并发模型\n\n高并发需要根据两个条件划分：连接数量，请求数量。\n\n * 海量连接（成千上万）海量请求：例如抢购，双十一等\n * 常量连接（几十上百）海量请求：例如中间件\n * 海量连接常量请求：例如门户网站\n * 常量连接常量请求：例如内部运营系统，管理系统\n\n单服务器高性能的关键之一就是服务器采取的并发模型\n\n * 服务器如何管理连接。\n * 服务器如何处理请求。\n\n以上两个设计点最终都和操作系统的 i/o 模型及进程模型相关。\n\n * i/o 模型：阻塞、非阻塞、同步、异步。\n * 进程模型：单进程、多进程、多线程。\n\n# ppc\n\nppc 是 process per connection 的缩写，其含义是指每次有新的连接就新建一个进程去专门处理这个连接的请求，这是传统的 unix 网络服务器所采用的模型。基本的流程图是：\n\n\n\n * 父进程接受连接（图中 accept）。\n * 父进程“fork”子进程（图中 fork）。\n * 子进程处理连接的读写请求（图中子进程 read、业务处理、write）。\n * 子进程关闭连接（图中子进程中的 close）。\n\n这种模式的缺点：\n\n * fork 代价高\n * 父子进程通信复杂\n * 支持的并发连接数量有限\n\n# prefork\n\nppc 模式中，当连接进来时才 fork 新进程来处理连接请求，由于 fork 进程代价高，用户访问时可能感觉比较慢，prefork 模式的出现就是为了解决这个问题。\n\n顾名思义，prefork 就是提前创建进程（pre-fork）。系统在启动的时候就预先创建好进程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去 fork 进程的操作，让用户访问更快、体验更好。prefork 的基本示意图是：\n\n\n\nprefork 的实现关键就是多个子进程都 accept 同一个 socket，当有新的连接进入时，操作系统保证只有一个进程能最后 accept 成功。但这里也存在一个小小的问题：“惊群”现象，就是指虽然只有一个子进程能 accept 成功，但所有阻塞在 accept 上的子进程都会被唤醒，这样就导致了不必要的进程调度和上下文切换了。幸运的是，操作系统可以解决这个问题，例如 linux 2.6 版本后内核已经解决了 accept 惊群问题。\n\nprefork 模式和 ppc 一样，还是存在父子进程通信复杂、支持的并发连接数量有限的问题，因此目前实际应用也不多。apache 服务器提供了 mpm prefork 模式，推荐在需要可靠性或者与旧软件兼容的站点时采用这种模式，默认情况下最大支持 256 个并发连接。\n\n# tpc\n\ntpc 是 thread per connection 的缩写，其含义是指每次有新的连接就新建一个线程去专门处理这个连接的请求。与进程相比，线程更轻量级，创建线程的消耗比进程要少得多；同时多线程是共享进程内存空间的，线程通信相比进程通信更简单。因此，tpc 实际上是解决或者弱化了 ppc fork 代价高的问题和父子进程通信复杂的问题。\n\ntpc 的基本流程是：\n\n\n\n * 父进程接受连接（图中 accept）。\n * 父进程创建子线程（图中 pthread）。\n * 子线程处理连接的读写请求（图中子线程 read、业务处理、write）。\n * 子线程关闭连接（图中子线程中的 close）。\n\n注意，和 ppc 相比，主进程不用“close”连接了。原因是在于子线程是共享主进程的进程空间的，连接的文件描述符并没有被复制，因此只需要一次 close 即可。\n\ntpc 虽然解决了 fork 代价高和进程通信复杂的问题，但是也引入了新的问题，具体表现在：\n\n * 创建线程虽然比创建进程代价低，但并不是没有代价，高并发时（例如每秒上万连接）还是有性能问题。\n * 无须进程间通信，但是线程间的互斥和共享又引入了复杂度，可能一不小心就导致了死锁问题。\n * 多线程会出现互相影响的情况，某个线程出现异常时，可能导致整个进程退出（例如内存越界）。\n\n除了引入了新的问题，tpc 还是存在 cpu 线程调度和切换代价的问题。因此，tpc 方案本质上和 ppc 方案基本类似，在并发几百连接的场景下，反而更多地是采用 ppc 的方案，因为 ppc 方案不会有死锁的风险，也不会多进程互相影响，稳定性更高。\n\n# prethread\n\ntpc 模式中，当连接进来时才创建新的线程来处理连接请求，虽然创建线程比创建进程要更加轻量级，但还是有一定的代价，而 prethread 模式就是为了解决这个问题。\n\n和 prefork 类似，prethread 模式会预先创建线程，然后才开始接受用户的请求，当有新的连接进来的时候，就可以省去创建线程的操作，让用户感觉更快、体验更好。\n\n由于多线程之间数据共享和通信比较方便，因此实际上 prethread 的实现方式相比 prefork 要灵活一些，常见的实现方式有下面几种：\n\n * 主进程 accept，然后将连接交给某个线程处理。\n * 子线程都尝试去 accept，最终只有一个线程 accept 成功，方案的基本示意图如下：\n\n\n\napache 服务器的 mpm worker 模式本质上就是一种 prethread 方案，但稍微做了改进。apache 服务器会首先创建多个进程，每个进程里面再创建多个线程，这样做主要是为了考虑稳定性，即：即使某个子进程里面的某个线程异常导致整个子进程退出，还会有其他子进程继续提供服务，不会导致整个服务器全部挂掉。\n\nprethread 理论上可以比 prefork 支持更多的并发连接，apache 服务器 mpm worker 模式默认支持 16 × 25 = 400 个并发处理线程。\n\n# reactor\n\ni/o 多路复用技术归纳起来有两个关键实现点：\n\n * 当多条连接共用一个阻塞对象后，进程只需要在一个阻塞对象上等待，而无须再轮询所有连接，常见的实现方式有 select、epoll、kqueue 等。\n * 当某条连接有新的数据可以处理时，操作系统会通知进程，进程从阻塞状态返回，开始进行业务处理。\n\ni/o 多路复用结合线程池，完美地解决了 ppc 和 tpc 的问题\n\nreactor 模式的核心组成部分包括 reactor 和处理资源池（进程池或线程池），其中 reactor 负责监听和分配事件，处理资源池负责处理事件。初看 reactor 的实现是比较简单的，但实际上结合不同的业务场景，reactor 模式的具体实现方案灵活多变，主要体现在：\n\n * reactor 的数量可以变化：可以是一个 reactor，也可以是多个 reactor。\n * 资源池的数量可以变化：以进程为例，可以是单个进程，也可以是多个进程（线程类似）。\n\n最终 reactor 模式有这三种典型的实现方案：\n\n * 单 reactor 单进程 / 线程。\n * 单 reactor 多线程。\n * 多 reactor 多进程 / 线程。\n\n\n# 异步操作\n\n异步处理不仅可以减少系统服务间的耦合度，提高扩展性，事实上，它还可以提高系统的性能。异步处理可以有效减少响应等待时间，从而提高响应速度。\n\n异步处理一般是通过分布式消息队列的方式。\n\n异步处理可以解决以下问题：\n\n * 异步响应\n * 应用解耦\n * 流量削锋\n * 日志处理\n * 消息通讯\n\n\n# 负载均衡\n\n在高并发场景下，使用负载均衡技术为一个应用构建一个由多台服务器组成的服务器集群，将并发访问请求分发到多台服务器上处理，避免单一服务器因负载压力过大而响应缓慢，使用户请求具有更好的响应延迟特性。\n\n高性能集群的复杂性主要体现在需要增加一个任务分配器，以及为任务选择一个合适的任务分配算法。\n\n> 缓存解决方案请参考：负载均衡\n\n\n# 代码优化\n\n# 多线程\n\n从资源利用的角度看，使用多线程的原因主要有两个：io 阻塞和多 cpu。\n\n线程数并非越多越好，那么启动多少线程合适呢？\n\n有个参考公式：\n\n启动线程数 = (任务执行时间 / (任务执行时间 - io 等待时间)) * cpu 内核数\n\n\n最佳启动线程数和 cpu 内核数成正比，和 io 阻塞时间成反比。\n\n * 如果任务都是 cpu 计算型任务，那么线程数最多不要超过 cpu 内核数，因为启动再多线程，cpu 也来不及调度；\n * 相反，如果是任务需要等待磁盘操作，网络响应，那么多启动线程有助于任务并罚赌，提高系统吞吐量。\n\n# 线程安全问题\n\n线程安全问题时指多个线程并发访问某个资源，导致数据混乱。\n\n解决手段有：\n\n * 将对象设计为无状态对象 - 典型应用：servlet 就是无状态对象，可以被服务器多线程并发调用处理用户请求。\n * 使用局部对象\n * 并发访问资源时使用锁 - 但是引入锁会产生性能开销，应尽量使用轻量级的锁。\n\n# 资源复用\n\n应该尽量减少那些开销很大的系统资源的创建和销毁，如数据库连接、网络通信连接、线程、复杂对象等。从编程角度，资源复用主要有两种模式：单例模式和对象池。\n\n# 数据结构\n\n根据具体场景，选择合适的数据结构。\n\n# 垃圾回收\n\n如果 web 应用运行在 jvm 等具有垃圾回收功能的环境中，那么垃圾回收可能会对系统的性能特性产生巨大影响。立即垃圾回收机制有助于程序优化和参数调优，以及编写内存安全的代码。\n\n\n# 存储性能优化\n\n\n# 数据库\n\n# 数据库读写分离\n\n读写分离的基本原理是将数据库读写操作分散到不同的节点上\n\n> 详细解决方案参考：分布式存储\n\n# 数据库分库分表\n\n数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。\n\n> 详细解决方案参考：分布式存储\n\n# nosql\n\n关系型数据库的优势在于：存储结构化数据，有利于进行各种复杂查询。\n\n但是，它也存在一些缺点：\n\n * 关系数据库存储的是行记录，无法存储数据结构\n * 关系数据库的 schema 扩展很不方便\n * 关系数据库在大数据场景下 i/o 较高\n * 关系数据库的全文搜索功能比较弱\n\n为了解决上述问题，分别诞生了解决不同问题的 nosql 数据库。\n\n常见的 nosql 数据库可以分为四类：\n\n * k-v 数据库：kv 存储非常适合存储不涉及过多数据关系业务关系的数据，同时能有效减少读写磁盘的次数，比 sql 数据库存储拥有更好的读写性能，能够解决关系型数据库无法存储数据结构的问题。以 redis 为代表。\n * 列式数据库：适合于批量数据处理和即时查询，解决关系数据库大数据场景下的 i/o 问题。以 hbase 为代表。\n * 文档数据库：文档数据库（也称为文档型数据库）是旨在将半结构化数据存储为文档的一种数据库，它可以解决关系型数据库表结构 schema 扩展不方便的问题。文档数据库通常以 json 或 xml 格式存储数据。以 mongodb 为代表。\n * 全文搜索引擎：解决关系型数据库全文搜索功能较弱的问题。以 elasticsearch 为代表。\n\n> 详情参考：nosql 技术选型\n\n\n# 文件存储\n\n# 机械键盘和固态硬盘\n\n考虑使用固态硬盘替代机械键盘，因为它的读写速度更快。\n\n# b+数和 lsm 树\n\n传统关系数据库的数据库索引一般都使用两级索引的 b+ 树 结构，树的层次最多三层。因此可能需要 5 次磁盘访问才能更新一条记录（三次磁盘访问获得数据索引及行 id，然后再进行一次数据文件读操作及一次数据文件写操作）。\n\n由于磁盘访问是随机的，传统机械键盘在数据随机访问时性能较差，每次数据访问都需要多次访问磁盘影响数据访问性能。\n\n许多 nosql 数据库中的索引采用 lsm 树 作为主要数据结构。lsm 树可视为一个 n 阶合并树。数据写操作都在内存中进行。在 lsm 树上进行一次数据更新不需要磁盘访问，速度远快于 b+ 树。\n\n# raid 和 hdfs\n\nraid 是 redundant array of independent disks 的缩写，中文简称为独立冗余磁盘阵列。\n\nraid 是一种把多块独立的硬盘（物理硬盘）按不同的方式组合起来形成一个硬盘组（逻辑硬盘），从而提供比单个硬盘更高的存储性能和提供数据备份技术。\n\nhdfs(分布式文件系统) 更被大型网站所青睐。它可以配合 mapreduce 并发计算任务框架进行大数据处理，可以在整个集群上并发访问所有磁盘，无需 raid 支持。\n\nhdfs 对数据存储空间的管理以数据块（block）为单位，默认为 64 mb。所以，hdfs 更适合存储较大的文件。\n\n\n# 前端性能优化\n\n\n# 浏览器访问优化\n\n 1. 减少 http 请求 - http 请求需要建立通信链路，进行数据传输，开销高昂，所以减少 http 请求数可以有效提高访问性能。减少 http 的主要手段是合并 css、javascript、图片。\n 2. 使用浏览器缓存 - 因为静态资源文件更新频率低，可以缓存浏览器中以提高性能。设置 http 头中的 cache-control 和 expires 属性，可设定浏览器缓存。\n 3. 启用压缩 - 在服务器端压缩静态资源文件，在浏览器端解压缩，可以有效减少传输的数据量。由于文本文件压缩率可达 80% 以上，所以可以对静态资源，如 html、css、javascrip 进行压缩。\n 4. css 放在页面最上面，javascript 放在页面最下面 - 浏览器会在下载完全部的 css 后才对整个页面进行渲染，所以最好的做法是将 css 放在页面最上面，让浏览器尽快下载 css；javascript 则相反，浏览器加载 javascript 后立即执行，可能会阻塞整个页面，造成页面显示缓慢，因此 javascript 最好放在页面最下面。\n 5. 减少 cookie 传输 - cookie 包含在 http 每次的请求和响应中，太大的 cookie 会严重影响数据传输。\n\n\n# cdn\n\ncdn 一般缓存的是静态资源。\n\ncdn 的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户已最快速度获取数据，即所谓网络访问第一跳。\n\n\n\n\n# 反向代理\n\n传统代理服务器位于浏览器一侧，代理浏览器将 http 请求发送到互联网上，而反向代理服务器位于网站机房一侧，代理网站服务器接收 http 请求。\n\n\n\n反向代理服务器可以配置缓存功能加速 web 请求，当用户第一次访问静态内容时，静态内容就会被缓存在反向代理服务器上。\n\n反向代理还可以实现负载均衡，通过负载均衡构建的集群可以提高系统总体处理能力。\n\n因为所有请求都必须先经过反向代理服务器，所以可以屏蔽一些攻击 ip，达到保护网站安全的作用。\n\n\n# 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * java 性能调优实战",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"系统高可用架构",frontmatter:{title:"系统高可用架构",date:"2018-07-05T15:11:00.000Z",categories:["架构"],tags:["架构","高可用"],permalink:"/pages/ad5762/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/04.%E7%B3%BB%E7%BB%9F%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84.html",relativePath:"01.架构/04.系统高可用架构.md",key:"v-932f2d58",path:"/pages/ad5762/",headers:[{level:2,title:"1. 高可用架构简介",slug:"_1-高可用架构简介",normalizedTitle:"1. 高可用架构简介",charIndex:14},{level:3,title:"1.1. 系统可用性的度量",slug:"_1-1-系统可用性的度量",normalizedTitle:"1.1. 系统可用性的度量",charIndex:29},{level:3,title:"1.2. 故障原因",slug:"_1-2-故障原因",normalizedTitle:"1.2. 故障原因",charIndex:529},{level:3,title:"1.3. 什么是高可用的系统架构",slug:"_1-3-什么是高可用的系统架构",normalizedTitle:"1.3. 什么是高可用的系统架构",charIndex:1016},{level:2,title:"2. 高可用架构理论",slug:"_2-高可用架构理论",normalizedTitle:"2. 高可用架构理论",charIndex:1506},{level:2,title:"3. 架构模式",slug:"_3-架构模式",normalizedTitle:"3. 架构模式",charIndex:2050},{level:3,title:"3.1. 主备复制",slug:"_3-1-主备复制",normalizedTitle:"3.1. 主备复制",charIndex:2062},{level:3,title:"3.2. 主从复制",slug:"_3-2-主从复制",normalizedTitle:"3.2. 主从复制",charIndex:2518},{level:3,title:"3.3. 集群+分区",slug:"_3-3-集群-分区",normalizedTitle:"3.3. 集群+分区",charIndex:2957},{level:2,title:"4. 高可用的应用",slug:"_4-高可用的应用",normalizedTitle:"4. 高可用的应用",charIndex:3128},{level:3,title:"4.1. 负载均衡",slug:"_4-1-负载均衡",normalizedTitle:"4.1. 负载均衡",charIndex:3342},{level:3,title:"4.2. 分布式 Session",slug:"_4-2-分布式-session",normalizedTitle:"4.2. 分布式 session",charIndex:3589},{level:2,title:"5. 高可用的服务",slug:"_5-高可用的服务",normalizedTitle:"5. 高可用的服务",charIndex:3902},{level:3,title:"5.1. 分级管理",slug:"_5-1-分级管理",normalizedTitle:"5.1. 分级管理",charIndex:4107},{level:3,title:"5.2. 超时重试",slug:"_5-2-超时重试",normalizedTitle:"5.2. 超时重试",charIndex:4274},{level:3,title:"5.3. 异步调用",slug:"_5-3-异步调用",normalizedTitle:"5.3. 异步调用",charIndex:4384},{level:3,title:"5.4. 过载保护",slug:"_5-4-过载保护",normalizedTitle:"5.4. 过载保护",charIndex:4546},{level:4,title:"限流",slug:"限流",normalizedTitle:"限流",charIndex:1459},{level:5,title:"基于请求限流",slug:"基于请求限流",normalizedTitle:"基于请求限流",charIndex:4685},{level:5,title:"基于资源限流",slug:"基于资源限流",normalizedTitle:"基于资源限流",charIndex:4692},{level:4,title:"降级",slug:"降级",normalizedTitle:"降级",charIndex:4083},{level:4,title:"熔断",slug:"熔断",normalizedTitle:"熔断",charIndex:4575},{level:3,title:"5.5. 幂等性设计",slug:"_5-5-幂等性设计",normalizedTitle:"5.5. 幂等性设计",charIndex:5588},{level:2,title:"6. 高可用的存储",slug:"_6-高可用的存储",normalizedTitle:"6. 高可用的存储",charIndex:5901},{level:3,title:"6.1. 数据备份",slug:"_6-1-数据备份",normalizedTitle:"6.1. 数据备份",charIndex:6062},{level:3,title:"6.2. 失效转移",slug:"_6-2-失效转移",normalizedTitle:"6.2. 失效转移",charIndex:6370},{level:4,title:"失效确认",slug:"失效确认",normalizedTitle:"失效确认",charIndex:6426},{level:4,title:"访问转移",slug:"访问转移",normalizedTitle:"访问转移",charIndex:6559},{level:4,title:"数据恢复",slug:"数据恢复",normalizedTitle:"数据恢复",charIndex:6672},{level:2,title:"7. 辅助手段",slug:"_7-辅助手段",normalizedTitle:"7. 辅助手段",charIndex:6792},{level:3,title:"7.1. 异地多活",slug:"_7-1-异地多活",normalizedTitle:"7.1. 异地多活",charIndex:6804},{level:3,title:"7.2. 发布流程",slug:"_7-2-发布流程",normalizedTitle:"7.2. 发布流程",charIndex:7348},{level:3,title:"7.3. 系统监控",slug:"_7-3-系统监控",normalizedTitle:"7.3. 系统监控",charIndex:7422},{level:2,title:"8. 参考资料",slug:"_8-参考资料",normalizedTitle:"8. 参考资料",charIndex:8091}],headersStr:"1. 高可用架构简介 1.1. 系统可用性的度量 1.2. 故障原因 1.3. 什么是高可用的系统架构 2. 高可用架构理论 3. 架构模式 3.1. 主备复制 3.2. 主从复制 3.3. 集群+分区 4. 高可用的应用 4.1. 负载均衡 4.2. 分布式 Session 5. 高可用的服务 5.1. 分级管理 5.2. 超时重试 5.3. 异步调用 5.4. 过载保护 限流 基于请求限流 基于资源限流 降级 熔断 5.5. 幂等性设计 6. 高可用的存储 6.1. 数据备份 6.2. 失效转移 失效确认 访问转移 数据恢复 7. 辅助手段 7.1. 异地多活 7.2. 发布流程 7.3. 系统监控 8. 参考资料",content:"# 系统高可用架构\n\n\n# 1. 高可用架构简介\n\n\n# 1.1. 系统可用性的度量\n\n系统不可用也被称作系统故障，业界通常用多个 9 来衡量系统的可用性。如 QQ 的可用性为 4 个 9，即 99.99% 可用。\n\n网站不可用时间 = 故障修复时间点 - 故障发现时间点\n网站年度可用性指标 = (1 - 网站不可用时间/年度总时间) * 100%\n\n\n可用性计量表：\n\n可用性级别   系统可用性%    宕机时间/年     宕机时间/月    宕机时间/周    宕机时间/天\n不可用     90%       36.5 天     73 小时     16.8 小时   144 分钟\n基本可用    99%       87.6 小时    7.3 小时    1.68 小时   14.4 分钟\n较高可用    99.9%     8.76 小时    43.8 分钟   10.1 分钟   1.44 分钟\n高可用     99.99%    52.56 分钟   4.38 分钟   1.01 秒    8.64 秒\n极高可用    99.999%   5.26 分钟    26.28 秒   6.06 秒    0.86 秒\n\n\n# 1.2. 故障原因\n\n系统宕机原因主要有以下：\n\n无计划的\n\n * 系统级故障，包括主机、操作系统、中间件、数据库、网络、电源以及外围设备。\n * 数据和中介的故障，包括人员误操作、硬盘故障、数据乱了。\n * 还有自然灾害、人为破坏，以及供电问题等。\n\n有计划的\n\n * 日常任务：备份，容量规划，用户和安全管理，后台批处理应用。\n * 运维相关：数据库维护、应用维护、中间件维护、操作系统维护、网络维护。\n * 升级相关：数据库、应用、中间件、操作系统、网络，包括硬件升级。\n\n我们再给它们归个类。\n\n 1. 网络问题。网络链接出现问题，网络带宽出现拥塞……\n 2. 性能问题。数据库慢 SQL、Java Full GC、硬盘 IO 过大、CPU 飙高、内存不足……\n 3. 安全问题。被网络攻击，如 DDoS 等。\n 4. 运维问题。系统总是在被更新和修改，架构也在不断地被调整，监控问题……\n 5. 管理问题。没有梳理出关键服务以及服务的依赖关系，运行信息没有和控制系统同步……\n 6. 硬件问题。硬盘损坏、网卡出问题、交换机出问题、机房掉电、挖掘机问题……\n\n\n# 1.3. 什么是高可用的系统架构\n\n通常，企业级应用系统为提高系统可用性，会采用较昂贵的软硬件设备，当然这样的设备也比较稳定。\n\n互联网公司或一些初创型公司基于成本考虑，更多采用 PC 级软硬件设备，节约成本所付出的代价就是设备较为不稳定。服务器一年中出现几次宕机，高强度读写磁盘导致磁盘损坏等事件实属正常。\n\n综上，硬件出现故障应视为必然的，而高可用的系统架构设计目标就是要保证当出现硬件故障时，服务依然可用，数据依然能够保存并被访问。实现高可用的系统架构的主要手段是数据和服务的冗余备份及失效转移，一旦某些服务器宕机，就将服务切换到其他可用的服务器上；如果磁盘损坏，则从备份的磁盘读取数据。\n\n大型系统的分层架构及物理服务器的分布式部署使得位于不同层次的服务器具有不同的可用性特点。关闭服务或服务器宕机时产生的影响也不相同，高可用的解决方案也差异甚大。大致可以分为：\n\n * 高可用的应用 - 主要手段是：负载均衡\n * 高可用的服务 - 主要手段是：分级管理、超时重试、异步调用、限流、降解、断路、幂等性设计\n * 高可用的数据 - 主要手段是：数据备份和失效转移\n\n\n# 2. 高可用架构理论\n\n学习高可用架构，首先需要了解分布式基础理论：CAP 和 BASE。\n\n然后，很多著名的分布式系统，都利用选举机制，来保证主节点宕机时的故障恢复。如果要深入理解选举机制，有必要了解：Paxos 算法 和 Raft 算法。Paxos 和 Raft 是为了实现分布式系统中高可用架构而提出的共识性算法，已经成为业界标准。\n\nCAP 定理又称为 CAP 原则，指的是：在一个分布式系统中， 一致性（C：Consistency）、可用性（A：Availability） 和 分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。\n\nBASE 是 基本可用（Basically Available）、软状态（Soft State） 和 最终一致性（Eventually Consistent） 三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n> CAP 和 BASE 理论的详细说明请参考：分布式理论\n> \n> Paxos 和 Raft 的详细说明请参考：Paxos 算法 和 Raft 算法\n\n\n# 3. 架构模式\n\n\n# 3.1. 主备复制\n\n主备复制是最常见也是最简单的一种存储高可用方案，几乎所有的存储系统都提供了主备复制的功能，例如 MySQL、Redis、MongoDB 等。\n\n主备复制要点：\n\n * 存在一主多备。\n * 主机负责读&写，并定期复制数据给备机。\n * 一旦主机宕机，可以通过人工手段，将其中一个备节点作为主节点。\n\n\n\n优点\n\n * 主备复制架构中，客户端可以不感知备机的存在。即使灾难恢复后，原来的备机被人工修改为主机后，对于客户端来说，只是认为主机的地址换了而已，无须知道是原来的备机升级为主机。\n * 主备复制架构中，主机和备机之间，只需要进行数据复制即可，无须进行状态判断和主备切换这类复杂的操作。\n\n缺点\n\n * 主备复制架构中，故障后需要人工干预，无法自动恢复。\n\n适用场景\n\n综合主备复制架构的优缺点，内部的后台管理系统使用主备复制架构的情况会比较多，例如学生管理系统、员工管理系统、假期管理系统等，因为这类系统的数据变更频率低，即使在某些场景下丢失数据，也可以通过人工的方式补全。\n\n\n# 3.2. 主从复制\n\n主从复制和主备复制只有一字之差，区别在于：主从复制模式中，从机要承担读操作。\n\n主从复制要点：\n\n * 存在一主多从。\n * 主机负责读&写，并定期复制数据给从机。\n * 从机只负责读。\n * 一旦主机宕机，可以通过人工手段，将其中一个从节点作为主节点。\n\n\n\n优点\n\n * 主从复制架构中，主机故障时，读操作相关的业务可以继续运行。\n * 主从复制架构中，从机提供读操作，发挥了硬件的性能。\n\n缺点\n\n * 主从复制架构中，客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备复制要高。\n * 主从复制架构中，从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题。\n * 主从复制架构中，故障时需要人工干预。\n\n适用场景\n\n综合主从复制的优缺点，一般情况下，写少读多的业务使用主从复制的存储架构比较多。例如，论坛、BBS、新闻网站这类业务，此类业务的读操作数量是写操作数量的 10 倍甚至 100 倍以上。\n\n\n# 3.3. 集群+分区\n\n在主备复制和主从复制模式中，都由一个共性问题：\n\n每个机器上存储的都是全量数据。但是，单机的数据存储量总是有上限的，当数据量上升为 TB 级甚至 PB 级数据，单机终究有无法支撑的时候。这时，就需要对数据进行分片（sharding）。\n\n分片后的节点可以视为一个独立的子集，针对子集，任然需要保证高可用。\n\n\n\n\n# 4. 高可用的应用\n\n应用层主要处理网站应用的业务逻辑，一个显著的特点是应用的 无状态 性。\n\n所谓的 无状态 的应用是指应用服务器不保存业务的上下文信息，而仅根据每次请求提交的数据进行相应的业务逻辑处理，多个服务实例之间完全对等，请求提交到任意服务器，处理结果都是完全一样的。\n\n由于无状态应用，各实例之间不用考虑数据一致性问题，所以其高可用方案相对简单。主要手段是：\n\n * 负载均衡\n * 分布式 Session\n\n\n# 4.1. 负载均衡\n\n负载均衡，顾名思义，主要使用在业务量和数据量较高的情况下，当单台服务器不足以承担所有的负载压力时，通过负载均衡手段，将流量和数据分摊到一个集群组成的多台服务器上，以提高整体的负载处理能力。\n\n无状态应用的失效转移可以利用负载均衡来实现。\n\n无状态的应用实现高可用架构十分简单，由于服务器不保存请求状态，那么所有服务器完全对等，在任意节点执行同样的请求，结果总是一致的。这种情况下，最简单的高可用方案就是使用负载均衡。\n\n> 负载均衡原理可以参考：负载均衡基本原理\n\n\n# 4.2. 分布式 Session\n\n应用服务器的高可用架构设计主要基于服务无状态这一特性。事实上，业务总是有状态的，如购物车记录用户的购买信息；用户的登录状态；最新发布的消息等等。\n\n在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。\n\n为了解决分布式 Session 问题，常见的解决方案有：\n\n * 粘性 session\n * 应用服务器间的 session 复制共享\n * 基于缓存的 session 共享 ✅\n\n> 分布式会话原理可以参考：分布式会话基本原理\n\n\n# 5. 高可用的服务\n\n可复用的服务为业务产品提供基础公共服务，大型系统中这些服务通常都独立分布式部署，被具体应用远程调用。可复用的服务和应用一样，一般也是无状态的服务，因此，同样可以使用负载均衡的失效转移策略来实现高可用。\n\n除此以外，还有以下手段来保证服务的高可用：\n\n * 分级管理\n * 超时重试\n * 异步调用\n * 过载保护\n   * 限流\n   * 降级\n   * 断路\n * 幂等性设计\n\n\n# 5.1. 分级管理\n\n将服务根据业务重要性进行分级管理，核心应用和服务优先使用更好的硬件，在运维响应速度上也格外迅速。\n\n在服务部署上进行必要的隔离，避免故障的连锁反应。低优先级的服务通过启动不同的线程或部署在不同的虚拟机上进行隔离，而高优先级的服务则需要部署在不同的物理机上，核心服务和数据甚至要部署在不同地域的数据中心。\n\n\n# 5.2. 超时重试\n\n由于服务器宕机、线程死锁等原因，可能导致应用程序对服务端的调用失去响应。所以有必要引入超时机制，一旦调用超时，服务化框架抛出异常，应用程序根据服务调度策略，选择重试或请求转移到其他机器上。\n\n\n# 5.3. 异步调用\n\n对于需要即时响应的业务，应用在调用服务时可以通过消息队列等异步方式完成，避免一个服务失败导致整个应用请求失败的情况。当然不是所有服务调用都可以异步调用，对于获取用户信息这类调用，采用异步方式会延长响应时间，得不偿失；此外，对于那些必须确认服务调用才能继续下一步操作的应用也不适宜食用异步调用。\n\n\n# 5.4. 过载保护\n\n过载保护的手段，一般有：限流、降级、熔断。\n\n# 限流\n\n降级是从系统功能优先级的角度考虑如何应对故障，而限流则是从用户访问压力的角度来考虑如何应对故障。限流指只允许系统能够承受的访问量进来，超出系统访问能力的请求将被丢弃。\n\n常见的限流方式可以分为两类：基于请求限流和基于资源限流。\n\n# 基于请求限流\n\n基于请求限流指从外部访问的请求角度考虑限流，常见的方式有：限制总量、限制时间量。\n\n限制总量的方式是限制某个指标的累积上限，常见的是限制当前系统服务的用户总量，例如某个直播间限制总用户数上限为 100 万，超过 100 万后新的用户无法进入；某个抢购活动商品数量只有 100 个，限制参与抢购的用户上限为 1 万个，1 万以后的用户直接拒绝。限制时间量指限制一段时间内某个指标的上限，例如，1 分钟内只允许 10000 个用户访问，每秒请求峰值最高为 10 万。\n\n无论是限制总量还是限制时间量，共同的特点都是实现简单，但在实践中面临的主要问题是比较难以找到合适的阈值。\n\n# 基于资源限流\n\n基于请求限流是从系统外部考虑的，而基于资源限流是从系统内部考虑的，即：找到系统内部影响性能的关键资源，对其使用上限进行限制。常见的内部资源有：连接数、文件句柄、线程数、请求队列等。\n\n基于资源限流相比基于请求限流能够更加有效地反映当前系统的压力，但实践中设计也面临两个主要的难点：如何确定关键资源，如何确定关键资源的阈值。\n\n# 降级\n\n降级指系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能。\n\n在服务访问的高峰期，服务可能因为大量并发调用而性能下降，严重时可能会导致宕机。为了保证核心功能的正常运行，需要对服务进行降级。降级有两种手段：\n\n拒绝服务 - 拒绝低优先级应用的调用，减少服务调用并发数，确保核心应用正常使用。或者随机拒绝部分调用，节约资源，避免要死大家一起死的惨剧。\n\n关闭服务 - 关闭部分不重要的服务，或者服务内部关闭部分不重要的功能，以节约资源。\n\n# 熔断\n\n熔断和降级是两个比较容易混淆的概念，因为单纯从名字上看好像都有禁止某个功能的意思，但其实内在含义是不同的，原因在于降级的目的是应对系统自身的故障，而熔断的目的是应对依赖的外部系统故障的情况。\n\n熔断机制实现的关键是需要有一个统一的 API 调用层，由 API 调用层来进行采样或者统计，如果接口调用散落在代码各处就没法进行统一处理了。\n\n\n# 5.5. 幂等性设计\n\n服务调用失败后，调用方会将请求转发到其他服务器上，但是这个失败可能是虚假的失败。比如服务已经处理成功，但因为网络故障导致调用方没有收到应答，或等待超时。这种情况下，重新发起请求，可能会导致重复操作，如：向数据库写入两条记录。如果这个操作是比较敏感的交易操作，就会产生严重后果。\n\n服务重复调用时无法避免的，但是只要能从业务实现上保证，重复调用和一次调用的处理结果一致，则业务就没有问题，这就是幂等性设计。\n\n有些服务的业务天然具有幂等性，比如将用户性别设为男性，不管执行多少次，结果是一致的。但有些复杂的业务，要想保证幂等性，就需要根据全局性的 ID 去进行有效性验证，验证通过才能继续执行。\n\n\n# 6. 高可用的存储\n\n对于绝大部分软件系统而言，数据都是最宝贵的虚拟资产，一旦丢失，可以说是毁灭性的打击。\n\n保证存储高可用的主要手段是：数据备份和失效转移。\n\n存储高可用架构的复杂性主要体现在：如何应对副本同步延迟和中断导致的数据一致性问题。\n\n> 提示：再开始学习这部分内容前，建议先学习 二、高可用架构理论\n\n\n# 6.1. 数据备份\n\n数据备份是保证数据有多个副本，任意副本的丢失都不会导致数据的永久丢失。\n\n * 冷备份 - 定期将数据复制到某种存储介质。\n * 热备份\n   * 异步热备方式 - 异步热备方式是指多份数据副本的写入操作异步完成，应用程序收到数据服务系统的写操作成功响应时，只写成功了一份，存储系统将会异步地写其他副本。\n   * 同步热备方式 - 同步热备方式是指多份数据副本的写入操作同步完成，即应用程序收到数据服务系统的写成功响应时，多份数据都已经写操作成功。但是当应用程序收到数据写操作失败的响应式，可能有部分副本或者全部副本都已经写入成功了（因为网络或者系统故障，无法返回操作成功的响应）。\n\n\n# 6.2. 失效转移\n\n失效转移是保证任意一个副本不可访问时，可以快速切换访问其他副本，保证系统整体可用。\n\n# 失效确认\n\n\n\n判断服务器宕机的手段有两种：心跳检测和访问失败报告。\n\n对于应用程序的访问失败报告，控制中心还需要再一次发送心跳检测进行确认，以免错误判断服务器宕机。因为一旦进行数据访问的失效转移，意味着数据存储多份副本不一致，需要进行后续一系列的复杂动作。\n\n# 访问转移\n\n确认某台数据服务器宕机后，就需要将数据读写访问重新路由到其他服务器上。对于完全对等存储的服务器，当其中一台宕机后，应用程序根据配置直接切换到对等服务器上。如果存储不对等，就需要重新计算路由，选择存储服务器。\n\n# 数据恢复\n\n因为某台服务器宕机，所以数据存储的副本数目会减少，必须将副本的数目恢复到系统设定的值，否则，再有服务器宕机时，就可能出现无法访问转移，数据永久丢失的情况。因此系统需要从健康的服务器复制数据，将数据副本数目恢复到设定值。\n\n\n# 7. 辅助手段\n\n\n# 7.1. 异地多活\n\n异地多活架构的关键点就是异地、多活，其中异地就是指地理位置上不同的地方，类似于“不要把鸡蛋都放在同一篮子里”；多活就是指不同地理位置上的系统都能够提供业务服务，这里的“活”是活动、活跃的意思。\n\n异地多活架构可以分为同城异区、跨城异地、跨国异地。\n\n异地多活架构的代价：\n\n * 系统复杂度会发生质的变化，需要设计复杂的异地多活架构。\n * 成本会上升，毕竟要多在一个或者多个机房搭建独立的一套业务系统。\n\n异地多活的设计原则：\n\n * 保证核心业务的异地多活\n * 保证核心数据最终一致性\n * 采用多种手段同步数据\n * 只保证绝大部分用户的异地多活\n\n异地多活设计步骤：\n\n * 业务分级 - 常见的分级标准有：\n   * 流量大的业务\n   * 核心业务\n   * 盈利业务\n * 数据分类 - 常见的数据分析维度有：\n   * 数据量\n   * 唯一性\n   * 实时性\n   * 可丢实性\n   * 可恢复性\n * 数据同步 - 常见的数据同步方案\n   * 存储系统同步\n   * 消息队列同步\n   * 重复生成\n * 异常处理 - 常见异常处理措施：\n   * 多通道同步\n   * 同步和访问结合\n   * 日志记录\n   * 用户补偿\n\n\n# 7.2. 发布流程\n\n高可用的软件质量保证的手段：\n\n * 自动化测试\n * 预发布验证\n * 代码控制\n * 自动化发布\n * 灰度发布\n\n\n# 7.3. 系统监控\n\n> 不允许没有监控的系统上线。\n\n * 监控数据采集\n   * 用户行为日志收集\n     * 服务端日志收集 - Apache、Nginx 等几乎所有 Web 服务器都具备日志记录功能，只要开启日志记录即可。如果是服务器比较多，需要集中采集日志，通常会使用 Elastic 来进行收集。\n     * 客户端日志收集 - 利用页面嵌入专门的 JavaScript 脚本可以收集用户真实的操作行为。\n     * 日志分析 - 可以利用 ElasticSearch 做语义分析及搜索；利用实时计算框架 Storm、Flink 等开发日志统计与分析工具。\n   * 服务器性能监控 - 收集服务器性能指标，如系统负载、内存占用、CPU 占用、磁盘 IO、网络 IO 等。常用的监控工具有：Apache SkyWalking 、Pinpoint 等。\n   * 运行数据报告 - 应该监控一些与具体业务场景相关的技术和业务指标，如：缓存命中率、平均响应时延、TPS、QPS 等。\n * 监控管理\n   * 系统报警 - 设置阈值。当达到阈值，及时触发告警（短信、邮件、通信工具均可），通过及时判断状况，防患于未然。\n   * 失效转移 - 监控系统可以在发现故障的情况下主动通知应用进行失效转移。\n   * 自动优雅降级\n     * 优雅降级是为了应付突然爆发的访问高峰，主动关闭部分功能，释放部分资源，以保证核心功能的优先访问。\n     * 系统在监控管理基础之上实现自动优雅降级，是柔性架构的理想状态。\n\n\n# 8. 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * 《亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统》\n * 左耳听风",normalizedContent:"# 系统高可用架构\n\n\n# 1. 高可用架构简介\n\n\n# 1.1. 系统可用性的度量\n\n系统不可用也被称作系统故障，业界通常用多个 9 来衡量系统的可用性。如 qq 的可用性为 4 个 9，即 99.99% 可用。\n\n网站不可用时间 = 故障修复时间点 - 故障发现时间点\n网站年度可用性指标 = (1 - 网站不可用时间/年度总时间) * 100%\n\n\n可用性计量表：\n\n可用性级别   系统可用性%    宕机时间/年     宕机时间/月    宕机时间/周    宕机时间/天\n不可用     90%       36.5 天     73 小时     16.8 小时   144 分钟\n基本可用    99%       87.6 小时    7.3 小时    1.68 小时   14.4 分钟\n较高可用    99.9%     8.76 小时    43.8 分钟   10.1 分钟   1.44 分钟\n高可用     99.99%    52.56 分钟   4.38 分钟   1.01 秒    8.64 秒\n极高可用    99.999%   5.26 分钟    26.28 秒   6.06 秒    0.86 秒\n\n\n# 1.2. 故障原因\n\n系统宕机原因主要有以下：\n\n无计划的\n\n * 系统级故障，包括主机、操作系统、中间件、数据库、网络、电源以及外围设备。\n * 数据和中介的故障，包括人员误操作、硬盘故障、数据乱了。\n * 还有自然灾害、人为破坏，以及供电问题等。\n\n有计划的\n\n * 日常任务：备份，容量规划，用户和安全管理，后台批处理应用。\n * 运维相关：数据库维护、应用维护、中间件维护、操作系统维护、网络维护。\n * 升级相关：数据库、应用、中间件、操作系统、网络，包括硬件升级。\n\n我们再给它们归个类。\n\n 1. 网络问题。网络链接出现问题，网络带宽出现拥塞……\n 2. 性能问题。数据库慢 sql、java full gc、硬盘 io 过大、cpu 飙高、内存不足……\n 3. 安全问题。被网络攻击，如 ddos 等。\n 4. 运维问题。系统总是在被更新和修改，架构也在不断地被调整，监控问题……\n 5. 管理问题。没有梳理出关键服务以及服务的依赖关系，运行信息没有和控制系统同步……\n 6. 硬件问题。硬盘损坏、网卡出问题、交换机出问题、机房掉电、挖掘机问题……\n\n\n# 1.3. 什么是高可用的系统架构\n\n通常，企业级应用系统为提高系统可用性，会采用较昂贵的软硬件设备，当然这样的设备也比较稳定。\n\n互联网公司或一些初创型公司基于成本考虑，更多采用 pc 级软硬件设备，节约成本所付出的代价就是设备较为不稳定。服务器一年中出现几次宕机，高强度读写磁盘导致磁盘损坏等事件实属正常。\n\n综上，硬件出现故障应视为必然的，而高可用的系统架构设计目标就是要保证当出现硬件故障时，服务依然可用，数据依然能够保存并被访问。实现高可用的系统架构的主要手段是数据和服务的冗余备份及失效转移，一旦某些服务器宕机，就将服务切换到其他可用的服务器上；如果磁盘损坏，则从备份的磁盘读取数据。\n\n大型系统的分层架构及物理服务器的分布式部署使得位于不同层次的服务器具有不同的可用性特点。关闭服务或服务器宕机时产生的影响也不相同，高可用的解决方案也差异甚大。大致可以分为：\n\n * 高可用的应用 - 主要手段是：负载均衡\n * 高可用的服务 - 主要手段是：分级管理、超时重试、异步调用、限流、降解、断路、幂等性设计\n * 高可用的数据 - 主要手段是：数据备份和失效转移\n\n\n# 2. 高可用架构理论\n\n学习高可用架构，首先需要了解分布式基础理论：cap 和 base。\n\n然后，很多著名的分布式系统，都利用选举机制，来保证主节点宕机时的故障恢复。如果要深入理解选举机制，有必要了解：paxos 算法 和 raft 算法。paxos 和 raft 是为了实现分布式系统中高可用架构而提出的共识性算法，已经成为业界标准。\n\ncap 定理又称为 cap 原则，指的是：在一个分布式系统中， 一致性（c：consistency）、可用性（a：availability） 和 分区容忍性（p：partition tolerance），最多只能同时满足其中两项。\n\nbase 是 基本可用（basically available）、软状态（soft state） 和 最终一致性（eventually consistent） 三个短语的缩写。base 理论是对 cap 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n> cap 和 base 理论的详细说明请参考：分布式理论\n> \n> paxos 和 raft 的详细说明请参考：paxos 算法 和 raft 算法\n\n\n# 3. 架构模式\n\n\n# 3.1. 主备复制\n\n主备复制是最常见也是最简单的一种存储高可用方案，几乎所有的存储系统都提供了主备复制的功能，例如 mysql、redis、mongodb 等。\n\n主备复制要点：\n\n * 存在一主多备。\n * 主机负责读&写，并定期复制数据给备机。\n * 一旦主机宕机，可以通过人工手段，将其中一个备节点作为主节点。\n\n\n\n优点\n\n * 主备复制架构中，客户端可以不感知备机的存在。即使灾难恢复后，原来的备机被人工修改为主机后，对于客户端来说，只是认为主机的地址换了而已，无须知道是原来的备机升级为主机。\n * 主备复制架构中，主机和备机之间，只需要进行数据复制即可，无须进行状态判断和主备切换这类复杂的操作。\n\n缺点\n\n * 主备复制架构中，故障后需要人工干预，无法自动恢复。\n\n适用场景\n\n综合主备复制架构的优缺点，内部的后台管理系统使用主备复制架构的情况会比较多，例如学生管理系统、员工管理系统、假期管理系统等，因为这类系统的数据变更频率低，即使在某些场景下丢失数据，也可以通过人工的方式补全。\n\n\n# 3.2. 主从复制\n\n主从复制和主备复制只有一字之差，区别在于：主从复制模式中，从机要承担读操作。\n\n主从复制要点：\n\n * 存在一主多从。\n * 主机负责读&写，并定期复制数据给从机。\n * 从机只负责读。\n * 一旦主机宕机，可以通过人工手段，将其中一个从节点作为主节点。\n\n\n\n优点\n\n * 主从复制架构中，主机故障时，读操作相关的业务可以继续运行。\n * 主从复制架构中，从机提供读操作，发挥了硬件的性能。\n\n缺点\n\n * 主从复制架构中，客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备复制要高。\n * 主从复制架构中，从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题。\n * 主从复制架构中，故障时需要人工干预。\n\n适用场景\n\n综合主从复制的优缺点，一般情况下，写少读多的业务使用主从复制的存储架构比较多。例如，论坛、bbs、新闻网站这类业务，此类业务的读操作数量是写操作数量的 10 倍甚至 100 倍以上。\n\n\n# 3.3. 集群+分区\n\n在主备复制和主从复制模式中，都由一个共性问题：\n\n每个机器上存储的都是全量数据。但是，单机的数据存储量总是有上限的，当数据量上升为 tb 级甚至 pb 级数据，单机终究有无法支撑的时候。这时，就需要对数据进行分片（sharding）。\n\n分片后的节点可以视为一个独立的子集，针对子集，任然需要保证高可用。\n\n\n\n\n# 4. 高可用的应用\n\n应用层主要处理网站应用的业务逻辑，一个显著的特点是应用的 无状态 性。\n\n所谓的 无状态 的应用是指应用服务器不保存业务的上下文信息，而仅根据每次请求提交的数据进行相应的业务逻辑处理，多个服务实例之间完全对等，请求提交到任意服务器，处理结果都是完全一样的。\n\n由于无状态应用，各实例之间不用考虑数据一致性问题，所以其高可用方案相对简单。主要手段是：\n\n * 负载均衡\n * 分布式 session\n\n\n# 4.1. 负载均衡\n\n负载均衡，顾名思义，主要使用在业务量和数据量较高的情况下，当单台服务器不足以承担所有的负载压力时，通过负载均衡手段，将流量和数据分摊到一个集群组成的多台服务器上，以提高整体的负载处理能力。\n\n无状态应用的失效转移可以利用负载均衡来实现。\n\n无状态的应用实现高可用架构十分简单，由于服务器不保存请求状态，那么所有服务器完全对等，在任意节点执行同样的请求，结果总是一致的。这种情况下，最简单的高可用方案就是使用负载均衡。\n\n> 负载均衡原理可以参考：负载均衡基本原理\n\n\n# 4.2. 分布式 session\n\n应用服务器的高可用架构设计主要基于服务无状态这一特性。事实上，业务总是有状态的，如购物车记录用户的购买信息；用户的登录状态；最新发布的消息等等。\n\n在分布式场景下，一个用户的 session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 session，就可能导致用户需要重新进行登录等操作。\n\n为了解决分布式 session 问题，常见的解决方案有：\n\n * 粘性 session\n * 应用服务器间的 session 复制共享\n * 基于缓存的 session 共享 ✅\n\n> 分布式会话原理可以参考：分布式会话基本原理\n\n\n# 5. 高可用的服务\n\n可复用的服务为业务产品提供基础公共服务，大型系统中这些服务通常都独立分布式部署，被具体应用远程调用。可复用的服务和应用一样，一般也是无状态的服务，因此，同样可以使用负载均衡的失效转移策略来实现高可用。\n\n除此以外，还有以下手段来保证服务的高可用：\n\n * 分级管理\n * 超时重试\n * 异步调用\n * 过载保护\n   * 限流\n   * 降级\n   * 断路\n * 幂等性设计\n\n\n# 5.1. 分级管理\n\n将服务根据业务重要性进行分级管理，核心应用和服务优先使用更好的硬件，在运维响应速度上也格外迅速。\n\n在服务部署上进行必要的隔离，避免故障的连锁反应。低优先级的服务通过启动不同的线程或部署在不同的虚拟机上进行隔离，而高优先级的服务则需要部署在不同的物理机上，核心服务和数据甚至要部署在不同地域的数据中心。\n\n\n# 5.2. 超时重试\n\n由于服务器宕机、线程死锁等原因，可能导致应用程序对服务端的调用失去响应。所以有必要引入超时机制，一旦调用超时，服务化框架抛出异常，应用程序根据服务调度策略，选择重试或请求转移到其他机器上。\n\n\n# 5.3. 异步调用\n\n对于需要即时响应的业务，应用在调用服务时可以通过消息队列等异步方式完成，避免一个服务失败导致整个应用请求失败的情况。当然不是所有服务调用都可以异步调用，对于获取用户信息这类调用，采用异步方式会延长响应时间，得不偿失；此外，对于那些必须确认服务调用才能继续下一步操作的应用也不适宜食用异步调用。\n\n\n# 5.4. 过载保护\n\n过载保护的手段，一般有：限流、降级、熔断。\n\n# 限流\n\n降级是从系统功能优先级的角度考虑如何应对故障，而限流则是从用户访问压力的角度来考虑如何应对故障。限流指只允许系统能够承受的访问量进来，超出系统访问能力的请求将被丢弃。\n\n常见的限流方式可以分为两类：基于请求限流和基于资源限流。\n\n# 基于请求限流\n\n基于请求限流指从外部访问的请求角度考虑限流，常见的方式有：限制总量、限制时间量。\n\n限制总量的方式是限制某个指标的累积上限，常见的是限制当前系统服务的用户总量，例如某个直播间限制总用户数上限为 100 万，超过 100 万后新的用户无法进入；某个抢购活动商品数量只有 100 个，限制参与抢购的用户上限为 1 万个，1 万以后的用户直接拒绝。限制时间量指限制一段时间内某个指标的上限，例如，1 分钟内只允许 10000 个用户访问，每秒请求峰值最高为 10 万。\n\n无论是限制总量还是限制时间量，共同的特点都是实现简单，但在实践中面临的主要问题是比较难以找到合适的阈值。\n\n# 基于资源限流\n\n基于请求限流是从系统外部考虑的，而基于资源限流是从系统内部考虑的，即：找到系统内部影响性能的关键资源，对其使用上限进行限制。常见的内部资源有：连接数、文件句柄、线程数、请求队列等。\n\n基于资源限流相比基于请求限流能够更加有效地反映当前系统的压力，但实践中设计也面临两个主要的难点：如何确定关键资源，如何确定关键资源的阈值。\n\n# 降级\n\n降级指系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能。\n\n在服务访问的高峰期，服务可能因为大量并发调用而性能下降，严重时可能会导致宕机。为了保证核心功能的正常运行，需要对服务进行降级。降级有两种手段：\n\n拒绝服务 - 拒绝低优先级应用的调用，减少服务调用并发数，确保核心应用正常使用。或者随机拒绝部分调用，节约资源，避免要死大家一起死的惨剧。\n\n关闭服务 - 关闭部分不重要的服务，或者服务内部关闭部分不重要的功能，以节约资源。\n\n# 熔断\n\n熔断和降级是两个比较容易混淆的概念，因为单纯从名字上看好像都有禁止某个功能的意思，但其实内在含义是不同的，原因在于降级的目的是应对系统自身的故障，而熔断的目的是应对依赖的外部系统故障的情况。\n\n熔断机制实现的关键是需要有一个统一的 api 调用层，由 api 调用层来进行采样或者统计，如果接口调用散落在代码各处就没法进行统一处理了。\n\n\n# 5.5. 幂等性设计\n\n服务调用失败后，调用方会将请求转发到其他服务器上，但是这个失败可能是虚假的失败。比如服务已经处理成功，但因为网络故障导致调用方没有收到应答，或等待超时。这种情况下，重新发起请求，可能会导致重复操作，如：向数据库写入两条记录。如果这个操作是比较敏感的交易操作，就会产生严重后果。\n\n服务重复调用时无法避免的，但是只要能从业务实现上保证，重复调用和一次调用的处理结果一致，则业务就没有问题，这就是幂等性设计。\n\n有些服务的业务天然具有幂等性，比如将用户性别设为男性，不管执行多少次，结果是一致的。但有些复杂的业务，要想保证幂等性，就需要根据全局性的 id 去进行有效性验证，验证通过才能继续执行。\n\n\n# 6. 高可用的存储\n\n对于绝大部分软件系统而言，数据都是最宝贵的虚拟资产，一旦丢失，可以说是毁灭性的打击。\n\n保证存储高可用的主要手段是：数据备份和失效转移。\n\n存储高可用架构的复杂性主要体现在：如何应对副本同步延迟和中断导致的数据一致性问题。\n\n> 提示：再开始学习这部分内容前，建议先学习 二、高可用架构理论\n\n\n# 6.1. 数据备份\n\n数据备份是保证数据有多个副本，任意副本的丢失都不会导致数据的永久丢失。\n\n * 冷备份 - 定期将数据复制到某种存储介质。\n * 热备份\n   * 异步热备方式 - 异步热备方式是指多份数据副本的写入操作异步完成，应用程序收到数据服务系统的写操作成功响应时，只写成功了一份，存储系统将会异步地写其他副本。\n   * 同步热备方式 - 同步热备方式是指多份数据副本的写入操作同步完成，即应用程序收到数据服务系统的写成功响应时，多份数据都已经写操作成功。但是当应用程序收到数据写操作失败的响应式，可能有部分副本或者全部副本都已经写入成功了（因为网络或者系统故障，无法返回操作成功的响应）。\n\n\n# 6.2. 失效转移\n\n失效转移是保证任意一个副本不可访问时，可以快速切换访问其他副本，保证系统整体可用。\n\n# 失效确认\n\n\n\n判断服务器宕机的手段有两种：心跳检测和访问失败报告。\n\n对于应用程序的访问失败报告，控制中心还需要再一次发送心跳检测进行确认，以免错误判断服务器宕机。因为一旦进行数据访问的失效转移，意味着数据存储多份副本不一致，需要进行后续一系列的复杂动作。\n\n# 访问转移\n\n确认某台数据服务器宕机后，就需要将数据读写访问重新路由到其他服务器上。对于完全对等存储的服务器，当其中一台宕机后，应用程序根据配置直接切换到对等服务器上。如果存储不对等，就需要重新计算路由，选择存储服务器。\n\n# 数据恢复\n\n因为某台服务器宕机，所以数据存储的副本数目会减少，必须将副本的数目恢复到系统设定的值，否则，再有服务器宕机时，就可能出现无法访问转移，数据永久丢失的情况。因此系统需要从健康的服务器复制数据，将数据副本数目恢复到设定值。\n\n\n# 7. 辅助手段\n\n\n# 7.1. 异地多活\n\n异地多活架构的关键点就是异地、多活，其中异地就是指地理位置上不同的地方，类似于“不要把鸡蛋都放在同一篮子里”；多活就是指不同地理位置上的系统都能够提供业务服务，这里的“活”是活动、活跃的意思。\n\n异地多活架构可以分为同城异区、跨城异地、跨国异地。\n\n异地多活架构的代价：\n\n * 系统复杂度会发生质的变化，需要设计复杂的异地多活架构。\n * 成本会上升，毕竟要多在一个或者多个机房搭建独立的一套业务系统。\n\n异地多活的设计原则：\n\n * 保证核心业务的异地多活\n * 保证核心数据最终一致性\n * 采用多种手段同步数据\n * 只保证绝大部分用户的异地多活\n\n异地多活设计步骤：\n\n * 业务分级 - 常见的分级标准有：\n   * 流量大的业务\n   * 核心业务\n   * 盈利业务\n * 数据分类 - 常见的数据分析维度有：\n   * 数据量\n   * 唯一性\n   * 实时性\n   * 可丢实性\n   * 可恢复性\n * 数据同步 - 常见的数据同步方案\n   * 存储系统同步\n   * 消息队列同步\n   * 重复生成\n * 异常处理 - 常见异常处理措施：\n   * 多通道同步\n   * 同步和访问结合\n   * 日志记录\n   * 用户补偿\n\n\n# 7.2. 发布流程\n\n高可用的软件质量保证的手段：\n\n * 自动化测试\n * 预发布验证\n * 代码控制\n * 自动化发布\n * 灰度发布\n\n\n# 7.3. 系统监控\n\n> 不允许没有监控的系统上线。\n\n * 监控数据采集\n   * 用户行为日志收集\n     * 服务端日志收集 - apache、nginx 等几乎所有 web 服务器都具备日志记录功能，只要开启日志记录即可。如果是服务器比较多，需要集中采集日志，通常会使用 elastic 来进行收集。\n     * 客户端日志收集 - 利用页面嵌入专门的 javascript 脚本可以收集用户真实的操作行为。\n     * 日志分析 - 可以利用 elasticsearch 做语义分析及搜索；利用实时计算框架 storm、flink 等开发日志统计与分析工具。\n   * 服务器性能监控 - 收集服务器性能指标，如系统负载、内存占用、cpu 占用、磁盘 io、网络 io 等。常用的监控工具有：apache skywalking 、pinpoint 等。\n   * 运行数据报告 - 应该监控一些与具体业务场景相关的技术和业务指标，如：缓存命中率、平均响应时延、tps、qps 等。\n * 监控管理\n   * 系统报警 - 设置阈值。当达到阈值，及时触发告警（短信、邮件、通信工具均可），通过及时判断状况，防患于未然。\n   * 失效转移 - 监控系统可以在发现故障的情况下主动通知应用进行失效转移。\n   * 自动优雅降级\n     * 优雅降级是为了应付突然爆发的访问高峰，主动关闭部分功能，释放部分资源，以保证核心功能的优先访问。\n     * 系统在监控管理基础之上实现自动优雅降级，是柔性架构的理想状态。\n\n\n# 8. 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * 《亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统》\n * 左耳听风",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"系统伸缩性架构",frontmatter:{title:"系统伸缩性架构",date:"2018-07-05T15:11:00.000Z",categories:["架构"],tags:["架构","伸缩性"],permalink:"/pages/ed2a88/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/05.%E7%B3%BB%E7%BB%9F%E4%BC%B8%E7%BC%A9%E6%80%A7%E6%9E%B6%E6%9E%84.html",relativePath:"01.架构/05.系统伸缩性架构.md",key:"v-6097cc9c",path:"/pages/ed2a88/",headers:[{level:2,title:"1. 系统架构的伸缩性设计",slug:"_1-系统架构的伸缩性设计",normalizedTitle:"1. 系统架构的伸缩性设计",charIndex:69},{level:3,title:"1.1. 不同功能进行物理分离实现伸缩",slug:"_1-1-不同功能进行物理分离实现伸缩",normalizedTitle:"1.1. 不同功能进行物理分离实现伸缩",charIndex:87},{level:3,title:"1.2. 单一功能通过集群规模实现伸缩",slug:"_1-2-单一功能通过集群规模实现伸缩",normalizedTitle:"1.2. 单一功能通过集群规模实现伸缩",charIndex:197},{level:2,title:"2. 应用服务器集群的伸缩性设计",slug:"_2-应用服务器集群的伸缩性设计",normalizedTitle:"2. 应用服务器集群的伸缩性设计",charIndex:333},{level:3,title:"2.1. HTTP 重定向负载均衡",slug:"_2-1-http-重定向负载均衡",normalizedTitle:"2.1. http 重定向负载均衡",charIndex:457},{level:3,title:"2.2. DNS 域名解析负载均衡",slug:"_2-2-dns-域名解析负载均衡",normalizedTitle:"2.2. dns 域名解析负载均衡",charIndex:631},{level:3,title:"2.3. 反向代理负载均衡",slug:"_2-3-反向代理负载均衡",normalizedTitle:"2.3. 反向代理负载均衡",charIndex:1164},{level:3,title:"2.4. IP 负载均衡",slug:"_2-4-ip-负载均衡",normalizedTitle:"2.4. ip 负载均衡",charIndex:1265},{level:3,title:"2.5. 数据链路层负载均衡",slug:"_2-5-数据链路层负载均衡",normalizedTitle:"2.5. 数据链路层负载均衡",charIndex:1571},{level:3,title:"2.6. 负载均衡算法",slug:"_2-6-负载均衡算法",normalizedTitle:"2.6. 负载均衡算法",charIndex:1914},{level:2,title:"3. 分布式缓存集群的伸缩性设计",slug:"_3-分布式缓存集群的伸缩性设计",normalizedTitle:"3. 分布式缓存集群的伸缩性设计",charIndex:2512},{level:2,title:"4. 数据存储服务集群的伸缩性设计",slug:"_4-数据存储服务集群的伸缩性设计",normalizedTitle:"4. 数据存储服务集群的伸缩性设计",charIndex:2566},{level:3,title:"4.1. 关系型数据库的伸缩性设计",slug:"_4-1-关系型数据库的伸缩性设计",normalizedTitle:"4.1. 关系型数据库的伸缩性设计",charIndex:2588},{level:3,title:"4.2. NoSql 数据库的伸缩性设计",slug:"_4-2-nosql-数据库的伸缩性设计",normalizedTitle:"4.2. nosql 数据库的伸缩性设计",charIndex:2714},{level:2,title:"5. 参考资料",slug:"_5-参考资料",normalizedTitle:"5. 参考资料",charIndex:2785}],headersStr:"1. 系统架构的伸缩性设计 1.1. 不同功能进行物理分离实现伸缩 1.2. 单一功能通过集群规模实现伸缩 2. 应用服务器集群的伸缩性设计 2.1. HTTP 重定向负载均衡 2.2. DNS 域名解析负载均衡 2.3. 反向代理负载均衡 2.4. IP 负载均衡 2.5. 数据链路层负载均衡 2.6. 负载均衡算法 3. 分布式缓存集群的伸缩性设计 4. 数据存储服务集群的伸缩性设计 4.1. 关系型数据库的伸缩性设计 4.2. NoSql 数据库的伸缩性设计 5. 参考资料",content:"# 系统伸缩性架构\n\n> 伸缩性架构是指不需要改变系统的软硬件设计，仅通过改变部署服务器数量就可以扩大或缩小系统的服务处理能力。\n\n\n# 1. 系统架构的伸缩性设计\n\n\n# 1.1. 不同功能进行物理分离实现伸缩\n\n * 纵向分离（分层后分离） - 将业务处理流程上的不同部分分离部署，实现系统伸缩性。\n * 横向分离（业务分割后分离） - 将不同的业务模块分离部署，实现系统伸缩性。\n\n\n# 1.2. 单一功能通过集群规模实现伸缩\n\n将不同功能分离部署可以实现一定程度的伸缩性，但是随着访问量逐步增加，即使分离到最小粒度的独立部署，单一的服务器也不能满足业务规模的要求。因此必须使用服务器集群，即将相同服务部署在多态服务器上构成一个集群整体对外提供服务。\n\n\n# 2. 应用服务器集群的伸缩性设计\n\n如果 HTTP 请求分发装置可以感知或者可以配置集群的服务器数量，可以及时发现集群中新上线或下线的服务器，并能向新上线的服务器分发请求，停止向已下线的服务器分发请求，那么就实现了应用服务器集群的伸缩性。\n\n\n# 2.1. HTTP 重定向负载均衡\n\n\n\n利用 HTTP 重定向协议实现负载均衡。\n\n这种负载均衡方案的优点是比较简单。\n\n缺点是浏览器需要两次请求服务器才能完成一次访问，性能较差：重定向服务器自身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限；使用 HTTP 302 响应码重定向，可能使搜索引擎判断为 SEO 作弊，降低搜索排名。\n\n\n# 2.2. DNS 域名解析负载均衡\n\n利用 DNS 处理域名解析请求的同时进行负载均衡处理的一种方案。\n\n\n\n在 DNS 服务器中配置多个 A 记录，如：\n\n114.100.40.1 www.mysite.com\n114.100.40.2 www.mysite.com\n114.100.40.3 www.mysite.com\n\n\n每次域名解析请求都会根据负载均衡算法计算一个不同的 IP 地址返回，这样 A 记录中配置的多个服务器就构成一个集群，并可以实现负载均衡。\n\nDNS 域名解析负载均衡的优点：\n\n * 将负载均衡的工作转交给了 DNS，省掉了网站管理维护的麻烦。\n * 同时，许多 DNS 服务器还支持基于地理位置的域名解析，即将域名解析成距离用户地理最近的一个服务器地址，这样可以加快用户访问速度，改善性能。\n\nDNS 域名解析负载均衡的缺点：\n\n * DNS 是多级解析，每一级 DNS 都可能缓存 A 记录，当某台服务器下线后，即使修改了 DNS 的 A 记录，要使其生效也需要较长时间。这段时间，依然会域名解析到已经下线的服务器，导致用户访问失败。\n * DNS 的负载均衡的控制权在域名服务商那里，网站无法对其做更多改善和更强大的管理。\n\n\n# 2.3. 反向代理负载均衡\n\n大多数反向代理服务器同时提供反向代理和负载均衡的功能。\n\n\n\n反向代理服务器的优点是部署简单。缺点是反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。\n\n\n# 2.4. IP 负载均衡\n\n在网络层通过修改请求目标地址进行负载均衡。\n\n\n\n负载均衡服务器（网关服务器）在操作系统内核获取网络数据包，根据负载均衡算法计算得到一台真实 Web 服务器 10.0.0.1，然后将目的 IP 地址修改为 10.0.0.1，不需要通过用户进程。真实 Web 服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器再将数据包原地址修改为自身的 IP 地址（114.100.80.10）发送给浏览器。\n\nIP 负载均衡在内核完成数据分发，所以处理性能优于反向代理负载均衡。但是因为所有请求响应都要经过负载均衡服务器，集群的最大响应数据吞吐量受制于负载均衡服务器网卡带宽。\n\n\n# 2.5. 数据链路层负载均衡\n\n数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。\n\n\n\n这种方式又称作三角传输方式，负载均衡数据分发过程中不修改 IP 地址，只修改目的 mac 地址，通过配置真实物理服务器集群所有机器虚拟 IP 和负载均衡服务器 IP 地址一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的，由于实际处理请求的真实物理服务器 IP 和数据请求目的 IP 一致，不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种负载方式又称作直接路由方式。\n\n在 Linux 平台上最好的链路层负载均衡开源产品是 LVS(Linux Virtual Server)。\n\n\n# 2.6. 负载均衡算法\n\n负载均衡服务器的实现可以分为两个部分：\n\n 1. 根据负载均衡算法和 Web 服务器列表计算得到集群中一台 Web 服务器的地址。\n 2. 将请求数据发送到该地址对应的 Web 服务器上。\n\n负载均衡算法通常有以下几种：\n\n * 轮询（Round Robin） - 所有请求被依次分发到每台应用服务器上，即每台服务器需要处理的请求数据都相同，适合于所有服务器硬件都相同的场景。\n * 加权轮询（Weighted Round Robin） - 根据服务器硬件性能情况，在轮询的基础上，按照配置权重将请求分发到每个服务器，高性能服务器能分配更多请求。\n * 随机（Random） - 请求被随机分配到各个应用服务器，在许多场合下，这种方案都很简单实用，因为好的随机数本身就很平均，即使应用服务器硬件配置不同，也可以使用加权随机算法。\n * 最少连接（Least Connection） - 记录每个应用服务器正在处理的连接数，将新到的请求分发到最少连接的服务器上，应该说，这是最符合负载均衡定义的算法。\n * 源地址 Hash（Source Hash） - 根据请求来源的 IP 地址进行 Hash 计算，得到应用服务器，这样来自同一个 IP 地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，从而实现会话粘滞。\n\n\n# 3. 分布式缓存集群的伸缩性设计\n\n目前比较流行的分布式集群伸缩性方案就是：一致性 HASH 算法\n\n\n# 4. 数据存储服务集群的伸缩性设计\n\n\n# 4.1. 关系型数据库的伸缩性设计\n\n * 主从复制 - 主流关系型数据库一般都支持主从复制。\n * 分库 - 根据业务对数据库进行分割。制约条件是跨库的表不能进行 Join 操作。\n * 分表 - 使用数据库分片中间件，如 Cobar 等。\n\n\n# 4.2. NoSql 数据库的伸缩性设计\n\n一般而言，Nosql 不支持 SQL 和 ACID，但是强化了对于高可用和伸缩性的支持。\n\n\n# 5. 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》",normalizedContent:"# 系统伸缩性架构\n\n> 伸缩性架构是指不需要改变系统的软硬件设计，仅通过改变部署服务器数量就可以扩大或缩小系统的服务处理能力。\n\n\n# 1. 系统架构的伸缩性设计\n\n\n# 1.1. 不同功能进行物理分离实现伸缩\n\n * 纵向分离（分层后分离） - 将业务处理流程上的不同部分分离部署，实现系统伸缩性。\n * 横向分离（业务分割后分离） - 将不同的业务模块分离部署，实现系统伸缩性。\n\n\n# 1.2. 单一功能通过集群规模实现伸缩\n\n将不同功能分离部署可以实现一定程度的伸缩性，但是随着访问量逐步增加，即使分离到最小粒度的独立部署，单一的服务器也不能满足业务规模的要求。因此必须使用服务器集群，即将相同服务部署在多态服务器上构成一个集群整体对外提供服务。\n\n\n# 2. 应用服务器集群的伸缩性设计\n\n如果 http 请求分发装置可以感知或者可以配置集群的服务器数量，可以及时发现集群中新上线或下线的服务器，并能向新上线的服务器分发请求，停止向已下线的服务器分发请求，那么就实现了应用服务器集群的伸缩性。\n\n\n# 2.1. http 重定向负载均衡\n\n\n\n利用 http 重定向协议实现负载均衡。\n\n这种负载均衡方案的优点是比较简单。\n\n缺点是浏览器需要两次请求服务器才能完成一次访问，性能较差：重定向服务器自身的处理能力有可能成为瓶颈，整个集群的伸缩性规模有限；使用 http 302 响应码重定向，可能使搜索引擎判断为 seo 作弊，降低搜索排名。\n\n\n# 2.2. dns 域名解析负载均衡\n\n利用 dns 处理域名解析请求的同时进行负载均衡处理的一种方案。\n\n\n\n在 dns 服务器中配置多个 a 记录，如：\n\n114.100.40.1 www.mysite.com\n114.100.40.2 www.mysite.com\n114.100.40.3 www.mysite.com\n\n\n每次域名解析请求都会根据负载均衡算法计算一个不同的 ip 地址返回，这样 a 记录中配置的多个服务器就构成一个集群，并可以实现负载均衡。\n\ndns 域名解析负载均衡的优点：\n\n * 将负载均衡的工作转交给了 dns，省掉了网站管理维护的麻烦。\n * 同时，许多 dns 服务器还支持基于地理位置的域名解析，即将域名解析成距离用户地理最近的一个服务器地址，这样可以加快用户访问速度，改善性能。\n\ndns 域名解析负载均衡的缺点：\n\n * dns 是多级解析，每一级 dns 都可能缓存 a 记录，当某台服务器下线后，即使修改了 dns 的 a 记录，要使其生效也需要较长时间。这段时间，依然会域名解析到已经下线的服务器，导致用户访问失败。\n * dns 的负载均衡的控制权在域名服务商那里，网站无法对其做更多改善和更强大的管理。\n\n\n# 2.3. 反向代理负载均衡\n\n大多数反向代理服务器同时提供反向代理和负载均衡的功能。\n\n\n\n反向代理服务器的优点是部署简单。缺点是反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈。\n\n\n# 2.4. ip 负载均衡\n\n在网络层通过修改请求目标地址进行负载均衡。\n\n\n\n负载均衡服务器（网关服务器）在操作系统内核获取网络数据包，根据负载均衡算法计算得到一台真实 web 服务器 10.0.0.1，然后将目的 ip 地址修改为 10.0.0.1，不需要通过用户进程。真实 web 服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器再将数据包原地址修改为自身的 ip 地址（114.100.80.10）发送给浏览器。\n\nip 负载均衡在内核完成数据分发，所以处理性能优于反向代理负载均衡。但是因为所有请求响应都要经过负载均衡服务器，集群的最大响应数据吞吐量受制于负载均衡服务器网卡带宽。\n\n\n# 2.5. 数据链路层负载均衡\n\n数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。\n\n\n\n这种方式又称作三角传输方式，负载均衡数据分发过程中不修改 ip 地址，只修改目的 mac 地址，通过配置真实物理服务器集群所有机器虚拟 ip 和负载均衡服务器 ip 地址一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的，由于实际处理请求的真实物理服务器 ip 和数据请求目的 ip 一致，不需要通过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。这种负载方式又称作直接路由方式。\n\n在 linux 平台上最好的链路层负载均衡开源产品是 lvs(linux virtual server)。\n\n\n# 2.6. 负载均衡算法\n\n负载均衡服务器的实现可以分为两个部分：\n\n 1. 根据负载均衡算法和 web 服务器列表计算得到集群中一台 web 服务器的地址。\n 2. 将请求数据发送到该地址对应的 web 服务器上。\n\n负载均衡算法通常有以下几种：\n\n * 轮询（round robin） - 所有请求被依次分发到每台应用服务器上，即每台服务器需要处理的请求数据都相同，适合于所有服务器硬件都相同的场景。\n * 加权轮询（weighted round robin） - 根据服务器硬件性能情况，在轮询的基础上，按照配置权重将请求分发到每个服务器，高性能服务器能分配更多请求。\n * 随机（random） - 请求被随机分配到各个应用服务器，在许多场合下，这种方案都很简单实用，因为好的随机数本身就很平均，即使应用服务器硬件配置不同，也可以使用加权随机算法。\n * 最少连接（least connection） - 记录每个应用服务器正在处理的连接数，将新到的请求分发到最少连接的服务器上，应该说，这是最符合负载均衡定义的算法。\n * 源地址 hash（source hash） - 根据请求来源的 ip 地址进行 hash 计算，得到应用服务器，这样来自同一个 ip 地址的请求总在同一个服务器上处理，该请求的上下文信息可以存储在这台服务器上，在一个会话周期内重复使用，从而实现会话粘滞。\n\n\n# 3. 分布式缓存集群的伸缩性设计\n\n目前比较流行的分布式集群伸缩性方案就是：一致性 hash 算法\n\n\n# 4. 数据存储服务集群的伸缩性设计\n\n\n# 4.1. 关系型数据库的伸缩性设计\n\n * 主从复制 - 主流关系型数据库一般都支持主从复制。\n * 分库 - 根据业务对数据库进行分割。制约条件是跨库的表不能进行 join 操作。\n * 分表 - 使用数据库分片中间件，如 cobar 等。\n\n\n# 4.2. nosql 数据库的伸缩性设计\n\n一般而言，nosql 不支持 sql 和 acid，但是强化了对于高可用和伸缩性的支持。\n\n\n# 5. 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"系统扩展性架构",frontmatter:{title:"系统扩展性架构",date:"2018-07-05T15:11:00.000Z",categories:["架构"],tags:["架构","扩展性"],permalink:"/pages/1580de/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/06.%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E6%80%A7%E6%9E%B6%E6%9E%84.html",relativePath:"01.架构/06.系统扩展性架构.md",key:"v-6395f8b6",path:"/pages/1580de/",headers:[{level:2,title:"1. 可扩展的基本思想",slug:"_1-可扩展的基本思想",normalizedTitle:"1. 可扩展的基本思想",charIndex:328},{level:2,title:"2. 可扩展方式",slug:"_2-可扩展方式",normalizedTitle:"2. 可扩展方式",charIndex:445},{level:3,title:"2.1. 分层架构",slug:"_2-1-分层架构",normalizedTitle:"2.1. 分层架构",charIndex:525},{level:3,title:"2.2. SOA",slug:"_2-2-soa",normalizedTitle:"2.2. soa",charIndex:780},{level:3,title:"2.3. 微服务",slug:"_2-3-微服务",normalizedTitle:"2.3. 微服务",charIndex:1221},{level:3,title:"2.4. 微内核",slug:"_2-4-微内核",normalizedTitle:"2.4. 微内核",charIndex:1764},{level:2,title:"3. 易扩展的系统架构",slug:"_3-易扩展的系统架构",normalizedTitle:"3. 易扩展的系统架构",charIndex:2373},{level:2,title:"4. 利用分布式消息队列降低系统耦合性",slug:"_4-利用分布式消息队列降低系统耦合性",normalizedTitle:"4. 利用分布式消息队列降低系统耦合性",charIndex:2612},{level:3,title:"4.1. 事件驱动架构",slug:"_4-1-事件驱动架构",normalizedTitle:"4.1. 事件驱动架构",charIndex:2636},{level:3,title:"4.2. 分布式消息队列",slug:"_4-2-分布式消息队列",normalizedTitle:"4.2. 分布式消息队列",charIndex:2759},{level:2,title:"5. 利用分布式服务打造可复用的业务平台",slug:"_5-利用分布式服务打造可复用的业务平台",normalizedTitle:"5. 利用分布式服务打造可复用的业务平台",charIndex:3121},{level:2,title:"6. 可扩展的数据结构",slug:"_6-可扩展的数据结构",normalizedTitle:"6. 可扩展的数据结构",charIndex:3455},{level:2,title:"7. 开放平台",slug:"_7-开放平台",normalizedTitle:"7. 开放平台",charIndex:3637},{level:2,title:"8. 参考资料",slug:"_8-参考资料",normalizedTitle:"8. 参考资料",charIndex:3817}],headersStr:"1. 可扩展的基本思想 2. 可扩展方式 2.1. 分层架构 2.2. SOA 2.3. 微服务 2.4. 微内核 3. 易扩展的系统架构 4. 利用分布式消息队列降低系统耦合性 4.1. 事件驱动架构 4.2. 分布式消息队列 5. 利用分布式服务打造可复用的业务平台 6. 可扩展的数据结构 7. 开放平台 8. 参考资料",content:"# 系统扩展性架构\n\n> 扩展性和伸缩性是不同的概念：\n> \n>  * 扩展性（Extensibility） - 指对现有系统影响最小的情况下，系统功能可持续扩展或提升的能力。表现在系统基础设施稳定不需要经常变更，应用之间较少依赖和耦合，对需求变更可以敏捷响应。它是系统架构设计层面的开闭原则（对扩展开放、对修改关闭），架构设计考虑未来功能扩展，当系统增加新功能时，不需要对现有系统的结构和代码进行修改。\n>  * 伸缩性（Scalability） - 指系统能够通过增加减少自身资源规模的方式增减自己计算处理事务的能力。如果这种增减是成比例的，就被称作线性伸缩性。在网站架构中 ，通常指利用集群的方式增加服务器数量、提高系统的整体事务吞吐能力。\n\n\n# 1. 可扩展的基本思想\n\n * 面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一部分。\n * 面向服务拆分：将系统提供的服务拆分，每个服务作为一部分。\n * 面向功能拆分：将系统提供的功能拆分，每个功能作为一部分。\n\n\n# 2. 可扩展方式\n\n典型的可扩展系统架构有：\n\n * 面向流程拆分：分层架构。\n * 面向服务拆分：SOA、微服务。\n * 面向功能拆分：微内核架构。\n\n\n# 2.1. 分层架构\n\n分层架构的核心点时：需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构\n\n分层架构是很常见的架构模式，它也叫 N 层架构，通常情况下，N 至少是 2 层。例如，C/S 架构、B/S 架构。常见的是 3 层架构（例如，MVC、MVP 架构）、4 层架构，5 层架构的比较少见，一般是比较复杂的系统才会达到或者超过 5 层，比如操作系统内核架构。\n\n典型分层架构：\n\n * C/S 架构、B/S 架构\n * MVC 架构、MVP 架构\n * 逻辑分层架构\n\n\n# 2.2. SOA\n\nSOA 的全称是 Service Oriented Architecture，即“面向服务的架构”。\n\nSOA 提出了 3 个关键概念。\n\n * 服务 - 所有业务功能都是一项服务，服务就意味着要对外提供开放的能力，当其他系统需要使用这项功能时，无须定制化开发。\n * ESB - ESB 的全称是 Enterprise Service Bus，即 “企业服务总线”。ESB 将企业中各个不同的服务连接在一起。因为各个独立的服务是异构的，如果没有统一的标准，则各个异构系统对外提供的接口是各式各样的。SOA 使用 ESB 来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。\n * 松耦合 - 松耦合的目的是减少各个服务间的依赖和互相影响。因为采用 SOA 架构后，各个服务是相互独立运行的，甚至都不清楚某个服务到底有多少对其他服务的依赖。如果做不到松耦合，某个服务一升级，依赖它的其他服务全部故障，这样肯定是无法满足业务需求的。\n\n\n# 2.3. 微服务\n\n微服务是去掉 ESB 后的 SOA。\n\n微服务的问题：\n\n * 服务划分过细，服务间关系复杂 - 服务划分过细，单个服务的复杂度确实下降了，但整个系统的复杂度却上升了，因为微服务将系统内的复杂度转移为系统间的复杂度了。\n * 服务数量太多，团队效率急剧下降\n * 调用链太长，性能下降\n * 调用链太长，问题定位困难\n * 没有自动化支撑，无法快速交付\n * 没有服务治理，微服务数量多了后管理混乱\n\n微服务拆分：\n\n * 基于业务逻辑拆分\n * 基于可扩展拆分 - 将已经成熟和改动不大的服务拆分为稳定服务，将经常变化和迭代的服务拆分为变动服务。\n * 基于可靠性拆分 - 将系统中的业务模块按照优先级排序，将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来，然后重点保证核心服务的高可用。\n\n基础设施：\n\n * 服务发现、服务路由、服务容错：这是最基本的微服务基础设施。\n * 接口框架、API 网关：主要是为了提升开发效率，接口框架是提升内部服务的开发效率，API 网关是为了提升与外部服务对接的效率。\n * 自动化部署、自动化测试、配置中心：主要是为了提升测试和运维效率。\n * 服务监控、服务跟踪、服务安全：主要是为了进一步提升运维效率。\n\n\n# 2.4. 微内核\n\n\n\n微内核的核心系统设计的关键技术有：插件管理、插件连接和插件通信。\n\n插件管理\n\n核心系统需要知道当前有哪些插件可用，如何加载这些插件，什么时候加载插件。常见的实现方法是插件注册表机制。核心系统提供插件注册表（可以是配置文件，也可以是代码，还可以是数据库），插件注册表含有每个插件模块的信息，包括它的名字、位置、加载时机（启动就加载，还是按需加载）等。\n\n插件连接\n\n插件连接指插件如何连接到核心系统。通常来说，核心系统必须制定插件和核心系统的连接规范，然后插件按照规范实现，核心系统按照规范加载即可。\n\n常见的连接机制有 OSGi（Eclipse 使用）、消息模式、依赖注入（Spring 使用），甚至使用分布式的协议都是可以的，比如 RPC 或者 HTTP Web 的方式。\n\n插件通信\n\n插件通信指插件间的通信。虽然设计的时候插件间是完全解耦的，但实际业务运行过程中，必然会出现某个业务流程需要多个插件协作，这就要求两个插件间进行通信。由于插件之间没有直接联系，通信必须通过核心系统，因此核心系统需要提供插件通信机制。这种情况和计算机类似，计算机的 CPU、硬盘、内存、网卡是独立设计的配件，但计算机运行过程中，CPU 和内存、内存和硬盘肯定是有通信的，计算机通过主板上的总线提供了这些组件之间的通信功能。微内核的核心系统也必须提供类似的通信机制，各个插件之间才能进行正常的通信。\n\n\n# 3. 易扩展的系统架构\n\n> 低耦合的系统更容易扩展、复用。\n\n可扩展架构的核心思想是模块化，并在此基础上，降低模块间的耦合性，提高模块的复用性。\n\n分层和分割不仅可以进行架构伸缩，也是模块化设计的重要手段，利用分层和分割的方式将软件分割为若干个低耦合的独立的组件模块，这些组件模块以消息传递及依赖调用的方式聚合成一个完整的系统。\n\n在大型网站中，这些模块通过分布式部署的方式，独立的模块部署在独立的服务器上，从物理上分离模块间的耦合关系，进一步降低耦合性提高复用性。\n\n\n# 4. 利用分布式消息队列降低系统耦合性\n\n\n# 4.1. 事件驱动架构\n\n事件驱动架构通过在低耦合的模块间传输事件消息，以保持模块的松散耦合，并借助事件消息的通信完成模块间合作。典型的事件驱动架构就是操作系统中常见的生产者消费者模式。在大型网站中，最常见的实现手段就是分布式消息队列。\n\n\n# 4.2. 分布式消息队列\n\n消息生产者应用程序通过远程访问接口将消息推送给消息队列服务器，消息队列服务器将消息写入本地内存队列后立即返回成功响应给消息生产者。消息队列服务器根据消息订阅列表查找订阅该消息的消息消费者应用程序，将消息队列中的消息按照先进先出（FIFO）的原则将消息通过远程通信接口发送给消息消费者程序。\n\n\n\n在伸缩性方面，由于消息队列服务器上的数据可以看作是即时处理的，因此类似于无状态的服务器，伸缩性设计比较简单。将新服务器加入分布式消息队列集群中，通知生产者服务器更改消息队列服务器列表即可。\n\n在可用性方面，为了避免消费者进程处理缓慢，分布式消息队列服务器内存空间不足造成的问题，如果内存队列已满，会将消息写入磁盘，消息推送模块在将内存队列消息处理完成以后，将磁盘内容加载到内存队列继续处理。\n\n\n# 5. 利用分布式服务打造可复用的业务平台\n\n巨无霸系统的问题：\n\n * 构建、部署困难\n * 代码分支管理困难\n * 数据库连接耗尽\n * 扩展业务困难\n\n而解决巨无霸系统问题的方案就是拆分：\n\n * 通过纵向拆分将业务拆分多个应用或模块；\n * 通过横向拆分将可复用业务作为独立应用。\n\n然后，需要通过一个分布式服务管理框架将这些应用或服务组织管理起来：通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务调用。常见的分布式服务管理框架如：Spring Cloud、Dubbo 等。\n\n大型网站分布式服务的需求与特点：\n\n * 负载均衡\n * 失效转移\n * 高效的远程通信\n * 整合异构系统\n * 对应用最少侵入\n * 版本管理\n * 实时监控\n\n\n# 6. 可扩展的数据结构\n\n传统的关系型数据库为了保证关系运算的正确性，在设计数据库表结构的时候，就需要指定表的 schema ——字段名称，数据类型等，并要遵循特定的设计范式。这些规范带来一个问题：难以面对需求变更带来的挑战，所以有人通过预先设计一些冗余字段来应对。\n\n许多 NoSql 数据库使用 ColumnFamily 设计来设计可扩展的数据结构。\n\n\n# 7. 开放平台\n\n很多大公司会利用开放平台提供大量开放性 API 使得企业和个人可以方便的接入业务。通过开放平台，可以构建生态圈，提升品牌价值以及竞争力。\n\n开放平台不是一朝一夕完成的，这需要大量 OPEN API 的沉淀。系统架构在设计之初，应该有意识的将未来可能被复用的接口好好设计，以便于需要开放 OPEN API 时，可以便捷的暴露服务接口。\n\n\n# 8. 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》",normalizedContent:"# 系统扩展性架构\n\n> 扩展性和伸缩性是不同的概念：\n> \n>  * 扩展性（extensibility） - 指对现有系统影响最小的情况下，系统功能可持续扩展或提升的能力。表现在系统基础设施稳定不需要经常变更，应用之间较少依赖和耦合，对需求变更可以敏捷响应。它是系统架构设计层面的开闭原则（对扩展开放、对修改关闭），架构设计考虑未来功能扩展，当系统增加新功能时，不需要对现有系统的结构和代码进行修改。\n>  * 伸缩性（scalability） - 指系统能够通过增加减少自身资源规模的方式增减自己计算处理事务的能力。如果这种增减是成比例的，就被称作线性伸缩性。在网站架构中 ，通常指利用集群的方式增加服务器数量、提高系统的整体事务吞吐能力。\n\n\n# 1. 可扩展的基本思想\n\n * 面向流程拆分：将整个业务流程拆分为几个阶段，每个阶段作为一部分。\n * 面向服务拆分：将系统提供的服务拆分，每个服务作为一部分。\n * 面向功能拆分：将系统提供的功能拆分，每个功能作为一部分。\n\n\n# 2. 可扩展方式\n\n典型的可扩展系统架构有：\n\n * 面向流程拆分：分层架构。\n * 面向服务拆分：soa、微服务。\n * 面向功能拆分：微内核架构。\n\n\n# 2.1. 分层架构\n\n分层架构的核心点时：需要保证各层之间的差异足够清晰，边界足够明显，让人看到架构图后就能看懂整个架构\n\n分层架构是很常见的架构模式，它也叫 n 层架构，通常情况下，n 至少是 2 层。例如，c/s 架构、b/s 架构。常见的是 3 层架构（例如，mvc、mvp 架构）、4 层架构，5 层架构的比较少见，一般是比较复杂的系统才会达到或者超过 5 层，比如操作系统内核架构。\n\n典型分层架构：\n\n * c/s 架构、b/s 架构\n * mvc 架构、mvp 架构\n * 逻辑分层架构\n\n\n# 2.2. soa\n\nsoa 的全称是 service oriented architecture，即“面向服务的架构”。\n\nsoa 提出了 3 个关键概念。\n\n * 服务 - 所有业务功能都是一项服务，服务就意味着要对外提供开放的能力，当其他系统需要使用这项功能时，无须定制化开发。\n * esb - esb 的全称是 enterprise service bus，即 “企业服务总线”。esb 将企业中各个不同的服务连接在一起。因为各个独立的服务是异构的，如果没有统一的标准，则各个异构系统对外提供的接口是各式各样的。soa 使用 esb 来屏蔽异构系统对外提供各种不同的接口方式，以此来达到服务间高效的互联互通。\n * 松耦合 - 松耦合的目的是减少各个服务间的依赖和互相影响。因为采用 soa 架构后，各个服务是相互独立运行的，甚至都不清楚某个服务到底有多少对其他服务的依赖。如果做不到松耦合，某个服务一升级，依赖它的其他服务全部故障，这样肯定是无法满足业务需求的。\n\n\n# 2.3. 微服务\n\n微服务是去掉 esb 后的 soa。\n\n微服务的问题：\n\n * 服务划分过细，服务间关系复杂 - 服务划分过细，单个服务的复杂度确实下降了，但整个系统的复杂度却上升了，因为微服务将系统内的复杂度转移为系统间的复杂度了。\n * 服务数量太多，团队效率急剧下降\n * 调用链太长，性能下降\n * 调用链太长，问题定位困难\n * 没有自动化支撑，无法快速交付\n * 没有服务治理，微服务数量多了后管理混乱\n\n微服务拆分：\n\n * 基于业务逻辑拆分\n * 基于可扩展拆分 - 将已经成熟和改动不大的服务拆分为稳定服务，将经常变化和迭代的服务拆分为变动服务。\n * 基于可靠性拆分 - 将系统中的业务模块按照优先级排序，将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来，然后重点保证核心服务的高可用。\n\n基础设施：\n\n * 服务发现、服务路由、服务容错：这是最基本的微服务基础设施。\n * 接口框架、api 网关：主要是为了提升开发效率，接口框架是提升内部服务的开发效率，api 网关是为了提升与外部服务对接的效率。\n * 自动化部署、自动化测试、配置中心：主要是为了提升测试和运维效率。\n * 服务监控、服务跟踪、服务安全：主要是为了进一步提升运维效率。\n\n\n# 2.4. 微内核\n\n\n\n微内核的核心系统设计的关键技术有：插件管理、插件连接和插件通信。\n\n插件管理\n\n核心系统需要知道当前有哪些插件可用，如何加载这些插件，什么时候加载插件。常见的实现方法是插件注册表机制。核心系统提供插件注册表（可以是配置文件，也可以是代码，还可以是数据库），插件注册表含有每个插件模块的信息，包括它的名字、位置、加载时机（启动就加载，还是按需加载）等。\n\n插件连接\n\n插件连接指插件如何连接到核心系统。通常来说，核心系统必须制定插件和核心系统的连接规范，然后插件按照规范实现，核心系统按照规范加载即可。\n\n常见的连接机制有 osgi（eclipse 使用）、消息模式、依赖注入（spring 使用），甚至使用分布式的协议都是可以的，比如 rpc 或者 http web 的方式。\n\n插件通信\n\n插件通信指插件间的通信。虽然设计的时候插件间是完全解耦的，但实际业务运行过程中，必然会出现某个业务流程需要多个插件协作，这就要求两个插件间进行通信。由于插件之间没有直接联系，通信必须通过核心系统，因此核心系统需要提供插件通信机制。这种情况和计算机类似，计算机的 cpu、硬盘、内存、网卡是独立设计的配件，但计算机运行过程中，cpu 和内存、内存和硬盘肯定是有通信的，计算机通过主板上的总线提供了这些组件之间的通信功能。微内核的核心系统也必须提供类似的通信机制，各个插件之间才能进行正常的通信。\n\n\n# 3. 易扩展的系统架构\n\n> 低耦合的系统更容易扩展、复用。\n\n可扩展架构的核心思想是模块化，并在此基础上，降低模块间的耦合性，提高模块的复用性。\n\n分层和分割不仅可以进行架构伸缩，也是模块化设计的重要手段，利用分层和分割的方式将软件分割为若干个低耦合的独立的组件模块，这些组件模块以消息传递及依赖调用的方式聚合成一个完整的系统。\n\n在大型网站中，这些模块通过分布式部署的方式，独立的模块部署在独立的服务器上，从物理上分离模块间的耦合关系，进一步降低耦合性提高复用性。\n\n\n# 4. 利用分布式消息队列降低系统耦合性\n\n\n# 4.1. 事件驱动架构\n\n事件驱动架构通过在低耦合的模块间传输事件消息，以保持模块的松散耦合，并借助事件消息的通信完成模块间合作。典型的事件驱动架构就是操作系统中常见的生产者消费者模式。在大型网站中，最常见的实现手段就是分布式消息队列。\n\n\n# 4.2. 分布式消息队列\n\n消息生产者应用程序通过远程访问接口将消息推送给消息队列服务器，消息队列服务器将消息写入本地内存队列后立即返回成功响应给消息生产者。消息队列服务器根据消息订阅列表查找订阅该消息的消息消费者应用程序，将消息队列中的消息按照先进先出（fifo）的原则将消息通过远程通信接口发送给消息消费者程序。\n\n\n\n在伸缩性方面，由于消息队列服务器上的数据可以看作是即时处理的，因此类似于无状态的服务器，伸缩性设计比较简单。将新服务器加入分布式消息队列集群中，通知生产者服务器更改消息队列服务器列表即可。\n\n在可用性方面，为了避免消费者进程处理缓慢，分布式消息队列服务器内存空间不足造成的问题，如果内存队列已满，会将消息写入磁盘，消息推送模块在将内存队列消息处理完成以后，将磁盘内容加载到内存队列继续处理。\n\n\n# 5. 利用分布式服务打造可复用的业务平台\n\n巨无霸系统的问题：\n\n * 构建、部署困难\n * 代码分支管理困难\n * 数据库连接耗尽\n * 扩展业务困难\n\n而解决巨无霸系统问题的方案就是拆分：\n\n * 通过纵向拆分将业务拆分多个应用或模块；\n * 通过横向拆分将可复用业务作为独立应用。\n\n然后，需要通过一个分布式服务管理框架将这些应用或服务组织管理起来：通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务调用。常见的分布式服务管理框架如：spring cloud、dubbo 等。\n\n大型网站分布式服务的需求与特点：\n\n * 负载均衡\n * 失效转移\n * 高效的远程通信\n * 整合异构系统\n * 对应用最少侵入\n * 版本管理\n * 实时监控\n\n\n# 6. 可扩展的数据结构\n\n传统的关系型数据库为了保证关系运算的正确性，在设计数据库表结构的时候，就需要指定表的 schema ——字段名称，数据类型等，并要遵循特定的设计范式。这些规范带来一个问题：难以面对需求变更带来的挑战，所以有人通过预先设计一些冗余字段来应对。\n\n许多 nosql 数据库使用 columnfamily 设计来设计可扩展的数据结构。\n\n\n# 7. 开放平台\n\n很多大公司会利用开放平台提供大量开放性 api 使得企业和个人可以方便的接入业务。通过开放平台，可以构建生态圈，提升品牌价值以及竞争力。\n\n开放平台不是一朝一夕完成的，这需要大量 open api 的沉淀。系统架构在设计之初，应该有意识的将未来可能被复用的接口好好设计，以便于需要开放 open api 时，可以便捷的暴露服务接口。\n\n\n# 8. 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"系统安全性架构",frontmatter:{title:"系统安全性架构",date:"2018-07-05T15:11:00.000Z",categories:["架构"],tags:["架构","安全"],permalink:"/pages/039552/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/07.%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E6%80%A7%E6%9E%B6%E6%9E%84.html",relativePath:"01.架构/07.系统安全性架构.md",key:"v-11101d84",path:"/pages/039552/",headers:[{level:2,title:"1. 认证",slug:"_1-认证",normalizedTitle:"1. 认证",charIndex:54},{level:3,title:"1.1. SSO",slug:"_1-1-sso",normalizedTitle:"1.1. sso",charIndex:64},{level:4,title:"1.1.1. Session 共享问题",slug:"_1-1-1-session-共享问题",normalizedTitle:"1.1.1. session 共享问题",charIndex:184},{level:4,title:"1.1.2. Cookie 跨域",slug:"_1-1-2-cookie-跨域",normalizedTitle:"1.1.2. cookie 跨域",charIndex:455},{level:4,title:"1.1.3. CAS",slug:"_1-1-3-cas",normalizedTitle:"1.1.3. cas",charIndex:837},{level:3,title:"1.2. Oauth 2.0",slug:"_1-2-oauth-2-0",normalizedTitle:"1.2. oauth 2.0",charIndex:2109},{level:4,title:"1.2.1. 基本原理",slug:"_1-2-1-基本原理",normalizedTitle:"1.2.1. 基本原理",charIndex:2127},{level:4,title:"1.2.2. 授权模式",slug:"_1-2-2-授权模式",normalizedTitle:"1.2.2. 授权模式",charIndex:2613},{level:4,title:"1.2.3. 授权码模式",slug:"_1-2-3-授权码模式",normalizedTitle:"1.2.3. 授权码模式",charIndex:2827},{level:4,title:"1.2.4. 简化模式",slug:"_1-2-4-简化模式",normalizedTitle:"1.2.4. 简化模式",charIndex:4943},{level:4,title:"1.2.5. 更新令牌",slug:"_1-2-5-更新令牌",normalizedTitle:"1.2.5. 更新令牌",charIndex:8081},{level:2,title:"2. 鉴权",slug:"_2-鉴权",normalizedTitle:"2. 鉴权",charIndex:8530},{level:3,title:"2.1. RBAC",slug:"_2-1-rbac",normalizedTitle:"2.1. rbac",charIndex:8540},{level:3,title:"2.2. 角色继承",slug:"_2-2-角色继承",normalizedTitle:"2.2. 角色继承",charIndex:8746},{level:4,title:"2.2.1. 职责分离(Separation of Duty)",slug:"_2-2-1-职责分离-separation-of-duty",normalizedTitle:"2.2.1. 职责分离(separation of duty)",charIndex:8857},{level:3,title:"2.3. RBAC0 模型",slug:"_2-3-rbac0-模型",normalizedTitle:"2.3. rbac0 模型",charIndex:9198},{level:3,title:"2.4. RBAC1 模型",slug:"_2-4-rbac1-模型",normalizedTitle:"2.4. rbac1 模型",charIndex:9499},{level:3,title:"2.5. RBAC2 模型",slug:"_2-5-rbac2-模型",normalizedTitle:"2.5. rbac2 模型",charIndex:9742},{level:3,title:"2.6. RBAC3 模型",slug:"_2-6-rbac3-模型",normalizedTitle:"2.6. rbac3 模型",charIndex:10081},{level:3,title:"2.7. 什么是权限",slug:"_2-7-什么是权限",normalizedTitle:"2.7. 什么是权限",charIndex:10189},{level:3,title:"2.8. 用户组的使用",slug:"_2-8-用户组的使用",normalizedTitle:"2.8. 用户组的使用",charIndex:11088},{level:3,title:"2.9. 实例分析",slug:"_2-9-实例分析",normalizedTitle:"2.9. 实例分析",charIndex:11533},{level:3,title:"2.10. 如何设计 RBAC 权限系统",slug:"_2-10-如何设计-rbac-权限系统",normalizedTitle:"2.10. 如何设计 rbac 权限系统",charIndex:11547},{level:3,title:"2.11. 实例分析",slug:"_2-11-实例分析",normalizedTitle:"2.11. 实例分析",charIndex:11960},{level:2,title:"3. 审计",slug:"_3-审计",normalizedTitle:"3. 审计",charIndex:12334},{level:2,title:"4. 网站攻击",slug:"_4-网站攻击",normalizedTitle:"4. 网站攻击",charIndex:12350},{level:3,title:"4.1. XSS",slug:"_4-1-xss",normalizedTitle:"4.1. xss",charIndex:12423},{level:4,title:"4.1.1. 概念",slug:"_4-1-1-概念",normalizedTitle:"4.1.1. 概念",charIndex:12435},{level:4,title:"4.1.2. 攻击手段和目的",slug:"_4-1-2-攻击手段和目的",normalizedTitle:"4.1.2. 攻击手段和目的",charIndex:12904},{level:4,title:"4.1.3. 应对手段",slug:"_4-1-3-应对手段",normalizedTitle:"4.1.3. 应对手段",charIndex:13222},{level:3,title:"4.2. CSRF",slug:"_4-2-csrf",normalizedTitle:"4.2. csrf",charIndex:13556},{level:4,title:"4.2.1. 概念",slug:"_4-2-1-概念",normalizedTitle:"4.2.1. 概念",charIndex:13569},{level:4,title:"4.2.2. 攻击手段和目的",slug:"_4-2-2-攻击手段和目的",normalizedTitle:"4.2.2. 攻击手段和目的",charIndex:13777},{level:4,title:"4.2.3. 应对手段",slug:"_4-2-3-应对手段",normalizedTitle:"4.2.3. 应对手段",charIndex:13910},{level:3,title:"4.3. SQL 注入",slug:"_4-3-sql-注入",normalizedTitle:"4.3. sql 注入",charIndex:14250},{level:4,title:"4.3.1. 概念",slug:"_4-3-1-概念",normalizedTitle:"4.3.1. 概念",charIndex:14265},{level:4,title:"4.3.2. 攻击手段和目的",slug:"_4-3-2-攻击手段和目的",normalizedTitle:"4.3.2. 攻击手段和目的",charIndex:15574},{level:4,title:"4.3.3. 应对手段",slug:"_4-3-3-应对手段",normalizedTitle:"4.3.3. 应对手段",charIndex:15918},{level:3,title:"4.4. DoS",slug:"_4-4-dos",normalizedTitle:"4.4. dos",charIndex:16236},{level:4,title:"4.4.1. 攻击方式",slug:"_4-4-1-攻击方式",normalizedTitle:"4.4.1. 攻击方式",charIndex:16464},{level:4,title:"4.4.2. 应对手段",slug:"_4-4-2-应对手段",normalizedTitle:"4.4.2. 应对手段",charIndex:16502},{level:2,title:"5. 加密技术",slug:"_5-加密技术",normalizedTitle:"5. 加密技术",charIndex:16695},{level:3,title:"5.1. 消息摘要",slug:"_5-1-消息摘要",normalizedTitle:"5.1. 消息摘要",charIndex:16818},{level:3,title:"5.2. 加密算法",slug:"_5-2-加密算法",normalizedTitle:"5.2. 加密算法",charIndex:16903},{level:4,title:"5.2.1. 对称加密",slug:"_5-2-1-对称加密",normalizedTitle:"5.2.1. 对称加密",charIndex:16916},{level:4,title:"5.2.2. 非对称加密",slug:"_5-2-2-非对称加密",normalizedTitle:"5.2.2. 非对称加密",charIndex:17e3},{level:4,title:"5.2.3. 密钥安全管理",slug:"_5-2-3-密钥安全管理",normalizedTitle:"5.2.3. 密钥安全管理",charIndex:17177},{level:3,title:"5.3. 证书",slug:"_5-3-证书",normalizedTitle:"5.3. 证书",charIndex:17338},{level:4,title:"5.3.1. 证书原理",slug:"_5-3-1-证书原理",normalizedTitle:"5.3.1. 证书原理",charIndex:17895},{level:2,title:"6. 信息过滤",slug:"_6-信息过滤",normalizedTitle:"6. 信息过滤",charIndex:18341},{level:3,title:"6.1. 文本匹配",slug:"_6-1-文本匹配",normalizedTitle:"6.1. 文本匹配",charIndex:18394},{level:3,title:"6.2. 黑名单",slug:"_6-2-黑名单",normalizedTitle:"6.2. 黑名单",charIndex:18454},{level:3,title:"6.3. 分类算法",slug:"_6-3-分类算法",normalizedTitle:"6.3. 分类算法",charIndex:18634},{level:2,title:"7. 风险控制",slug:"_7-风险控制",normalizedTitle:"7. 风险控制",charIndex:18784},{level:3,title:"7.1. 风险种类",slug:"_7-1-风险种类",normalizedTitle:"7.1. 风险种类",charIndex:18884},{level:3,title:"7.2. 风险控制手段",slug:"_7-2-风险控制手段",normalizedTitle:"7.2. 风险控制手段",charIndex:19016},{level:3,title:"7.3. 规则引擎",slug:"_7-3-规则引擎",normalizedTitle:"7.3. 规则引擎",charIndex:19109},{level:3,title:"7.4. 统计模型",slug:"_7-4-统计模型",normalizedTitle:"7.4. 统计模型",charIndex:19346},{level:2,title:"8. 参考资料",slug:"_8-参考资料",normalizedTitle:"8. 参考资料",charIndex:19586}],headersStr:"1. 认证 1.1. SSO 1.1.1. Session 共享问题 1.1.2. Cookie 跨域 1.1.3. CAS 1.2. Oauth 2.0 1.2.1. 基本原理 1.2.2. 授权模式 1.2.3. 授权码模式 1.2.4. 简化模式 1.2.5. 更新令牌 2. 鉴权 2.1. RBAC 2.2. 角色继承 2.2.1. 职责分离(Separation of Duty) 2.3. RBAC0 模型 2.4. RBAC1 模型 2.5. RBAC2 模型 2.6. RBAC3 模型 2.7. 什么是权限 2.8. 用户组的使用 2.9. 实例分析 2.10. 如何设计 RBAC 权限系统 2.11. 实例分析 3. 审计 4. 网站攻击 4.1. XSS 4.1.1. 概念 4.1.2. 攻击手段和目的 4.1.3. 应对手段 4.2. CSRF 4.2.1. 概念 4.2.2. 攻击手段和目的 4.2.3. 应对手段 4.3. SQL 注入 4.3.1. 概念 4.3.2. 攻击手段和目的 4.3.3. 应对手段 4.4. DoS 4.4.1. 攻击方式 4.4.2. 应对手段 5. 加密技术 5.1. 消息摘要 5.2. 加密算法 5.2.1. 对称加密 5.2.2. 非对称加密 5.2.3. 密钥安全管理 5.3. 证书 5.3.1. 证书原理 6. 信息过滤 6.1. 文本匹配 6.2. 黑名单 6.3. 分类算法 7. 风险控制 7.1. 风险种类 7.2. 风险控制手段 7.3. 规则引擎 7.4. 统计模型 8. 参考资料",content:'# 系统安全性架构\n\n> 关键词：XSS、CSRF、SQL 注入、DoS、消息摘要、加密算法、证书\n\n\n# 1. 认证\n\n\n# 1.1. SSO\n\nSSO(Single Sign On)，即单点登录。所谓单点登录，就是同平台的诸多应用登陆一次，下一次就免登陆的功能。\n\nSSO 需要解决多个异构系统之间的问题：\n\n * Session 共享问题\n * 跨域问题\n\n# 1.1.1. Session 共享问题\n\n分布式 Session 的几种实现策略：\n\n * 粘性 Session - 缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。\n * 应用服务器间的 Session 复制共享 - 缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。\n * 基于缓存的 Session 共享 ✅ （推荐方案） - 不过需要程序自身控制 Session 读写，可以考虑基于 spring-session + redis 这种成熟的方案来处理。\n\n> 详情请参考：Session 原理\n\n# 1.1.2. Cookie 跨域\n\nCookie 不能跨域！比如：浏览器不会把 www.google.com 的 cookie 传给 www.baidu.com。\n\n这就存在一个问题：由于域名不同，用户在系统 A 登录后，浏览器记录系统 A 的 Cookie，但是访问系统 B 的时候不会携带这个 Cookie。\n\n针对 Cookie 不能跨域 的问题，有几种解决方案：\n\n * 服务端生成 Cookie 后，返回给客户端，客户端解析 Cookie ，提取 Token （比如 JWT），此后每次请求都携带这个 Token。\n * 多个域名共享 Cookie，在返回 Cookie 给客户端的时候，在 Cookie 中设置 domain 白名单。\n * 将 Token 保存在 SessionStroage 中（不依赖 Cookie 就没有跨域的问题了）。\n\n# 1.1.3. CAS\n\nCAS 是实现 SSO 的主流方式。\n\nCAS 分为两部分，CAS Server 和 CAS Client\n\n * CAS Server - 负责用户的认证工作，就像是把第一次登录用户的一个标识存在这里，以便此用户在其他系统登录时验证其需不需要再次登录。\n * CAS Client - 业务应用，需要接入 CAS Server。当用户访问我们的应用时，首先需要重定向到 CAS Server 端进行验证，要是原来登陆过，就免去登录，重定向到下游系统，否则进行用户名密码登陆操作。\n\n术语：\n\n * Ticket Granting Ticket (TGT) - 可以认为是 CAS Server 根据用户名、密码生成的一张票，存在 Server 端。\n * Ticket Granting Cookie (TGC) - 其实就是一个 Cookie，存放用户身份信息，由 Server 发给 Client 端。\n * Service Ticket (ST) - 由 TGT 生成的一次性票据，用于验证，只能用一次。\n\nCAS 工作流程：\n\n\n\n 1. 用户访问 CAS Client A（业务系统），第一次访问，重定向到认证服务中心（CAS Server）。CAS Server 发现当前请求中没有 Cookie，再重定向到 CAS Server 的登录页面。重定向请求的 URL 中包含访问地址，以便认证成功后直接跳转到访问页面。\n 2. 用户在登录页面输入用户名、密码等认证信息，认证成功后，CAS Server 生成 TGT，再用 TGT 生成一个 ST。然后返回 ST 和 TGC（Cookie）给浏览器。\n 3. 浏览器携带 ST 再度访问之前想访问的 CAS Client A 页面。\n 4. CAS Client A 收到 ST 后，向 CAS Server 验证 ST 的有效性。验证通过则允许用户访问页面。\n 5. 此时，如果登录另一个 CAS Client B，会先重定向到 CAS Server，CAS Server 可以判断这个 CAS Client B 是第一次访问，但是本地有 TGC，所以无需再次登录。用 TGC 创建一个 ST，返回给浏览器。\n 6. 重复类似 3、4 步骤。\n\n\n\n以上了归纳总结如下：\n\n 1. 访问服务 - 用户访问 SSO Client 资源。\n 2. 定向认证 - SSO Client 重定向用户请求到 SSO Server。\n 3. 用户认证 - 用户身份认证。\n 4. 发放票据 - SSO Server 会产生一个 Service Ticket (ST) 并返回给浏览器。\n 5. 验证票据 - 浏览器每次访问 SSO Client 时，携带 ST，SSO Client 向 SSO Server 验证票据。只有验证通过，才允许访问。\n 6. 传输用户信息 - SSO Server 验证票据通过后，传输用户认证结果信息给 SSO Client。\n\n\n# 1.2. Oauth 2.0\n\n# 1.2.1. 基本原理\n\nOAuth 在"客户端"与"服务提供商"之间，设置了一个授权层（authorization layer）。"客户端"不能直接登录"服务提供商"，只能登录授权层，以此将用户与客户端区分开来。"客户端"登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。\n\n"客户端"登录授权层以后，"服务提供商"根据令牌的权限范围和有效期，向"客户端"开放用户储存的资料。\n\nOAuth 2.0 的运行流程如下图，摘自 RFC 6749。\n\n\n（A）用户打开客户端以后，客户端要求用户给予授权。\n\n（B）用户同意给予客户端授权。\n\n（C）客户端使用上一步获得的授权，向认证服务器申请令牌。\n\n（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。\n\n（E）客户端使用令牌，向资源服务器申请获取资源。\n\n（F）资源服务器确认令牌无误，同意向客户端开放资源。\n\n不难看出来，上面六个步骤之中，B 是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。\n\n# 1.2.2. 授权模式\n\n客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。OAuth 2.0 定义了四种授权方式。\n\n * 授权码模式（authorization code）\n * 简化模式（implicit）\n * 密码模式（resource owner password credentials）\n * 客户端模式（client credentials）\n\n# 1.2.3. 授权码模式\n\n授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与"服务提供商"的认证服务器进行互动。\n\n\n它的步骤如下：\n\n（A）用户访问客户端，后者将前者导向认证服务器。\n\n（B）用户选择是否给予客户端授权。\n\n（C）假设用户给予授权，认证服务器将用户导向客户端事先指定的"重定向 URI"（redirection URI），同时附上一个授权码。\n\n（D）客户端收到授权码，附上早先的"重定向 URI"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。\n\n（E）认证服务器核对了授权码和重定向 URI，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。\n\n下面是上面这些步骤所需要的参数。\n\nA 步骤中，客户端申请认证的 URI，包含以下参数：\n\n * response_type：表示授权类型，必选项，此处的值固定为"code"\n * client_id：表示客户端的 ID，必选项\n * redirect_uri：表示重定向 URI，可选项\n * scope：表示申请的权限范围，可选项\n * state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。\n\n下面是一个例子。\n\nGET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz\n  &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\nHost: server.example.com\n\n\nC 步骤中，服务器回应客户端的 URI，包含以下参数：\n\n * code：表示授权码，必选项。该码的有效期应该很短，通常设为 10 分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端 ID 和重定向 URI，是一一对应关系。\n * state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。\n\n下面是一个例子。\n\nHTTP/1.1 302 Found\nLocation: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA\n    &state=xyz\n\n\nD 步骤中，客户端向认证服务器申请令牌的 HTTP 请求，包含以下参数：\n\n * grant_type：表示使用的授权模式，必选项，此处的值固定为"authorization_code"。\n * code：表示上一步获得的授权码，必选项。\n * redirect_uri：表示重定向 URI，必选项，且必须与 A 步骤中的该参数值保持一致。\n * client_id：表示客户端 ID，必选项。\n\n下面是一个例子。\n\nPOST /token HTTP/1.1\nHost: server.example.com\nAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA\n&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\n\n\nE 步骤中，认证服务器发送的 HTTP 回复，包含以下参数：\n\n * access_token：表示访问令牌，必选项。\n * token_type：表示令牌类型，该值大小写不敏感，必选项，可以是 bearer 类型或 mac 类型。\n * expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。\n * refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。\n * scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。\n\n下面是一个例子。\n\nHTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n\n{\n "access_token":"2YotnFZFEjr1zCsicMWpAA",\n "token_type":"example",\n "expires_in":3600,\n "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",\n "example_parameter":"example_value"\n}\n\n\n从上面代码可以看到，相关参数使用 JSON 格式发送（Content-Type: application/json）。此外，HTTP 头信息中明确指定不得缓存。\n\n# 1.2.4. 简化模式\n\n简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。\n\n\n它的步骤如下：\n\n（A）客户端将用户导向认证服务器。\n\n（B）用户决定是否给于客户端授权。\n\n（C）假设用户给予授权，认证服务器将用户导向客户端指定的"重定向 URI"，并在 URI 的 Hash 部分包含了访问令牌。\n\n（D）浏览器向资源服务器发出请求，其中不包括上一步收到的 Hash 值。\n\n（E）资源服务器返回一个网页，其中包含的代码可以获取 Hash 值中的令牌。\n\n（F）浏览器执行上一步获得的脚本，提取出令牌。\n\n（G）浏览器将令牌发给客户端。\n\n下面是上面这些步骤所需要的参数。\n\nA 步骤中，客户端发出的 HTTP 请求，包含以下参数：\n\n * response_type：表示授权类型，此处的值固定为"token"，必选项。\n * client_id：表示客户端的 ID，必选项。\n * redirect_uri：表示重定向的 URI，可选项。\n * scope：表示权限范围，可选项。\n * state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。\n\n下面是一个例子。\n\nGET /authorize?response_type=token&client_id=s6BhdRkqt3&state=xyz\n  &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\nHost: server.example.com\n\n\nC 步骤中，认证服务器回应客户端的 URI，包含以下参数：\n\n * access_token：表示访问令牌，必选项。\n * token_type：表示令牌类型，该值大小写不敏感，必选项。\n * expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。\n * scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。\n * state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。\n\n下面是一个例子。\n\nHTTP/1.1 302 Found\nLocation: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA\n         &state=xyz&token_type=example&expires_in=3600\n\n\n在上面的例子中，认证服务器用 HTTP 头信息的 Location 栏，指定浏览器重定向的网址。注意，在这个网址的 Hash 部分包含了令牌。\n\n根据上面的 D 步骤，下一步浏览器会访问 Location 指定的网址，但是 Hash 部分不会发送。接下来的 E 步骤，服务提供商的资源服务器发送过来的代码，会提取出 Hash 中的令牌。\n\n密码模式\n\n密码模式（Resource Owner Password Credentials Grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。\n\n在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。\n\n\n\n它的步骤如下：\n\n（A）用户向客户端提供用户名和密码。\n\n（B）客户端将用户名和密码发给认证服务器，向后者请求令牌。\n\n（C）认证服务器确认无误后，向客户端提供访问令牌。\n\nB 步骤中，客户端发出的 HTTP 请求，包含以下参数：\n\n * grant_type：表示授权类型，此处的值固定为"password"，必选项。\n * username：表示用户名，必选项。\n * password：表示用户的密码，必选项。\n * scope：表示权限范围，可选项。\n\n下面是一个例子。\n\nPOST /token HTTP/1.1\nHost: server.example.com\nAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=password&username=johndoe&password=A3ddj3w\n\n\nC 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。\n\nHTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n\n{\n "access_token":"2YotnFZFEjr1zCsicMWpAA",\n "token_type":"example",\n "expires_in":3600,\n "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",\n "example_parameter":"example_value"\n}\n\n\n上面代码中，各个参数的含义参见《授权码模式》一节。\n\n整个过程中，客户端不得保存用户的密码。\n\n客户端模式\n\n客户端模式（Client Credentials Grant）指客户端以自己的名义，而不是以用户的名义，向"服务提供商"进行认证。严格地说，客户端模式并不属于 OAuth 框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求"服务提供商"提供服务，其实不存在授权问题。\n\n\n\n它的步骤如下：\n\n（A）客户端向认证服务器进行身份认证，并要求一个访问令牌。\n\n（B）认证服务器确认无误后，向客户端提供访问令牌。\n\nA 步骤中，客户端发出的 HTTP 请求，包含以下参数：\n\n * granttype：表示授权类型，此处的值固定为"clientcredentials"，必选项。\n * scope：表示权限范围，可选项。\n\nPOST /token HTTP/1.1\nHost: server.example.com\nAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=client_credentials\n\n\n认证服务器必须以某种方式，验证客户端身份。\n\nB 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。\n\nHTTP/1.1 200 OK\nContent-Type: application/json;charset=UTF-8\nCache-Control: no-store\nPragma: no-cache\n\n{\n "access_token":"2YotnFZFEjr1zCsicMWpAA",\n "token_type":"example",\n "expires_in":3600,\n "example_parameter":"example_value"\n}\n\n\n上面代码中，各个参数的含义参见《授权码模式》一节。\n\n# 1.2.5. 更新令牌\n\n如果用户访问的时候，客户端的"访问令牌"已经过期，则需要使用"更新令牌"申请一个新的访问令牌。\n\n客户端发出更新令牌的 HTTP 请求，包含以下参数：\n\n * granttype：表示使用的授权模式，此处的值固定为"refreshtoken"，必选项。\n * refresh_token：表示早前收到的更新令牌，必选项。\n * scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。\n\n下面是一个例子。\n\nPOST /token HTTP/1.1\nHost: server.example.com\nAuthorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\nContent-Type: application/x-www-form-urlencoded\n\ngrant_type=refresh_token&refresh_token=tGzv3JOkF0XG5Qx2TlKWIA\n\n\n\n# 2. 鉴权\n\n\n# 2.1. RBAC\n\nRBAC（Role-Based Access Control）即：基于角色的权限控制。通过角色关联用户，角色关联权限的方式间接赋予用户权限。\n\n每个用户关联一个或多个角色，每个角色关联一个或多个权限，从而可以实现了非常灵活的权限管理。角色可以根据实际业务需求灵活创建，这样就省去了每新增一个用户就要关联一遍所有权限的麻烦。简单来说 RBAC 就是：用户关联角色，角色关联权限。\n\n\n\n\n# 2.2. 角色继承\n\n角色继承(Hierarchical Role) 就是指角色可以继承于其他角色，在拥有其他角色权限的同时，自己还可以关联额外的权限。这种设计可以给角色分组和分层，一定程度简化了权限管理工作。\n\n\n\n# 2.2.1. 职责分离(Separation of Duty)\n\n为了避免用户拥有过多权限而产生利益冲突，例如一个篮球运动员同时拥有裁判的权限（看一眼就给你判犯规狠不狠？），另一种职责分离扩展版的 RBAC 被提出。\n\n职责分离有两种模式：\n\n静态职责分离(Static Separation of Duty)：用户无法同时被赋予有冲突的角色。\n\n\n\n动态职责分离(Dynamic Separation of Duty)：用户在一次会话（Session）中不能同时激活自身所拥有的、互相有冲突的角色，只能选择其一。\n\n\n\n讲了这么多 RBAC，都还只是在用户和权限之间进行设计，并没有涉及到用户和对象之间的权限判断，而在实际业务系统中限制用户能够使用的对象是很常见的需求。\n\n\n# 2.3. RBAC0 模型\n\n最简单的用户、角色、权限模型。这里面又包含了 2 种：\n\n 1. 用户和角色是多对一关系，即：一个用户只充当一种角色，一种角色可以有多个用户担当。\n 2. 用户和角色是多对多关系，即：一个用户可同时充当多种角色，一种角色可以有多个用户担当。\n\n那么，什么时候该使用多对一的权限体系，什么时候又该使用多对多的权限体系呢？\n\n如果系统功能比较单一，使用人员较少，岗位权限相对清晰且确保不会出现兼岗的情况，此时可以考虑用多对一的权限体系。其余情况尽量使用多对多的权限体系，保证系统的可扩展性。如：张三既是行政，也负责财务工作，那张三就同时拥有行政和财务两个角色的权限。\n\n\n# 2.4. RBAC1 模型\n\n相对于 RBAC0 模型，增加了子角色，引入了继承概念，即子角色可以继承父角色的所有权限。\n\n\n\n**使用场景：**如某个业务部门，有经理、主管、专员。主管的权限不能大于经理，专员的权限不能大于主管，如果采用 RBAC0 模型做权限系统，极可能出现分配权限失误，最终出现主管拥有经理都没有的权限的情况。\n\n而 RBAC1 模型就很好解决了这个问题，创建完经理角色并配置好权限后，主管角色的权限继承经理角色的权限，并且支持在经理权限上删减主管权限。\n\n\n# 2.5. RBAC2 模型\n\n基于 RBAC0 模型，增加了对角色的一些限制：角色互斥、基数约束、先决条件角色等。\n\n * **角色互斥：**同一用户不能分配到一组互斥角色集合中的多个角色，互斥角色是指权限互相制约的两个角色。案例：财务系统中一个用户不能同时被指派给会计角色和审计员角色。\n * **基数约束：**一个角色被分配的用户数量受限，它指的是有多少用户能拥有这个角色。例如：一个角色专门为公司 CEO 创建的，那这个角色的数量是有限的。\n * **先决条件角色：**指要想获得较高的权限，要首先拥有低一级的权限。例如：先有副总经理权限，才能有总经理权限。\n * **运行时互斥：**例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色。\n\n\n# 2.6. RBAC3 模型\n\n称为统一模型，它包含了 RBAC1 和 RBAC2，利用传递性，也把 RBAC0 包括在内，综合了 RBAC0、RBAC1 和 RBAC2 的所有特点，这里就不在多描述了。\n\n\n\n\n# 2.7. 什么是权限\n\n说了这么久用户-角色-权限，可能小伙伴们都了解了什么是用户、什么是角色。但是有的小伙伴会好奇，那权限又是个什么玩意呢？\n\n权限是资源的集合，这里的资源指的是软件中所有的内容，包括模块、菜单、页面、字段、操作功能（增删改查）等等。具体的权限配置上，目前形式多种多样，按照我个人的理解，可以将权限分为：页面权限、操作权限和数据权限（这种分类法，主要是结合自己在工作中的实际情况理解总结而来，若有不足之处，也请大家指出）。\n\n**页面权限：**所有系统都是由一个个的页面组成，页面再组成模块，用户是否能看到这个页面的菜单、是否能进入这个页面就称为页面权限。\n\n如下图：\n\n\n\n客户列表、客户黑名单、客户审批页面组成了客户管理这个模块。对于普通用户，不能进行审批操作，即无客户审批页面权限，在他的账号登录后侧边导航栏只显示客户列表、客户黑名单两个菜单。\n\n**操作权限：**用户凡是在操作系统中的任何动作、交互都是操作权限，如增删改查等。\n\n**数据权限：**一般业务管理系统，都有数据私密性的要求：哪些人可以看到哪些数据，不可以看到哪些数据。\n\n简单举个例子：某系统中有销售部门，销售专员负责推销商品，销售主管负责管理销售专员日常工作，经理负责组织管理销售主管作业。\n\n如下图：\n\n\n\n按照实际理解，‘销售专员张三’登录时，只能看到自己负责的数据；销售主管 2 登录时，能看到他所领导的所有业务员负责的数据，但看不到其他团队业务员负责的数据。\n\n换另外一句话就是：我的客户只有我和我的直属上级以及直属上级的领导能看到，这就是我理解的数据权限。\n\n要实现数据权限有多种方式：\n\n 1. 可以利用 RBAC1 模型，通过角色分级来实现。\n 2. 在‘用户-角色-权限’的基础上，增加用户与组织的关联关系，用组织决定用户的数据权限。\n\n具体如何做呢？\n\n① 组织层级划分：\n\n\n\n**② 数据可视权限规则制定：**上级组织只能看到下级组织员工负责的数据，而不能看到其他平级组织及其下级组织的员工数据等。\n\n通过以上两点，系统就可以在用户登录时，自动判断要给用户展示哪些数据了。\n\n\n# 2.8. 用户组的使用\n\n当平台用户基数增大，角色类型增多时，如果直接给用户配角色，管理员的工作量就会很大。这时候我们可以引入一个概念“用户组”，就是将相同属性的用户归类到一起。\n\n例如：加入用户组的概念后，可以将部门看做一个用户组，再给这个部门直接赋予角色（1 万员工部门可能就几十个），使部门拥有部门权限，这样这个部门的所有用户都有了部门权限，而不需要为每一个用户再单独指定角色，极大的减少了分配权限的工作量。\n\n同时，也可以为特定的用户指定角色，这样用户除了拥有所属用户组的所有权限外，还拥有自身特定的权限。\n\n用户组的优点，除了减少工作量，还有更便于理解、增加多级管理关系等。如：我们在进行组织机构配置的时候，除了加入部门，还可以加入科室、岗位等层级，来为用户组内部成员的权限进行等级上的区分。\n\n关于用户组的详细疑难解答，请查看https://wen.woshipm.com/question/detail/88fues.html。在这里也十分感谢为我解答疑惑的朋友们！\n\n\n# 2.9. 实例分析\n\n\n# 2.10. 如何设计 RBAC 权限系统\n\n首先，我们思考一下一个简单的权限系统应该具备哪些内容？\n\n答案显而易见，RBAC 模型：用户-角色-权限。所以最基本的我们应该具备用户、角色、权限这三个内容。\n\n接下来，我们思考，究竟如何将三者关联起来。回顾前文，角色作为枢纽，关联用户、权限。所以在 RBAC 模型下，我们应该：创建一个角色，并为这个角色赋予相应权限，最后将角色赋予用户。\n\n将这个问题抽象为流程，如下图：\n\n\n\n现在，基本的流程逻辑已经抽象出来了，接下来，分析该如何设计呢？\n\n * 第一步，需要角色管理列表，在角色管理列表能快速创建一个角色，且创建角色的同时能为角色配置权限，并且支持创建成功的角色列表能随时进行权限配置的的修改；\n * 第二步，需要用户管理列表，在用户管理列表能快速添加一个用户，且添加用户时有让用户关联角色的功能。\n\n简单来说权限系统设计就包含以上两步，接下来为大家进行实例分析。\n\n\n# 2.11. 实例分析\n\n① 创建角色列表\n\n\n\n在角色列表快速创建一个角色：点击创建角色，支持创建角色时配置权限。\n\n\n\n② 创建用户列表\n\n\n\n在用户列表快速创建一个用户：支持用户关联角色的功能。\n\n\n\n上述案例是基于最简单的 RBAC0 模型创建，适用于大部分常规的权限管理系统。\n\n下面再分析一下 RBAC1 中角色分级具体如何设计。\n\n 1. 在 RBAC0 的基础上，加上角色等级这个字段。\n 2. 权限分配规则制定：低等级角色只能在高等级角色权限基础上进行删减权限。\n\n具体界面呈现如下图：\n\n\n\n以上就是简单的 RBAC 系统设计，若需更复杂的，还请读者根据上面的分析自行揣摩思考，尽管样式不同，但万变不离其宗，理解清楚 RBAC 模型后，结合自己的业务就可以设计出一套符合自己平台需求的角色权限系统，具体的就不再多阐述了。\n\n\n# 3. 审计\n\nTODO\n\n\n# 4. 网站攻击\n\n互联网环境鱼龙混杂，网站被攻击是常见现象，所以了解一些常见的网站攻击手段十分必要。下面列举比较常见的 4 种攻击手段：\n\n\n# 4.1. XSS\n\n# 4.1.1. 概念\n\n跨站脚本（Cross-site scripting，通常简称为XSS） 是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及用户端脚本语言。\n\nXSS 攻击示例：\n\n假如有下面一个 textbox\n\n<input type="text" name="address1" value="value1from" />\n\n\nvalue1from 是来自用户的输入，如果用户不是输入 value1from,而是输入 "/><script>alert(document.cookie)<\/script><!- 那么就会变成：\n\n<input type="text" name="address1" value="" />\n<script>\n  alert(document.cookie)\n<\/script>\n<!- ">\n\n\n嵌入的 JavaScript 代码将会被执行。攻击的威力，取决于用户输入了什么样的脚本。\n\n# 4.1.2. 攻击手段和目的\n\n常用的 XSS 攻击手段和目的有：\n\n * 盗用 cookie，获取敏感信息。\n * 利用植入 Flash，通过 crossdomain 权限设置进一步获取更高权限；或者利用 Java 等得到类似的操作。\n * 利用 iframe、frame、XMLHttpRequest 或上述 Flash 等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。\n * 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。\n * 在访问量极大的一些页面上的 XSS 可以攻击一些小型网站，实现 DDoS 攻击的效果。\n\n# 4.1.3. 应对手段\n\n * 过滤特殊字符 - 将用户所提供的内容进行过滤，从而避免 HTML 和 Jascript 代码的运行。如 > 转义为 &gt、< 转义为 &lt 等，就可以防止大部分攻击。为了避免对不必要的内容错误转移，如 3<5 中的 < 需要进行文本匹配后再转移，如：<img src= 这样的上下文中的 < 才转义。\n * 设置 Cookie 为 HttpOnly - 设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。\n\n> 👉 参考阅读：\n> \n>  * Wiki 词条 - 跨站脚本\n>  * Web 安全测试之 XSS\n\n\n# 4.2. CSRF\n\n# 4.2.1. 概念\n\n跨站请求伪造（Cross-site request forgery，CSRF），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF。它是一种挟持用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。和跨站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。\n\n# 4.2.2. 攻击手段和目的\n\n可以如此理解 CSRF：攻击者盗用了你的身份，以你的名义发送恶意请求。\n\nCSRF 能做的事太多：\n\n * 以你名义发送邮件，发消息\n * 用你的账号购买商品\n * 用你的名义完成虚拟货币转账\n * 泄露个人隐私\n * ...\n\n# 4.2.3. 应对手段\n\n * 表单 Token - CSRF 是一个伪造用户请求的操作，所以需要构造用户请求的所有参数才可以。表单 Token 通过在请求参数中添加随机数的办法来阻止攻击者获得所有请求参数。\n * 验证码 - 请求提交时，需要用户输入验证码，以避免用户在不知情的情况下被攻击者伪造请求。\n * Referer check - HTTP 请求头的 Referer 域中记录着请求资源，可通过检查请求来源，验证其是否合法。\n\n> 👉 参考阅读：\n> \n>  * Wiki 词条 - 跨站请求伪造\n>  * 浅谈 CSRF 攻击方式\n>  * 「每日一题」CSRF 是什么？「每日一题」CSRF 是什么？\n>  * WEB 安全之-CSRF（跨站请求伪造）\n\n\n# 4.3. SQL 注入\n\n# 4.3.1. 概念\n\nSQL 注入攻击（SQL injection），是发生于应用程序之数据层的安全漏洞。简而言之，是在输入的字符串之中注入 SQL 指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的 SQL 指令而运行，因此遭到破坏或是入侵。\n\n攻击示例：\n\n考虑以下简单的登录表单：\n\n<form action="/login" method="POST">\n  <p>Username: <input type="text" name="username" /></p>\n  <p>Password: <input type="password" name="password" /></p>\n  <p><input type="submit" value="登陆" /></p>\n</form>\n\n\n我们的处理里面的 SQL 可能是这样的：\n\nusername:=r.Form.Get("username")\npassword:=r.Form.Get("password")\nsql:="SELECT * FROM user WHERE username=\'"+username+"\' AND password=\'"+password+"\'"\n\n\n如果用户的输入的用户名如下，密码任意\n\nmyuser\' or \'foo\' = \'foo\' --\n\n\n那么我们的 SQL 变成了如下所示：\n\nSELECT * FROM user WHERE username=\'myuser\' or \'foo\' = \'foo\' --\'\' AND password=\'xxx\'\n\n\n在 SQL 里面 -- 是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。\n\n对于 MSSQL 还有更加危险的一种 SQL 注入，就是控制系统，下面这个可怕的例子将演示如何在某些版本的 MSSQL 数据库上执行系统命令。\n\nsql:="SELECT * FROM products WHERE name LIKE \'%"+prod+"%\'"\nDb.Exec(sql)\n\n\n如果攻击提交 a%\' exec master..xp_cmdshell \'net user test testpass /ADD\' -- 作为变量 prod 的值，那么 sql 将会变成\n\nsql:="SELECT * FROM products WHERE name LIKE \'%a%\' exec master..xp_cmdshell \'net user test testpass /ADD\'--%\'"\n\n\nMSSQL 服务器会执行这条 SQL 语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以 sa 运行而 MSSQLSERVER 服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。\n\n虽然以上的例子是针对某一特定的数据库系统的，但是这并不代表不能对其它数据库系统实施类似的攻击。针对这种安全漏洞，只要使用不同方法，各种数据库都有可能遭殃。\n\n# 4.3.2. 攻击手段和目的\n\n * 数据表中的数据外泄，例如个人机密数据，账户数据，密码等。\n * 数据结构被黑客探知，得以做进一步攻击（例如 SELECT * FROM sys.tables）。\n * 数据库服务器被攻击，系统管理员账户被窜改（例如 ALTER LOGIN sa WITH PASSWORD=\'xxxxxx\'）。\n * 获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 XSS 等。\n * 经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell "net stop iisadmin"可停止服务器的 IIS 服务）。\n * 破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell "FORMAT C:"）。\n\n# 4.3.3. 应对手段\n\n * 使用参数化查询 - 建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如使用 database/sql 里面的查询函数 Prepare 和 Query ，或者 Exec(query string, args ...interface{})。\n * 单引号转换 - 在组合 SQL 字符串时，先针对所传入的参数进行字符替换（将单引号字符替换为连续 2 个单引号字符）。\n\n> 👉 参考阅读：\n> \n>  * Wiki 词条 - SQL 注入攻击\n>  * 避免 SQL 注入\n>  * 实例讲解 SQL 注入攻击\n\n\n# 4.4. DoS\n\n拒绝服务攻击（denial-of-service attack, DoS）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。\n\n当黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击时，称为分布式拒绝服务攻击（distributed denial-of-service attack，缩写：DDoS attack、DDoS）。\n\n# 4.4.1. 攻击方式\n\n * 带宽消耗型攻击\n * 资源消耗型攻击\n\n# 4.4.2. 应对手段\n\n * 防火墙 - 允许或拒绝特定通讯协议，端口或 IP 地址。当攻击从少数不正常的 IP 地址发出时，可以简单的使用拒绝规则阻止一切从攻击源 IP 发出的通信。\n * 路由器、交换机 - 具有速度限制和访问控制能力。\n * 流量清洗 - 通过采用抗 DoS 软件处理，将正常流量和恶意流量区分开。\n\n> 👉 参考阅读：\n> \n>  * 拒绝服务攻击\n\n\n# 5. 加密技术\n\n对于网站来说，用户信息、账户等等敏感数据一旦泄漏，后果严重，所以为了保护数据，应对这些信息进行加密处理。\n\n信息加密技术一般分为：\n\n * 消息摘要\n * 加密算法\n   * 对称加密\n   * 非对称加密\n * 证书\n\n\n# 5.1. 消息摘要\n\n常用数字签名算法：MD5、SHA 等。\n\n应用场景：将用户密码以消息摘要形式保存到数据库中。\n\n> 👉 参考阅读： Java 编码和加密\n\n\n# 5.2. 加密算法\n\n# 5.2.1. 对称加密\n\n对称加密指加密和解密所使用的密钥是同一个密钥。\n\n常用对称加密算法：DES、AES 等。\n\n应用场景：Cookie 加密、通信机密等。\n\n# 5.2.2. 非对称加密\n\n非对称加密指加密和解密所使用的不是同一个密钥，而是一个公私钥对。用公钥加密的信息必须用私钥才能解开；反之，用私钥加密的信息只有用公钥才能解开。\n\n常用非对称加密算法：RSA 等。\n\n应用场景：HTTPS 传输中浏览器使用的数字证书实质上是经过权威机构认证的非对称加密公钥。\n\n> 👉 参考阅读： Java 编码和加密\n\n# 5.2.3. 密钥安全管理\n\n保证密钥安全的方法：\n\n 1. 把密钥和算法放在一个独立的服务器上，对外提供加密和解密服务，应用系统通过调用这个服务，实现数据的加解密。\n 2. 把加解密算法放在应用系统中，密钥则放在独立服务器中，为了提高密钥的安全性，实际存储时，密钥被切分成数片，加密后分别保存在不同存储介质中。\n\n\n# 5.3. 证书\n\n证书可以称为信息安全加密的终极手段。公开密钥认证（英语：Public key certificate），又称公开密钥证书、公钥证书、数字证书（digital certificate）、数字认证、身份证书（identity certificate）、电子证书或安全证书，是用于公开密钥基础建设的电子文件，用来证明公开密钥拥有者的身份。此文件包含了公钥信息、拥有者身份信息（主体）、以及数字证书认证机构（发行者）对这份文件的数字签名，以保证这个文件的整体内容正确无误。\n\n透过信任权威数字证书认证机构的根证书、及其使用公开密钥加密作数字签名核发的公开密钥认证，形成信任链架构，已在 TLS 实现并在万维网的 HTTP 以 HTTPS、在电子邮件的 SMTP 以 STARTTLS 引入并广泛应用。\n\n众所周知，常见的应用层协议 HTTP、FTP、Telnet 本身不保证信息安全。但是加入了 SSL/TLS 加密数据包机制的 HTTPS、FTPS、Telnets 是信息安全的。传输层安全性协议（Transport Layer Security, TLS），及其前身安全套接层（Secure Sockets Layer, SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。\n\n# 5.3.1. 证书原理\n\nSSL/TLS 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。\n\n这里有两个问题：\n\n（1）如何保证公钥不被篡改？\n\n解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。\n\n（2）公钥加密计算量太大，如何减少耗用的时间？\n\n解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。\n\nSSL/TLS 协议的基本过程是这样的：\n\n 1. 客户端向服务器端索要并验证公钥。\n 2. 双方协商生成"对话密钥"。\n 3. 双方采用"对话密钥"进行加密通信。\n\n> 👉 参考阅读：\n> \n>  * 传输层安全性协议\n>  * 公开密钥认证\n>  * SSL/TLS 协议运行机制的概述\n\n\n# 6. 信息过滤\n\n在网络中，广告和垃圾信息屡见不鲜，泛滥成灾。\n\n常见的信息过滤与反垃圾手段有：\n\n\n# 6.1. 文本匹配\n\n解决敏感词过滤。系统维护一份敏感词清单，如果信息中含有敏感词，则自动进行过滤或拒绝信息。\n\n\n# 6.2. 黑名单\n\n黑名单就是将一些已经被识别出有违规行为的 IP、域名、邮箱等加入黑名单，拒绝其请求。\n\n黑名单可以通过 Hash 表来实现，方法简单，复杂度小，适于一般应用场景。\n\n但如果黑名单列表非常大时，Hash 表要占用很大的内存空间，这时就不再使用了。这种情况下，可以使用布隆过滤器来实现，即通过一个二进制列表和一组随机数映射函数来实现。\n\n\n# 6.3. 分类算法\n\n对于海量信息，难以通过人工去审核。对广告贴。\n\n垃圾邮件等内容的识别比较好的自动化方法就是采用分类算法。\n\n简单来说，即将批量已分类的样本输入分类算法进行训练，得到一个分类模型，然后利用分类算法结合分类模型去对信息进行识别。想了解具体做法，需要去理解机器学习相关知识。\n\n\n# 7. 风险控制\n\n网络给商务、金融领域带来极大便利的同时，也将风险带给了对网络安全一无所知的人们。由于交易双方信息的不对等，使得交易存在着风险，而当交易发生在网络上时，风险就更加难以控制了。\n\n\n# 7.1. 风险种类\n\n * 账户风险 - 盗用账户、恶意注册账户等\n * 买家风险 - 虚假询盘、恶意拒收、恶意下单、黄牛党抢购热门商品等\n * 卖家风险 - 虚假发货、出售违禁品、侵权等\n * 交易风险 - 信用卡盗刷、交易欺诈、洗钱、套现、电信诈骗等\n\n\n# 7.2. 风险控制手段\n\n大型电商网站系统或金融系统都配备专业的风控团队进行风险控制。风险控制手段既包括人工审核也包括自动审核。\n\n自动风控的技术手段主要有规则引擎和统计模型。\n\n\n# 7.3. 规则引擎\n\n在交易中，买家、卖家的某些指标满足一定条件时，就会被认为存在风险。如：交易金额超过某个数值；用户来自黑名单；用户和上次登录的地址距离差距很大；用户在一定时间内频繁交易等等。\n\n如果以上这些条件都通过 if ... else ... 式样的代码去实现，代码维护、扩展会非常不便。因此，就有了规则引擎来处理这类问题。规则引擎是一种将业务规则和规则处理逻辑相分离的技术，业务规则由运营人员通过管理界面去编辑，实现无需修改代码，即可实时的使用新规则。\n\n\n# 7.4. 统计模型\n\n规则引擎虽然技术简单，但是随着规则不断增加，规模越来越大。可能会出现规则冲突，难以维护的情况，并且规则越多，性能也越差。\n\n为了解决这种问题，就有了统计模型。统计模型会使用分类算法或更复杂的机器学习算法进行智能统计。根据历史交易中的信息训练分类，然后将经过采集加工后的交易信息输入分类算法，得到交易风险值，然后基于此，做出预测。\n\n经过充分训练后的统计模型，准确率不低于规则引擎。但是，需要有领域专家、行业专家介入，建立合理的训练模型，并不断优化。\n\n\n# 8. 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * Wiki 词条 - 跨站脚本\n * Web 安全测试之 XSS\n * Wiki 词条 - 跨站请求伪造\n * 浅谈 CSRF 攻击方式\n * 「每日一题」CSRF 是什么？「每日一题」CSRF 是什么？\n * WEB 安全之-CSRF（跨站请求伪造）\n * Wiki 词条 - SQL 注入攻击\n * 避免 SQL 注入\n * 实例讲解 SQL 注入攻击\n * 拒绝服务攻击\n * 传输层安全性协议\n * 公开密钥认证\n * SSL/TLS 协议运行机制的概述\n * http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\n * CAS 实现 SSO 单点登录原理\n * 权限系统设计模型分析（DAC，MAC，RBAC，ABAC）\n * RBAC 模型：基于用户-角色-权限控制的一些思考',normalizedContent:'# 系统安全性架构\n\n> 关键词：xss、csrf、sql 注入、dos、消息摘要、加密算法、证书\n\n\n# 1. 认证\n\n\n# 1.1. sso\n\nsso(single sign on)，即单点登录。所谓单点登录，就是同平台的诸多应用登陆一次，下一次就免登陆的功能。\n\nsso 需要解决多个异构系统之间的问题：\n\n * session 共享问题\n * 跨域问题\n\n# 1.1.1. session 共享问题\n\n分布式 session 的几种实现策略：\n\n * 粘性 session - 缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 session。\n * 应用服务器间的 session 复制共享 - 缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。\n * 基于缓存的 session 共享 ✅ （推荐方案） - 不过需要程序自身控制 session 读写，可以考虑基于 spring-session + redis 这种成熟的方案来处理。\n\n> 详情请参考：session 原理\n\n# 1.1.2. cookie 跨域\n\ncookie 不能跨域！比如：浏览器不会把 www.google.com 的 cookie 传给 www.baidu.com。\n\n这就存在一个问题：由于域名不同，用户在系统 a 登录后，浏览器记录系统 a 的 cookie，但是访问系统 b 的时候不会携带这个 cookie。\n\n针对 cookie 不能跨域 的问题，有几种解决方案：\n\n * 服务端生成 cookie 后，返回给客户端，客户端解析 cookie ，提取 token （比如 jwt），此后每次请求都携带这个 token。\n * 多个域名共享 cookie，在返回 cookie 给客户端的时候，在 cookie 中设置 domain 白名单。\n * 将 token 保存在 sessionstroage 中（不依赖 cookie 就没有跨域的问题了）。\n\n# 1.1.3. cas\n\ncas 是实现 sso 的主流方式。\n\ncas 分为两部分，cas server 和 cas client\n\n * cas server - 负责用户的认证工作，就像是把第一次登录用户的一个标识存在这里，以便此用户在其他系统登录时验证其需不需要再次登录。\n * cas client - 业务应用，需要接入 cas server。当用户访问我们的应用时，首先需要重定向到 cas server 端进行验证，要是原来登陆过，就免去登录，重定向到下游系统，否则进行用户名密码登陆操作。\n\n术语：\n\n * ticket granting ticket (tgt) - 可以认为是 cas server 根据用户名、密码生成的一张票，存在 server 端。\n * ticket granting cookie (tgc) - 其实就是一个 cookie，存放用户身份信息，由 server 发给 client 端。\n * service ticket (st) - 由 tgt 生成的一次性票据，用于验证，只能用一次。\n\ncas 工作流程：\n\n\n\n 1. 用户访问 cas client a（业务系统），第一次访问，重定向到认证服务中心（cas server）。cas server 发现当前请求中没有 cookie，再重定向到 cas server 的登录页面。重定向请求的 url 中包含访问地址，以便认证成功后直接跳转到访问页面。\n 2. 用户在登录页面输入用户名、密码等认证信息，认证成功后，cas server 生成 tgt，再用 tgt 生成一个 st。然后返回 st 和 tgc（cookie）给浏览器。\n 3. 浏览器携带 st 再度访问之前想访问的 cas client a 页面。\n 4. cas client a 收到 st 后，向 cas server 验证 st 的有效性。验证通过则允许用户访问页面。\n 5. 此时，如果登录另一个 cas client b，会先重定向到 cas server，cas server 可以判断这个 cas client b 是第一次访问，但是本地有 tgc，所以无需再次登录。用 tgc 创建一个 st，返回给浏览器。\n 6. 重复类似 3、4 步骤。\n\n\n\n以上了归纳总结如下：\n\n 1. 访问服务 - 用户访问 sso client 资源。\n 2. 定向认证 - sso client 重定向用户请求到 sso server。\n 3. 用户认证 - 用户身份认证。\n 4. 发放票据 - sso server 会产生一个 service ticket (st) 并返回给浏览器。\n 5. 验证票据 - 浏览器每次访问 sso client 时，携带 st，sso client 向 sso server 验证票据。只有验证通过，才允许访问。\n 6. 传输用户信息 - sso server 验证票据通过后，传输用户认证结果信息给 sso client。\n\n\n# 1.2. oauth 2.0\n\n# 1.2.1. 基本原理\n\noauth 在"客户端"与"服务提供商"之间，设置了一个授权层（authorization layer）。"客户端"不能直接登录"服务提供商"，只能登录授权层，以此将用户与客户端区分开来。"客户端"登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。\n\n"客户端"登录授权层以后，"服务提供商"根据令牌的权限范围和有效期，向"客户端"开放用户储存的资料。\n\noauth 2.0 的运行流程如下图，摘自 rfc 6749。\n\n\n（a）用户打开客户端以后，客户端要求用户给予授权。\n\n（b）用户同意给予客户端授权。\n\n（c）客户端使用上一步获得的授权，向认证服务器申请令牌。\n\n（d）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。\n\n（e）客户端使用令牌，向资源服务器申请获取资源。\n\n（f）资源服务器确认令牌无误，同意向客户端开放资源。\n\n不难看出来，上面六个步骤之中，b 是关键，即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取资源。\n\n# 1.2.2. 授权模式\n\n客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。oauth 2.0 定义了四种授权方式。\n\n * 授权码模式（authorization code）\n * 简化模式（implicit）\n * 密码模式（resource owner password credentials）\n * 客户端模式（client credentials）\n\n# 1.2.3. 授权码模式\n\n授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点就是通过客户端的后台服务器，与"服务提供商"的认证服务器进行互动。\n\n\n它的步骤如下：\n\n（a）用户访问客户端，后者将前者导向认证服务器。\n\n（b）用户选择是否给予客户端授权。\n\n（c）假设用户给予授权，认证服务器将用户导向客户端事先指定的"重定向 uri"（redirection uri），同时附上一个授权码。\n\n（d）客户端收到授权码，附上早先的"重定向 uri"，向认证服务器申请令牌。这一步是在客户端的后台的服务器上完成的，对用户不可见。\n\n（e）认证服务器核对了授权码和重定向 uri，确认无误后，向客户端发送访问令牌（access token）和更新令牌（refresh token）。\n\n下面是上面这些步骤所需要的参数。\n\na 步骤中，客户端申请认证的 uri，包含以下参数：\n\n * response_type：表示授权类型，必选项，此处的值固定为"code"\n * client_id：表示客户端的 id，必选项\n * redirect_uri：表示重定向 uri，可选项\n * scope：表示申请的权限范围，可选项\n * state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。\n\n下面是一个例子。\n\nget /authorize?response_type=code&client_id=s6bhdrkqt3&state=xyz\n  &redirect_uri=https%3a%2f%2fclient%2eexample%2ecom%2fcb http/1.1\nhost: server.example.com\n\n\nc 步骤中，服务器回应客户端的 uri，包含以下参数：\n\n * code：表示授权码，必选项。该码的有效期应该很短，通常设为 10 分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端 id 和重定向 uri，是一一对应关系。\n * state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。\n\n下面是一个例子。\n\nhttp/1.1 302 found\nlocation: https://client.example.com/cb?code=splxlobezqqybys6wxsbia\n    &state=xyz\n\n\nd 步骤中，客户端向认证服务器申请令牌的 http 请求，包含以下参数：\n\n * grant_type：表示使用的授权模式，必选项，此处的值固定为"authorization_code"。\n * code：表示上一步获得的授权码，必选项。\n * redirect_uri：表示重定向 uri，必选项，且必须与 a 步骤中的该参数值保持一致。\n * client_id：表示客户端 id，必选项。\n\n下面是一个例子。\n\npost /token http/1.1\nhost: server.example.com\nauthorization: basic czzcagrsa3f0mzpnwdfmqmf0m2jw\ncontent-type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&code=splxlobezqqybys6wxsbia\n&redirect_uri=https%3a%2f%2fclient%2eexample%2ecom%2fcb\n\n\ne 步骤中，认证服务器发送的 http 回复，包含以下参数：\n\n * access_token：表示访问令牌，必选项。\n * token_type：表示令牌类型，该值大小写不敏感，必选项，可以是 bearer 类型或 mac 类型。\n * expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。\n * refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。\n * scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。\n\n下面是一个例子。\n\nhttp/1.1 200 ok\ncontent-type: application/json;charset=utf-8\ncache-control: no-store\npragma: no-cache\n\n{\n "access_token":"2yotnfzfejr1zcsicmwpaa",\n "token_type":"example",\n "expires_in":3600,\n "refresh_token":"tgzv3jokf0xg5qx2tlkwia",\n "example_parameter":"example_value"\n}\n\n\n从上面代码可以看到，相关参数使用 json 格式发送（content-type: application/json）。此外，http 头信息中明确指定不得缓存。\n\n# 1.2.4. 简化模式\n\n简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。\n\n\n它的步骤如下：\n\n（a）客户端将用户导向认证服务器。\n\n（b）用户决定是否给于客户端授权。\n\n（c）假设用户给予授权，认证服务器将用户导向客户端指定的"重定向 uri"，并在 uri 的 hash 部分包含了访问令牌。\n\n（d）浏览器向资源服务器发出请求，其中不包括上一步收到的 hash 值。\n\n（e）资源服务器返回一个网页，其中包含的代码可以获取 hash 值中的令牌。\n\n（f）浏览器执行上一步获得的脚本，提取出令牌。\n\n（g）浏览器将令牌发给客户端。\n\n下面是上面这些步骤所需要的参数。\n\na 步骤中，客户端发出的 http 请求，包含以下参数：\n\n * response_type：表示授权类型，此处的值固定为"token"，必选项。\n * client_id：表示客户端的 id，必选项。\n * redirect_uri：表示重定向的 uri，可选项。\n * scope：表示权限范围，可选项。\n * state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。\n\n下面是一个例子。\n\nget /authorize?response_type=token&client_id=s6bhdrkqt3&state=xyz\n  &redirect_uri=https%3a%2f%2fclient%2eexample%2ecom%2fcb http/1.1\nhost: server.example.com\n\n\nc 步骤中，认证服务器回应客户端的 uri，包含以下参数：\n\n * access_token：表示访问令牌，必选项。\n * token_type：表示令牌类型，该值大小写不敏感，必选项。\n * expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。\n * scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。\n * state：如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。\n\n下面是一个例子。\n\nhttp/1.1 302 found\nlocation: http://example.com/cb#access_token=2yotnfzfejr1zcsicmwpaa\n         &state=xyz&token_type=example&expires_in=3600\n\n\n在上面的例子中，认证服务器用 http 头信息的 location 栏，指定浏览器重定向的网址。注意，在这个网址的 hash 部分包含了令牌。\n\n根据上面的 d 步骤，下一步浏览器会访问 location 指定的网址，但是 hash 部分不会发送。接下来的 e 步骤，服务提供商的资源服务器发送过来的代码，会提取出 hash 中的令牌。\n\n密码模式\n\n密码模式（resource owner password credentials grant）中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向"服务商提供商"索要授权。\n\n在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。而认证服务器只有在其他授权模式无法执行的情况下，才能考虑使用这种模式。\n\n\n\n它的步骤如下：\n\n（a）用户向客户端提供用户名和密码。\n\n（b）客户端将用户名和密码发给认证服务器，向后者请求令牌。\n\n（c）认证服务器确认无误后，向客户端提供访问令牌。\n\nb 步骤中，客户端发出的 http 请求，包含以下参数：\n\n * grant_type：表示授权类型，此处的值固定为"password"，必选项。\n * username：表示用户名，必选项。\n * password：表示用户的密码，必选项。\n * scope：表示权限范围，可选项。\n\n下面是一个例子。\n\npost /token http/1.1\nhost: server.example.com\nauthorization: basic czzcagrsa3f0mzpnwdfmqmf0m2jw\ncontent-type: application/x-www-form-urlencoded\n\ngrant_type=password&username=johndoe&password=a3ddj3w\n\n\nc 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。\n\nhttp/1.1 200 ok\ncontent-type: application/json;charset=utf-8\ncache-control: no-store\npragma: no-cache\n\n{\n "access_token":"2yotnfzfejr1zcsicmwpaa",\n "token_type":"example",\n "expires_in":3600,\n "refresh_token":"tgzv3jokf0xg5qx2tlkwia",\n "example_parameter":"example_value"\n}\n\n\n上面代码中，各个参数的含义参见《授权码模式》一节。\n\n整个过程中，客户端不得保存用户的密码。\n\n客户端模式\n\n客户端模式（client credentials grant）指客户端以自己的名义，而不是以用户的名义，向"服务提供商"进行认证。严格地说，客户端模式并不属于 oauth 框架所要解决的问题。在这种模式中，用户直接向客户端注册，客户端以自己的名义要求"服务提供商"提供服务，其实不存在授权问题。\n\n\n\n它的步骤如下：\n\n（a）客户端向认证服务器进行身份认证，并要求一个访问令牌。\n\n（b）认证服务器确认无误后，向客户端提供访问令牌。\n\na 步骤中，客户端发出的 http 请求，包含以下参数：\n\n * granttype：表示授权类型，此处的值固定为"clientcredentials"，必选项。\n * scope：表示权限范围，可选项。\n\npost /token http/1.1\nhost: server.example.com\nauthorization: basic czzcagrsa3f0mzpnwdfmqmf0m2jw\ncontent-type: application/x-www-form-urlencoded\n\ngrant_type=client_credentials\n\n\n认证服务器必须以某种方式，验证客户端身份。\n\nb 步骤中，认证服务器向客户端发送访问令牌，下面是一个例子。\n\nhttp/1.1 200 ok\ncontent-type: application/json;charset=utf-8\ncache-control: no-store\npragma: no-cache\n\n{\n "access_token":"2yotnfzfejr1zcsicmwpaa",\n "token_type":"example",\n "expires_in":3600,\n "example_parameter":"example_value"\n}\n\n\n上面代码中，各个参数的含义参见《授权码模式》一节。\n\n# 1.2.5. 更新令牌\n\n如果用户访问的时候，客户端的"访问令牌"已经过期，则需要使用"更新令牌"申请一个新的访问令牌。\n\n客户端发出更新令牌的 http 请求，包含以下参数：\n\n * granttype：表示使用的授权模式，此处的值固定为"refreshtoken"，必选项。\n * refresh_token：表示早前收到的更新令牌，必选项。\n * scope：表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。\n\n下面是一个例子。\n\npost /token http/1.1\nhost: server.example.com\nauthorization: basic czzcagrsa3f0mzpnwdfmqmf0m2jw\ncontent-type: application/x-www-form-urlencoded\n\ngrant_type=refresh_token&refresh_token=tgzv3jokf0xg5qx2tlkwia\n\n\n\n# 2. 鉴权\n\n\n# 2.1. rbac\n\nrbac（role-based access control）即：基于角色的权限控制。通过角色关联用户，角色关联权限的方式间接赋予用户权限。\n\n每个用户关联一个或多个角色，每个角色关联一个或多个权限，从而可以实现了非常灵活的权限管理。角色可以根据实际业务需求灵活创建，这样就省去了每新增一个用户就要关联一遍所有权限的麻烦。简单来说 rbac 就是：用户关联角色，角色关联权限。\n\n\n\n\n# 2.2. 角色继承\n\n角色继承(hierarchical role) 就是指角色可以继承于其他角色，在拥有其他角色权限的同时，自己还可以关联额外的权限。这种设计可以给角色分组和分层，一定程度简化了权限管理工作。\n\n\n\n# 2.2.1. 职责分离(separation of duty)\n\n为了避免用户拥有过多权限而产生利益冲突，例如一个篮球运动员同时拥有裁判的权限（看一眼就给你判犯规狠不狠？），另一种职责分离扩展版的 rbac 被提出。\n\n职责分离有两种模式：\n\n静态职责分离(static separation of duty)：用户无法同时被赋予有冲突的角色。\n\n\n\n动态职责分离(dynamic separation of duty)：用户在一次会话（session）中不能同时激活自身所拥有的、互相有冲突的角色，只能选择其一。\n\n\n\n讲了这么多 rbac，都还只是在用户和权限之间进行设计，并没有涉及到用户和对象之间的权限判断，而在实际业务系统中限制用户能够使用的对象是很常见的需求。\n\n\n# 2.3. rbac0 模型\n\n最简单的用户、角色、权限模型。这里面又包含了 2 种：\n\n 1. 用户和角色是多对一关系，即：一个用户只充当一种角色，一种角色可以有多个用户担当。\n 2. 用户和角色是多对多关系，即：一个用户可同时充当多种角色，一种角色可以有多个用户担当。\n\n那么，什么时候该使用多对一的权限体系，什么时候又该使用多对多的权限体系呢？\n\n如果系统功能比较单一，使用人员较少，岗位权限相对清晰且确保不会出现兼岗的情况，此时可以考虑用多对一的权限体系。其余情况尽量使用多对多的权限体系，保证系统的可扩展性。如：张三既是行政，也负责财务工作，那张三就同时拥有行政和财务两个角色的权限。\n\n\n# 2.4. rbac1 模型\n\n相对于 rbac0 模型，增加了子角色，引入了继承概念，即子角色可以继承父角色的所有权限。\n\n\n\n**使用场景：**如某个业务部门，有经理、主管、专员。主管的权限不能大于经理，专员的权限不能大于主管，如果采用 rbac0 模型做权限系统，极可能出现分配权限失误，最终出现主管拥有经理都没有的权限的情况。\n\n而 rbac1 模型就很好解决了这个问题，创建完经理角色并配置好权限后，主管角色的权限继承经理角色的权限，并且支持在经理权限上删减主管权限。\n\n\n# 2.5. rbac2 模型\n\n基于 rbac0 模型，增加了对角色的一些限制：角色互斥、基数约束、先决条件角色等。\n\n * **角色互斥：**同一用户不能分配到一组互斥角色集合中的多个角色，互斥角色是指权限互相制约的两个角色。案例：财务系统中一个用户不能同时被指派给会计角色和审计员角色。\n * **基数约束：**一个角色被分配的用户数量受限，它指的是有多少用户能拥有这个角色。例如：一个角色专门为公司 ceo 创建的，那这个角色的数量是有限的。\n * **先决条件角色：**指要想获得较高的权限，要首先拥有低一级的权限。例如：先有副总经理权限，才能有总经理权限。\n * **运行时互斥：**例如，允许一个用户具有两个角色的成员资格，但在运行中不可同时激活这两个角色。\n\n\n# 2.6. rbac3 模型\n\n称为统一模型，它包含了 rbac1 和 rbac2，利用传递性，也把 rbac0 包括在内，综合了 rbac0、rbac1 和 rbac2 的所有特点，这里就不在多描述了。\n\n\n\n\n# 2.7. 什么是权限\n\n说了这么久用户-角色-权限，可能小伙伴们都了解了什么是用户、什么是角色。但是有的小伙伴会好奇，那权限又是个什么玩意呢？\n\n权限是资源的集合，这里的资源指的是软件中所有的内容，包括模块、菜单、页面、字段、操作功能（增删改查）等等。具体的权限配置上，目前形式多种多样，按照我个人的理解，可以将权限分为：页面权限、操作权限和数据权限（这种分类法，主要是结合自己在工作中的实际情况理解总结而来，若有不足之处，也请大家指出）。\n\n**页面权限：**所有系统都是由一个个的页面组成，页面再组成模块，用户是否能看到这个页面的菜单、是否能进入这个页面就称为页面权限。\n\n如下图：\n\n\n\n客户列表、客户黑名单、客户审批页面组成了客户管理这个模块。对于普通用户，不能进行审批操作，即无客户审批页面权限，在他的账号登录后侧边导航栏只显示客户列表、客户黑名单两个菜单。\n\n**操作权限：**用户凡是在操作系统中的任何动作、交互都是操作权限，如增删改查等。\n\n**数据权限：**一般业务管理系统，都有数据私密性的要求：哪些人可以看到哪些数据，不可以看到哪些数据。\n\n简单举个例子：某系统中有销售部门，销售专员负责推销商品，销售主管负责管理销售专员日常工作，经理负责组织管理销售主管作业。\n\n如下图：\n\n\n\n按照实际理解，‘销售专员张三’登录时，只能看到自己负责的数据；销售主管 2 登录时，能看到他所领导的所有业务员负责的数据，但看不到其他团队业务员负责的数据。\n\n换另外一句话就是：我的客户只有我和我的直属上级以及直属上级的领导能看到，这就是我理解的数据权限。\n\n要实现数据权限有多种方式：\n\n 1. 可以利用 rbac1 模型，通过角色分级来实现。\n 2. 在‘用户-角色-权限’的基础上，增加用户与组织的关联关系，用组织决定用户的数据权限。\n\n具体如何做呢？\n\n① 组织层级划分：\n\n\n\n**② 数据可视权限规则制定：**上级组织只能看到下级组织员工负责的数据，而不能看到其他平级组织及其下级组织的员工数据等。\n\n通过以上两点，系统就可以在用户登录时，自动判断要给用户展示哪些数据了。\n\n\n# 2.8. 用户组的使用\n\n当平台用户基数增大，角色类型增多时，如果直接给用户配角色，管理员的工作量就会很大。这时候我们可以引入一个概念“用户组”，就是将相同属性的用户归类到一起。\n\n例如：加入用户组的概念后，可以将部门看做一个用户组，再给这个部门直接赋予角色（1 万员工部门可能就几十个），使部门拥有部门权限，这样这个部门的所有用户都有了部门权限，而不需要为每一个用户再单独指定角色，极大的减少了分配权限的工作量。\n\n同时，也可以为特定的用户指定角色，这样用户除了拥有所属用户组的所有权限外，还拥有自身特定的权限。\n\n用户组的优点，除了减少工作量，还有更便于理解、增加多级管理关系等。如：我们在进行组织机构配置的时候，除了加入部门，还可以加入科室、岗位等层级，来为用户组内部成员的权限进行等级上的区分。\n\n关于用户组的详细疑难解答，请查看https://wen.woshipm.com/question/detail/88fues.html。在这里也十分感谢为我解答疑惑的朋友们！\n\n\n# 2.9. 实例分析\n\n\n# 2.10. 如何设计 rbac 权限系统\n\n首先，我们思考一下一个简单的权限系统应该具备哪些内容？\n\n答案显而易见，rbac 模型：用户-角色-权限。所以最基本的我们应该具备用户、角色、权限这三个内容。\n\n接下来，我们思考，究竟如何将三者关联起来。回顾前文，角色作为枢纽，关联用户、权限。所以在 rbac 模型下，我们应该：创建一个角色，并为这个角色赋予相应权限，最后将角色赋予用户。\n\n将这个问题抽象为流程，如下图：\n\n\n\n现在，基本的流程逻辑已经抽象出来了，接下来，分析该如何设计呢？\n\n * 第一步，需要角色管理列表，在角色管理列表能快速创建一个角色，且创建角色的同时能为角色配置权限，并且支持创建成功的角色列表能随时进行权限配置的的修改；\n * 第二步，需要用户管理列表，在用户管理列表能快速添加一个用户，且添加用户时有让用户关联角色的功能。\n\n简单来说权限系统设计就包含以上两步，接下来为大家进行实例分析。\n\n\n# 2.11. 实例分析\n\n① 创建角色列表\n\n\n\n在角色列表快速创建一个角色：点击创建角色，支持创建角色时配置权限。\n\n\n\n② 创建用户列表\n\n\n\n在用户列表快速创建一个用户：支持用户关联角色的功能。\n\n\n\n上述案例是基于最简单的 rbac0 模型创建，适用于大部分常规的权限管理系统。\n\n下面再分析一下 rbac1 中角色分级具体如何设计。\n\n 1. 在 rbac0 的基础上，加上角色等级这个字段。\n 2. 权限分配规则制定：低等级角色只能在高等级角色权限基础上进行删减权限。\n\n具体界面呈现如下图：\n\n\n\n以上就是简单的 rbac 系统设计，若需更复杂的，还请读者根据上面的分析自行揣摩思考，尽管样式不同，但万变不离其宗，理解清楚 rbac 模型后，结合自己的业务就可以设计出一套符合自己平台需求的角色权限系统，具体的就不再多阐述了。\n\n\n# 3. 审计\n\ntodo\n\n\n# 4. 网站攻击\n\n互联网环境鱼龙混杂，网站被攻击是常见现象，所以了解一些常见的网站攻击手段十分必要。下面列举比较常见的 4 种攻击手段：\n\n\n# 4.1. xss\n\n# 4.1.1. 概念\n\n跨站脚本（cross-site scripting，通常简称为xss） 是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了 html 以及用户端脚本语言。\n\nxss 攻击示例：\n\n假如有下面一个 textbox\n\n<input type="text" name="address1" value="value1from" />\n\n\nvalue1from 是来自用户的输入，如果用户不是输入 value1from,而是输入 "/><script>alert(document.cookie)<\/script><!- 那么就会变成：\n\n<input type="text" name="address1" value="" />\n<script>\n  alert(document.cookie)\n<\/script>\n<!- ">\n\n\n嵌入的 javascript 代码将会被执行。攻击的威力，取决于用户输入了什么样的脚本。\n\n# 4.1.2. 攻击手段和目的\n\n常用的 xss 攻击手段和目的有：\n\n * 盗用 cookie，获取敏感信息。\n * 利用植入 flash，通过 crossdomain 权限设置进一步获取更高权限；或者利用 java 等得到类似的操作。\n * 利用 iframe、frame、xmlhttprequest 或上述 flash 等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。\n * 利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。\n * 在访问量极大的一些页面上的 xss 可以攻击一些小型网站，实现 ddos 攻击的效果。\n\n# 4.1.3. 应对手段\n\n * 过滤特殊字符 - 将用户所提供的内容进行过滤，从而避免 html 和 jascript 代码的运行。如 > 转义为 &gt、< 转义为 &lt 等，就可以防止大部分攻击。为了避免对不必要的内容错误转移，如 3<5 中的 < 需要进行文本匹配后再转移，如：<img src= 这样的上下文中的 < 才转义。\n * 设置 cookie 为 httponly - 设置了 httponly 的 cookie 可以防止 javascript 脚本调用，就无法通过 document.cookie 获取用户 cookie 信息。\n\n> 👉 参考阅读：\n> \n>  * wiki 词条 - 跨站脚本\n>  * web 安全测试之 xss\n\n\n# 4.2. csrf\n\n# 4.2.1. 概念\n\n跨站请求伪造（cross-site request forgery，csrf），也被称为 one-click attack 或者 session riding，通常缩写为 csrf 或者 xsrf。它是一种挟持用户在当前已登录的 web 应用程序上执行非本意的操作的攻击方法。和跨站脚本（xss）相比，xss 利用的是用户对指定网站的信任，csrf 利用的是网站对用户网页浏览器的信任。\n\n# 4.2.2. 攻击手段和目的\n\n可以如此理解 csrf：攻击者盗用了你的身份，以你的名义发送恶意请求。\n\ncsrf 能做的事太多：\n\n * 以你名义发送邮件，发消息\n * 用你的账号购买商品\n * 用你的名义完成虚拟货币转账\n * 泄露个人隐私\n * ...\n\n# 4.2.3. 应对手段\n\n * 表单 token - csrf 是一个伪造用户请求的操作，所以需要构造用户请求的所有参数才可以。表单 token 通过在请求参数中添加随机数的办法来阻止攻击者获得所有请求参数。\n * 验证码 - 请求提交时，需要用户输入验证码，以避免用户在不知情的情况下被攻击者伪造请求。\n * referer check - http 请求头的 referer 域中记录着请求资源，可通过检查请求来源，验证其是否合法。\n\n> 👉 参考阅读：\n> \n>  * wiki 词条 - 跨站请求伪造\n>  * 浅谈 csrf 攻击方式\n>  * 「每日一题」csrf 是什么？「每日一题」csrf 是什么？\n>  * web 安全之-csrf（跨站请求伪造）\n\n\n# 4.3. sql 注入\n\n# 4.3.1. 概念\n\nsql 注入攻击（sql injection），是发生于应用程序之数据层的安全漏洞。简而言之，是在输入的字符串之中注入 sql 指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的 sql 指令而运行，因此遭到破坏或是入侵。\n\n攻击示例：\n\n考虑以下简单的登录表单：\n\n<form action="/login" method="post">\n  <p>username: <input type="text" name="username" /></p>\n  <p>password: <input type="password" name="password" /></p>\n  <p><input type="submit" value="登陆" /></p>\n</form>\n\n\n我们的处理里面的 sql 可能是这样的：\n\nusername:=r.form.get("username")\npassword:=r.form.get("password")\nsql:="select * from user where username=\'"+username+"\' and password=\'"+password+"\'"\n\n\n如果用户的输入的用户名如下，密码任意\n\nmyuser\' or \'foo\' = \'foo\' --\n\n\n那么我们的 sql 变成了如下所示：\n\nselect * from user where username=\'myuser\' or \'foo\' = \'foo\' --\'\' and password=\'xxx\'\n\n\n在 sql 里面 -- 是注释标记，所以查询语句会在此中断。这就让攻击者在不知道任何合法用户名和密码的情况下成功登录了。\n\n对于 mssql 还有更加危险的一种 sql 注入，就是控制系统，下面这个可怕的例子将演示如何在某些版本的 mssql 数据库上执行系统命令。\n\nsql:="select * from products where name like \'%"+prod+"%\'"\ndb.exec(sql)\n\n\n如果攻击提交 a%\' exec master..xp_cmdshell \'net user test testpass /add\' -- 作为变量 prod 的值，那么 sql 将会变成\n\nsql:="select * from products where name like \'%a%\' exec master..xp_cmdshell \'net user test testpass /add\'--%\'"\n\n\nmssql 服务器会执行这条 sql 语句，包括它后面那个用于向系统添加新用户的命令。如果这个程序是以 sa 运行而 mssqlserver 服务又有足够的权限的话，攻击者就可以获得一个系统帐号来访问主机了。\n\n虽然以上的例子是针对某一特定的数据库系统的，但是这并不代表不能对其它数据库系统实施类似的攻击。针对这种安全漏洞，只要使用不同方法，各种数据库都有可能遭殃。\n\n# 4.3.2. 攻击手段和目的\n\n * 数据表中的数据外泄，例如个人机密数据，账户数据，密码等。\n * 数据结构被黑客探知，得以做进一步攻击（例如 select * from sys.tables）。\n * 数据库服务器被攻击，系统管理员账户被窜改（例如 alter login sa with password=\'xxxxxx\'）。\n * 获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及 xss 等。\n * 经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如 xp_cmdshell "net stop iisadmin"可停止服务器的 iis 服务）。\n * 破坏硬盘数据，瘫痪全系统（例如 xp_cmdshell "format c:"）。\n\n# 4.3.3. 应对手段\n\n * 使用参数化查询 - 建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 sql 语句中，即不要直接拼接 sql 语句。例如使用 database/sql 里面的查询函数 prepare 和 query ，或者 exec(query string, args ...interface{})。\n * 单引号转换 - 在组合 sql 字符串时，先针对所传入的参数进行字符替换（将单引号字符替换为连续 2 个单引号字符）。\n\n> 👉 参考阅读：\n> \n>  * wiki 词条 - sql 注入攻击\n>  * 避免 sql 注入\n>  * 实例讲解 sql 注入攻击\n\n\n# 4.4. dos\n\n拒绝服务攻击（denial-of-service attack, dos）亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。\n\n当黑客使用网络上两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击时，称为分布式拒绝服务攻击（distributed denial-of-service attack，缩写：ddos attack、ddos）。\n\n# 4.4.1. 攻击方式\n\n * 带宽消耗型攻击\n * 资源消耗型攻击\n\n# 4.4.2. 应对手段\n\n * 防火墙 - 允许或拒绝特定通讯协议，端口或 ip 地址。当攻击从少数不正常的 ip 地址发出时，可以简单的使用拒绝规则阻止一切从攻击源 ip 发出的通信。\n * 路由器、交换机 - 具有速度限制和访问控制能力。\n * 流量清洗 - 通过采用抗 dos 软件处理，将正常流量和恶意流量区分开。\n\n> 👉 参考阅读：\n> \n>  * 拒绝服务攻击\n\n\n# 5. 加密技术\n\n对于网站来说，用户信息、账户等等敏感数据一旦泄漏，后果严重，所以为了保护数据，应对这些信息进行加密处理。\n\n信息加密技术一般分为：\n\n * 消息摘要\n * 加密算法\n   * 对称加密\n   * 非对称加密\n * 证书\n\n\n# 5.1. 消息摘要\n\n常用数字签名算法：md5、sha 等。\n\n应用场景：将用户密码以消息摘要形式保存到数据库中。\n\n> 👉 参考阅读： java 编码和加密\n\n\n# 5.2. 加密算法\n\n# 5.2.1. 对称加密\n\n对称加密指加密和解密所使用的密钥是同一个密钥。\n\n常用对称加密算法：des、aes 等。\n\n应用场景：cookie 加密、通信机密等。\n\n# 5.2.2. 非对称加密\n\n非对称加密指加密和解密所使用的不是同一个密钥，而是一个公私钥对。用公钥加密的信息必须用私钥才能解开；反之，用私钥加密的信息只有用公钥才能解开。\n\n常用非对称加密算法：rsa 等。\n\n应用场景：https 传输中浏览器使用的数字证书实质上是经过权威机构认证的非对称加密公钥。\n\n> 👉 参考阅读： java 编码和加密\n\n# 5.2.3. 密钥安全管理\n\n保证密钥安全的方法：\n\n 1. 把密钥和算法放在一个独立的服务器上，对外提供加密和解密服务，应用系统通过调用这个服务，实现数据的加解密。\n 2. 把加解密算法放在应用系统中，密钥则放在独立服务器中，为了提高密钥的安全性，实际存储时，密钥被切分成数片，加密后分别保存在不同存储介质中。\n\n\n# 5.3. 证书\n\n证书可以称为信息安全加密的终极手段。公开密钥认证（英语：public key certificate），又称公开密钥证书、公钥证书、数字证书（digital certificate）、数字认证、身份证书（identity certificate）、电子证书或安全证书，是用于公开密钥基础建设的电子文件，用来证明公开密钥拥有者的身份。此文件包含了公钥信息、拥有者身份信息（主体）、以及数字证书认证机构（发行者）对这份文件的数字签名，以保证这个文件的整体内容正确无误。\n\n透过信任权威数字证书认证机构的根证书、及其使用公开密钥加密作数字签名核发的公开密钥认证，形成信任链架构，已在 tls 实现并在万维网的 http 以 https、在电子邮件的 smtp 以 starttls 引入并广泛应用。\n\n众所周知，常见的应用层协议 http、ftp、telnet 本身不保证信息安全。但是加入了 ssl/tls 加密数据包机制的 https、ftps、telnets 是信息安全的。传输层安全性协议（transport layer security, tls），及其前身安全套接层（secure sockets layer, ssl）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。\n\n# 5.3.1. 证书原理\n\nssl/tls 协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。\n\n这里有两个问题：\n\n（1）如何保证公钥不被篡改？\n\n解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。\n\n（2）公钥加密计算量太大，如何减少耗用的时间？\n\n解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。\n\nssl/tls 协议的基本过程是这样的：\n\n 1. 客户端向服务器端索要并验证公钥。\n 2. 双方协商生成"对话密钥"。\n 3. 双方采用"对话密钥"进行加密通信。\n\n> 👉 参考阅读：\n> \n>  * 传输层安全性协议\n>  * 公开密钥认证\n>  * ssl/tls 协议运行机制的概述\n\n\n# 6. 信息过滤\n\n在网络中，广告和垃圾信息屡见不鲜，泛滥成灾。\n\n常见的信息过滤与反垃圾手段有：\n\n\n# 6.1. 文本匹配\n\n解决敏感词过滤。系统维护一份敏感词清单，如果信息中含有敏感词，则自动进行过滤或拒绝信息。\n\n\n# 6.2. 黑名单\n\n黑名单就是将一些已经被识别出有违规行为的 ip、域名、邮箱等加入黑名单，拒绝其请求。\n\n黑名单可以通过 hash 表来实现，方法简单，复杂度小，适于一般应用场景。\n\n但如果黑名单列表非常大时，hash 表要占用很大的内存空间，这时就不再使用了。这种情况下，可以使用布隆过滤器来实现，即通过一个二进制列表和一组随机数映射函数来实现。\n\n\n# 6.3. 分类算法\n\n对于海量信息，难以通过人工去审核。对广告贴。\n\n垃圾邮件等内容的识别比较好的自动化方法就是采用分类算法。\n\n简单来说，即将批量已分类的样本输入分类算法进行训练，得到一个分类模型，然后利用分类算法结合分类模型去对信息进行识别。想了解具体做法，需要去理解机器学习相关知识。\n\n\n# 7. 风险控制\n\n网络给商务、金融领域带来极大便利的同时，也将风险带给了对网络安全一无所知的人们。由于交易双方信息的不对等，使得交易存在着风险，而当交易发生在网络上时，风险就更加难以控制了。\n\n\n# 7.1. 风险种类\n\n * 账户风险 - 盗用账户、恶意注册账户等\n * 买家风险 - 虚假询盘、恶意拒收、恶意下单、黄牛党抢购热门商品等\n * 卖家风险 - 虚假发货、出售违禁品、侵权等\n * 交易风险 - 信用卡盗刷、交易欺诈、洗钱、套现、电信诈骗等\n\n\n# 7.2. 风险控制手段\n\n大型电商网站系统或金融系统都配备专业的风控团队进行风险控制。风险控制手段既包括人工审核也包括自动审核。\n\n自动风控的技术手段主要有规则引擎和统计模型。\n\n\n# 7.3. 规则引擎\n\n在交易中，买家、卖家的某些指标满足一定条件时，就会被认为存在风险。如：交易金额超过某个数值；用户来自黑名单；用户和上次登录的地址距离差距很大；用户在一定时间内频繁交易等等。\n\n如果以上这些条件都通过 if ... else ... 式样的代码去实现，代码维护、扩展会非常不便。因此，就有了规则引擎来处理这类问题。规则引擎是一种将业务规则和规则处理逻辑相分离的技术，业务规则由运营人员通过管理界面去编辑，实现无需修改代码，即可实时的使用新规则。\n\n\n# 7.4. 统计模型\n\n规则引擎虽然技术简单，但是随着规则不断增加，规模越来越大。可能会出现规则冲突，难以维护的情况，并且规则越多，性能也越差。\n\n为了解决这种问题，就有了统计模型。统计模型会使用分类算法或更复杂的机器学习算法进行智能统计。根据历史交易中的信息训练分类，然后将经过采集加工后的交易信息输入分类算法，得到交易风险值，然后基于此，做出预测。\n\n经过充分训练后的统计模型，准确率不低于规则引擎。但是，需要有领域专家、行业专家介入，建立合理的训练模型，并不断优化。\n\n\n# 8. 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * wiki 词条 - 跨站脚本\n * web 安全测试之 xss\n * wiki 词条 - 跨站请求伪造\n * 浅谈 csrf 攻击方式\n * 「每日一题」csrf 是什么？「每日一题」csrf 是什么？\n * web 安全之-csrf（跨站请求伪造）\n * wiki 词条 - sql 注入攻击\n * 避免 sql 注入\n * 实例讲解 sql 注入攻击\n * 拒绝服务攻击\n * 传输层安全性协议\n * 公开密钥认证\n * ssl/tls 协议运行机制的概述\n * http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\n * cas 实现 sso 单点登录原理\n * 权限系统设计模型分析（dac，mac，rbac，abac）\n * rbac 模型：基于用户-角色-权限控制的一些思考',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"大型系统核心技术",frontmatter:{title:"大型系统核心技术",date:"2018-07-09T00:00:00.000Z",categories:["架构"],tags:["架构","分布式"],permalink:"/pages/eb0425/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/08.%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html",relativePath:"01.架构/08.大型系统核心技术.md",key:"v-190803ce",path:"/pages/eb0425/",headers:[{level:2,title:"1. 分布式事务",slug:"_1-分布式事务",normalizedTitle:"1. 分布式事务",charIndex:269},{level:2,title:"2. 分布式锁",slug:"_2-分布式锁",normalizedTitle:"2. 分布式锁",charIndex:304},{level:3,title:"2.1. 基于数据库实现分布式锁",slug:"_2-1-基于数据库实现分布式锁",normalizedTitle:"2.1. 基于数据库实现分布式锁",charIndex:450},{level:4,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:395},{level:5,title:"1. 创建表",slug:"_1-创建表",normalizedTitle:"1. 创建表",charIndex:476},{level:5,title:"2. 获取锁",slug:"_2-获取锁",normalizedTitle:"2. 获取锁",charIndex:933},{level:5,title:"3. 释放锁",slug:"_3-释放锁",normalizedTitle:"3. 释放锁",charIndex:1150},{level:4,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:139},{level:4,title:"解决办法",slug:"解决办法",normalizedTitle:"解决办法",charIndex:1487},{level:4,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:1694},{level:3,title:"2.2. 基于 Redis 实现分布式锁",slug:"_2-2-基于-redis-实现分布式锁",normalizedTitle:"2.2. 基于 redis 实现分布式锁",charIndex:1786},{level:4,title:"Redis 命令",slug:"redis-命令",normalizedTitle:"redis 命令",charIndex:1899},{level:4,title:"实现",slug:"实现-2",normalizedTitle:"实现",charIndex:395},{level:4,title:"问题",slug:"问题-2",normalizedTitle:"问题",charIndex:139},{level:4,title:"小结",slug:"小结-2",normalizedTitle:"小结",charIndex:1694},{level:3,title:"2.3. 基于 ZooKeeper 实现分布式锁",slug:"_2-3-基于-zookeeper-实现分布式锁",normalizedTitle:"2.3. 基于 zookeeper 实现分布式锁",charIndex:2391},{level:4,title:"实现",slug:"实现-3",normalizedTitle:"实现",charIndex:395},{level:4,title:"小结",slug:"小结-3",normalizedTitle:"小结",charIndex:1694},{level:2,title:"3. 分布式 Session",slug:"_3-分布式-session",normalizedTitle:"3. 分布式 session",charIndex:3158},{level:3,title:"3.1. Sticky Sessions",slug:"_3-1-sticky-sessions",normalizedTitle:"3.1. sticky sessions",charIndex:3373},{level:3,title:"3.2. Session Replication",slug:"_3-2-session-replication",normalizedTitle:"3.2. session replication",charIndex:3502},{level:3,title:"3.3. Session Server",slug:"_3-3-session-server",normalizedTitle:"3.3. session server",charIndex:3612},{level:2,title:"4. 分布式存储",slug:"_4-分布式存储",normalizedTitle:"4. 分布式存储",charIndex:3739},{level:2,title:"5. 分布式缓存",slug:"_5-分布式缓存",normalizedTitle:"5. 分布式缓存",charIndex:3853},{level:2,title:"6. 分布式计算",slug:"_6-分布式计算",normalizedTitle:"6. 分布式计算",charIndex:4194},{level:2,title:"7. 负载均衡",slug:"_7-负载均衡",normalizedTitle:"7. 负载均衡",charIndex:4207},{level:3,title:"7.1. 算法",slug:"_7-1-算法",normalizedTitle:"7.1. 算法",charIndex:4219},{level:4,title:"轮询（Round Robin）",slug:"轮询-round-robin",normalizedTitle:"轮询（round robin）",charIndex:4230},{level:4,title:"加权轮询（Weighted Round Robbin）",slug:"加权轮询-weighted-round-robbin",normalizedTitle:"加权轮询（weighted round robbin）",charIndex:4459},{level:4,title:"最少连接（least Connections）",slug:"最少连接-least-connections",normalizedTitle:"最少连接（least connections）",charIndex:4617},{level:4,title:"加权最少连接（Weighted Least Connection）",slug:"加权最少连接-weighted-least-connection",normalizedTitle:"加权最少连接（weighted least connection）",charIndex:4917},{level:4,title:"随机算法（Random）",slug:"随机算法-random",normalizedTitle:"随机算法（random）",charIndex:5008},{level:4,title:"源地址哈希法 (IP Hash)",slug:"源地址哈希法-ip-hash",normalizedTitle:"源地址哈希法 (ip hash)",charIndex:5068},{level:3,title:"7.2. 实现",slug:"_7-2-实现",normalizedTitle:"7.2. 实现",charIndex:5243},{level:4,title:"HTTP 重定向",slug:"http-重定向",normalizedTitle:"http 重定向",charIndex:5254},{level:4,title:"DNS 重定向",slug:"dns-重定向",normalizedTitle:"dns 重定向",charIndex:5392},{level:4,title:"修改 MAC 地址",slug:"修改-mac-地址",normalizedTitle:"修改 mac 地址",charIndex:5540},{level:4,title:"修改 IP 地址",slug:"修改-ip-地址",normalizedTitle:"修改 ip 地址",charIndex:5615},{level:4,title:"代理自动配置",slug:"代理自动配置",normalizedTitle:"代理自动配置",charIndex:5649},{level:2,title:"8. 资料",slug:"_8-资料",normalizedTitle:"8. 资料",charIndex:5803}],headersStr:"1. 分布式事务 2. 分布式锁 2.1. 基于数据库实现分布式锁 实现 1. 创建表 2. 获取锁 3. 释放锁 问题 解决办法 小结 2.2. 基于 Redis 实现分布式锁 Redis 命令 实现 问题 小结 2.3. 基于 ZooKeeper 实现分布式锁 实现 小结 3. 分布式 Session 3.1. Sticky Sessions 3.2. Session Replication 3.3. Session Server 4. 分布式存储 5. 分布式缓存 6. 分布式计算 7. 负载均衡 7.1. 算法 轮询（Round Robin） 加权轮询（Weighted Round Robbin） 最少连接（least Connections） 加权最少连接（Weighted Least Connection） 随机算法（Random） 源地址哈希法 (IP Hash) 7.2. 实现 HTTP 重定向 DNS 重定向 修改 MAC 地址 修改 IP 地址 代理自动配置 8. 资料",content:"# 大型系统核心技术\n\n> 大型系统的设计目标就是为了快速、高效、稳定的处理海量的数据以及高并发的请求。\n> \n> 单机服务受限于硬件，客观存在着资源瓶颈，难以应对不断增长的数据量和请求量，为了打破瓶颈，大型系统基本上都被设计为分布式系统。\n> \n> 分布式系统由于其面临的共性问题，在很多场景下的解决方案往往也存在着共性。因此，我们会发现，很多优秀的大型系统在设计方案上存在着很多的共同点。\n> \n> 本文主要讨论应对分布式系统共性问题的解决方案，这既可以加深对分布式系统运作原理的理解，也可以作为设计大型分布式系统时的借鉴。\n\n\n# 1. 分布式事务\n\n> 参考：分布式原理#4-分布式事务问题\n\n\n# 2. 分布式锁\n\nJava 原生 API 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。\n\n分布式锁的解决方案大致有以下几种：\n\n * 基于数据库实现\n * 基于缓存（redis，memcached 等）实现\n * 基于 Zookeeper 实现\n\n\n# 2.1. 基于数据库实现分布式锁\n\n# 实现\n\n# 1. 创建表\n\nCREATE TABLE `methodLock` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `method_name` varchar(64) NOT NULL DEFAULT '' COMMENT '锁定的方法名',\n  `desc` varchar(1024) NOT NULL DEFAULT '备注信息',\n  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '保存数据时间，自动生成',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uidx_method_name` (`method_name `) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='锁定中的方法';\n\n\n# 2. 获取锁\n\n想要锁住某个方法时，执行以下 SQL：\n\ninsert into methodLock(method_name,desc) values (‘method_name’,‘desc’)\n\n\n因为我们对 method_name 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。\n\n成功插入则获取锁。\n\n# 3. 释放锁\n\n当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:\n\ndelete from methodLock where method_name ='method_name'\n\n\n# 问题\n\n 1. 这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。\n 2. 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。\n 3. 这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。\n 4. 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。\n\n# 解决办法\n\n 1. 单点问题可以用多数据库实例，同时塞 N 个表，N/2+1 个成功就任务锁定成功\n 2. 写一个定时任务，隔一段时间清除一次过期的数据。\n 3. 写一个 while 循环，不断的重试插入，直到成功。\n 4. 在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。\n\n# 小结\n\n * 优点: 直接借助数据库，容易理解。\n * 缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。\n\n\n# 2.2. 基于 Redis 实现分布式锁\n\n相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。\n\n# Redis 命令\n\n * setnx - setnx key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。\n * expire - expire key timeout：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。\n * delete - delete key：删除 key\n\n# 实现\n\n单点实现步骤：\n\n 1. 获取锁的使用，使用 setnx 加锁，锁的 value 值为一个随机生成的 UUID，再使用 expire 设置一个过期值。\n 2. 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。\n 3. 释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。\n\n# 问题\n\n * 单点问题。如果单机 redis 挂掉了，那么程序会跟着出错。\n * 如果转移使用 slave 节点，复制不是同步复制，会出现多个程序获取锁的情况\n\n# 小结\n\n可以考虑使用 redisson 的解决方案。\n\n\n# 2.3. 基于 ZooKeeper 实现分布式锁\n\n# 实现\n\n这也是 ZooKeeper 客户端 curator 的分布式锁实现。\n\n 1. 创建一个目录 mylock；\n 2. 线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；\n 3. 获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；\n 4. 线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；\n 5. 线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。\n\n# 小结\n\nZooKeeper 版本的分布式锁问题相对比较来说少。\n\n * 锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。\n * 是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。\n\n总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。\n\n\n# 3. 分布式 Session\n\n在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。\n\n分布式 Session 的几种实现策略：\n\n 1. 粘性 session\n 2. 应用服务器间的 session 复制共享\n 3. 基于 cache DB 缓存的 session 共享\n\n\n# 3.1. Sticky Sessions\n\n需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 Session 存放在该服务器节点中。\n\n缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。\n\n\n\n\n# 3.2. Session Replication\n\n在服务器节点之间进行 Session 同步操作，这样的话用户可以访问任何一个服务器节点。\n\n缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。\n\n\n\n\n# 3.3. Session Server\n\n使用一个单独的服务器存储 Session 数据，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。\n\n缺点：需要去实现存取 Session 的代码。\n\n\n\n\n# 4. 分布式存储\n\n通常有两种解决方案：\n\n 1. 数据分布：就是把数据分块存在不同的服务器上（分库分表）。\n 2. 数据复制：让所有的服务器都有相同的数据，提供相当的服务。\n\n> 参考：分布式原理.md#2-数据分布\n\n\n# 5. 分布式缓存\n\n使用缓存的好处：\n\n * 提升数据读取速度\n * 提升系统扩展能力，通过扩展缓存，提升系统承载能力\n * 降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本\n\n根据业务场景，通常缓存有以下几种使用方式\n\n * 懒汉式(读时触发)：写入 DB 后, 然后把相关的数据也写入 Cache\n * 饥饿式(写时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache\n * 定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性\n\n缓存分类：\n\n * 应用内缓存：如：EHCache\n * 分布式缓存：如：Memached、Redis\n\n> 参考：分布式原理.md#6-分布式缓存问题\n\n\n# 6. 分布式计算\n\n\n# 7. 负载均衡\n\n\n# 7.1. 算法\n\n# 轮询（Round Robin）\n\n轮询算法把每个请求轮流发送到每个服务器上。下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。\n\n\n\n该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。\n\n\n\n# 加权轮询（Weighted Round Robbin）\n\n加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。\n\n\n\n# 最少连接（least Connections）\n\n由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开。该系统继续运行时，服务器 2 会承担过大的负载。\n\n\n\n最少连接算法就是将请求发送给当前最少连接数的服务器上。例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。\n\n\n\n# 加权最少连接（Weighted Least Connection）\n\n在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。\n\n\n\n# 随机算法（Random）\n\n把请求随机发送到服务器上。和轮询算法类似，该算法比较适合服务器性能差不多的场景。\n\n\n\n# 源地址哈希法 (IP Hash)\n\n源地址哈希通过对客户端 IP 哈希计算得到的一个数值，用该数值对服务器数量进行取模运算，取模结果便是目标服务器的序号。\n\n * 优点：保证同一 IP 的客户端都会被 hash 到同一台服务器上。\n * 缺点：不利于集群扩展，后台服务器数量变更都会影响 hash 结果。可以采用一致性 Hash 改进。\n\n\n\n\n# 7.2. 实现\n\n# HTTP 重定向\n\nHTTP 重定向负载均衡服务器收到 HTTP 请求之后会返回服务器的地址，并将该地址写入 HTTP 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求。\n\n缺点：\n\n * 用户访问的延迟会增加；\n * 如果负载均衡器宕机，就无法访问该站点。\n\n\n\n# DNS 重定向\n\n使用 DNS 作为负载均衡器，根据负载情况返回不同服务器的 IP 地址。大型网站基本使用了这种方式做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。\n\n缺点：\n\n * DNS 查找表可能会被客户端缓存起来，那么之后的所有请求都会被重定向到同一个服务器。\n\n\n\n# 修改 MAC 地址\n\n使用 LVS（Linux Virtual Server）这种链路层负载均衡器，根据负载情况修改请求的 MAC 地址。\n\n\n\n# 修改 IP 地址\n\n在网络层修改请求的目的 IP 地址。\n\n\n\n# 代理自动配置\n\n正向代理与反向代理的区别：\n\n * 正向代理：发生在客户端，是由用户主动发起的。比如翻墙，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。\n * 反向代理：发生在服务器端，用户不知道代理的存在。\n\nPAC 服务器是用来判断一个请求是否要经过代理。\n\n\n\n\n# 8. 资料\n\n * https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html\n * https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E5%88%86%E5%B8%83%E5%BC%8F%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.md\n * https://www.jianshu.com/p/453c6e7ff81c\n * https://juejin.im/post/5a20cd8bf265da43163cdd9a\n * https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8\n * https://github.com/L316476844/distributed-session\n * 分布式缓存架构基础\n * 阿里 P8 技术专家细究分布式缓存问题",normalizedContent:"# 大型系统核心技术\n\n> 大型系统的设计目标就是为了快速、高效、稳定的处理海量的数据以及高并发的请求。\n> \n> 单机服务受限于硬件，客观存在着资源瓶颈，难以应对不断增长的数据量和请求量，为了打破瓶颈，大型系统基本上都被设计为分布式系统。\n> \n> 分布式系统由于其面临的共性问题，在很多场景下的解决方案往往也存在着共性。因此，我们会发现，很多优秀的大型系统在设计方案上存在着很多的共同点。\n> \n> 本文主要讨论应对分布式系统共性问题的解决方案，这既可以加深对分布式系统运作原理的理解，也可以作为设计大型分布式系统时的借鉴。\n\n\n# 1. 分布式事务\n\n> 参考：分布式原理#4-分布式事务问题\n\n\n# 2. 分布式锁\n\njava 原生 api 虽然有并发锁，但并没有提供分布式锁的能力，所以针对分布式场景中的锁需要解决的方案。\n\n分布式锁的解决方案大致有以下几种：\n\n * 基于数据库实现\n * 基于缓存（redis，memcached 等）实现\n * 基于 zookeeper 实现\n\n\n# 2.1. 基于数据库实现分布式锁\n\n# 实现\n\n# 1. 创建表\n\ncreate table `methodlock` (\n  `id` int(11) not null auto_increment comment '主键',\n  `method_name` varchar(64) not null default '' comment '锁定的方法名',\n  `desc` varchar(1024) not null default '备注信息',\n  `update_time` timestamp not null default current_timestamp on update current_timestamp comment '保存数据时间，自动生成',\n  primary key (`id`),\n  unique key `uidx_method_name` (`method_name `) using btree\n) engine=innodb default charset=utf8 comment='锁定中的方法';\n\n\n# 2. 获取锁\n\n想要锁住某个方法时，执行以下 sql：\n\ninsert into methodlock(method_name,desc) values (‘method_name’,‘desc’)\n\n\n因为我们对 method_name 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。\n\n成功插入则获取锁。\n\n# 3. 释放锁\n\n当方法执行完毕之后，想要释放锁的话，需要执行以下 sql:\n\ndelete from methodlock where method_name ='method_name'\n\n\n# 问题\n\n 1. 这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。\n 2. 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。\n 3. 这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。\n 4. 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。\n\n# 解决办法\n\n 1. 单点问题可以用多数据库实例，同时塞 n 个表，n/2+1 个成功就任务锁定成功\n 2. 写一个定时任务，隔一段时间清除一次过期的数据。\n 3. 写一个 while 循环，不断的重试插入，直到成功。\n 4. 在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。\n\n# 小结\n\n * 优点: 直接借助数据库，容易理解。\n * 缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。\n\n\n# 2.2. 基于 redis 实现分布式锁\n\n相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好一些。目前有很多成熟的分布式产品，包括 redis、memcache、tair 等。这里以 redis 举例。\n\n# redis 命令\n\n * setnx - setnx key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。\n * expire - expire key timeout：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。\n * delete - delete key：删除 key\n\n# 实现\n\n单点实现步骤：\n\n 1. 获取锁的使用，使用 setnx 加锁，锁的 value 值为一个随机生成的 uuid，再使用 expire 设置一个过期值。\n 2. 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。\n 3. 释放锁的时候，通过 uuid 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。\n\n# 问题\n\n * 单点问题。如果单机 redis 挂掉了，那么程序会跟着出错。\n * 如果转移使用 slave 节点，复制不是同步复制，会出现多个程序获取锁的情况\n\n# 小结\n\n可以考虑使用 redisson 的解决方案。\n\n\n# 2.3. 基于 zookeeper 实现分布式锁\n\n# 实现\n\n这也是 zookeeper 客户端 curator 的分布式锁实现。\n\n 1. 创建一个目录 mylock；\n 2. 线程 a 想获取锁就在 mylock 目录下创建临时顺序节点；\n 3. 获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；\n 4. 线程 b 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；\n 5. 线程 a 处理完，删除自己的节点，线程 b 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。\n\n# 小结\n\nzookeeper 版本的分布式锁问题相对比较来说少。\n\n * 锁的占用时间限制：redis 就有占用时间限制，而 zookeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 zookeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 zookeeper 一样添加一些与客户端绑定的临时键，也是一大好事。\n * 是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 zookeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。\n\n总体上来说 zookeeper 实现分布式锁更加的简单，可靠性更高。但 zookeeper 因为需要频繁的创建和删除节点，性能上不如 redis 方式。\n\n\n# 3. 分布式 session\n\n在分布式场景下，一个用户的 session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 session，就可能导致用户需要重新进行登录等操作。\n\n分布式 session 的几种实现策略：\n\n 1. 粘性 session\n 2. 应用服务器间的 session 复制共享\n 3. 基于 cache db 缓存的 session 共享\n\n\n# 3.1. sticky sessions\n\n需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 session 存放在该服务器节点中。\n\n缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 session。\n\n\n\n\n# 3.2. session replication\n\n在服务器节点之间进行 session 同步操作，这样的话用户可以访问任何一个服务器节点。\n\n缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。\n\n\n\n\n# 3.3. session server\n\n使用一个单独的服务器存储 session 数据，可以存在 mysql 数据库上，也可以存在 redis 或者 memcached 这种内存型数据库。\n\n缺点：需要去实现存取 session 的代码。\n\n\n\n\n# 4. 分布式存储\n\n通常有两种解决方案：\n\n 1. 数据分布：就是把数据分块存在不同的服务器上（分库分表）。\n 2. 数据复制：让所有的服务器都有相同的数据，提供相当的服务。\n\n> 参考：分布式原理.md#2-数据分布\n\n\n# 5. 分布式缓存\n\n使用缓存的好处：\n\n * 提升数据读取速度\n * 提升系统扩展能力，通过扩展缓存，提升系统承载能力\n * 降低存储成本，cache+db 的方式可以承担原有需要多台 db 才能承担的请求量，节省机器成本\n\n根据业务场景，通常缓存有以下几种使用方式\n\n * 懒汉式(读时触发)：写入 db 后, 然后把相关的数据也写入 cache\n * 饥饿式(写时触发)：先查询 db 里的数据, 然后把相关的数据写入 cache\n * 定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性\n\n缓存分类：\n\n * 应用内缓存：如：ehcache\n * 分布式缓存：如：memached、redis\n\n> 参考：分布式原理.md#6-分布式缓存问题\n\n\n# 6. 分布式计算\n\n\n# 7. 负载均衡\n\n\n# 7.1. 算法\n\n# 轮询（round robin）\n\n轮询算法把每个请求轮流发送到每个服务器上。下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。最后，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。\n\n\n\n该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 server 2）。\n\n\n\n# 加权轮询（weighted round robbin）\n\n加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值。例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。\n\n\n\n# 最少连接（least connections）\n\n由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开。该系统继续运行时，服务器 2 会承担过大的负载。\n\n\n\n最少连接算法就是将请求发送给当前最少连接数的服务器上。例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。\n\n\n\n# 加权最少连接（weighted least connection）\n\n在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。\n\n\n\n# 随机算法（random）\n\n把请求随机发送到服务器上。和轮询算法类似，该算法比较适合服务器性能差不多的场景。\n\n\n\n# 源地址哈希法 (ip hash)\n\n源地址哈希通过对客户端 ip 哈希计算得到的一个数值，用该数值对服务器数量进行取模运算，取模结果便是目标服务器的序号。\n\n * 优点：保证同一 ip 的客户端都会被 hash 到同一台服务器上。\n * 缺点：不利于集群扩展，后台服务器数量变更都会影响 hash 结果。可以采用一致性 hash 改进。\n\n\n\n\n# 7.2. 实现\n\n# http 重定向\n\nhttp 重定向负载均衡服务器收到 http 请求之后会返回服务器的地址，并将该地址写入 http 重定向响应中返回给浏览器，浏览器收到后需要再次发送请求。\n\n缺点：\n\n * 用户访问的延迟会增加；\n * 如果负载均衡器宕机，就无法访问该站点。\n\n\n\n# dns 重定向\n\n使用 dns 作为负载均衡器，根据负载情况返回不同服务器的 ip 地址。大型网站基本使用了这种方式做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。\n\n缺点：\n\n * dns 查找表可能会被客户端缓存起来，那么之后的所有请求都会被重定向到同一个服务器。\n\n\n\n# 修改 mac 地址\n\n使用 lvs（linux virtual server）这种链路层负载均衡器，根据负载情况修改请求的 mac 地址。\n\n\n\n# 修改 ip 地址\n\n在网络层修改请求的目的 ip 地址。\n\n\n\n# 代理自动配置\n\n正向代理与反向代理的区别：\n\n * 正向代理：发生在客户端，是由用户主动发起的。比如翻墙，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。\n * 反向代理：发生在服务器端，用户不知道代理的存在。\n\npac 服务器是用来判断一个请求是否要经过代理。\n\n\n\n\n# 8. 资料\n\n * https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html\n * https://github.com/cyc2018/interview-notebook/blob/master/notes/%e5%88%86%e5%b8%83%e5%bc%8f%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90.md\n * https://www.jianshu.com/p/453c6e7ff81c\n * https://juejin.im/post/5a20cd8bf265da43163cdd9a\n * https://github.com/redisson/redisson/wiki/8.-%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e5%92%8c%e5%90%8c%e6%ad%a5%e5%99%a8\n * https://github.com/l316476844/distributed-session\n * 分布式缓存架构基础\n * 阿里 p8 技术专家细究分布式缓存问题",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"领域驱动设计",frontmatter:{title:"领域驱动设计",date:"2020-08-10T10:59:18.000Z",categories:["架构"],tags:["架构","设计","DDD"],permalink:"/pages/4dfb51/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/09.%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1.html",relativePath:"01.架构/09.领域驱动设计.md",key:"v-6655d46f",path:"/pages/4dfb51/",headers:[{level:2,title:"1. DDD 简介",slug:"_1-ddd-简介",normalizedTitle:"1. ddd 简介",charIndex:13},{level:3,title:"1.1. 软件架构模式的演进",slug:"_1-1-软件架构模式的演进",normalizedTitle:"1.1. 软件架构模式的演进",charIndex:27},{level:3,title:"1.2. 什么是 DDD",slug:"_1-2-什么是-ddd",normalizedTitle:"1.2. 什么是 ddd",charIndex:375},{level:3,title:"1.3. DDD 与微服务的关系",slug:"_1-3-ddd-与微服务的关系",normalizedTitle:"1.3. ddd 与微服务的关系",charIndex:699},{level:2,title:"2. DDD 核心概念",slug:"_2-ddd-核心概念",normalizedTitle:"2. ddd 核心概念",charIndex:947},{level:3,title:"2.1. 域",slug:"_2-1-域",normalizedTitle:"2.1. 域",charIndex:965},{level:3,title:"2.2. 通用语言和上下文边界",slug:"_2-2-通用语言和上下文边界",normalizedTitle:"2.2. 通用语言和上下文边界",charIndex:1375},{level:3,title:"2.3. 实体和值对象",slug:"_2-3-实体和值对象",normalizedTitle:"2.3. 实体和值对象",charIndex:1634},{level:3,title:"2.4. 聚合和聚合跟",slug:"_2-4-聚合和聚合跟",normalizedTitle:"2.4. 聚合和聚合跟",charIndex:1921},{level:4,title:"2.4.1. 聚合设计步骤",slug:"_2-4-1-聚合设计步骤",normalizedTitle:"2.4.1. 聚合设计步骤",charIndex:2253},{level:4,title:"2.4.2. 聚合设计原则",slug:"_2-4-2-聚合设计原则",normalizedTitle:"2.4.2. 聚合设计原则",charIndex:2558},{level:2,title:"3. 架构模型",slug:"_3-架构模型",normalizedTitle:"3. 架构模型",charIndex:2662},{level:3,title:"3.1. DDD 架构",slug:"_3-1-ddd-架构",normalizedTitle:"3.1. ddd 架构",charIndex:2674},{level:3,title:"3.2. 整洁架构",slug:"_3-2-整洁架构",normalizedTitle:"3.2. 整洁架构",charIndex:2806},{level:3,title:"3.3. 六边形架构",slug:"_3-3-六边形架构",normalizedTitle:"3.3. 六边形架构",charIndex:2972},{level:3,title:"3.4. 三种架构对比",slug:"_3-4-三种架构对比",normalizedTitle:"3.4. 三种架构对比",charIndex:3320},{level:4,title:"3.4.1. 架构模型和中台、微服务的联系",slug:"_3-4-1-架构模型和中台、微服务的联系",normalizedTitle:"3.4.1. 架构模型和中台、微服务的联系",charIndex:3372},{level:4,title:"3.4.2. 中台建设要聚焦领域模型",slug:"_3-4-2-中台建设要聚焦领域模型",normalizedTitle:"3.4.2. 中台建设要聚焦领域模型",charIndex:3548},{level:4,title:"3.4.3. 微服务要有合理的架构分层",slug:"_3-4-3-微服务要有合理的架构分层",normalizedTitle:"3.4.3. 微服务要有合理的架构分层",charIndex:3732},{level:4,title:"3.4.4. 应用和资源的解耦与适配",slug:"_3-4-4-应用和资源的解耦与适配",normalizedTitle:"3.4.4. 应用和资源的解耦与适配",charIndex:3880},{level:2,title:"4. 中台战略",slug:"_4-中台战略",normalizedTitle:"4. 中台战略",charIndex:4002},{level:3,title:"4.1. 平台不是中台",slug:"_4-1-平台不是中台",normalizedTitle:"4.1. 平台不是中台",charIndex:4014},{level:3,title:"4.2. 什么是中台",slug:"_4-2-什么是中台",normalizedTitle:"4.2. 什么是中台",charIndex:4334},{level:3,title:"4.3. 数字化转型中台",slug:"_4-3-数字化转型中台",normalizedTitle:"4.3. 数字化转型中台",charIndex:4598},{level:3,title:"4.4. 前中后台协同",slug:"_4-4-前中后台协同",normalizedTitle:"4.4. 前中后台协同",charIndex:4615},{level:4,title:"4.4.1. 前台",slug:"_4-4-1-前台",normalizedTitle:"4.4.1. 前台",charIndex:4630},{level:4,title:"4.4.2. 中台",slug:"_4-4-2-中台",normalizedTitle:"4.4.2. 中台",charIndex:4774},{level:4,title:"4.4.3. 后台",slug:"_4-4-3-后台",normalizedTitle:"4.4.3. 后台",charIndex:5308},{level:3,title:"4.5. DDD、中台和微服务的协作",slug:"_4-5-ddd、中台和微服务的协作",normalizedTitle:"4.5. ddd、中台和微服务的协作",charIndex:5421},{level:3,title:"4.6. 如何构建中台",slug:"_4-6-如何构建中台",normalizedTitle:"4.6. 如何构建中台",charIndex:5521},{level:4,title:"4.6.1. 自顶向下策略",slug:"_4-6-1-自顶向下策略",normalizedTitle:"4.6.1. 自顶向下策略",charIndex:5536},{level:4,title:"4.6.2. 自顶向下策略",slug:"_4-6-2-自顶向下策略",normalizedTitle:"4.6.2. 自顶向下策略",charIndex:5664},{level:4,title:"4.6.3. 构建步骤",slug:"_4-6-3-构建步骤",normalizedTitle:"4.6.3. 构建步骤",charIndex:5830},{level:2,title:"5. 边界",slug:"_5-边界",normalizedTitle:"5. 边界",charIndex:5915},{level:2,title:"6. 参考资料",slug:"_6-参考资料",normalizedTitle:"6. 参考资料",charIndex:6203}],headersStr:"1. DDD 简介 1.1. 软件架构模式的演进 1.2. 什么是 DDD 1.3. DDD 与微服务的关系 2. DDD 核心概念 2.1. 域 2.2. 通用语言和上下文边界 2.3. 实体和值对象 2.4. 聚合和聚合跟 2.4.1. 聚合设计步骤 2.4.2. 聚合设计原则 3. 架构模型 3.1. DDD 架构 3.2. 整洁架构 3.3. 六边形架构 3.4. 三种架构对比 3.4.1. 架构模型和中台、微服务的联系 3.4.2. 中台建设要聚焦领域模型 3.4.3. 微服务要有合理的架构分层 3.4.4. 应用和资源的解耦与适配 4. 中台战略 4.1. 平台不是中台 4.2. 什么是中台 4.3. 数字化转型中台 4.4. 前中后台协同 4.4.1. 前台 4.4.2. 中台 4.4.3. 后台 4.5. DDD、中台和微服务的协作 4.6. 如何构建中台 4.6.1. 自顶向下策略 4.6.2. 自顶向下策略 4.6.3. 构建步骤 5. 边界 6. 参考资料",content:"# 领域驱动设计\n\n\n# 1. DDD 简介\n\n\n# 1.1. 软件架构模式的演进\n\n**第一阶段是单机架构：**采用面向过程的设计方法，系统包括客户端 UI 层和数据库两层，采用 C/S 架构模式，整个系统围绕数据库驱动设计和开发，并且总是从设计数据库和字段开始。\n\n**第二阶段是集中式架构：**采用面向对象的设计方法，系统包括业务接入层、业务逻辑层和数据库层，采用经典的三层架构，也有部分应用采用传统的 SOA 架构。这种架构容易使系统变得臃肿，可扩展性和弹性伸缩性差。\n\n**第三阶段是分布式微服务架构：**随着微服务架构理念的提出，集中式架构正向分布式微服务架构演进。微服务架构可以很好地实现应用之间的解耦，解决单体应用扩展性和弹性伸缩能力不足的问题。\n\n在单机和集中式架构时代，系统分析、设计和开发往往是独立、分阶段割裂进行的。\n\n\n# 1.2. 什么是 DDD\n\nDDD 是一种处理高度复杂领域的设计思想，它试图分离技术实现的复杂性，并围绕业务概念构建领域模型来控制业务的复杂性，以解决软件难以理解，难以演进的问题。DDD 不是架构，而是一种架构设计方法论，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进。DDD 分为两个思维层面：\n\n * 战略设计主要从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言的上下文边界，上下文边界可以作为微服务设计的参考边界。\n * 战术设计则从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现。\n\n\n# 1.3. DDD 与微服务的关系\n\nDDD 是一种架构设计方法，微服务是一种架构风格。两者都是为了拆解业务复杂度：合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力，也就是我们常说的演进式架构。\n\nDDD 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。\n\n微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。\n\n\n# 2. DDD 核心概念\n\n\n\n\n# 2.1. 域\n\n * 领域：领域具体指一种特定的范围。领域是用来限定业务边界的，那么就会有大小之分，领域越大，业务范围就越大，反之则相反。\n * 子域：领域可以进一步划分为子领域。我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围。\n * 核心域：决定产品和公司核心竞争力的子域是核心域。\n * 通用域：同时被多个子域使用的通用功能子域是通用域。\n * 支撑域：还有一种功能子域是必需的，但既非核心域也非通用域，它就是支撑域。\n\n> 领域的核心思想就是将问题域逐级细分，来降低业务理解和系统实现的复杂度。通过领域细分，逐步缩小微服务需要解决的问题域，构建合适的领域模型，而领域模型映射成系统就是微服务了。\n> \n> 核心域、支撑域和通用域的主要目标是：通过领域划分，区分不同子域在公司内的不同功能属性和重要性，从而公司可对不同子域采取不同的资源投入和建设策略，其关注度也会不一样。\n\n\n# 2.2. 通用语言和上下文边界\n\n通用语言：通过团队交流达成共识性的，能够简单、清晰、准确描述业务涵义和规则的语言。\n\n上下文边界：限界就是领域的边界，而上下文则是语义环境。通过领域的上下文边界，我们就可以在统一的领域边界内用统一的语言进行交流。综合一下，上下文边界的定义就是：用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。这个边界定义了模型的适用范围，使团队所有成员能够明确地知道什么应该在模型中实现，什么不应该在模型中实现。\n\n\n# 2.3. 实体和值对象\n\n实体是多个属性、操作或行为的载体。在事件风暴中，我们可以根据命令、操作或者事件，找出产生这些行为的业务实体对象，进而按照一定的业务规则将依存度高和业务关联紧密的多个实体对象和值对象进行聚类，形成聚合。你可以这么理解，实体和值对象是组成领域模型的基础单元。\n\n本质上，实体是看得到、摸得着的实实在在的业务对象，实体具有业务属性、业务行为和业务逻辑。而值对象只是若干个属性的集合，只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑。值对象的属性集虽然在物理上独立出来了，但在逻辑上它仍然是实体属性的一部分，用于描述实体的特征。\n\n\n# 2.4. 聚合和聚合跟\n\n领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。\n\n聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。聚合有一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，而聚合之间的边界是松耦合的。\n\n聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。\n\n\n\n# 2.4.1. 聚合设计步骤\n\n * 第 1 步：采用事件风暴，根据业务行为，梳理出所有的实体和值对象。\n * 第 2 步：从众多实体中选出适合作为对象管理者的根实体，也就是聚合根。判断一个实体 是否是聚合根，你可以结合以下场景分析：是否有独立的生命周期？是否有全局唯一 ID？ 是否可以创建或修改其它对象？是否有专门的模块来管这个实体。\n * 第 3 步：根据业务单一职责和高内聚原则，找出与聚合根关联的所有紧密依赖的实体和值 对象。\n * 第 4 步：在聚合内根据聚合根、实体和值对象的依赖关系，画出对象的引用和依赖模型。\n * 第 5 步：多个聚合根据业务语义和上下文一起划分到同一个限界上下文内。\n\n# 2.4.2. 聚合设计原则\n\n * 在一致性边界内建模真正的不变条件。\n * 设计小聚合。\n * 通过唯一标识引用其它聚合。\n * 在边界之外使用最终一致性。\n * 通过应用层实现跨聚合的服务调用。\n\n\n# 3. 架构模型\n\n\n# 3.1. DDD 架构\n\n\n\n三层架构向 DDD 分层架构演进，主要发生在业务逻辑层和数据访问层。\n\nDDD 分层架构包含用户接口层、应用层、领域层和基础层。通过这些层次划分，我们可以明确微服务各层的职能，划定各领域对象的边界，确定各领域对象的协作方式。\n\n\n# 3.2. 整洁架构\n\n在整洁架构里，同心圆代表应用软件的不同部分，从里到外依次是领域模型、领域服务、应用服务和最外围的容易变化的内容，比如用户界面和基础设施。\n\n整洁架构最主要的原则是依赖原则，它定义了各层的依赖关系，越往里依赖越低，代码级别越高，越是核心能力。外圆代码依赖只能指向内圆，内圆不需要知道外圆的任何情况。\n\n\n\n\n# 3.3. 六边形架构\n\n六边形架构的核心理念是：应用是通过端口与外部进行交互的。我想这也是微服务架构下 API 网关盛行的主要原因吧。\n\n也就是说，在下图的六边形架构中，红圈内的核心业务逻辑（应用程序和领域模型）与外部资源（包括 APP、Web 应用以及数据库资源等）完全隔离，仅通过适配器进行交互。它解决了业务逻辑与用户界面的代码交错问题，很好地实现了前后端分离。六边形架构各层的依赖关系与整洁架构一样，都是由外向内依赖。\n\n六边形架构将系统分为内六边形和外六边形两层，这两层的职能划分如下：\n\n红圈内的六边形实现应用的核心业务逻辑；\n\n外六边形完成外部应用、驱动和基础资源等的交互和访问，对前端应用以 API 主动适配的方式提供服务，对基础资源以依赖倒置被动适配的方式实现资源访问。\n\n\n# 3.4. 三种架构对比\n\n这三种架构模型的设计思想正是微服务架构高内聚低耦合原则的完美体现。\n\n\n\n# 3.4.1. 架构模型和中台、微服务的联系\n\n中台本质上是领域的子域，它可能是核心域，也可能是通用域或支撑域。通常大家认为阿里的中台对应 DDD 的通用域，将通用的公共能力沉淀为中台，对外提供通用共享服务。\n\nDDD、中台、微服务这三者之间似乎没什么关联，实际上它们的关系是非常紧密的，组合在一起可以作为 一个理论体系用于你的中台和微服务设计。\n\n# 3.4.2. 中台建设要聚焦领域模型\n\n中台需要站在全企业的高度考虑能力的共享和复用。\n\n中台设计时，我们需要建立中台内所有限界上下文的领域模型，DDD 建模过程中会考虑架构演进和功能的重新组合。领域模型建立的过程会对业务和应用进行清晰的逻辑和物理边界（微服务）划分。领域模型的结果会影响到后续的系统模型、架构模型和代码模型，最终影响到微服务的拆分和项目落地。\n\n# 3.4.3. 微服务要有合理的架构分层\n\n微服务设计要有分层的设计思想，让各层各司其职，建立松耦合的层间关系。\n\n不要把与领域无关的逻辑放在领域层实现，保证领域层的纯洁和领域逻辑的稳定，避免污染领域模型。也不要把领域模型的业务逻辑放在应用层，这样会导致应用层过于庞大，最终领域模型会失焦。\n\n# 3.4.4. 应用和资源的解耦与适配\n\n传统以数据为中心的设计模式，应用会对数据库、缓存、文件系统等基础资源产生严重依赖。\n\n正是由于它们之间的这种强依赖的关系，我们一旦更换基础资源就会对应用产生很大的影响，因此需要为应用和资源解耦。\n\n\n# 4. 中台战略\n\n\n# 4.1. 平台不是中台\n\n中台源于平台，但它的战略高度要比平台高很多。\n\n平台只是将部分通用的公共能力独立为共享平台。虽然可以通过 API 或者数据对外提供公共共享服务，解决系统重复建设的问题，但这类平台并没有和企业内的其它平台或应用，实现页面、业务流程和数据从前端到后端的全面融合，并且没有将核心业务服务链路作为一个整体方案考虑，各平台仍然是分离且独立的。\n\n简单的理解就是把传统的前后台体系中的后台进行了细分。阿里巴巴提出了大中台小前台的战略。就是强化业务和技术中台，把前端的应用变得更小更灵活。当中台越强大，能力就越强，越能更好的快速响应前台的业务需求。打个比喻，就是土壤越肥沃，越适合生长不同的生物，打造好的生态系统。\n\n\n\n\n# 4.2. 什么是中台\n\n中台是一个基础的理念和架构，我们要把所有的基础服务用中台的思路建设，进行联通，共同支持上端的业务。业务中台更多的是支持在线业务，数据中台提供了基础数据处理能力和很多的数据产品给所有业务方去用。业务中台、数据中台、算法中台等等一起提供对上层业务的支撑。\n\n中台的关键词：共享、联通、融合和创新。联通是前台以及中台之间的联通，融合是前台流程和数据的融合，并以共享的方式支持前端一线业务的发展和创新。其中最关键的是快速响应能力和企业级的无缝联通和融合能力，尤其是对于跨业经营的超大型企业来说至关重要。\n\n\n# 4.3. 数字化转型中台\n\n\n# 4.4. 前中后台协同\n\n# 4.4.1. 前台\n\n在前台设计中我们可以借鉴微前端的设计思想，在企业内不仅实现前端解耦和复用，还可以根据核心链路和业务流程，通过对微前端页面的动态组合和流程编排，实现前台业务的融合。\n\n前端页面可以很自然地融合到不同的终端和渠道应用核心业务链路中，实现前端页面、流程和功能复用。\n\n# 4.4.2. 中台\n\n业务中台的建设可采用领域驱动设计方法，通过领域建模，将可复用的公共能力从各个单体剥离，沉淀并组合，采用微服务架构模式，建设成为可共享的通用能力中台。\n\n同样的，我们可以将核心能力用微服务架构模式，建设成为可面向不同渠道和场景的可复用的核心能力中台。 业务中台向前台、第三方和其它中台提供 API 服务，实现通用能力和核心能力的复用。\n\n数据中台的主要目标是打通数据孤岛，实现业务融合和创新，包括三大主要职能：\n\n * 一是完成企业全域数据的采集与存储，实现各不同业务类别中台数据的汇总和集中管理。\n * 二是按照标准的数据规范或数据模型，将数据按照不同主题域或场景进行加工和处理，形成面向不同主题和场景的数据应用，比如客户视图、代理人视图、渠道视图、机构视图等不同数据体系。\n * 三是建立业务需求驱动的数据体系，基于各个维度的数据，深度萃取数据价值，支持业务和商业模式的创新。\n\n相应的，数据中台的建设就可分为三步走：\n\n * 第一步实现各中台业务数据的汇集，解决数据孤岛和初级数据共享问题。\n * 第二步实现企业级实时或非实时全维度数据的深度融合、加工和共享。\n * 第三步萃取数据价值，支持业务创新，加速从数据转换为业务价值的过程。\n\n# 4.4.3. 后台\n\n前台主要面向客户以及终端销售者，实现营销推广以及交易转化；中台主要面向运营人员，完成运营支撑；后台主要面向后台管理人员，实现流程审核、内部管理以及后勤支撑，比如采购、人力、财务和 OA 等系统。\n\n\n# 4.5. DDD、中台和微服务的协作\n\n传统企业可以将需要共享的公共能力进行领域建模，建设可共享的通用中台。除此之外，传统企业还会将核心能力进行领域建模，建设面向不同渠道的可复用的核心中台。\n\n\n# 4.6. 如何构建中台\n\n# 4.6.1. 自顶向下策略\n\n自顶向下的策略适用于全新的应用系统建设，或旧系统推倒重建的情况。这种策略是先做顶层设计，从最高领域逐级分解为中台，分别建立领域模型，根据业务属性分为通用中台或核心中台。领域建模过程主要基于业务现状，暂时不考虑系统现状。\n\n# 4.6.2. 自顶向下策略\n\n自底向上策略适用于遗留系统业务模型的演进式重构。这种策略是基于业务和系统现状完成领域建模。首先分别完成系统所在业务域的领域建模；然后对齐业务域，找出具有同类或相似业务功能的领域模型，对比分析领域模型的差异，重组领域对象，重构领域模型。这个过程会沉淀公共和复用的业务能力，会将分散的业务模型整合。\n\n# 4.6.3. 构建步骤\n\n第一步：锁定系统所在业务域，构建领域模型。\n\n\n\n第二步：对齐业务域，构建中台业务模型。\n\n第三步：中台归类，根据领域模型设计微服务。\n\n\n# 5. 边界\n\n逻辑边界：微服务内聚合之间的边界是逻辑边界。它是一个虚拟的边界，强调业务的内聚，可根据需要变成物理边界，也就是说聚合也可以独立为微服务。\n\n物理边界：微服务之间的边界是物理边界。它强调微服务部署和运行的隔离，关注微服务的服务调用、容错和运行等。\n\n代码边界：不同层或者聚合之间代码目录的边界是代码边界。它强调的是代码之间的隔离，方便架构演进时代码的重组。\n\n通过以上边界，我们可以让业务能力高内聚、代码松耦合，且清晰的边界，可以快速实现微服务代码的拆分和组合，轻松实现微服务架构演进。但有一点一定要格外注意，边界清晰的微服务，不是大单体向小单体的演进。\n\n\n# 6. 参考资料\n\n * DDD 实战课",normalizedContent:"# 领域驱动设计\n\n\n# 1. ddd 简介\n\n\n# 1.1. 软件架构模式的演进\n\n**第一阶段是单机架构：**采用面向过程的设计方法，系统包括客户端 ui 层和数据库两层，采用 c/s 架构模式，整个系统围绕数据库驱动设计和开发，并且总是从设计数据库和字段开始。\n\n**第二阶段是集中式架构：**采用面向对象的设计方法，系统包括业务接入层、业务逻辑层和数据库层，采用经典的三层架构，也有部分应用采用传统的 soa 架构。这种架构容易使系统变得臃肿，可扩展性和弹性伸缩性差。\n\n**第三阶段是分布式微服务架构：**随着微服务架构理念的提出，集中式架构正向分布式微服务架构演进。微服务架构可以很好地实现应用之间的解耦，解决单体应用扩展性和弹性伸缩能力不足的问题。\n\n在单机和集中式架构时代，系统分析、设计和开发往往是独立、分阶段割裂进行的。\n\n\n# 1.2. 什么是 ddd\n\nddd 是一种处理高度复杂领域的设计思想，它试图分离技术实现的复杂性，并围绕业务概念构建领域模型来控制业务的复杂性，以解决软件难以理解，难以演进的问题。ddd 不是架构，而是一种架构设计方法论，它通过边界划分将复杂业务领域简单化，帮我们设计出清晰的领域和应用边界，可以很容易地实现架构演进。ddd 分为两个思维层面：\n\n * 战略设计主要从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言的上下文边界，上下文边界可以作为微服务设计的参考边界。\n * 战术设计则从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现。\n\n\n# 1.3. ddd 与微服务的关系\n\nddd 是一种架构设计方法，微服务是一种架构风格。两者都是为了拆解业务复杂度：合理划分领域边界，持续调整现有架构，优化现有代码，以保持架构和代码的生命力，也就是我们常说的演进式架构。\n\nddd 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。\n\n微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。\n\n\n# 2. ddd 核心概念\n\n\n\n\n# 2.1. 域\n\n * 领域：领域具体指一种特定的范围。领域是用来限定业务边界的，那么就会有大小之分，领域越大，业务范围就越大，反之则相反。\n * 子域：领域可以进一步划分为子领域。我们把划分出来的多个子领域称为子域，每个子域对应一个更小的问题域或更小的业务范围。\n * 核心域：决定产品和公司核心竞争力的子域是核心域。\n * 通用域：同时被多个子域使用的通用功能子域是通用域。\n * 支撑域：还有一种功能子域是必需的，但既非核心域也非通用域，它就是支撑域。\n\n> 领域的核心思想就是将问题域逐级细分，来降低业务理解和系统实现的复杂度。通过领域细分，逐步缩小微服务需要解决的问题域，构建合适的领域模型，而领域模型映射成系统就是微服务了。\n> \n> 核心域、支撑域和通用域的主要目标是：通过领域划分，区分不同子域在公司内的不同功能属性和重要性，从而公司可对不同子域采取不同的资源投入和建设策略，其关注度也会不一样。\n\n\n# 2.2. 通用语言和上下文边界\n\n通用语言：通过团队交流达成共识性的，能够简单、清晰、准确描述业务涵义和规则的语言。\n\n上下文边界：限界就是领域的边界，而上下文则是语义环境。通过领域的上下文边界，我们就可以在统一的领域边界内用统一的语言进行交流。综合一下，上下文边界的定义就是：用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。这个边界定义了模型的适用范围，使团队所有成员能够明确地知道什么应该在模型中实现，什么不应该在模型中实现。\n\n\n# 2.3. 实体和值对象\n\n实体是多个属性、操作或行为的载体。在事件风暴中，我们可以根据命令、操作或者事件，找出产生这些行为的业务实体对象，进而按照一定的业务规则将依存度高和业务关联紧密的多个实体对象和值对象进行聚类，形成聚合。你可以这么理解，实体和值对象是组成领域模型的基础单元。\n\n本质上，实体是看得到、摸得着的实实在在的业务对象，实体具有业务属性、业务行为和业务逻辑。而值对象只是若干个属性的集合，只有数据初始化操作和有限的不涉及修改数据的行为，基本不包含业务逻辑。值对象的属性集虽然在物理上独立出来了，但在逻辑上它仍然是实体属性的一部分，用于描述实体的特征。\n\n\n# 2.4. 聚合和聚合跟\n\n领域模型内的实体和值对象就好比个体，而能让实体和值对象协同工作的组织就是聚合，它用来确保这些领域对象在实现共同的业务逻辑时，能保证数据的一致性。\n\n聚合就是由业务和逻辑紧密关联的实体和值对象组合而成的，聚合是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。聚合有一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，而聚合之间的边界是松耦合的。\n\n聚合根的主要目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。如果把聚合比作组织，那聚合根就是这个组织的负责人。聚合根也称为根实体，它不仅是实体，还是聚合的管理者。\n\n\n\n# 2.4.1. 聚合设计步骤\n\n * 第 1 步：采用事件风暴，根据业务行为，梳理出所有的实体和值对象。\n * 第 2 步：从众多实体中选出适合作为对象管理者的根实体，也就是聚合根。判断一个实体 是否是聚合根，你可以结合以下场景分析：是否有独立的生命周期？是否有全局唯一 id？ 是否可以创建或修改其它对象？是否有专门的模块来管这个实体。\n * 第 3 步：根据业务单一职责和高内聚原则，找出与聚合根关联的所有紧密依赖的实体和值 对象。\n * 第 4 步：在聚合内根据聚合根、实体和值对象的依赖关系，画出对象的引用和依赖模型。\n * 第 5 步：多个聚合根据业务语义和上下文一起划分到同一个限界上下文内。\n\n# 2.4.2. 聚合设计原则\n\n * 在一致性边界内建模真正的不变条件。\n * 设计小聚合。\n * 通过唯一标识引用其它聚合。\n * 在边界之外使用最终一致性。\n * 通过应用层实现跨聚合的服务调用。\n\n\n# 3. 架构模型\n\n\n# 3.1. ddd 架构\n\n\n\n三层架构向 ddd 分层架构演进，主要发生在业务逻辑层和数据访问层。\n\nddd 分层架构包含用户接口层、应用层、领域层和基础层。通过这些层次划分，我们可以明确微服务各层的职能，划定各领域对象的边界，确定各领域对象的协作方式。\n\n\n# 3.2. 整洁架构\n\n在整洁架构里，同心圆代表应用软件的不同部分，从里到外依次是领域模型、领域服务、应用服务和最外围的容易变化的内容，比如用户界面和基础设施。\n\n整洁架构最主要的原则是依赖原则，它定义了各层的依赖关系，越往里依赖越低，代码级别越高，越是核心能力。外圆代码依赖只能指向内圆，内圆不需要知道外圆的任何情况。\n\n\n\n\n# 3.3. 六边形架构\n\n六边形架构的核心理念是：应用是通过端口与外部进行交互的。我想这也是微服务架构下 api 网关盛行的主要原因吧。\n\n也就是说，在下图的六边形架构中，红圈内的核心业务逻辑（应用程序和领域模型）与外部资源（包括 app、web 应用以及数据库资源等）完全隔离，仅通过适配器进行交互。它解决了业务逻辑与用户界面的代码交错问题，很好地实现了前后端分离。六边形架构各层的依赖关系与整洁架构一样，都是由外向内依赖。\n\n六边形架构将系统分为内六边形和外六边形两层，这两层的职能划分如下：\n\n红圈内的六边形实现应用的核心业务逻辑；\n\n外六边形完成外部应用、驱动和基础资源等的交互和访问，对前端应用以 api 主动适配的方式提供服务，对基础资源以依赖倒置被动适配的方式实现资源访问。\n\n\n# 3.4. 三种架构对比\n\n这三种架构模型的设计思想正是微服务架构高内聚低耦合原则的完美体现。\n\n\n\n# 3.4.1. 架构模型和中台、微服务的联系\n\n中台本质上是领域的子域，它可能是核心域，也可能是通用域或支撑域。通常大家认为阿里的中台对应 ddd 的通用域，将通用的公共能力沉淀为中台，对外提供通用共享服务。\n\nddd、中台、微服务这三者之间似乎没什么关联，实际上它们的关系是非常紧密的，组合在一起可以作为 一个理论体系用于你的中台和微服务设计。\n\n# 3.4.2. 中台建设要聚焦领域模型\n\n中台需要站在全企业的高度考虑能力的共享和复用。\n\n中台设计时，我们需要建立中台内所有限界上下文的领域模型，ddd 建模过程中会考虑架构演进和功能的重新组合。领域模型建立的过程会对业务和应用进行清晰的逻辑和物理边界（微服务）划分。领域模型的结果会影响到后续的系统模型、架构模型和代码模型，最终影响到微服务的拆分和项目落地。\n\n# 3.4.3. 微服务要有合理的架构分层\n\n微服务设计要有分层的设计思想，让各层各司其职，建立松耦合的层间关系。\n\n不要把与领域无关的逻辑放在领域层实现，保证领域层的纯洁和领域逻辑的稳定，避免污染领域模型。也不要把领域模型的业务逻辑放在应用层，这样会导致应用层过于庞大，最终领域模型会失焦。\n\n# 3.4.4. 应用和资源的解耦与适配\n\n传统以数据为中心的设计模式，应用会对数据库、缓存、文件系统等基础资源产生严重依赖。\n\n正是由于它们之间的这种强依赖的关系，我们一旦更换基础资源就会对应用产生很大的影响，因此需要为应用和资源解耦。\n\n\n# 4. 中台战略\n\n\n# 4.1. 平台不是中台\n\n中台源于平台，但它的战略高度要比平台高很多。\n\n平台只是将部分通用的公共能力独立为共享平台。虽然可以通过 api 或者数据对外提供公共共享服务，解决系统重复建设的问题，但这类平台并没有和企业内的其它平台或应用，实现页面、业务流程和数据从前端到后端的全面融合，并且没有将核心业务服务链路作为一个整体方案考虑，各平台仍然是分离且独立的。\n\n简单的理解就是把传统的前后台体系中的后台进行了细分。阿里巴巴提出了大中台小前台的战略。就是强化业务和技术中台，把前端的应用变得更小更灵活。当中台越强大，能力就越强，越能更好的快速响应前台的业务需求。打个比喻，就是土壤越肥沃，越适合生长不同的生物，打造好的生态系统。\n\n\n\n\n# 4.2. 什么是中台\n\n中台是一个基础的理念和架构，我们要把所有的基础服务用中台的思路建设，进行联通，共同支持上端的业务。业务中台更多的是支持在线业务，数据中台提供了基础数据处理能力和很多的数据产品给所有业务方去用。业务中台、数据中台、算法中台等等一起提供对上层业务的支撑。\n\n中台的关键词：共享、联通、融合和创新。联通是前台以及中台之间的联通，融合是前台流程和数据的融合，并以共享的方式支持前端一线业务的发展和创新。其中最关键的是快速响应能力和企业级的无缝联通和融合能力，尤其是对于跨业经营的超大型企业来说至关重要。\n\n\n# 4.3. 数字化转型中台\n\n\n# 4.4. 前中后台协同\n\n# 4.4.1. 前台\n\n在前台设计中我们可以借鉴微前端的设计思想，在企业内不仅实现前端解耦和复用，还可以根据核心链路和业务流程，通过对微前端页面的动态组合和流程编排，实现前台业务的融合。\n\n前端页面可以很自然地融合到不同的终端和渠道应用核心业务链路中，实现前端页面、流程和功能复用。\n\n# 4.4.2. 中台\n\n业务中台的建设可采用领域驱动设计方法，通过领域建模，将可复用的公共能力从各个单体剥离，沉淀并组合，采用微服务架构模式，建设成为可共享的通用能力中台。\n\n同样的，我们可以将核心能力用微服务架构模式，建设成为可面向不同渠道和场景的可复用的核心能力中台。 业务中台向前台、第三方和其它中台提供 api 服务，实现通用能力和核心能力的复用。\n\n数据中台的主要目标是打通数据孤岛，实现业务融合和创新，包括三大主要职能：\n\n * 一是完成企业全域数据的采集与存储，实现各不同业务类别中台数据的汇总和集中管理。\n * 二是按照标准的数据规范或数据模型，将数据按照不同主题域或场景进行加工和处理，形成面向不同主题和场景的数据应用，比如客户视图、代理人视图、渠道视图、机构视图等不同数据体系。\n * 三是建立业务需求驱动的数据体系，基于各个维度的数据，深度萃取数据价值，支持业务和商业模式的创新。\n\n相应的，数据中台的建设就可分为三步走：\n\n * 第一步实现各中台业务数据的汇集，解决数据孤岛和初级数据共享问题。\n * 第二步实现企业级实时或非实时全维度数据的深度融合、加工和共享。\n * 第三步萃取数据价值，支持业务创新，加速从数据转换为业务价值的过程。\n\n# 4.4.3. 后台\n\n前台主要面向客户以及终端销售者，实现营销推广以及交易转化；中台主要面向运营人员，完成运营支撑；后台主要面向后台管理人员，实现流程审核、内部管理以及后勤支撑，比如采购、人力、财务和 oa 等系统。\n\n\n# 4.5. ddd、中台和微服务的协作\n\n传统企业可以将需要共享的公共能力进行领域建模，建设可共享的通用中台。除此之外，传统企业还会将核心能力进行领域建模，建设面向不同渠道的可复用的核心中台。\n\n\n# 4.6. 如何构建中台\n\n# 4.6.1. 自顶向下策略\n\n自顶向下的策略适用于全新的应用系统建设，或旧系统推倒重建的情况。这种策略是先做顶层设计，从最高领域逐级分解为中台，分别建立领域模型，根据业务属性分为通用中台或核心中台。领域建模过程主要基于业务现状，暂时不考虑系统现状。\n\n# 4.6.2. 自顶向下策略\n\n自底向上策略适用于遗留系统业务模型的演进式重构。这种策略是基于业务和系统现状完成领域建模。首先分别完成系统所在业务域的领域建模；然后对齐业务域，找出具有同类或相似业务功能的领域模型，对比分析领域模型的差异，重组领域对象，重构领域模型。这个过程会沉淀公共和复用的业务能力，会将分散的业务模型整合。\n\n# 4.6.3. 构建步骤\n\n第一步：锁定系统所在业务域，构建领域模型。\n\n\n\n第二步：对齐业务域，构建中台业务模型。\n\n第三步：中台归类，根据领域模型设计微服务。\n\n\n# 5. 边界\n\n逻辑边界：微服务内聚合之间的边界是逻辑边界。它是一个虚拟的边界，强调业务的内聚，可根据需要变成物理边界，也就是说聚合也可以独立为微服务。\n\n物理边界：微服务之间的边界是物理边界。它强调微服务部署和运行的隔离，关注微服务的服务调用、容错和运行等。\n\n代码边界：不同层或者聚合之间代码目录的边界是代码边界。它强调的是代码之间的隔离，方便架构演进时代码的重组。\n\n通过以上边界，我们可以让业务能力高内聚、代码松耦合，且清晰的边界，可以快速实现微服务代码的拆分和组合，轻松实现微服务架构演进。但有一点一定要格外注意，边界清晰的微服务，不是大单体向小单体的演进。\n\n\n# 6. 参考资料\n\n * ddd 实战课",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"架构设计",frontmatter:{title:"架构设计",date:"2019-03-08T13:16:53.000Z",categories:["架构"],tags:["架构"],permalink:"/pages/cbf9f8/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/",relativePath:"01.架构/README.md",key:"v-510eccb8",path:"/pages/cbf9f8/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:472},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:581},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:971}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# 架构设计\n\n架构设计的目的是解决软件系统的复杂度带来的问题。架构即(重要)决策，是在一个有约束的盒子里去求解或接近最合适的解。这个有约束的盒子是团队经验、成本、资源、进度、业务所处阶段等所编织、掺杂在一起的综合体(人，财，物，时间，事情等)。架构无优劣，但是存在恰当的架构用在合适的软件系统中，而这些就是决策的结果。\n\n架构设计原则：合适原则、简单原则、演化原则。合适优于先进 => 演化优于一步到位 => 简单优于复杂\n\n架构设计有业务需求驱动，需要识别出主要问题，然后根据业务、技术、团队、成本等综合评估排序，优先解决当前面临的最主要的复杂度问题。\n\n架构设计一般要给出多套备选方案（3 ~ 5 个最佳），并评估各方案利弊。\n\n评估方案时，应该先列出关注的维度（如：功能性、性能、可用性、复杂度、硬件成本、运维成本等），然后根据这些维度去评估打分，再综合挑选最合适当时情况的方案。\n\n架构失败的主因：\n\n * 没那么多人，却想干那么多活\n * 没有那么多积累，却想一步登天\n * 没有那么卓越的业务场景，却幻想灵光一闪成为天才\n\n\n# 📖 内容\n\n * 系统架构面试题\n * 系统架构概述\n * 系统高性能架构\n * 系统高可用架构\n * 系统伸缩性架构\n * 系统扩展性架构\n * 系统安全性架构\n * 大型系统核心技术\n * 领域驱动设计\n\n\n# 📚 资料\n\n * 书籍\n   * 《大型网站技术架构：核心原理与案例分析》 - 浅显易懂的将解大型网站架构演进之路；简介了大型系统所面临的挑战以及核心技术点。\n   * 《大型网站系统与 Java 中间件实践》\n   * 《亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统》\n   * 《企业 IT 架构转型之道：阿里巴巴中台战略思想与架构实战》 - 阐述阿里巴巴中台系统发展，更多的是讲解应用场景和能力，没有讲解技术细节。\n   * 《逆流而上：阿里巴巴技术成长之路》 - 主要以运维的视角阐述系统运维中遇到的困难，定位思路以及解决方法。\n * 教程\n   * system-design-primer\n   * 从 0 开始学架构\n   * 从 0 开始学微服务\n   * RPC 实战与核心原理\n   * 微服务架构核心 20 讲\n   * DDD 实战课\n\n\n# 🚪 传送\n\n◾ 🏠 DESIGN 首页 ◾ 🎯 我的博客 ◾",normalizedContent:"# 架构设计\n\n架构设计的目的是解决软件系统的复杂度带来的问题。架构即(重要)决策，是在一个有约束的盒子里去求解或接近最合适的解。这个有约束的盒子是团队经验、成本、资源、进度、业务所处阶段等所编织、掺杂在一起的综合体(人，财，物，时间，事情等)。架构无优劣，但是存在恰当的架构用在合适的软件系统中，而这些就是决策的结果。\n\n架构设计原则：合适原则、简单原则、演化原则。合适优于先进 => 演化优于一步到位 => 简单优于复杂\n\n架构设计有业务需求驱动，需要识别出主要问题，然后根据业务、技术、团队、成本等综合评估排序，优先解决当前面临的最主要的复杂度问题。\n\n架构设计一般要给出多套备选方案（3 ~ 5 个最佳），并评估各方案利弊。\n\n评估方案时，应该先列出关注的维度（如：功能性、性能、可用性、复杂度、硬件成本、运维成本等），然后根据这些维度去评估打分，再综合挑选最合适当时情况的方案。\n\n架构失败的主因：\n\n * 没那么多人，却想干那么多活\n * 没有那么多积累，却想一步登天\n * 没有那么卓越的业务场景，却幻想灵光一闪成为天才\n\n\n# 📖 内容\n\n * 系统架构面试题\n * 系统架构概述\n * 系统高性能架构\n * 系统高可用架构\n * 系统伸缩性架构\n * 系统扩展性架构\n * 系统安全性架构\n * 大型系统核心技术\n * 领域驱动设计\n\n\n# 📚 资料\n\n * 书籍\n   * 《大型网站技术架构：核心原理与案例分析》 - 浅显易懂的将解大型网站架构演进之路；简介了大型系统所面临的挑战以及核心技术点。\n   * 《大型网站系统与 java 中间件实践》\n   * 《亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统》\n   * 《企业 it 架构转型之道：阿里巴巴中台战略思想与架构实战》 - 阐述阿里巴巴中台系统发展，更多的是讲解应用场景和能力，没有讲解技术细节。\n   * 《逆流而上：阿里巴巴技术成长之路》 - 主要以运维的视角阐述系统运维中遇到的困难，定位思路以及解决方法。\n * 教程\n   * system-design-primer\n   * 从 0 开始学架构\n   * 从 0 开始学微服务\n   * rpc 实战与核心原理\n   * 微服务架构核心 20 讲\n   * ddd 实战课\n\n\n# 🚪 传送\n\n◾ 🏠 design 首页 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"如何设计系统",frontmatter:{title:"如何设计系统",date:"2021-11-08T08:15:33.000Z",categories:["架构"],tags:["架构","设计"],permalink:"/pages/3d05e6/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%B3%BB%E7%BB%9F.html",relativePath:"01.架构/如何设计系统.md",key:"v-491fd7ec",path:"/pages/3d05e6/",headers:[{level:2,title:"1. 系统设计过程",slug:"_1-系统设计过程",normalizedTitle:"1. 系统设计过程",charIndex:13},{level:3,title:"1.1. 步骤一、约束和用例",slug:"_1-1-步骤一、约束和用例",normalizedTitle:"1.1. 步骤一、约束和用例",charIndex:27},{level:3,title:"1.2. 步骤二、顶层设计",slug:"_1-2-步骤二、顶层设计",normalizedTitle:"1.2. 步骤二、顶层设计",charIndex:330},{level:3,title:"1.3. 步骤三、分析瓶颈",slug:"_1-3-步骤三、分析瓶颈",normalizedTitle:"1.3. 步骤三、分析瓶颈",charIndex:467},{level:3,title:"1.4. 步骤四、扩展设计",slug:"_1-4-步骤四、扩展设计",normalizedTitle:"1.4. 步骤四、扩展设计",charIndex:794},{level:2,title:"2. 参考资料",slug:"_2-参考资料",normalizedTitle:"2. 参考资料",charIndex:1428}],headersStr:"1. 系统设计过程 1.1. 步骤一、约束和用例 1.2. 步骤二、顶层设计 1.3. 步骤三、分析瓶颈 1.4. 步骤四、扩展设计 2. 参考资料",content:"# 如何设计系统\n\n\n# 1. 系统设计过程\n\n\n# 1.1. 步骤一、约束和用例\n\n对于任何系统设计，第一件应该做的事是：阐明系统的约束并确定系统需要满足哪些用例。\n\n永远不要假设没有明确说明的事情。一定要尽力收集、理解需求，并设计一个很好地涵盖这些要求的解决方案。\n\n例如，URL 缩短服务可能只为几千个用户提供服务，但每个用户都可能共享数百万个 URL。它可能旨在处理对缩短的 URL 的数百万次点击或数十次点击。该服务可能必须提供有关每个缩短的 URL 的大量统计信息（这会增加您的数据大小），或者可能根本不需要统计信息。\n\n您还必须考虑预期会发生的用例。您的系统将根据其预期功能进行设计。不要忘记确保你知道面试官一开始没有告诉你的所有要求。\n\n\n# 1.2. 步骤二、顶层设计\n\n一旦确定了要设计的系统的范围，接下来就要做顶层设计：概述系统架构中所需的所有重要组件。\n\n此时，应该绘制出主要组件以及它们之间的连接。通常，这种顶层设计是基于主流技术的组合。这就要求设计必须熟悉这些技术，了解其利弊以及适合使用的场景。\n\n\n# 1.3. 步骤三、分析瓶颈\n\n顶层设计很可能会遇到一个或多个瓶颈。这完全没问题，不要指望一个新系统可以立即处理世界上的所有负载。它只需要可扩展，以便您能够使用一些标准工具和技术对其进行改进。\n\n现在有了顶层设计，就要考虑这些组件在系统扩展时面临的瓶颈。也许，系统需要一个负载均衡器和集群来处理用户请求。或者，由于数据容量庞大，以至于需要将数据库分库分表（分布在多台机器上）。这些方案有什么利弊，是否适用？数据库是否太慢，是否需要一些内存缓存？\n\n通常每个解决方案都是某种权衡和取舍。改变某事会使其他事情恶化。然而，重要的是能够讨论这些权衡，并根据定义的约束和用例来衡量它们对系统的影响。\n\n一旦分析清楚核心瓶颈，就可以着手在下一步中去解决它们。\n\n\n# 1.4. 步骤四、扩展设计\n\n首先，你需要了解以下技术手段：\n\n * 垂直扩展\n * 水平罗占\n * 缓存\n * 负载均衡\n * 数据库复制\n * 数据库分区\n * 异步\n * NoSql\n\n在系统设计方面，回顾现实中的架构非常有用。注意使用了哪些技术。继续研究每一项新技术，看看它解决了什么问题，它的替代品是什么，它擅长的地方，以及失败的地方。\n\n一切都是权衡的结果——这是系统设计中最基本的概念之一。\n\n一些推荐的学习资料\n\n * 生产中的深度学习：关于 EyeEm 如何构建在大量图像上运行多个深度学习模型的生产系统的精彩故事\n * Uber：一篇关于 Uber 如何快速扩展的好文章，关于将您的服务分解为分布在许多存储库中的许多微服务。\n * Facebook：Facebook 如何在直播中同时处理 800,000 名观众\n * Kraken.io：如何大规模缩放图像优化，本文将更详细地看一些具体使用的硬件方案，以及部署、监控等重要方面\n * Twitter：Twitter 如何处理每秒 3,000 张图片上传以及为什么它使用的旧方式现在行不通\n * 最后，Twitter 子组件的一些很好的例子：存储数据（video | text）和时间轴（video | text）。\n * 有关更高级的示例，请查看 Google、Youtube（video | text）、Tumblr、StackOverflow 和 Datashift 上的这些帖子。\n\n\n# 2. 参考资料\n\n * system-design-primer\n * System Design for Tech Interviews",normalizedContent:"# 如何设计系统\n\n\n# 1. 系统设计过程\n\n\n# 1.1. 步骤一、约束和用例\n\n对于任何系统设计，第一件应该做的事是：阐明系统的约束并确定系统需要满足哪些用例。\n\n永远不要假设没有明确说明的事情。一定要尽力收集、理解需求，并设计一个很好地涵盖这些要求的解决方案。\n\n例如，url 缩短服务可能只为几千个用户提供服务，但每个用户都可能共享数百万个 url。它可能旨在处理对缩短的 url 的数百万次点击或数十次点击。该服务可能必须提供有关每个缩短的 url 的大量统计信息（这会增加您的数据大小），或者可能根本不需要统计信息。\n\n您还必须考虑预期会发生的用例。您的系统将根据其预期功能进行设计。不要忘记确保你知道面试官一开始没有告诉你的所有要求。\n\n\n# 1.2. 步骤二、顶层设计\n\n一旦确定了要设计的系统的范围，接下来就要做顶层设计：概述系统架构中所需的所有重要组件。\n\n此时，应该绘制出主要组件以及它们之间的连接。通常，这种顶层设计是基于主流技术的组合。这就要求设计必须熟悉这些技术，了解其利弊以及适合使用的场景。\n\n\n# 1.3. 步骤三、分析瓶颈\n\n顶层设计很可能会遇到一个或多个瓶颈。这完全没问题，不要指望一个新系统可以立即处理世界上的所有负载。它只需要可扩展，以便您能够使用一些标准工具和技术对其进行改进。\n\n现在有了顶层设计，就要考虑这些组件在系统扩展时面临的瓶颈。也许，系统需要一个负载均衡器和集群来处理用户请求。或者，由于数据容量庞大，以至于需要将数据库分库分表（分布在多台机器上）。这些方案有什么利弊，是否适用？数据库是否太慢，是否需要一些内存缓存？\n\n通常每个解决方案都是某种权衡和取舍。改变某事会使其他事情恶化。然而，重要的是能够讨论这些权衡，并根据定义的约束和用例来衡量它们对系统的影响。\n\n一旦分析清楚核心瓶颈，就可以着手在下一步中去解决它们。\n\n\n# 1.4. 步骤四、扩展设计\n\n首先，你需要了解以下技术手段：\n\n * 垂直扩展\n * 水平罗占\n * 缓存\n * 负载均衡\n * 数据库复制\n * 数据库分区\n * 异步\n * nosql\n\n在系统设计方面，回顾现实中的架构非常有用。注意使用了哪些技术。继续研究每一项新技术，看看它解决了什么问题，它的替代品是什么，它擅长的地方，以及失败的地方。\n\n一切都是权衡的结果——这是系统设计中最基本的概念之一。\n\n一些推荐的学习资料\n\n * 生产中的深度学习：关于 eyeem 如何构建在大量图像上运行多个深度学习模型的生产系统的精彩故事\n * uber：一篇关于 uber 如何快速扩展的好文章，关于将您的服务分解为分布在许多存储库中的许多微服务。\n * facebook：facebook 如何在直播中同时处理 800,000 名观众\n * kraken.io：如何大规模缩放图像优化，本文将更详细地看一些具体使用的硬件方案，以及部署、监控等重要方面\n * twitter：twitter 如何处理每秒 3,000 张图片上传以及为什么它使用的旧方式现在行不通\n * 最后，twitter 子组件的一些很好的例子：存储数据（video | text）和时间轴（video | text）。\n * 有关更高级的示例，请查看 google、youtube（video | text）、tumblr、stackoverflow 和 datashift 上的这些帖子。\n\n\n# 2. 参考资料\n\n * system-design-primer\n * system design for tech interviews",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"系统测试架构",frontmatter:{title:"系统测试架构",date:"2019-12-10T17:00:00.000Z",categories:["架构"],tags:["架构","设计","测试"],permalink:"/pages/45e366/"},regularPath:"/01.%E6%9E%B6%E6%9E%84/%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95%E6%9E%B6%E6%9E%84.html",relativePath:"01.架构/系统测试架构.md",key:"v-b75e4ec2",path:"/pages/45e366/",headers:[{level:2,title:"1. 测试方法分类",slug:"_1-测试方法分类",normalizedTitle:"1. 测试方法分类",charIndex:301},{level:3,title:"1.1. 从测试设计方法分类",slug:"_1-1-从测试设计方法分类",normalizedTitle:"1.1. 从测试设计方法分类",charIndex:315},{level:3,title:"1.2. 从测试的目的分类",slug:"_1-2-从测试的目的分类",normalizedTitle:"1.2. 从测试的目的分类",charIndex:605},{level:4,title:"1.2.1. 功能测试",slug:"_1-2-1-功能测试",normalizedTitle:"1.2.1. 功能测试",charIndex:622},{level:4,title:"1.2.2. 非功能测试",slug:"_1-2-2-非功能测试",normalizedTitle:"1.2.2. 非功能测试",charIndex:1003},{level:2,title:"2. 参考资料",slug:"_2-参考资料",normalizedTitle:"2. 参考资料",charIndex:1415}],headersStr:"1. 测试方法分类 1.1. 从测试设计方法分类 1.2. 从测试的目的分类 1.2.1. 功能测试 1.2.2. 非功能测试 2. 参考资料",content:"# 系统测试架构\n\n> 软件测试描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。软件测试的经典定义是：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。\n> \n> 现代软件开发项目中，分工明确，基本上都会有研发、测试、QA 等角色。不同角色由于关注的视角不同，测试目标和测试方法也不完全相同。本文主要从研发、测试的视角去考量软件测试技术。\n> \n> 注意：\n> \n>  * 为了方便，只有测试人员需要关注的测试点用【测试】标注；\n>  * 而只有研发人员需要关注的测试点用【研发】标注；\n>  * 都需要关注的测试点则不作标注。\n\n\n# 1. 测试方法分类\n\n\n# 1.1. 从测试设计方法分类\n\n * 黑盒测试【测试】 - 把软件系统当作一个“黑箱”，无法了解或使用系统的内部结构及知识。从软件的行为，而不是内部结构出发来设计测试。\n * 白盒测试【研发】 - 设计者可以看到软件系统的内部结构，并且使用软件的内部知识来指导测试数据及方法的选择。\n * 灰盒测试 - 介于黑盒和白盒之间。\n\n> 小结：\n> \n>  * 黑河测试通常针对的是软件的行为或功能，一般是测试人员主要关注的。\n>  * 白盒测试通常则需要对软件有一定程度的了解，一般是开发人员所关注的。\n>  * 灰盒测试通常是为了测试软件在特定的场景下的表现，而非主场景。\n\n\n# 1.2. 从测试的目的分类\n\n# 1.2.1. 功能测试\n\n * 单元测试（Unit Test） - 在最低粒度的功能/参数上验证程序的准确性，比如测试一个函数的正确性。【研发】\n   * 常用技术：junit4、junit5、mockito、assertj-core\n * 功能测试（Functional Test） - 验证模块的功能。【测试】\n * 集成测试（Integration Test） - 验证几个互相有依赖关系的模块的功能。【测试】\n * 场景测试（Scenario Test）- 验证几个模块是否能完成一个用户场景。【测试】\n * 系统测试（System Test） - 对于整个系统功能的测试。【测试】\n * Alpha 测试 - 软件测试人员在真实用户环境中对软件进行全面的测试。【测试】\n * Beta 测试 - 也叫公测，是真实的用户在真实的环境中进行的测试。\n\n# 1.2.2. 非功能测试\n\n * 压力测试（Stress test） - 验证软件在超过负载设计的情况下仍能返回正确的结果，没有崩溃\n * 负载测试（Load test） - 测试软件在负载情况下能否正常工作\n * 性能测试（Performance test） - 测试软件的效能，是否提供满意的服务质量。\n   * 常用技术：JMeter、JMH。\n * 软件辅助功能测试（Accessibility test） - 测试软件是否向残疾用户提供足够的辅助功能\n * 本地化/全球化测试（Localization/Globalization）\n * 兼容性测试（Compatibility Test）\n * 配置测试（Configuration Test） - 测试软件在各种配置下能否正常工作\n * 可用性测试（Usability Test） – 测试软件是否好用\n * 安全性测试（Security Test）\n\n\n# 2. 参考资料\n\n * 软件测试 (一) 软件测试方法大汇总\n * Java 微基准测试框架 JMH",normalizedContent:"# 系统测试架构\n\n> 软件测试描述一种用来促进鉴定软件的正确性、完整性、安全性和质量的过程。软件测试的经典定义是：在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。\n> \n> 现代软件开发项目中，分工明确，基本上都会有研发、测试、qa 等角色。不同角色由于关注的视角不同，测试目标和测试方法也不完全相同。本文主要从研发、测试的视角去考量软件测试技术。\n> \n> 注意：\n> \n>  * 为了方便，只有测试人员需要关注的测试点用【测试】标注；\n>  * 而只有研发人员需要关注的测试点用【研发】标注；\n>  * 都需要关注的测试点则不作标注。\n\n\n# 1. 测试方法分类\n\n\n# 1.1. 从测试设计方法分类\n\n * 黑盒测试【测试】 - 把软件系统当作一个“黑箱”，无法了解或使用系统的内部结构及知识。从软件的行为，而不是内部结构出发来设计测试。\n * 白盒测试【研发】 - 设计者可以看到软件系统的内部结构，并且使用软件的内部知识来指导测试数据及方法的选择。\n * 灰盒测试 - 介于黑盒和白盒之间。\n\n> 小结：\n> \n>  * 黑河测试通常针对的是软件的行为或功能，一般是测试人员主要关注的。\n>  * 白盒测试通常则需要对软件有一定程度的了解，一般是开发人员所关注的。\n>  * 灰盒测试通常是为了测试软件在特定的场景下的表现，而非主场景。\n\n\n# 1.2. 从测试的目的分类\n\n# 1.2.1. 功能测试\n\n * 单元测试（unit test） - 在最低粒度的功能/参数上验证程序的准确性，比如测试一个函数的正确性。【研发】\n   * 常用技术：junit4、junit5、mockito、assertj-core\n * 功能测试（functional test） - 验证模块的功能。【测试】\n * 集成测试（integration test） - 验证几个互相有依赖关系的模块的功能。【测试】\n * 场景测试（scenario test）- 验证几个模块是否能完成一个用户场景。【测试】\n * 系统测试（system test） - 对于整个系统功能的测试。【测试】\n * alpha 测试 - 软件测试人员在真实用户环境中对软件进行全面的测试。【测试】\n * beta 测试 - 也叫公测，是真实的用户在真实的环境中进行的测试。\n\n# 1.2.2. 非功能测试\n\n * 压力测试（stress test） - 验证软件在超过负载设计的情况下仍能返回正确的结果，没有崩溃\n * 负载测试（load test） - 测试软件在负载情况下能否正常工作\n * 性能测试（performance test） - 测试软件的效能，是否提供满意的服务质量。\n   * 常用技术：jmeter、jmh。\n * 软件辅助功能测试（accessibility test） - 测试软件是否向残疾用户提供足够的辅助功能\n * 本地化/全球化测试（localization/globalization）\n * 兼容性测试（compatibility test）\n * 配置测试（configuration test） - 测试软件在各种配置下能否正常工作\n * 可用性测试（usability test） – 测试软件是否好用\n * 安全性测试（security test）\n\n\n# 2. 参考资料\n\n * 软件测试 (一) 软件测试方法大汇总\n * java 微基准测试框架 jmh",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"分布式面试总结",frontmatter:{title:"分布式面试总结",categories:["分布式","分布式综合"],tags:["分布式","分布式综合","面试"],abbrlink:"375c2802",date:"2018-07-10T16:02:00.000Z",permalink:"/pages/cd56bb/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/01.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%BC%E5%90%88/01.%E5%88%86%E5%B8%83%E5%BC%8F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.html",relativePath:"02.分布式/01.分布式综合/01.分布式面试总结.md",key:"v-21ce6260",path:"/pages/cd56bb/",headers:[{level:2,title:"1. 分布式缓存",slug:"_1-分布式缓存",normalizedTitle:"1. 分布式缓存",charIndex:14},{level:3,title:"1.1. Redis 有什么数据类型？分别用于什么场景",slug:"_1-1-redis-有什么数据类型-分别用于什么场景",normalizedTitle:"1.1. redis 有什么数据类型？分别用于什么场景",charIndex:27},{level:3,title:"1.2. Redis 的主从复制是如何实现的",slug:"_1-2-redis-的主从复制是如何实现的",normalizedTitle:"1.2. redis 的主从复制是如何实现的",charIndex:670},{level:3,title:"1.3. Redis 的 key 是如何寻址的",slug:"_1-3-redis-的-key-是如何寻址的",normalizedTitle:"1.3. redis 的 key 是如何寻址的",charIndex:953},{level:4,title:"1.3.1. 背景",slug:"_1-3-1-背景",normalizedTitle:"1.3.1. 背景",charIndex:980},{level:4,title:"1.3.2. 寻址 key 的步骤",slug:"_1-3-2-寻址-key-的步骤",normalizedTitle:"1.3.2. 寻址 key 的步骤",charIndex:1698},{level:3,title:"1.4. Redis 的集群模式是如何实现的？",slug:"_1-4-redis-的集群模式是如何实现的",normalizedTitle:"1.4. redis 的集群模式是如何实现的？",charIndex:2144},{level:4,title:"1.4.1. Redis Cluster 节点分配",slug:"_1-4-1-redis-cluster-节点分配",normalizedTitle:"1.4.1. redis cluster 节点分配",charIndex:2276},{level:4,title:"1.4.2. Redis Cluster 主从模式",slug:"_1-4-2-redis-cluster-主从模式",normalizedTitle:"1.4.2. redis cluster 主从模式",charIndex:2683},{level:4,title:"1.4.3. Redis Sentinel",slug:"_1-4-3-redis-sentinel",normalizedTitle:"1.4.3. redis sentinel",charIndex:2861},{level:3,title:"1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？",slug:"_1-5-redis-如何实现分布式锁-zookeeper-如何实现分布式锁-比较二者优劣",normalizedTitle:"1.5. redis 如何实现分布式锁？zookeeper 如何实现分布式锁？比较二者优劣？",charIndex:3595},{level:4,title:"1.5.1. 数据库实现",slug:"_1-5-1-数据库实现",normalizedTitle:"1.5.1. 数据库实现",charIndex:3722},{level:4,title:"1.5.2. Redis 实现",slug:"_1-5-2-redis-实现",normalizedTitle:"1.5.2. redis 实现",charIndex:3738},{level:4,title:"1.5.3. ZooKeeper 实现",slug:"_1-5-3-zookeeper-实现",normalizedTitle:"1.5.3. zookeeper 实现",charIndex:3945},{level:4,title:"1.5.4. 实现对比",slug:"_1-5-4-实现对比",normalizedTitle:"1.5.4. 实现对比",charIndex:4183},{level:3,title:"1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？",slug:"_1-6-redis-的持久化方式-有什么优缺点-持久化实现原理",normalizedTitle:"1.6. redis 的持久化方式？有什么优缺点？持久化实现原理？",charIndex:4280},{level:4,title:"1.6.1. RDB 快照（snapshot）",slug:"_1-6-1-rdb-快照-snapshot",normalizedTitle:"1.6.1. rdb 快照（snapshot）",charIndex:4317},{level:5,title:"快照的原理",slug:"快照的原理",normalizedTitle:"快照的原理",charIndex:4367},{level:5,title:"快照的优点",slug:"快照的优点",normalizedTitle:"快照的优点",charIndex:4716},{level:5,title:"快照的缺点",slug:"快照的缺点",normalizedTitle:"快照的缺点",charIndex:4935},{level:4,title:"1.6.2. AOF",slug:"_1-6-2-aof",normalizedTitle:"1.6.2. aof",charIndex:5085},{level:4,title:"1.6.3. AOF 的原理",slug:"_1-6-3-aof-的原理",normalizedTitle:"1.6.3. aof 的原理",charIndex:5152},{level:4,title:"1.6.4. AOF 的优点",slug:"_1-6-4-aof-的优点",normalizedTitle:"1.6.4. aof 的优点",charIndex:5430},{level:4,title:"1.6.5. AOF 的缺点",slug:"_1-6-5-aof-的缺点",normalizedTitle:"1.6.5. aof 的缺点",charIndex:5833},{level:3,title:"1.7. Redis 过期策略有哪些？",slug:"_1-7-redis-过期策略有哪些",normalizedTitle:"1.7. redis 过期策略有哪些？",charIndex:6035},{level:3,title:"1.8. Redis 和 Memcached 有什么区别？",slug:"_1-8-redis-和-memcached-有什么区别",normalizedTitle:"1.8. redis 和 memcached 有什么区别？",charIndex:6331},{level:3,title:"1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？",slug:"_1-9-为什么单线程的-redis-性能反而优于多线程的-memcached",normalizedTitle:"1.9. 为什么单线程的 redis 性能反而优于多线程的 memcached？",charIndex:6851},{level:2,title:"2. 分布式消息队列（MQ）",slug:"_2-分布式消息队列-mq",normalizedTitle:"2. 分布式消息队列（mq）",charIndex:7072},{level:3,title:"2.1. 为什么使用 MQ？",slug:"_2-1-为什么使用-mq",normalizedTitle:"2.1. 为什么使用 mq？",charIndex:7091},{level:3,title:"2.2. 如何保证 MQ 的高可用？",slug:"_2-2-如何保证-mq-的高可用",normalizedTitle:"2.2. 如何保证 mq 的高可用？",charIndex:7302},{level:4,title:"2.2.1. 数据复制",slug:"_2-2-1-数据复制",normalizedTitle:"2.2.1. 数据复制",charIndex:7324},{level:4,title:"2.2.2. 选举主服务器",slug:"_2-2-2-选举主服务器",normalizedTitle:"2.2.2. 选举主服务器",charIndex:7486},{level:3,title:"2.3. MQ 有哪些常见问题？如何解决这些问题？",slug:"_2-3-mq-有哪些常见问题-如何解决这些问题",normalizedTitle:"2.3. mq 有哪些常见问题？如何解决这些问题？",charIndex:7504},{level:4,title:"2.3.1. 消息的顺序问题",slug:"_2-3-1-消息的顺序问题",normalizedTitle:"2.3.1. 消息的顺序问题",charIndex:7570},{level:4,title:"2.3.2. 消息的重复问题",slug:"_2-3-2-消息的重复问题",normalizedTitle:"2.3.2. 消息的重复问题",charIndex:7914},{level:3,title:"2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？",slug:"_2-4-kafka-activemq-rabbitmq-rocketmq-各有什么优缺点",normalizedTitle:"2.4. kafka, activemq, rabbitmq, rocketmq 各有什么优缺点？",charIndex:8146},{level:3,title:"3.1. Dubbo 的实现过程？",slug:"_3-1-dubbo-的实现过程",normalizedTitle:"3.1. dubbo 的实现过程？",charIndex:8219},{level:3,title:"3.2. Dubbo 负载均衡策略有哪些？",slug:"_3-2-dubbo-负载均衡策略有哪些",normalizedTitle:"3.2. dubbo 负载均衡策略有哪些？",charIndex:8643},{level:5,title:"Random",slug:"random",normalizedTitle:"random",charIndex:8668},{level:5,title:"RoundRobin",slug:"roundrobin",normalizedTitle:"roundrobin",charIndex:8754},{level:5,title:"LeastActive",slug:"leastactive",normalizedTitle:"leastactive",charIndex:8857},{level:5,title:"ConsistentHash",slug:"consistenthash",normalizedTitle:"consistenthash",charIndex:8943},{level:3,title:"3.3. Dubbo 集群容错策略 ？",slug:"_3-3-dubbo-集群容错策略",normalizedTitle:"3.3. dubbo 集群容错策略 ？",charIndex:9257},{level:3,title:"3.4. 动态代理策略？",slug:"_3-4-动态代理策略",normalizedTitle:"3.4. 动态代理策略？",charIndex:9685},{level:3,title:"3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？",slug:"_3-5-dubbo-支持哪些序列化协议-hessian-hessian-的数据结构",normalizedTitle:"3.5. dubbo 支持哪些序列化协议？hessian？hessian 的数据结构？",charIndex:10385},{level:3,title:"3.6. Protoco Buffer 是什么？",slug:"_3-6-protoco-buffer-是什么",normalizedTitle:"3.6. protoco buffer 是什么？",charIndex:10961},{level:3,title:"3.7. 注册中心挂了可以继续通信吗？",slug:"_3-7-注册中心挂了可以继续通信吗",normalizedTitle:"3.7. 注册中心挂了可以继续通信吗？",charIndex:11311},{level:3,title:"3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？",slug:"_3-8-zookeeper-原理是什么-zookeeper-有什么用",normalizedTitle:"3.8. zookeeper 原理是什么？zookeeper 有什么用？",charIndex:11403},{level:3,title:"3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？",slug:"_3-9-netty-有什么用-nio-bio-aio-有什么用-有什么区别",normalizedTitle:"3.9. netty 有什么用？nio/bio/aio 有什么用？有什么区别？",charIndex:11668},{level:3,title:"3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？",slug:"_3-10-为什么要进行系统拆分-拆分不用-dubbo-可以吗",normalizedTitle:"3.10. 为什么要进行系统拆分？拆分不用 dubbo 可以吗？",charIndex:12441},{level:3,title:"3.11. Dubbo 和 Thrift 有什么区别？",slug:"_3-11-dubbo-和-thrift-有什么区别",normalizedTitle:"3.11. dubbo 和 thrift 有什么区别？",charIndex:12759},{level:2,title:"4. 分布式锁基本原理",slug:"_4-分布式锁基本原理",normalizedTitle:"4. 分布式锁基本原理",charIndex:12846}],headersStr:"1. 分布式缓存 1.1. Redis 有什么数据类型？分别用于什么场景 1.2. Redis 的主从复制是如何实现的 1.3. Redis 的 key 是如何寻址的 1.3.1. 背景 1.3.2. 寻址 key 的步骤 1.4. Redis 的集群模式是如何实现的？ 1.4.1. Redis Cluster 节点分配 1.4.2. Redis Cluster 主从模式 1.4.3. Redis Sentinel 1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？ 1.5.1. 数据库实现 1.5.2. Redis 实现 1.5.3. ZooKeeper 实现 1.5.4. 实现对比 1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？ 1.6.1. RDB 快照（snapshot） 快照的原理 快照的优点 快照的缺点 1.6.2. AOF 1.6.3. AOF 的原理 1.6.4. AOF 的优点 1.6.5. AOF 的缺点 1.7. Redis 过期策略有哪些？ 1.8. Redis 和 Memcached 有什么区别？ 1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？ 2. 分布式消息队列（MQ） 2.1. 为什么使用 MQ？ 2.2. 如何保证 MQ 的高可用？ 2.2.1. 数据复制 2.2.2. 选举主服务器 2.3. MQ 有哪些常见问题？如何解决这些问题？ 2.3.1. 消息的顺序问题 2.3.2. 消息的重复问题 2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？ 3.1. Dubbo 的实现过程？ 3.2. Dubbo 负载均衡策略有哪些？ Random RoundRobin LeastActive ConsistentHash 3.3. Dubbo 集群容错策略 ？ 3.4. 动态代理策略？ 3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？ 3.6. Protoco Buffer 是什么？ 3.7. 注册中心挂了可以继续通信吗？ 3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？ 3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？ 3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？ 3.11. Dubbo 和 Thrift 有什么区别？ 4. 分布式锁基本原理",content:'# 分布式面试总结\n\n\n# 1. 分布式缓存\n\n\n# 1.1. Redis 有什么数据类型？分别用于什么场景\n\n数据类型     可以存储的值        操作\nSTRING   字符串、整数或者浮点数   对整个字符串或者字符串的其中一部分执行操作\n                       对整数和浮点数执行自增或者自减操作\nLIST     列表            从两端压入或者弹出元素\n                       读取单个或者多个元素\n                       进行修剪，只保留一个范围内的元素\nSET      无序集合          添加、获取、移除单个元素\n                       检查一个元素是否存在于集合中\n                       计算交集、并集、差集\n                       从集合里面随机获取元素\nHASH     包含键值对的无序散列表   添加、获取、移除单个键值对\n                       获取所有键值对\n                       检查某个键是否存在\nZSET     有序集合          添加、获取、删除元素\n                       根据分值范围或者成员来获取元素\n                       计算一个键的排名\n\n> What Redis data structures look like\n\n\n# 1.2. Redis 的主从复制是如何实现的\n\n 1. 从服务器连接主服务器，发送 SYNC 命令；\n 2. 主服务器接收到 SYNC 命名后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；\n 3. 主服务器 BGSAVE 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；\n 4. 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；\n 5. 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；\n 6. 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；\n\n\n# 1.3. Redis 的 key 是如何寻址的\n\n# 1.3.1. 背景\n\n（1）redis 中的每一个数据库，都由一个 redisDb 的结构存储。其中：\n\n * redisDb.id 存储着 redis 数据库以整数表示的号码。\n * redisDb.dict 存储着该库所有的键值对数据。\n * redisDb.expires 保存着每一个键的过期时间。\n\n（2）当 redis 服务器初始化时，会预先分配 16 个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisServer 的一个成员 redisServer.db 数组中。当我们选择数据库 select number 时，程序直接通过 redisServer.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 redisDb.id 即可。\n\n（3）redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0 号哈希表（ht[0]）主要用于存储数据库的所有键值，而 1 号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash 一般是在添加新值时会触发，这里不做过多的赘述。所以 redis 中查找一个 key，其实就是对进行该 dict 结构中的 ht[0] 进行查找操作。\n\n（4）既然是哈希，那么我们知道就会有哈希碰撞，那么当多个键哈希之后为同一个值怎么办呢？redis 采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据 key 的哈希值找到该列表后，如果列表的长度大于 1，那么我们需要遍历该链表来找到我们所查找的 key。当然，一般情况下链表长度都为是 1，所以时间复杂度可看作 o(1)。\n\n# 1.3.2. 寻址 key 的步骤\n\n 1. 当拿到一个 key 后，redis 先判断当前库的 0 号哈希表是否为空，即：if (dict->ht[0].size == 0)。如果为 true 直接返回 NULL。\n 2. 判断该 0 号哈希表是否需要 rehash，因为如果在进行 rehash，那么两个表中者有可能存储该 key。如果正在进行 rehash，将调用一次_dictRehashStep 方法，_dictRehashStep 用于对数据库字典、以及哈希键的字典进行被动 rehash，这里不作赘述。\n 3. 计算哈希表，根据当前字典与 key 进行哈希值的计算。\n 4. 根据哈希值与当前字典计算哈希表的索引值。\n 5. 根据索引值在哈希表中取出链表，遍历该链表找到 key 的位置。一般情况，该链表长度为 1。\n 6. 当 ht[0] 查找完了之后，再进行了次 rehash 判断，如果未在 rehashing，则直接结束，否则对 ht[1]重复 345 步骤。\n\n\n# 1.4. Redis 的集群模式是如何实现的？\n\nRedis Cluster 是 Redis 的分布式解决方案，在 Redis 3.0 版本正式推出的。\n\nRedis Cluster 去中心化，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。\n\n# 1.4.1. Redis Cluster 节点分配\n\nRedis Cluster 特点：\n\n 1. 所有的 redis 节点彼此互联(PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽。\n 2. 节点的 fail 是通过集群中超过半数的节点检测失效时才生效。\n 3. 客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。\n 4. redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node<->slot<->value。\n 5. Redis 集群预分好 16384 个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。\n\n# 1.4.2. Redis Cluster 主从模式\n\nRedis Cluster 为了保证数据的高可用性，加入了主从模式。\n\n一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份。当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。所以，在集群建立的时候，一定要为每个主节点都添加了从节点。\n\n# 1.4.3. Redis Sentinel\n\nRedis Sentinel 用于管理多个 Redis 服务器，它有三个功能：\n\n * 监控（Monitoring） - Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。\n * 提醒（Notification） - 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。\n * 自动故障迁移（Automatic failover） - 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。\n\nRedis 集群中应该有奇数个节点，所以至少有三个节点。\n\n哨兵监控集群中的主服务器出现故障时，需要根据 quorum 选举出一个哨兵来执行故障转移。选举需要 majority，即大多数哨兵是运行的（2 个哨兵的 majority=2，3 个哨兵的 majority=2，5 个哨兵的 majority=3，4 个哨兵的 majority=2）。\n\n假设集群仅仅部署 2 个节点\n\n+----+         +----+\n| M1 |---------| R1 |\n| S1 |         | S2 |\n+----+         +----+\n\n\n如果 M1 和 S1 所在服务器宕机，则哨兵只有 1 个，无法满足 majority 来进行选举，就不能执行故障转移。\n\n\n# 1.5. Redis 如何实现分布式锁？ZooKeeper 如何实现分布式锁？比较二者优劣？\n\n分布式锁的三种实现：\n\n * 基于数据库实现分布式锁；\n * 基于缓存（Redis 等）实现分布式锁；\n * 基于 Zookeeper 实现分布式锁；\n\n# 1.5.1. 数据库实现\n\n# 1.5.2. Redis 实现\n\n 1. 获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 UUID，通过此在释放锁的时候进行判断。\n 2. 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。\n 3. 释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。\n\n# 1.5.3. ZooKeeper 实现\n\n 1. 创建一个目录 mylock；\n 2. 线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；\n 3. 获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；\n 4. 线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；\n 5. 线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。\n\n# 1.5.4. 实现对比\n\nZooKeeper 具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。 但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。\n\n\n# 1.6. Redis 的持久化方式？有什么优缺点？持久化实现原理？\n\n# 1.6.1. RDB 快照（snapshot）\n\n将存在于某一时刻的所有数据都写入到硬盘中。\n\n# 快照的原理\n\n在默认情况下，Redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 Redis 进行设置， 让它在“N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 SAVE 或者 BGSAVE，手动让 Redis 进行数据集保存操作。这种持久化方式被称为快照。\n\n当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:\n\n * Redis 创建一个子进程。\n * 子进程将数据集写入到一个临时快照文件中。\n * 当子进程完成对新快照文件的写入时，Redis 用新快照文件替换原来的快照文件，并删除旧的快照文件。\n\n这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益。\n\n# 快照的优点\n\n * 它保存了某个时间点的数据集，非常适用于数据集的备份。\n * 很方便传送到另一个远端数据中心或者亚马逊的 S3（可能加密），非常适用于灾难恢复。\n * 快照在保存 RDB 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 IO 操作，所以快照持久化方式可以最大化 redis 的性能。\n * 与 AOF 相比，在恢复大的数据集的时候，DB 方式会更快一些。\n\n# 快照的缺点\n\n * 如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么快照不适合你。\n * 快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 Redis 在一些毫秒级内不能响应客户端的请求。\n\n# 1.6.2. AOF\n\nAOF 持久化方式记录每次对服务器执行的写操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据。\n\n# 1.6.3. AOF 的原理\n\n * Redis 创建一个子进程。\n * 子进程开始将新 AOF 文件的内容写入到临时文件。\n * 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾，这样样即使在重写的中途发生停机，现有的 AOF 文件也还是安全的。\n * 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。\n * 搞定！现在 Redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 AOF 文件的末尾。\n\n# 1.6.4. AOF 的优点\n\n * 使用默认的每秒 fsync 策略，Redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，使用 AOF ，你最多丢失 1 秒的数据。\n * AOF 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。\n * Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写：重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的。\n * AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存。因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。\n\n# 1.6.5. AOF 的缺点\n\n * 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。\n * 根据所使用的 fsync 策略，AOF 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 AOF 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。\n\n\n# 1.7. Redis 过期策略有哪些？\n\n * noeviction - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。\n * allkeys-lru - 在主键空间中，优先移除最近未使用的 key。\n * allkeys-random - 在主键空间中，随机移除某个 key。\n * volatile-lru - 在设置了过期时间的键空间中，优先移除最近未使用的 key。\n * volatile-random - 在设置了过期时间的键空间中，随机移除某个 key。\n * volatile-ttl - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。\n\n\n# 1.8. Redis 和 Memcached 有什么区别？\n\n两者都是非关系型内存键值数据库。有以下主要不同：\n\n数据类型\n\n * Memcached 仅支持字符串类型；\n * 而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。\n\n数据持久化\n\n * Memcached 不支持持久化；\n * Redis 支持两种持久化策略：RDB 快照和 AOF 日志。\n\n分布式\n\n * Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。\n * Redis Cluster 实现了分布式的支持。\n\n内存管理机制\n\n * Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。\n * 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。\n\n\n# 1.9. 为什么单线程的 Redis 性能反而优于多线程的 Memcached？\n\nRedis 快速的原因：\n\n 1. 绝大部分请求是纯粹的内存操作（非常快速）\n 2. 采用单线程,避免了不必要的上下文切换和竞争条件\n 3. 非阻塞 IO\n\n内部实现采用 epoll，采用了 epoll+自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 io 上浪费一点时间。\n\n\n# 2. 分布式消息队列（MQ）\n\n\n# 2.1. 为什么使用 MQ？\n\n * 异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。\n * 应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。\n * 流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。\n * 日志处理 - 解决大量日志传输。\n * 消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。\n\n\n# 2.2. 如何保证 MQ 的高可用？\n\n# 2.2.1. 数据复制\n\n 1. 将所有 Broker 和待分配的 Partition 排序\n 2. 将第 i 个 Partition 分配到第（i mod n）个 Broker 上\n 3. 将第 i 个 Partition 的第 j 个 Replica 分配到第（(i + j) mode n）个 Broker 上\n\n# 2.2.2. 选举主服务器\n\n\n# 2.3. MQ 有哪些常见问题？如何解决这些问题？\n\nMQ 的常见问题有：\n\n 1. 消息的顺序问题\n 2. 消息的重复问题\n\n# 2.3.1. 消息的顺序问题\n\n消息有序指的是可以按照消息的发送顺序来消费。\n\n假如生产者产生了 2 条消息：M1、M2，假定 M1 发送到 S1，M2 发送到 S2，如果要保证 M1 先于 M2 被消费，怎么做？\n\n\n解决方案：\n\n（1）保证生产者 - MQServer - 消费者是一对一对一的关系\n\n\n缺陷：\n * 并行度就会成为消息系统的瓶颈（吞吐量不够）\n * 更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。\n\n（2）通过合理的设计或者将问题分解来规避。\n\n * 不关注乱序的应用实际大量存在\n * 队列无序并不意味着消息无序\n\n所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。\n\n# 2.3.2. 消息的重复问题\n\n造成消息重复的根本原因是：网络不可达。\n\n所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？\n\n消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。 保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息。\n\n\n# 2.4. Kafka, ActiveMQ, RabbitMQ, RocketMQ 各有什么优缺点？\n\n\n## 3. 分布式服务（RPC）\n\n\n# 3.1. Dubbo 的实现过程？\n\n\n\n节点角色：\n\n节点          角色说明\nProvider    暴露服务的服务提供方\nConsumer    调用远程服务的服务消费方\nRegistry    服务注册与发现的注册中心\nMonitor     统计服务的调用次数和调用时间的监控中心\nContainer   服务运行容器\n\n调用关系：\n\n 1. 务容器负责启动，加载，运行服务提供者。\n 2. 服务提供者在启动时，向注册中心注册自己提供的服务。\n 3. 服务消费者在启动时，向注册中心订阅自己所需的服务。\n 4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n 5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n 6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n\n# 3.2. Dubbo 负载均衡策略有哪些？\n\n# Random\n\n * 随机，按权重设置随机概率。\n * 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n\n# RoundRobin\n\n * 轮循，按公约后的权重设置轮循比率。\n * 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n\n# LeastActive\n\n * 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。\n * 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\n\n# ConsistentHash\n\n * 一致性 Hash，相同参数的请求总是发到同一提供者。\n * 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。\n * 算法参见：http://en.wikipedia.org/wiki/Consistent_hashing\n * 缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key="hash.arguments" value="0,1" />\n * 缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key="hash.nodes" value="320" />\n\n\n# 3.3. Dubbo 集群容错策略 ？\n\n\n- **Failover** - 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries="2" 来设置重试次数(不含第一次)。 - **Failfast** - 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。 - **Failsafe** - 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。 - **Failback** - 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。 - **Forking** - 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2" 来设置最大并行数。 - **Broadcast** - 播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n\n\n# 3.4. 动态代理策略？\n\nDubbo 作为 RPC 框架，首先要完成的就是跨系统，跨网络的服务调用。消费方与提供方遵循统一的接口定义，消费方调用接口时，Dubbo 将其转换成统一格式的数据结构，通过网络传输，提供方根据规则找到接口实现，通过反射完成调用。也就是说，消费方获取的是对远程服务的一个代理(Proxy)，而提供方因为要支持不同的接口实现，需要一个包装层(Wrapper)。调用的过程大概是这样：\n\n\n消费方的 Proxy 和提供方的 Wrapper 得以让 Dubbo 构建出复杂、统一的体系。而这种动态代理与包装也是通过基于 SPI 的插件方式实现的，它的接口就是**ProxyFactory**。\n\n@SPI("javassist")\npublic interface ProxyFactory {\n\n    @Adaptive({Constants.PROXY_KEY})\n    <T> T getProxy(Invoker<T> invoker) throws RpcException;\n\n    @Adaptive({Constants.PROXY_KEY})\n    <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) throws RpcException;\n\n}\n\n\nProxyFactory 有两种实现方式，一种是基于 JDK 的代理实现，一种是基于 javassist 的实现。ProxyFactory 接口上定义了@SPI("javassist")，默认为 javassist 的实现。\n\n\n# 3.5. Dubbo 支持哪些序列化协议？Hessian？Hessian 的数据结构？\n\n 1. dubbo 序列化，阿里尚不成熟的 java 序列化实现。\n 2. hessian2 序列化：hessian 是一种跨语言的高效二进制的序列化方式，但这里实际不是原生的 hessian2 序列化，而是阿里修改过的 hessian lite，它是 dubbo RPC 默认启用的序列化方式。\n 3. json 序列化：目前有两种实现，一种是采用的阿里的 fastjson 库，另一种是采用 dubbo 中自已实现的简单 json 库，一般情况下，json 这种文本序列化性能不如二进制序列化。\n 4. java 序列化：主要是采用 JDK 自带的 java 序列化实现，性能很不理想。\n 5. Kryo 和 FST：Kryo 和 FST 的性能依然普遍优于 hessian 和 dubbo 序列化。\n\nHessian 序列化与 Java 默认的序列化区别？\n\nHessian 是一个轻量级的 remoting on http 工具，采用的是 Binary RPC 协议，所以它很适合于发送二进制数据，同时又具有防火墙穿透能力。\n\n 1. Hessian 支持跨语言串行\n 2. 比 java 序列化具有更好的性能和易用性\n 3. 支持的语言比较多\n\n\n# 3.6. Protoco Buffer 是什么？\n\nProtocol Buffer 是 Google 出品的一种轻量 & 高效的结构化数据存储格式，性能比 Json、XML 真的强！太！多！\n\nProtocol Buffer 的序列化 & 反序列化简单 & 速度快的原因是：\n\n 1. 编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）\n 2. 采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成\n\nProtocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是：\n\n 1. 采用了独特的编码方式，如 Varint、Zigzag 编码方式等等\n 2. 采用 T - L - V 的数据存储方式：减少了分隔符的使用 & 数据存储得紧凑\n\n\n# 3.7. 注册中心挂了可以继续通信吗？\n\n可以。Dubbo 消费者在应用启动时会从注册中心拉取已注册的生产者的地址接口，并缓存在本地。每次调用时，按照本地存储的地址进行调用。\n\n\n# 3.8. ZooKeeper 原理是什么？ZooKeeper 有什么用？\n\nZooKeeper 是一个分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。\n\n\n 1. 每个 Server 在内存中存储了一份数据；\n 2. Zookeeper 启动时，将从实例中选举一个 leader（Paxos 协议）；\n 3. Leader 负责处理数据更新等操作（Zab 协议）；\n 4. 一个更新操作成功，当且仅当大多数 Server 在内存中成功修改数据。\n\n\n# 3.9. Netty 有什么用？NIO/BIO/AIO 有什么用？有什么区别？\n\nNetty 是一个“网络通讯框架”。\n\nNetty 进行事件处理的流程。Channel是连接的通道，是 ChannelEvent 的产生者，而ChannelPipeline可以理解为 ChannelHandler 的集合。\n\n\n> 参考：https://github.com/code4craft/netty-learning/blob/master/posts/ch1-overview.md\n\nIO 的方式通常分为几种：\n\n * 同步阻塞的 BIO\n * 同步非阻塞的 NIO\n * 异步非阻塞的 AIO\n\n在使用同步 I/O 的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。\n\nNIO 基于 Reactor，当 socket 有流可读或可写入 socket 时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。\n\n与 NIO 不同，当进行读写操作时，只须直接调用 API 的 read 或 write 方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write 方法都是异步的，完成后会主动调用回调函数。\n\n> 参考：https://blog.csdn.net/skiof007/article/details/52873421\n\n\n# 3.10. 为什么要进行系统拆分？拆分不用 Dubbo 可以吗？\n\n系统拆分从资源角度分为：应用拆分和数据库拆分。\n\n从采用的先后顺序可分为：水平扩展、垂直拆分、业务拆分、水平拆分。\n\n\n是否使用服务依据实际业务场景来决定。\n\n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。\n\n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。\n\n\n# 3.11. Dubbo 和 Thrift 有什么区别？\n\n * Thrift 是跨语言的 RPC 框架。\n * Dubbo 支持服务治理，而 Thrift 不支持。\n\n\n# 4. 分布式锁基本原理\n\n> 分布式锁有几种实现方式？实现的要点是什么？\n> \n> 分布式锁各方案有什么利弊？如何选择方案？为什么？\n> \n> Redis 分布式锁如何保证可重入性？\n> \n> 详细内容请参考：分布式锁\n\n【答题思路】\n\n实现方式一般有：\n\n * 基于数据库实现：\n   * 建一张表（t_dlock），关键字段有：id、method_name、time。\n   * 向表中插入记录成功，即为获取锁成功。需要注意的是，获取锁一般是通过自旋方式，并设置尝试次数，超过最大尝试次数，才判定获取锁失败。\n   * 删除记录，即为释放锁。\n   * 因为数据库没有淘汰机制，为了避免获取锁永不释放，应用需要自身实现定期检查，删除过期记录（根据 time 判断）。\n * 基于 Redis 实现\n   * 生成一个分布式 ID 作为 key，通过 setnx 写入\n   * 写入成功，即为获取锁成功。需要注意的是，获取锁一般是通过自旋方式，并设置尝试次数，超过最大尝试次数，才判定获取锁失败。\n   * 删除 key，即为获取锁失败。\n   * Redis 自身有内存淘汰策略，所以只要设置 expire，就可以让 key 自动过期。\n * 基于 ZooKeeper 实现\n   * 创建一个节点，所有节点都 Watch 此节点。\n   * 任意节点的任意线程只要向这个节点创建临时子节点成功，即为获取锁成功。\n   * 由于创建临时子节点是原子性的，不存在竞态，不需要自旋尝试，性能很好。\n   * 因为 ZooKeeper 只要和节点断开会话，就会自动删除临时节点。即为删除锁。所以无需过期机制。\n\n从实现方式可以看出，三种方案的对比：\n\n * Mysql 方案性能最差，并且影响 Mysql 吞吐量。而且还要程序保证容错处理。不建议采用这种方案。\n * Redis 方案需要不断自旋尝试获取锁，应用会消耗一些性能开销。而且为了保证分布式锁的可重入性，需要设置对于所有节点、所有线程都唯一的分布式 ID，生成 ID 也需要一定的 CPU 开销。\n * ZooKeeper 方案实现最简单，最稳定。是推荐的方案。但是它也有一个问题：ZooKeeper 的主从架构，所有写都由 Master 节点负责，所以 ZooKeeper 自身有一定的性能瓶颈。',normalizedContent:'# 分布式面试总结\n\n\n# 1. 分布式缓存\n\n\n# 1.1. redis 有什么数据类型？分别用于什么场景\n\n数据类型     可以存储的值        操作\nstring   字符串、整数或者浮点数   对整个字符串或者字符串的其中一部分执行操作\n                       对整数和浮点数执行自增或者自减操作\nlist     列表            从两端压入或者弹出元素\n                       读取单个或者多个元素\n                       进行修剪，只保留一个范围内的元素\nset      无序集合          添加、获取、移除单个元素\n                       检查一个元素是否存在于集合中\n                       计算交集、并集、差集\n                       从集合里面随机获取元素\nhash     包含键值对的无序散列表   添加、获取、移除单个键值对\n                       获取所有键值对\n                       检查某个键是否存在\nzset     有序集合          添加、获取、删除元素\n                       根据分值范围或者成员来获取元素\n                       计算一个键的排名\n\n> what redis data structures look like\n\n\n# 1.2. redis 的主从复制是如何实现的\n\n 1. 从服务器连接主服务器，发送 sync 命令；\n 2. 主服务器接收到 sync 命名后，开始执行 bgsave 命令生成 rdb 文件并使用缓冲区记录此后执行的所有写命令；\n 3. 主服务器 bgsave 执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；\n 4. 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；\n 5. 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；\n 6. 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；\n\n\n# 1.3. redis 的 key 是如何寻址的\n\n# 1.3.1. 背景\n\n（1）redis 中的每一个数据库，都由一个 redisdb 的结构存储。其中：\n\n * redisdb.id 存储着 redis 数据库以整数表示的号码。\n * redisdb.dict 存储着该库所有的键值对数据。\n * redisdb.expires 保存着每一个键的过期时间。\n\n（2）当 redis 服务器初始化时，会预先分配 16 个数据库（该数量可以通过配置文件配置），所有数据库保存到结构 redisserver 的一个成员 redisserver.db 数组中。当我们选择数据库 select number 时，程序直接通过 redisserver.db[number] 来切换数据库。有时候当程序需要知道自己是在哪个数据库时，直接读取 redisdb.id 即可。\n\n（3）redis 的字典使用哈希表作为其底层实现。dict 类型使用的两个指向哈希表的指针，其中 0 号哈希表（ht[0]）主要用于存储数据库的所有键值，而 1 号哈希表主要用于程序对 0 号哈希表进行 rehash 时使用，rehash 一般是在添加新值时会触发，这里不做过多的赘述。所以 redis 中查找一个 key，其实就是对进行该 dict 结构中的 ht[0] 进行查找操作。\n\n（4）既然是哈希，那么我们知道就会有哈希碰撞，那么当多个键哈希之后为同一个值怎么办呢？redis 采取链表的方式来存储多个哈希碰撞的键。也就是说，当根据 key 的哈希值找到该列表后，如果列表的长度大于 1，那么我们需要遍历该链表来找到我们所查找的 key。当然，一般情况下链表长度都为是 1，所以时间复杂度可看作 o(1)。\n\n# 1.3.2. 寻址 key 的步骤\n\n 1. 当拿到一个 key 后，redis 先判断当前库的 0 号哈希表是否为空，即：if (dict->ht[0].size == 0)。如果为 true 直接返回 null。\n 2. 判断该 0 号哈希表是否需要 rehash，因为如果在进行 rehash，那么两个表中者有可能存储该 key。如果正在进行 rehash，将调用一次_dictrehashstep 方法，_dictrehashstep 用于对数据库字典、以及哈希键的字典进行被动 rehash，这里不作赘述。\n 3. 计算哈希表，根据当前字典与 key 进行哈希值的计算。\n 4. 根据哈希值与当前字典计算哈希表的索引值。\n 5. 根据索引值在哈希表中取出链表，遍历该链表找到 key 的位置。一般情况，该链表长度为 1。\n 6. 当 ht[0] 查找完了之后，再进行了次 rehash 判断，如果未在 rehashing，则直接结束，否则对 ht[1]重复 345 步骤。\n\n\n# 1.4. redis 的集群模式是如何实现的？\n\nredis cluster 是 redis 的分布式解决方案，在 redis 3.0 版本正式推出的。\n\nredis cluster 去中心化，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。\n\n# 1.4.1. redis cluster 节点分配\n\nredis cluster 特点：\n\n 1. 所有的 redis 节点彼此互联(ping-pong 机制)，内部使用二进制协议优化传输速度和带宽。\n 2. 节点的 fail 是通过集群中超过半数的节点检测失效时才生效。\n 3. 客户端与 redis 节点直连,不需要中间 proxy 层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。\n 4. redis-cluster 把所有的物理节点映射到[0-16383] 哈希槽 (hash slot)上（不一定是平均分配）,cluster 负责维护 node<->slot<->value。\n 5. redis 集群预分好 16384 个桶，当需要在 redis 集群中放置一个 key-value 时，根据 crc16(key) mod 16384 的值，决定将一个 key 放到哪个桶中。\n\n# 1.4.2. redis cluster 主从模式\n\nredis cluster 为了保证数据的高可用性，加入了主从模式。\n\n一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份。当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉。所以，在集群建立的时候，一定要为每个主节点都添加了从节点。\n\n# 1.4.3. redis sentinel\n\nredis sentinel 用于管理多个 redis 服务器，它有三个功能：\n\n * 监控（monitoring） - sentinel 会不断地检查你的主服务器和从服务器是否运作正常。\n * 提醒（notification） - 当被监控的某个 redis 服务器出现问题时， sentinel 可以通过 api 向管理员或者其他应用程序发送通知。\n * 自动故障迁移（automatic failover） - 当一个主服务器不能正常工作时， sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器， 并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。\n\nredis 集群中应该有奇数个节点，所以至少有三个节点。\n\n哨兵监控集群中的主服务器出现故障时，需要根据 quorum 选举出一个哨兵来执行故障转移。选举需要 majority，即大多数哨兵是运行的（2 个哨兵的 majority=2，3 个哨兵的 majority=2，5 个哨兵的 majority=3，4 个哨兵的 majority=2）。\n\n假设集群仅仅部署 2 个节点\n\n+----+         +----+\n| m1 |---------| r1 |\n| s1 |         | s2 |\n+----+         +----+\n\n\n如果 m1 和 s1 所在服务器宕机，则哨兵只有 1 个，无法满足 majority 来进行选举，就不能执行故障转移。\n\n\n# 1.5. redis 如何实现分布式锁？zookeeper 如何实现分布式锁？比较二者优劣？\n\n分布式锁的三种实现：\n\n * 基于数据库实现分布式锁；\n * 基于缓存（redis 等）实现分布式锁；\n * 基于 zookeeper 实现分布式锁；\n\n# 1.5.1. 数据库实现\n\n# 1.5.2. redis 实现\n\n 1. 获取锁的时候，使用 setnx 加锁，并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的 value 值为一个随机生成的 uuid，通过此在释放锁的时候进行判断。\n 2. 获取锁的时候还设置一个获取的超时时间，若超过这个时间则放弃获取锁。\n 3. 释放锁的时候，通过 uuid 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。\n\n# 1.5.3. zookeeper 实现\n\n 1. 创建一个目录 mylock；\n 2. 线程 a 想获取锁就在 mylock 目录下创建临时顺序节点；\n 3. 获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；\n 4. 线程 b 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；\n 5. 线程 a 处理完，删除自己的节点，线程 b 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。\n\n# 1.5.4. 实现对比\n\nzookeeper 具备高可用、可重入、阻塞锁特性，可解决失效死锁问题。 但 zookeeper 因为需要频繁的创建和删除节点，性能上不如 redis 方式。\n\n\n# 1.6. redis 的持久化方式？有什么优缺点？持久化实现原理？\n\n# 1.6.1. rdb 快照（snapshot）\n\n将存在于某一时刻的所有数据都写入到硬盘中。\n\n# 快照的原理\n\n在默认情况下，redis 将数据库快照保存在名字为 dump.rdb 的二进制文件中。你可以对 redis 进行设置， 让它在“n 秒内数据集至少有 m 个改动”这一条件被满足时， 自动保存一次数据集。你也可以通过调用 save 或者 bgsave，手动让 redis 进行数据集保存操作。这种持久化方式被称为快照。\n\n当 redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:\n\n * redis 创建一个子进程。\n * 子进程将数据集写入到一个临时快照文件中。\n * 当子进程完成对新快照文件的写入时，redis 用新快照文件替换原来的快照文件，并删除旧的快照文件。\n\n这种工作方式使得 redis 可以从写时复制（copy-on-write）机制中获益。\n\n# 快照的优点\n\n * 它保存了某个时间点的数据集，非常适用于数据集的备份。\n * 很方便传送到另一个远端数据中心或者亚马逊的 s3（可能加密），非常适用于灾难恢复。\n * 快照在保存 rdb 文件时父进程唯一需要做的就是 fork 出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他 io 操作，所以快照持久化方式可以最大化 redis 的性能。\n * 与 aof 相比，在恢复大的数据集的时候，db 方式会更快一些。\n\n# 快照的缺点\n\n * 如果你希望在 redis 意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么快照不适合你。\n * 快照需要经常 fork 子进程来保存数据集到硬盘上。当数据集比较大的时候，fork 的过程是非常耗时的，可能会导致 redis 在一些毫秒级内不能响应客户端的请求。\n\n# 1.6.2. aof\n\naof 持久化方式记录每次对服务器执行的写操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据。\n\n# 1.6.3. aof 的原理\n\n * redis 创建一个子进程。\n * 子进程开始将新 aof 文件的内容写入到临时文件。\n * 对于所有新执行的写入命令，父进程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 aof 文件的末尾，这样样即使在重写的中途发生停机，现有的 aof 文件也还是安全的。\n * 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 aof 文件的末尾。\n * 搞定！现在 redis 原子地用新文件替换旧文件，之后所有命令都会直接追加到新 aof 文件的末尾。\n\n# 1.6.4. aof 的优点\n\n * 使用默认的每秒 fsync 策略，redis 的性能依然很好(fsync 是由后台线程进行处理的,主线程会尽力处理客户端请求)，一旦出现故障，使用 aof ，你最多丢失 1 秒的数据。\n * aof 文件是一个只进行追加的日志文件，所以不需要写入 seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用 redis-check-aof 工具修复这些问题。\n * redis 可以在 aof 文件体积变得过大时，自动地在后台对 aof 进行重写：重写后的新 aof 文件包含了恢复当前数据集所需的最小命令集合。整个重写操作是绝对安全的。\n * aof 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 redis 协议的格式保存。因此 aof 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。\n\n# 1.6.5. aof 的缺点\n\n * 对于相同的数据集来说，aof 文件的体积通常要大于 rdb 文件的体积。\n * 根据所使用的 fsync 策略，aof 的速度可能会慢于快照。在一般情况下，每秒 fsync 的性能依然非常高，而关闭 fsync 可以让 aof 的速度和快照一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，快照可以提供更有保证的最大延迟时间（latency）。\n\n\n# 1.7. redis 过期策略有哪些？\n\n * noeviction - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。\n * allkeys-lru - 在主键空间中，优先移除最近未使用的 key。\n * allkeys-random - 在主键空间中，随机移除某个 key。\n * volatile-lru - 在设置了过期时间的键空间中，优先移除最近未使用的 key。\n * volatile-random - 在设置了过期时间的键空间中，随机移除某个 key。\n * volatile-ttl - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。\n\n\n# 1.8. redis 和 memcached 有什么区别？\n\n两者都是非关系型内存键值数据库。有以下主要不同：\n\n数据类型\n\n * memcached 仅支持字符串类型；\n * 而 redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。\n\n数据持久化\n\n * memcached 不支持持久化；\n * redis 支持两种持久化策略：rdb 快照和 aof 日志。\n\n分布式\n\n * memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。\n * redis cluster 实现了分布式的支持。\n\n内存管理机制\n\n * memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。\n * 在 redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 memcached 的数据则会一直在内存中。\n\n\n# 1.9. 为什么单线程的 redis 性能反而优于多线程的 memcached？\n\nredis 快速的原因：\n\n 1. 绝大部分请求是纯粹的内存操作（非常快速）\n 2. 采用单线程,避免了不必要的上下文切换和竞争条件\n 3. 非阻塞 io\n\n内部实现采用 epoll，采用了 epoll+自己实现的简单的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性，绝不在 io 上浪费一点时间。\n\n\n# 2. 分布式消息队列（mq）\n\n\n# 2.1. 为什么使用 mq？\n\n * 异步处理 - 相比于传统的串行、并行方式，提高了系统吞吐量。\n * 应用解耦 - 系统间通过消息通信，不用关心其他系统的处理。\n * 流量削锋 - 可以通过消息队列长度控制请求量；可以缓解短时间内的高并发请求。\n * 日志处理 - 解决大量日志传输。\n * 消息通讯 - 消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯。比如实现点对点消息队列，或者聊天室等。\n\n\n# 2.2. 如何保证 mq 的高可用？\n\n# 2.2.1. 数据复制\n\n 1. 将所有 broker 和待分配的 partition 排序\n 2. 将第 i 个 partition 分配到第（i mod n）个 broker 上\n 3. 将第 i 个 partition 的第 j 个 replica 分配到第（(i + j) mode n）个 broker 上\n\n# 2.2.2. 选举主服务器\n\n\n# 2.3. mq 有哪些常见问题？如何解决这些问题？\n\nmq 的常见问题有：\n\n 1. 消息的顺序问题\n 2. 消息的重复问题\n\n# 2.3.1. 消息的顺序问题\n\n消息有序指的是可以按照消息的发送顺序来消费。\n\n假如生产者产生了 2 条消息：m1、m2，假定 m1 发送到 s1，m2 发送到 s2，如果要保证 m1 先于 m2 被消费，怎么做？\n\n\n解决方案：\n\n（1）保证生产者 - mqserver - 消费者是一对一对一的关系\n\n\n缺陷：\n * 并行度就会成为消息系统的瓶颈（吞吐量不够）\n * 更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。\n\n（2）通过合理的设计或者将问题分解来规避。\n\n * 不关注乱序的应用实际大量存在\n * 队列无序并不意味着消息无序\n\n所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是一种更合理的方式。\n\n# 2.3.2. 消息的重复问题\n\n造成消息重复的根本原因是：网络不可达。\n\n所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？\n\n消费端处理消息的业务逻辑保持幂等性。只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。 保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现。利用一张日志表来记录已经处理成功的消息的 id，如果新到的消息 id 已经在日志表中，那么就不再处理这条消息。\n\n\n# 2.4. kafka, activemq, rabbitmq, rocketmq 各有什么优缺点？\n\n\n## 3. 分布式服务（rpc）\n\n\n# 3.1. dubbo 的实现过程？\n\n\n\n节点角色：\n\n节点          角色说明\nprovider    暴露服务的服务提供方\nconsumer    调用远程服务的服务消费方\nregistry    服务注册与发现的注册中心\nmonitor     统计服务的调用次数和调用时间的监控中心\ncontainer   服务运行容器\n\n调用关系：\n\n 1. 务容器负责启动，加载，运行服务提供者。\n 2. 服务提供者在启动时，向注册中心注册自己提供的服务。\n 3. 服务消费者在启动时，向注册中心订阅自己所需的服务。\n 4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n 5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。\n 6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。\n\n\n# 3.2. dubbo 负载均衡策略有哪些？\n\n# random\n\n * 随机，按权重设置随机概率。\n * 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n\n# roundrobin\n\n * 轮循，按公约后的权重设置轮循比率。\n * 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n\n# leastactive\n\n * 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。\n * 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\n\n# consistenthash\n\n * 一致性 hash，相同参数的请求总是发到同一提供者。\n * 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。\n * 算法参见：http://en.wikipedia.org/wiki/consistent_hashing\n * 缺省只对第一个参数 hash，如果要修改，请配置 <dubbo:parameter key="hash.arguments" value="0,1" />\n * 缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key="hash.nodes" value="320" />\n\n\n# 3.3. dubbo 集群容错策略 ？\n\n\n- **failover** - 失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries="2" 来设置重试次数(不含第一次)。 - **failfast** - 快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。 - **failsafe** - 失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。 - **failback** - 失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。 - **forking** - 并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2" 来设置最大并行数。 - **broadcast** - 播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n\n\n# 3.4. 动态代理策略？\n\ndubbo 作为 rpc 框架，首先要完成的就是跨系统，跨网络的服务调用。消费方与提供方遵循统一的接口定义，消费方调用接口时，dubbo 将其转换成统一格式的数据结构，通过网络传输，提供方根据规则找到接口实现，通过反射完成调用。也就是说，消费方获取的是对远程服务的一个代理(proxy)，而提供方因为要支持不同的接口实现，需要一个包装层(wrapper)。调用的过程大概是这样：\n\n\n消费方的 proxy 和提供方的 wrapper 得以让 dubbo 构建出复杂、统一的体系。而这种动态代理与包装也是通过基于 spi 的插件方式实现的，它的接口就是**proxyfactory**。\n\n@spi("javassist")\npublic interface proxyfactory {\n\n    @adaptive({constants.proxy_key})\n    <t> t getproxy(invoker<t> invoker) throws rpcexception;\n\n    @adaptive({constants.proxy_key})\n    <t> invoker<t> getinvoker(t proxy, class<t> type, url url) throws rpcexception;\n\n}\n\n\nproxyfactory 有两种实现方式，一种是基于 jdk 的代理实现，一种是基于 javassist 的实现。proxyfactory 接口上定义了@spi("javassist")，默认为 javassist 的实现。\n\n\n# 3.5. dubbo 支持哪些序列化协议？hessian？hessian 的数据结构？\n\n 1. dubbo 序列化，阿里尚不成熟的 java 序列化实现。\n 2. hessian2 序列化：hessian 是一种跨语言的高效二进制的序列化方式，但这里实际不是原生的 hessian2 序列化，而是阿里修改过的 hessian lite，它是 dubbo rpc 默认启用的序列化方式。\n 3. json 序列化：目前有两种实现，一种是采用的阿里的 fastjson 库，另一种是采用 dubbo 中自已实现的简单 json 库，一般情况下，json 这种文本序列化性能不如二进制序列化。\n 4. java 序列化：主要是采用 jdk 自带的 java 序列化实现，性能很不理想。\n 5. kryo 和 fst：kryo 和 fst 的性能依然普遍优于 hessian 和 dubbo 序列化。\n\nhessian 序列化与 java 默认的序列化区别？\n\nhessian 是一个轻量级的 remoting on http 工具，采用的是 binary rpc 协议，所以它很适合于发送二进制数据，同时又具有防火墙穿透能力。\n\n 1. hessian 支持跨语言串行\n 2. 比 java 序列化具有更好的性能和易用性\n 3. 支持的语言比较多\n\n\n# 3.6. protoco buffer 是什么？\n\nprotocol buffer 是 google 出品的一种轻量 & 高效的结构化数据存储格式，性能比 json、xml 真的强！太！多！\n\nprotocol buffer 的序列化 & 反序列化简单 & 速度快的原因是：\n\n 1. 编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等）\n 2. 采用 protocol buffer 自身的框架代码 和 编译器 共同完成\n\nprotocol buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是：\n\n 1. 采用了独特的编码方式，如 varint、zigzag 编码方式等等\n 2. 采用 t - l - v 的数据存储方式：减少了分隔符的使用 & 数据存储得紧凑\n\n\n# 3.7. 注册中心挂了可以继续通信吗？\n\n可以。dubbo 消费者在应用启动时会从注册中心拉取已注册的生产者的地址接口，并缓存在本地。每次调用时，按照本地存储的地址进行调用。\n\n\n# 3.8. zookeeper 原理是什么？zookeeper 有什么用？\n\nzookeeper 是一个分布式应用协调系统，已经用到了许多分布式项目中，用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等工作。\n\n\n 1. 每个 server 在内存中存储了一份数据；\n 2. zookeeper 启动时，将从实例中选举一个 leader（paxos 协议）；\n 3. leader 负责处理数据更新等操作（zab 协议）；\n 4. 一个更新操作成功，当且仅当大多数 server 在内存中成功修改数据。\n\n\n# 3.9. netty 有什么用？nio/bio/aio 有什么用？有什么区别？\n\nnetty 是一个“网络通讯框架”。\n\nnetty 进行事件处理的流程。channel是连接的通道，是 channelevent 的产生者，而channelpipeline可以理解为 channelhandler 的集合。\n\n\n> 参考：https://github.com/code4craft/netty-learning/blob/master/posts/ch1-overview.md\n\nio 的方式通常分为几种：\n\n * 同步阻塞的 bio\n * 同步非阻塞的 nio\n * 异步非阻塞的 aio\n\n在使用同步 i/o 的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。\n\nnio 基于 reactor，当 socket 有流可读或可写入 socket 时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经不是一个连接就要对应一个处理线程了，而是有效的请求，对应一个线程，当连接没有数据时，是没有工作线程来处理的。\n\n与 nio 不同，当进行读写操作时，只须直接调用 api 的 read 或 write 方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入 read 方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将 write 方法传递的流写入完毕时，操作系统主动通知应用程序。 即可以理解为，read/write 方法都是异步的，完成后会主动调用回调函数。\n\n> 参考：https://blog.csdn.net/skiof007/article/details/52873421\n\n\n# 3.10. 为什么要进行系统拆分？拆分不用 dubbo 可以吗？\n\n系统拆分从资源角度分为：应用拆分和数据库拆分。\n\n从采用的先后顺序可分为：水平扩展、垂直拆分、业务拆分、水平拆分。\n\n\n是否使用服务依据实际业务场景来决定。\n\n当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(rpc)是关键。\n\n当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(soa)是关键。\n\n\n# 3.11. dubbo 和 thrift 有什么区别？\n\n * thrift 是跨语言的 rpc 框架。\n * dubbo 支持服务治理，而 thrift 不支持。\n\n\n# 4. 分布式锁基本原理\n\n> 分布式锁有几种实现方式？实现的要点是什么？\n> \n> 分布式锁各方案有什么利弊？如何选择方案？为什么？\n> \n> redis 分布式锁如何保证可重入性？\n> \n> 详细内容请参考：分布式锁\n\n【答题思路】\n\n实现方式一般有：\n\n * 基于数据库实现：\n   * 建一张表（t_dlock），关键字段有：id、method_name、time。\n   * 向表中插入记录成功，即为获取锁成功。需要注意的是，获取锁一般是通过自旋方式，并设置尝试次数，超过最大尝试次数，才判定获取锁失败。\n   * 删除记录，即为释放锁。\n   * 因为数据库没有淘汰机制，为了避免获取锁永不释放，应用需要自身实现定期检查，删除过期记录（根据 time 判断）。\n * 基于 redis 实现\n   * 生成一个分布式 id 作为 key，通过 setnx 写入\n   * 写入成功，即为获取锁成功。需要注意的是，获取锁一般是通过自旋方式，并设置尝试次数，超过最大尝试次数，才判定获取锁失败。\n   * 删除 key，即为获取锁失败。\n   * redis 自身有内存淘汰策略，所以只要设置 expire，就可以让 key 自动过期。\n * 基于 zookeeper 实现\n   * 创建一个节点，所有节点都 watch 此节点。\n   * 任意节点的任意线程只要向这个节点创建临时子节点成功，即为获取锁成功。\n   * 由于创建临时子节点是原子性的，不存在竞态，不需要自旋尝试，性能很好。\n   * 因为 zookeeper 只要和节点断开会话，就会自动删除临时节点。即为删除锁。所以无需过期机制。\n\n从实现方式可以看出，三种方案的对比：\n\n * mysql 方案性能最差，并且影响 mysql 吞吐量。而且还要程序保证容错处理。不建议采用这种方案。\n * redis 方案需要不断自旋尝试获取锁，应用会消耗一些性能开销。而且为了保证分布式锁的可重入性，需要设置对于所有节点、所有线程都唯一的分布式 id，生成 id 也需要一定的 cpu 开销。\n * zookeeper 方案实现最简单，最稳定。是推荐的方案。但是它也有一个问题：zookeeper 的主从架构，所有写都由 master 节点负责，所以 zookeeper 自身有一定的性能瓶颈。',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"分布式理论",frontmatter:{title:"分布式理论",categories:["分布式","分布式理论"],tags:["分布式","分布式理论"],abbrlink:41166861,date:"2021-11-08T08:15:33.000Z",permalink:"/pages/367308/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/01.%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA.html",relativePath:"02.分布式/02.分布式理论/01.分布式理论.md",key:"v-6ef572de",path:"/pages/367308/",headers:[{level:2,title:"1. 分布式特性和分类",slug:"_1-分布式特性和分类",normalizedTitle:"1. 分布式特性和分类",charIndex:14},{level:3,title:"1.1. 分布式特性",slug:"_1-1-分布式特性",normalizedTitle:"1.1. 分布式特性",charIndex:30},{level:3,title:"1.2. 分布式分类",slug:"_1-2-分布式分类",normalizedTitle:"1.2. 分布式分类",charIndex:300},{level:2,title:"2. CAP 定理",slug:"_2-cap-定理",normalizedTitle:"2. cap 定理",charIndex:571},{level:3,title:"2.1. 一致性",slug:"_2-1-一致性",normalizedTitle:"2.1. 一致性",charIndex:900},{level:3,title:"2.2. 可用性",slug:"_2-2-可用性",normalizedTitle:"2.2. 可用性",charIndex:1406},{level:3,title:"2.3. 分区容错性",slug:"_2-3-分区容错性",normalizedTitle:"2.3. 分区容错性",charIndex:1555},{level:3,title:"2.4. AP or CP",slug:"_2-4-ap-or-cp",normalizedTitle:"2.4. ap or cp",charIndex:2273},{level:2,title:"3. BASE 定理",slug:"_3-base-定理",normalizedTitle:"3. base 定理",charIndex:2776},{level:3,title:"3.1. 什么是 BASE 定理",slug:"_3-1-什么是-base-定理",normalizedTitle:"3.1. 什么是 base 定理",charIndex:2791},{level:3,title:"3.2. BASE vs. ACID",slug:"_3-2-base-vs-acid",normalizedTitle:"3.2. base vs. acid",charIndex:3261},{level:2,title:"4. 错误的分布式假设",slug:"_4-错误的分布式假设",normalizedTitle:"4. 错误的分布式假设",charIndex:3481},{level:2,title:"5. 拜占庭将军问题",slug:"_5-拜占庭将军问题",normalizedTitle:"5. 拜占庭将军问题",charIndex:3771},{level:3,title:"5.1. 问题描述",slug:"_5-1-问题描述",normalizedTitle:"5.1. 问题描述",charIndex:3982},{level:3,title:"5.2. 问题分析",slug:"_5-2-问题分析",normalizedTitle:"5.2. 问题分析",charIndex:4550},{level:2,title:"6. 参考资料",slug:"_6-参考资料",normalizedTitle:"6. 参考资料",charIndex:4890}],headersStr:"1. 分布式特性和分类 1.1. 分布式特性 1.2. 分布式分类 2. CAP 定理 2.1. 一致性 2.2. 可用性 2.3. 分区容错性 2.4. AP or CP 3. BASE 定理 3.1. 什么是 BASE 定理 3.2. BASE vs. ACID 4. 错误的分布式假设 5. 拜占庭将军问题 5.1. 问题描述 5.2. 问题分析 6. 参考资料",content:'# 分布式理论\n\n\n\n\n# 1. 分布式特性和分类\n\n\n# 1.1. 分布式特性\n\n * 性能：用于衡量一个系统处理各种任务的能力。\n   * 吞吐量：系统在一定时间内可以处理的任务数。\n     * QPS，即每秒查询数\n     * TPS，即每秒事务数\n   * 响应时间：系统响应一个请求或输入需要花费的时间。\n * 可用性：指的是系统在面对各种异常时可以正确提供服务的能力。系统的可用性可以用系统停止服务的时间与总的时间之比衡量。\n * 可扩展性：指的是分布式系统通过扩展集群机器规模提高系统性能 (吞吐、响应时间、 完成时间)、存储容量、计算能力的特性，是分布式系统的特有性质。\n\n\n# 1.2. 分布式分类\n\n * 分布式计算：解决应用的分布式计算问题。基于分布式计算模式，包括批处理计算、离线计算、在线计算、融合计算等，根据应用类型构建高效智能的分布式计算框架。\n * 分布式存储：解决数据的分布式和多元化问题。包括分布式数据库、分布式文件系统、分布式缓存等，支持不同类型的数据的存储和管理。\n * 分布式通信：解决进程间的分布式通信问题。通过消息队列、远程调用等方式，实现简单高效的通信。\n * 分布式资源管理：解决资源的分布式和异构性问题。将 CPU、内存、IO 等物理资源虚拟化，新城逻辑资源池，以便统一管理。\n\n\n# 2. CAP 定理\n\n> CAP 定理是加州大学计算机科学家埃里克·布鲁尔提出来的猜想，后来被证明成为分布式计算领域公认的定理。\n\nCAP 定理，指的是：在一个分布式系统中， 最多只能同时满足其中两项。\n\nCAP 就是取 Consistency、Availability、Partition Tolerance 的首字母而命名。\n\n\n\n * 一致性（Consistency）：在任何给定时间，网络中的所有节点都具有完全相同（最近）的值。\n * 可用性（Availability）：对网络的每个请求都会收到响应，但不能保证返回的数据是最新的。\n * 分区容错性（Partition Tolerance）：即使任意数量的节点出现故障，网络仍会继续运行。\n\n\n# 2.1. 一致性\n\n一致性（Consistency）指的是多个数据副本是否能保持一致的特性。\n\n在一致性的条件下，分布式系统在执行写操作成功后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。\n\n数据一致性又可以分为以下几点：\n\n * 强一致性 - 数据更新操作结果和操作响应总是一致的，即操作响应通知更新失败，那么数据一定没有被更新，而不是处于不确定状态。\n * 最终一致性 - 即物理存储的数据可能是不一致的，终端用户访问到的数据可能也是不一致的，但系统经过一段时间的自我修复和修正，数据最终会达到一致。\n\n举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。\n\n\n\n接下来，用户的读操作就会得到 v1。这就叫一致性。\n\n\n\n问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。\n\n\n\n为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。\n\n\n\n这样的话，用户向 G2 发起读操作，也能得到 v1。\n\n\n\n\n# 2.2. 可用性\n\n可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。\n\n在可用性条件下，系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。\n\n\n# 2.3. 分区容错性\n\n分区容错性（Partition Tolerance）指 分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。\n\n在一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中，这就叫分区。\n\n假设，某个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。\n\n提高分区容错性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容错性就提高了。\n\n然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。\n\n总的来说就是，数据存在的节点越多，分区容错性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。\n\n大多数分布式系统都分布在多个子网络，每个子网络就叫做一个区（Partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。\n\n\n\n上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。\n\n一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。\n\n\n# 2.4. AP or CP\n\n在分布式系统中，分区容错性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际在是要在可用性和一致性之间做权衡。\n\n由于分布式数据存储（如区块链）的性质，分区容错性是一个既定的事实；网络中总会有失败/无法访问的节点（尤其是因为互联网的不稳定特性）。 CAP 定理指出，当存在 P（分区）时，必须在 C（一致性）或 A（可用性）之间进行选择。\n\n（1）AP 模式\n\n> AP 模式：对网络的每个请求都会收到响应，即使网络由于网络分区故障而无法保证它是最新的。\n\n选择 AP 模式，实现了服务的高可用。用户访问系统的时候，都能得到响应数据，不会出现响应错误；但是，当出现分区故障时，相同的读操作，访问不同的节点，得到响应数据可能不一样。\n\n（2）CP 模式\n\n> CP 模式：如果由于网络分区（故障节点）而无法保证特定信息是最新的，则系统将返回错误或超时。\n\n选择 CP 模式，这样能够提供一部分的可用性。采用 CP 模型的分布式系统，一旦因为消息丢失、延迟过高发生了网络分区，就影响用户的体验和业务的可用性。因为为了防止数据不一致，集群将拒绝新数据的写入。\n\n\n# 3. BASE 定理\n\n\n# 3.1. 什么是 BASE 定理\n\n> BASE 定理是对 CAP 中一致性和可用性权衡的结果。\n\nBASE 是 基本可用（Basically Available）、软状态（Soft State） 和 最终一致性（Eventually Consistent） 三个短语的缩写。\n\nBASE 理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n * **基本可用（Basically Available）**分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。\n * 软状态（Soft State）指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在延时。\n * 最终一致性（Eventually Consistent）强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。\n\n\n\n\n# 3.2. BASE vs. ACID\n\nBASE 的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\nACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。\n\n在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。\n\n\n# 4. 错误的分布式假设\n\n> 内容摘自 Fallacies of Distributed Computing\n\n随着时间的推移，每一条都会被证明是错误的，也都会导致严重的问题，以及痛苦的学习体验：\n\n * 网络是稳定的\n * 网络传输的延迟是零\n * 网络的带宽是无穷大\n * 网络是安全的\n * 网络的拓扑不会改变\n * 只有一个系统管理员\n * 传输数据的成本为零\n * 整个网络是同构的\n\n为什么我们要深刻地认识这 8 个错误？\n\n是因为，这要我们清楚地认识到——在分布式系统中，错误是不可能避免的。既然错误无可避免，那么，我们应该做的是，将容错也作为功能去实现。\n\n\n# 5. 拜占庭将军问题\n\n> 拜占庭将军问题是由莱斯利·兰波特在其同名论文中提出的分布式对等网络通信容错问题。\n> \n> 在分布式计算中，不同的节点通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的节点可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。拜占庭将军问题被认为是容错性问题中最难的问题类型之一。\n\n\n# 5.1. 问题描述\n\n一群拜占庭将军各领一支军队共同围困一座城市。\n\n为了简化问题，军队的行动策略只有两种：进攻（Attack，后面简称 A）或 撤退（Retreat，后面简称 R）。如果这些军队不是统一进攻或撤退，就可能因兵力不足导致失败。因此，将军们通过投票来达成一致策略：同进或同退。\n\n因为将军们分别在城市的不同方位，所以他们只能通过信使互相联系。在投票过程中，每位将军都将自己的投票信息（A 或 R）通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以分析出共同的投票结果而决定行动策略。\n\n这个抽象模型的问题在于：将军中可能存在叛徒，他们不仅会发出误导性投票，还可能选择性地发送投票信息。\n\n由于将军之间需要通过信使通讯，叛变将军可能通过伪造信件来以其他将军的身份发送假投票。而即使在保证所有将军忠诚的情况下，也不能排除信使被敌人截杀，甚至被敌人间谍替换等情况。因此很难通过保证人员可靠性及通讯可靠性来解决问题。\n\n假使那些忠诚（或是没有出错）的将军仍然能通过多数决定来决定他们的战略，便称达到了拜占庭容错。在此，票都会有一个默认值，若消息（票）没有被收到，则使用此默认值来投票。\n\n上述的故事可以映射到分布式系统中，将军代表分布式系统中的节点；信使代表通信系统；叛徒代表故障或异常。\n\n\n\n\n# 5.2. 问题分析\n\n> 兰伯特针对拜占庭将军问题，给出了两个解决方案：口头协议和书面协议。\n> \n> 本文介绍一下口头协议。\n\n在口头协议中，拜占庭将军问题被简化为将军 - 副官模型，其核心规则如下：\n\n * 忠诚的副官遵守同一命令。\n * 若将军是忠诚的，所有忠诚的副官都执行他的命令。\n * 如果叛徒人数为 m，将军人数不能少于 3m + 1 ，那么拜占庭将军问题就能解决了。\n\n示例一、叛徒人数为 1，将军人数为 3\n\n\n\n这个示例中，将军人数不满足 3m + 1，无法保证忠诚的副官都执行将军的命令。\n\n示例二、叛徒人数为 1，将军人数为 4\n\n\n\n这个示例中，将军人数满足 3m + 1，无论是副官中有叛徒，还是将军是叛徒，都能保证忠诚的副官执行将军的命令。\n\n\n# 6. 参考资料\n\n * Wiki - 拜占庭将军问题\n * 拜占庭将军问题视频讲解 - 李永乐老师讲解的通俗易懂\n * Fallacies of Distributed Computing - 分布式系统新手常犯的 8 个错误，并探讨了其会带来的影响。\n * Distributed Systems for Fun and Profit - 一本学习小册，涵盖了分布式系统中的关键问题，包括时间的作用和不同的复制策略。\n * A Note on Distributed Systems - 这是一篇经典的论文，讲述了为什么在分布式系统中，远程交互不能像本地对象那样进行。\n * Amazon’s Highly Available Key-value Store\n * CAP Theorem\n * CAP twelve years later: How the "rules" have changed\n * CAP 定理的含义 - by 阮一峰\n * 神一样的 CAP 理论被应用在何方\n * BASE: An Acid Alternative',normalizedContent:'# 分布式理论\n\n\n\n\n# 1. 分布式特性和分类\n\n\n# 1.1. 分布式特性\n\n * 性能：用于衡量一个系统处理各种任务的能力。\n   * 吞吐量：系统在一定时间内可以处理的任务数。\n     * qps，即每秒查询数\n     * tps，即每秒事务数\n   * 响应时间：系统响应一个请求或输入需要花费的时间。\n * 可用性：指的是系统在面对各种异常时可以正确提供服务的能力。系统的可用性可以用系统停止服务的时间与总的时间之比衡量。\n * 可扩展性：指的是分布式系统通过扩展集群机器规模提高系统性能 (吞吐、响应时间、 完成时间)、存储容量、计算能力的特性，是分布式系统的特有性质。\n\n\n# 1.2. 分布式分类\n\n * 分布式计算：解决应用的分布式计算问题。基于分布式计算模式，包括批处理计算、离线计算、在线计算、融合计算等，根据应用类型构建高效智能的分布式计算框架。\n * 分布式存储：解决数据的分布式和多元化问题。包括分布式数据库、分布式文件系统、分布式缓存等，支持不同类型的数据的存储和管理。\n * 分布式通信：解决进程间的分布式通信问题。通过消息队列、远程调用等方式，实现简单高效的通信。\n * 分布式资源管理：解决资源的分布式和异构性问题。将 cpu、内存、io 等物理资源虚拟化，新城逻辑资源池，以便统一管理。\n\n\n# 2. cap 定理\n\n> cap 定理是加州大学计算机科学家埃里克·布鲁尔提出来的猜想，后来被证明成为分布式计算领域公认的定理。\n\ncap 定理，指的是：在一个分布式系统中， 最多只能同时满足其中两项。\n\ncap 就是取 consistency、availability、partition tolerance 的首字母而命名。\n\n\n\n * 一致性（consistency）：在任何给定时间，网络中的所有节点都具有完全相同（最近）的值。\n * 可用性（availability）：对网络的每个请求都会收到响应，但不能保证返回的数据是最新的。\n * 分区容错性（partition tolerance）：即使任意数量的节点出现故障，网络仍会继续运行。\n\n\n# 2.1. 一致性\n\n一致性（consistency）指的是多个数据副本是否能保持一致的特性。\n\n在一致性的条件下，分布式系统在执行写操作成功后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。\n\n数据一致性又可以分为以下几点：\n\n * 强一致性 - 数据更新操作结果和操作响应总是一致的，即操作响应通知更新失败，那么数据一定没有被更新，而不是处于不确定状态。\n * 最终一致性 - 即物理存储的数据可能是不一致的，终端用户访问到的数据可能也是不一致的，但系统经过一段时间的自我修复和修正，数据最终会达到一致。\n\n举例来说，某条记录是 v0，用户向 g1 发起一个写操作，将其改为 v1。\n\n\n\n接下来，用户的读操作就会得到 v1。这就叫一致性。\n\n\n\n问题是，用户有可能向 g2 发起读操作，由于 g2 的值没有发生变化，因此返回的是 v0。g1 和 g2 读操作的结果不一致，这就不满足一致性了。\n\n\n\n为了让 g2 也能变为 v1，就要在 g1 写操作的时候，让 g1 向 g2 发送一条消息，要求 g2 也改成 v1。\n\n\n\n这样的话，用户向 g2 发起读操作，也能得到 v1。\n\n\n\n\n# 2.2. 可用性\n\n可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。\n\n在可用性条件下，系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。\n\n\n# 2.3. 分区容错性\n\n分区容错性（partition tolerance）指 分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。\n\n在一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中，这就叫分区。\n\n假设，某个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。\n\n提高分区容错性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容错性就提高了。\n\n然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。\n\n总的来说就是，数据存在的节点越多，分区容错性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。\n\n大多数分布式系统都分布在多个子网络，每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。\n\n\n\n上图中，g1 和 g2 是两台跨区的服务器。g1 向 g2 发送一条消息，g2 可能无法收到。系统设计的时候，必须考虑到这种情况。\n\n一般来说，分区容错无法避免，因此可以认为 cap 的 p 总是成立。cap 定理告诉我们，剩下的 c 和 a 无法同时做到。\n\n\n# 2.4. ap or cp\n\n在分布式系统中，分区容错性必不可少，因为需要总是假设网络是不可靠的。因此，cap 理论实际在是要在可用性和一致性之间做权衡。\n\n由于分布式数据存储（如区块链）的性质，分区容错性是一个既定的事实；网络中总会有失败/无法访问的节点（尤其是因为互联网的不稳定特性）。 cap 定理指出，当存在 p（分区）时，必须在 c（一致性）或 a（可用性）之间进行选择。\n\n（1）ap 模式\n\n> ap 模式：对网络的每个请求都会收到响应，即使网络由于网络分区故障而无法保证它是最新的。\n\n选择 ap 模式，实现了服务的高可用。用户访问系统的时候，都能得到响应数据，不会出现响应错误；但是，当出现分区故障时，相同的读操作，访问不同的节点，得到响应数据可能不一样。\n\n（2）cp 模式\n\n> cp 模式：如果由于网络分区（故障节点）而无法保证特定信息是最新的，则系统将返回错误或超时。\n\n选择 cp 模式，这样能够提供一部分的可用性。采用 cp 模型的分布式系统，一旦因为消息丢失、延迟过高发生了网络分区，就影响用户的体验和业务的可用性。因为为了防止数据不一致，集群将拒绝新数据的写入。\n\n\n# 3. base 定理\n\n\n# 3.1. 什么是 base 定理\n\n> base 定理是对 cap 中一致性和可用性权衡的结果。\n\nbase 是 基本可用（basically available）、软状态（soft state） 和 最终一致性（eventually consistent） 三个短语的缩写。\n\nbase 理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n * **基本可用（basically available）**分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。\n * 软状态（soft state）指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在延时。\n * 最终一致性（eventually consistent）强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。\n\n\n\n\n# 3.2. base vs. acid\n\nbase 的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\nacid 要求强一致性，通常运用在传统的数据库系统上。而 base 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。\n\n在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 acid 和 base 往往会结合在一起使用。\n\n\n# 4. 错误的分布式假设\n\n> 内容摘自 fallacies of distributed computing\n\n随着时间的推移，每一条都会被证明是错误的，也都会导致严重的问题，以及痛苦的学习体验：\n\n * 网络是稳定的\n * 网络传输的延迟是零\n * 网络的带宽是无穷大\n * 网络是安全的\n * 网络的拓扑不会改变\n * 只有一个系统管理员\n * 传输数据的成本为零\n * 整个网络是同构的\n\n为什么我们要深刻地认识这 8 个错误？\n\n是因为，这要我们清楚地认识到——在分布式系统中，错误是不可能避免的。既然错误无可避免，那么，我们应该做的是，将容错也作为功能去实现。\n\n\n# 5. 拜占庭将军问题\n\n> 拜占庭将军问题是由莱斯利·兰波特在其同名论文中提出的分布式对等网络通信容错问题。\n> \n> 在分布式计算中，不同的节点通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的节点可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。拜占庭将军问题被认为是容错性问题中最难的问题类型之一。\n\n\n# 5.1. 问题描述\n\n一群拜占庭将军各领一支军队共同围困一座城市。\n\n为了简化问题，军队的行动策略只有两种：进攻（attack，后面简称 a）或 撤退（retreat，后面简称 r）。如果这些军队不是统一进攻或撤退，就可能因兵力不足导致失败。因此，将军们通过投票来达成一致策略：同进或同退。\n\n因为将军们分别在城市的不同方位，所以他们只能通过信使互相联系。在投票过程中，每位将军都将自己的投票信息（a 或 r）通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以分析出共同的投票结果而决定行动策略。\n\n这个抽象模型的问题在于：将军中可能存在叛徒，他们不仅会发出误导性投票，还可能选择性地发送投票信息。\n\n由于将军之间需要通过信使通讯，叛变将军可能通过伪造信件来以其他将军的身份发送假投票。而即使在保证所有将军忠诚的情况下，也不能排除信使被敌人截杀，甚至被敌人间谍替换等情况。因此很难通过保证人员可靠性及通讯可靠性来解决问题。\n\n假使那些忠诚（或是没有出错）的将军仍然能通过多数决定来决定他们的战略，便称达到了拜占庭容错。在此，票都会有一个默认值，若消息（票）没有被收到，则使用此默认值来投票。\n\n上述的故事可以映射到分布式系统中，将军代表分布式系统中的节点；信使代表通信系统；叛徒代表故障或异常。\n\n\n\n\n# 5.2. 问题分析\n\n> 兰伯特针对拜占庭将军问题，给出了两个解决方案：口头协议和书面协议。\n> \n> 本文介绍一下口头协议。\n\n在口头协议中，拜占庭将军问题被简化为将军 - 副官模型，其核心规则如下：\n\n * 忠诚的副官遵守同一命令。\n * 若将军是忠诚的，所有忠诚的副官都执行他的命令。\n * 如果叛徒人数为 m，将军人数不能少于 3m + 1 ，那么拜占庭将军问题就能解决了。\n\n示例一、叛徒人数为 1，将军人数为 3\n\n\n\n这个示例中，将军人数不满足 3m + 1，无法保证忠诚的副官都执行将军的命令。\n\n示例二、叛徒人数为 1，将军人数为 4\n\n\n\n这个示例中，将军人数满足 3m + 1，无论是副官中有叛徒，还是将军是叛徒，都能保证忠诚的副官执行将军的命令。\n\n\n# 6. 参考资料\n\n * wiki - 拜占庭将军问题\n * 拜占庭将军问题视频讲解 - 李永乐老师讲解的通俗易懂\n * fallacies of distributed computing - 分布式系统新手常犯的 8 个错误，并探讨了其会带来的影响。\n * distributed systems for fun and profit - 一本学习小册，涵盖了分布式系统中的关键问题，包括时间的作用和不同的复制策略。\n * a note on distributed systems - 这是一篇经典的论文，讲述了为什么在分布式系统中，远程交互不能像本地对象那样进行。\n * amazon’s highly available key-value store\n * cap theorem\n * cap twelve years later: how the "rules" have changed\n * cap 定理的含义 - by 阮一峰\n * 神一样的 cap 理论被应用在何方\n * base: an acid alternative',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"深入剖析共识性算法 Paxos",frontmatter:{title:"深入剖析共识性算法 Paxos",categories:["分布式","分布式理论"],tags:["分布式","分布式理论","共识性","Paxos"],abbrlink:"9a1bd25e",date:"2020-02-02T22:00:00.000Z",permalink:"/pages/874539/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95Paxos.html",relativePath:"02.分布式/02.分布式理论/02.分布式算法Paxos.md",key:"v-47519682",path:"/pages/874539/",headers:[{level:2,title:"1. Paxos 背景",slug:"_1-paxos-背景",normalizedTitle:"1. paxos 背景",charIndex:152},{level:2,title:"2. Basic Paxos 算法",slug:"_2-basic-paxos-算法",normalizedTitle:"2. basic paxos 算法",charIndex:668},{level:3,title:"2.1. 角色",slug:"_2-1-角色",normalizedTitle:"2.1. 角色",charIndex:690},{level:3,title:"2.2. 算法",slug:"_2-2-算法",normalizedTitle:"2.2. 算法",charIndex:1010},{level:3,title:"2.3. 实例",slug:"_2-3-实例",normalizedTitle:"2.3. 实例",charIndex:2137},{level:4,title:"!img",slug:"img-https-pic2-zhimg-com-80-v2-3ae48cb81d39079022666ccb35821c71-hd-jpg",normalizedTitle:"!img",charIndex:null},{level:2,title:"3. Multi Paxos 思想",slug:"_3-multi-paxos-思想",normalizedTitle:"3. multi paxos 思想",charIndex:2826},{level:3,title:"3.1. Basic Paxos 的问题",slug:"_3-1-basic-paxos-的问题",normalizedTitle:"3.1. basic paxos 的问题",charIndex:2848},{level:3,title:"3.2. Multi Paxos 的改进",slug:"_3-2-multi-paxos-的改进",normalizedTitle:"3.2. multi paxos 的改进",charIndex:3053},{level:2,title:"4. 总结",slug:"_4-总结",normalizedTitle:"4. 总结",charIndex:3930},{level:2,title:"5. 参考资料",slug:"_5-参考资料",normalizedTitle:"5. 参考资料",charIndex:4193}],headersStr:"1. Paxos 背景 2. Basic Paxos 算法 2.1. 角色 2.2. 算法 2.3. 实例 !img 3. Multi Paxos 思想 3.1. Basic Paxos 的问题 3.2. Multi Paxos 的改进 4. 总结 5. 参考资料",content:"# 深入剖析共识性算法 Paxos\n\n> Paxos 是一种基于消息传递且具有容错性的共识性（consensus）算法。\n> \n> Paxos 算法解决的问题正是分布式一致性问题。在一个节点数为 2N+1 的分布式集群中，只要半数以上的节点（N + 1）还正常工作，整个系统仍可以正常工作。\n\n\n\n\n# 1. Paxos 背景\n\nPaxos 是 Leslie Lamport 于 1990 年提出的一种基于消息传递且具有高度容错特性的共识（consensus）算法。\n\n为描述 Paxos 算法，Lamport 虚拟了一个叫做 Paxos 的希腊城邦，这个岛按照议会民主制的政治模式制订法律，但是没有人愿意将自己的全部时间和精力放在这种事情上。所以无论是议员，议长或者传递纸条的服务员都不能承诺别人需要时一定会出现，也无法承诺批准决议或者传递消息的时间。\n\nPaxos 算法包含 2 个部分：\n\n * Basic Paxos 算法：描述的多节点之间如何就某个值达成共识。\n * Multi Paxos 思想：描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。\n\nPaxos 算法解决的问题正是分布式一致性问题，即一个分布式系统中的各个进程如何就某个值（决议）达成一致。\n\nPaxos 算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (Majority) 机制保证了 2N+1 的容错能力，即 2N+1 个节点的系统最多允许 N 个节点同时出现故障。\n\n\n# 2. Basic Paxos 算法\n\n\n# 2.1. 角色\n\nPaxos 将分布式系统中的节点分为以下角色：\n\n * 提议者（Proposer）：发出提案（Proposal）。Proposal 信息包括提案编号 (Proposal ID) 和提议的值 (Value)。\n * 决策者（Acceptor）：对每个 Proposal 进行投票，若 Proposal 获得多数 Acceptor 的接受，则称该 Proposal 被批准。\n * 学习者（Learner）：不参与决策，从 Proposers/Acceptors 学习、记录最新达成共识的提案（Value）。\n\n在多副本状态机中，每个副本都同时具有 Proposer、Acceptor、Learner 三种角色。\n\n\n\n\n# 2.2. 算法\n\nPaxos 算法通过一个决议分为两个阶段（Learn 阶段之前决议已经形成）：\n\n 1. 第一阶段：Prepare 阶段。Proposer 向 Acceptors 发出 Prepare 请求，Acceptors 针对收到的 Prepare 请求进行 Promise 承诺。\n 2. 第二阶段：Accept 阶段。Proposer 收到多数 Acceptors 承诺的 Promise 后，向 Acceptors 发出 Propose 请求，Acceptors 针对收到的 Propose 请求进行 Accept 处理。\n 3. 第三阶段：Learn 阶段。Proposer 在收到多数 Acceptors 的 Accept 之后，标志着本次 Accept 成功，决议形成，将形成的决议发送给所有 Learners。\n\nPaxos 算法流程中的每条消息描述如下：\n\n * Prepare: Proposer 生成全局唯一且递增的 Proposal ID (可使用时间戳加 Server ID)，向所有 Acceptors 发送 Prepare 请求，这里无需携带提案内容，只携带 Proposal ID 即可。\n\n * Promise: Acceptors 收到 Prepare 请求后，做出“两个承诺，一个应答”。\n   \n   * 两个承诺：\n     \n     * 不再接受 Proposal ID 小于等于当前请求的 Prepare 请求。\n     * 不再接受 Proposal ID 小于当前请求的 Propose 请求。\n   \n   * 一个应答：\n     \n     * 不违背以前作出的承诺下，回复已经 Accept 过的提案中 Proposal ID 最大的那个提案的 Value 和 Proposal ID，没有则返回空值。\n\n * Propose: Proposer 收到多数 Acceptors 的 Promise 应答后，从应答中选择 Proposal ID 最大的提案的 Value，作为本次要发起的提案。如果所有应答的提案 Value 均为空值，则可以自己随意决定提案 Value。然后携带当前 Proposal ID，向所有 Acceptors 发送 Propose 请求。\n\n * Accept: Acceptor 收到 Propose 请求后，在不违背自己之前作出的承诺下，接受并持久化当前 Proposal ID 和提案 Value。\n\n * Learn: Proposer 收到多数 Acceptors 的 Accept 后，决议形成，将形成的决议发送给所有 Learners。\n\n\n# 2.3. 实例\n\n下面举几个例子，实例 1 如下图：\n\n\n\n图中 P 代表 Prepare 阶段，A 代表 Accept 阶段。3.1 代表 Proposal ID 为 3.1，其中 3 为时间戳，1 为 Server ID。X 和 Y 代表提议 Value。\n\n实例 1 中 P 3.1 达成多数派，其 Value(X) 被 Accept，然后 P 4.5 学习到 Value(X)，并 Accept。\n\n#\n\n实例 2 中 P 3.1 没有被多数派 Accept（只有 S3 Accept），但是被 P 4.5 学习到，P 4.5 将自己的 Value 由 Y 替换为 X，Accept（X）。\n\nPaxos 算法实例 3\n\n实例 3 中 P 3.1 没有被多数派 Accept（只有 S1 Accept），同时也没有被 P 4.5 学习到。由于 P 4.5 Propose 的所有应答，均未返回 Value，则 P 4.5 可以 Accept 自己的 Value (Y)。后续 P 3.1 的 Accept (X) 会失败，已经 Accept 的 S1，会被覆盖。\n\nPaxos 算法可能形成活锁而永远不会结束，如下图实例所示：\n\nPaxos 算法形成活锁\n\n回顾两个承诺之一，Acceptor 不再应答 Proposal ID 小于等于当前请求的 Prepare 请求。意味着需要应答 Proposal ID 大于当前请求的 Prepare 请求。\n\n两个 Proposers 交替 Prepare 成功，而 Accept 失败，形成活锁（Livelock）。\n\n\n# 3. Multi Paxos 思想\n\n\n# 3.1. Basic Paxos 的问题\n\nBasic Paxos 有以下问题，导致它不能应用于实际：\n\n * Basic Paxos 算法只能对一个值形成决议。\n * Basic Paxos 算法会消耗大量网络带宽。Basic Paxos 中，决议的形成至少需要两次网络通信，在高并发情况下可能需要更多的网络通信，极端情况下甚至可能形成活锁。如果想连续确定多个值，Basic Paxos 搞不定了。\n\n\n# 3.2. Multi Paxos 的改进\n\nMulti Paxos 正是为解决以上问题而提出。Multi Paxos 基于 Basic Paxos 做了两点改进：\n\n * 针对每一个要确定的值，运行一次 Paxos 算法实例（Instance），形成决议。每一个 Paxos 实例使用唯一的 Instance ID 标识。\n * 在所有 Proposer 中选举一个 Leader，由 Leader 唯一地提交 Proposal 给 Acceptor 进行表决。这样没有 Proposer 竞争，解决了活锁问题。在系统中仅有一个 Leader 进行 Value 提交的情况下，Prepare 阶段就可以跳过，从而将两阶段变为一阶段，提高效率。\n\nMulti Paxos 首先需要选举 Leader，Leader 的确定也是一次决议的形成，所以可执行一次 Basic Paxos 实例来选举出一个 Leader。选出 Leader 之后只能由 Leader 提交 Proposal，在 Leader 宕机之后服务临时不可用，需要重新选举 Leader 继续服务。在系统中仅有一个 Leader 进行 Proposal 提交的情况下，Prepare 阶段可以跳过。\n\nMulti Paxos 通过改变 Prepare 阶段的作用范围至后面 Leader 提交的所有实例，从而使得 Leader 的连续提交只需要执行一次 Prepare 阶段，后续只需要执行 Accept 阶段，将两阶段变为一阶段，提高了效率。为了区分连续提交的多个实例，每个实例使用一个 Instance ID 标识，Instance ID 由 Leader 本地递增生成即可。\n\nMulti Paxos 允许有多个自认为是 Leader 的节点并发提交 Proposal 而不影响其安全性，这样的场景即退化为 Basic Paxos。\n\nChubby 和 Boxwood 均使用 Multi Paxos。ZooKeeper 使用的 Zab 也是 Multi Paxos 的变形。\n\n\n# 4. 总结\n\n你可以看到，Basic Paxos 是通过二阶段提交的方式来达成共识的。二阶段提交是达成共识的常用方式，如果你需要设计新的共识算法的时候，也可以考虑这个方式。\n\n除了共识，Basic Paxos 还实现了容错，在少于一半的节点出现故障时，集群也能工作。它不像分布式事务算法那样，必须要所有节点都同意后才提交操作，因为“所有节点都同意”这个原则，在出现节点故障的时候会导致整个集群不可用。也就是说，“大多数节点都同意”的原则，赋予了 Basic Paxos 容错的能力，让它能够容忍少于一半的节点的故障。\n\n\n# 5. 参考资料\n\n * Part-time Parliament 论文\n * Paxos Made Simple 论文\n * Paxos 算法详解\n * Wiki - Paxos 算法\n * 一致性算法（Paxos、Raft、Zab）\n * Raft 作者讲解 Paxos 视频\n * Paxos 算法讲解视频",normalizedContent:"# 深入剖析共识性算法 paxos\n\n> paxos 是一种基于消息传递且具有容错性的共识性（consensus）算法。\n> \n> paxos 算法解决的问题正是分布式一致性问题。在一个节点数为 2n+1 的分布式集群中，只要半数以上的节点（n + 1）还正常工作，整个系统仍可以正常工作。\n\n\n\n\n# 1. paxos 背景\n\npaxos 是 leslie lamport 于 1990 年提出的一种基于消息传递且具有高度容错特性的共识（consensus）算法。\n\n为描述 paxos 算法，lamport 虚拟了一个叫做 paxos 的希腊城邦，这个岛按照议会民主制的政治模式制订法律，但是没有人愿意将自己的全部时间和精力放在这种事情上。所以无论是议员，议长或者传递纸条的服务员都不能承诺别人需要时一定会出现，也无法承诺批准决议或者传递消息的时间。\n\npaxos 算法包含 2 个部分：\n\n * basic paxos 算法：描述的多节点之间如何就某个值达成共识。\n * multi paxos 思想：描述的是执行多个 basic paxos 实例，就一系列值达成共识。\n\npaxos 算法解决的问题正是分布式一致性问题，即一个分布式系统中的各个进程如何就某个值（决议）达成一致。\n\npaxos 算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 (majority) 机制保证了 2n+1 的容错能力，即 2n+1 个节点的系统最多允许 n 个节点同时出现故障。\n\n\n# 2. basic paxos 算法\n\n\n# 2.1. 角色\n\npaxos 将分布式系统中的节点分为以下角色：\n\n * 提议者（proposer）：发出提案（proposal）。proposal 信息包括提案编号 (proposal id) 和提议的值 (value)。\n * 决策者（acceptor）：对每个 proposal 进行投票，若 proposal 获得多数 acceptor 的接受，则称该 proposal 被批准。\n * 学习者（learner）：不参与决策，从 proposers/acceptors 学习、记录最新达成共识的提案（value）。\n\n在多副本状态机中，每个副本都同时具有 proposer、acceptor、learner 三种角色。\n\n\n\n\n# 2.2. 算法\n\npaxos 算法通过一个决议分为两个阶段（learn 阶段之前决议已经形成）：\n\n 1. 第一阶段：prepare 阶段。proposer 向 acceptors 发出 prepare 请求，acceptors 针对收到的 prepare 请求进行 promise 承诺。\n 2. 第二阶段：accept 阶段。proposer 收到多数 acceptors 承诺的 promise 后，向 acceptors 发出 propose 请求，acceptors 针对收到的 propose 请求进行 accept 处理。\n 3. 第三阶段：learn 阶段。proposer 在收到多数 acceptors 的 accept 之后，标志着本次 accept 成功，决议形成，将形成的决议发送给所有 learners。\n\npaxos 算法流程中的每条消息描述如下：\n\n * prepare: proposer 生成全局唯一且递增的 proposal id (可使用时间戳加 server id)，向所有 acceptors 发送 prepare 请求，这里无需携带提案内容，只携带 proposal id 即可。\n\n * promise: acceptors 收到 prepare 请求后，做出“两个承诺，一个应答”。\n   \n   * 两个承诺：\n     \n     * 不再接受 proposal id 小于等于当前请求的 prepare 请求。\n     * 不再接受 proposal id 小于当前请求的 propose 请求。\n   \n   * 一个应答：\n     \n     * 不违背以前作出的承诺下，回复已经 accept 过的提案中 proposal id 最大的那个提案的 value 和 proposal id，没有则返回空值。\n\n * propose: proposer 收到多数 acceptors 的 promise 应答后，从应答中选择 proposal id 最大的提案的 value，作为本次要发起的提案。如果所有应答的提案 value 均为空值，则可以自己随意决定提案 value。然后携带当前 proposal id，向所有 acceptors 发送 propose 请求。\n\n * accept: acceptor 收到 propose 请求后，在不违背自己之前作出的承诺下，接受并持久化当前 proposal id 和提案 value。\n\n * learn: proposer 收到多数 acceptors 的 accept 后，决议形成，将形成的决议发送给所有 learners。\n\n\n# 2.3. 实例\n\n下面举几个例子，实例 1 如下图：\n\n\n\n图中 p 代表 prepare 阶段，a 代表 accept 阶段。3.1 代表 proposal id 为 3.1，其中 3 为时间戳，1 为 server id。x 和 y 代表提议 value。\n\n实例 1 中 p 3.1 达成多数派，其 value(x) 被 accept，然后 p 4.5 学习到 value(x)，并 accept。\n\n#\n\n实例 2 中 p 3.1 没有被多数派 accept（只有 s3 accept），但是被 p 4.5 学习到，p 4.5 将自己的 value 由 y 替换为 x，accept（x）。\n\npaxos 算法实例 3\n\n实例 3 中 p 3.1 没有被多数派 accept（只有 s1 accept），同时也没有被 p 4.5 学习到。由于 p 4.5 propose 的所有应答，均未返回 value，则 p 4.5 可以 accept 自己的 value (y)。后续 p 3.1 的 accept (x) 会失败，已经 accept 的 s1，会被覆盖。\n\npaxos 算法可能形成活锁而永远不会结束，如下图实例所示：\n\npaxos 算法形成活锁\n\n回顾两个承诺之一，acceptor 不再应答 proposal id 小于等于当前请求的 prepare 请求。意味着需要应答 proposal id 大于当前请求的 prepare 请求。\n\n两个 proposers 交替 prepare 成功，而 accept 失败，形成活锁（livelock）。\n\n\n# 3. multi paxos 思想\n\n\n# 3.1. basic paxos 的问题\n\nbasic paxos 有以下问题，导致它不能应用于实际：\n\n * basic paxos 算法只能对一个值形成决议。\n * basic paxos 算法会消耗大量网络带宽。basic paxos 中，决议的形成至少需要两次网络通信，在高并发情况下可能需要更多的网络通信，极端情况下甚至可能形成活锁。如果想连续确定多个值，basic paxos 搞不定了。\n\n\n# 3.2. multi paxos 的改进\n\nmulti paxos 正是为解决以上问题而提出。multi paxos 基于 basic paxos 做了两点改进：\n\n * 针对每一个要确定的值，运行一次 paxos 算法实例（instance），形成决议。每一个 paxos 实例使用唯一的 instance id 标识。\n * 在所有 proposer 中选举一个 leader，由 leader 唯一地提交 proposal 给 acceptor 进行表决。这样没有 proposer 竞争，解决了活锁问题。在系统中仅有一个 leader 进行 value 提交的情况下，prepare 阶段就可以跳过，从而将两阶段变为一阶段，提高效率。\n\nmulti paxos 首先需要选举 leader，leader 的确定也是一次决议的形成，所以可执行一次 basic paxos 实例来选举出一个 leader。选出 leader 之后只能由 leader 提交 proposal，在 leader 宕机之后服务临时不可用，需要重新选举 leader 继续服务。在系统中仅有一个 leader 进行 proposal 提交的情况下，prepare 阶段可以跳过。\n\nmulti paxos 通过改变 prepare 阶段的作用范围至后面 leader 提交的所有实例，从而使得 leader 的连续提交只需要执行一次 prepare 阶段，后续只需要执行 accept 阶段，将两阶段变为一阶段，提高了效率。为了区分连续提交的多个实例，每个实例使用一个 instance id 标识，instance id 由 leader 本地递增生成即可。\n\nmulti paxos 允许有多个自认为是 leader 的节点并发提交 proposal 而不影响其安全性，这样的场景即退化为 basic paxos。\n\nchubby 和 boxwood 均使用 multi paxos。zookeeper 使用的 zab 也是 multi paxos 的变形。\n\n\n# 4. 总结\n\n你可以看到，basic paxos 是通过二阶段提交的方式来达成共识的。二阶段提交是达成共识的常用方式，如果你需要设计新的共识算法的时候，也可以考虑这个方式。\n\n除了共识，basic paxos 还实现了容错，在少于一半的节点出现故障时，集群也能工作。它不像分布式事务算法那样，必须要所有节点都同意后才提交操作，因为“所有节点都同意”这个原则，在出现节点故障的时候会导致整个集群不可用。也就是说，“大多数节点都同意”的原则，赋予了 basic paxos 容错的能力，让它能够容忍少于一半的节点的故障。\n\n\n# 5. 参考资料\n\n * part-time parliament 论文\n * paxos made simple 论文\n * paxos 算法详解\n * wiki - paxos 算法\n * 一致性算法（paxos、raft、zab）\n * raft 作者讲解 paxos 视频\n * paxos 算法讲解视频",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"深入剖析共识性算法 Raft",frontmatter:{title:"深入剖析共识性算法 Raft",categories:["分布式","分布式理论"],tags:["分布式","分布式理论","共识性","Raft"],abbrlink:"5f26a66c",date:"2020-02-01T22:07:00.000Z",permalink:"/pages/e40812/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/03.%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95Raft.html",relativePath:"02.分布式/02.分布式理论/03.分布式算法Raft.md",key:"v-67c5593b",path:"/pages/e40812/",headers:[{level:2,title:"1. Raft 简介",slug:"_1-raft-简介",normalizedTitle:"1. raft 简介",charIndex:23},{level:3,title:"1.1. 分布式一致性",slug:"_1-1-分布式一致性",normalizedTitle:"1.1. 分布式一致性",charIndex:392},{level:3,title:"1.2. 复制状态机",slug:"_1-2-复制状态机",normalizedTitle:"1.2. 复制状态机",charIndex:728},{level:3,title:"1.3. RAFT 应用",slug:"_1-3-raft-应用",normalizedTitle:"1.3. raft 应用",charIndex:1523},{level:2,title:"2. Raft 基础",slug:"_2-raft-基础",normalizedTitle:"2. raft 基础",charIndex:1768},{level:3,title:"2.1. 服务器角色",slug:"_2-1-服务器角色",normalizedTitle:"2.1. 服务器角色",charIndex:1876},{level:3,title:"2.2. 任期",slug:"_2-2-任期",normalizedTitle:"2.2. 任期",charIndex:2346},{level:3,title:"2.3. RPC",slug:"_2-3-rpc",normalizedTitle:"2.3. rpc",charIndex:2832},{level:2,title:"3. 选举 Leader",slug:"_3-选举-leader",normalizedTitle:"3. 选举 leader",charIndex:3013},{level:3,title:"3.1. 选举规则",slug:"_3-1-选举规则",normalizedTitle:"3.1. 选举规则",charIndex:3030},{level:4,title:"自己成为 Leader",slug:"自己成为-leader",normalizedTitle:"自己成为 leader",charIndex:3375},{level:4,title:"其他的服务器成为 Leader",slug:"其他的服务器成为-leader",normalizedTitle:"其他的服务器成为 leader",charIndex:3390},{level:4,title:"没有任何服务器成为 Leader",slug:"没有任何服务器成为-leader",normalizedTitle:"没有任何服务器成为 leader",charIndex:3409},{level:3,title:"3.2. 单 Candidate 选举",slug:"_3-2-单-candidate-选举",normalizedTitle:"3.2. 单 candidate 选举",charIndex:4447},{level:3,title:"3.3. 多 Candidate 选举",slug:"_3-3-多-candidate-选举",normalizedTitle:"3.3. 多 candidate 选举",charIndex:4770},{level:2,title:"4. 日志复制",slug:"_4-日志复制",normalizedTitle:"4. 日志复制",charIndex:4990},{level:3,title:"4.1. 日志格式",slug:"_4-1-日志格式",normalizedTitle:"4.1. 日志格式",charIndex:5002},{level:3,title:"4.2. 日志复制流程",slug:"_4-2-日志复制流程",normalizedTitle:"4.2. 日志复制流程",charIndex:5577},{level:3,title:"4.3. 日志一致性",slug:"_4-3-日志一致性",normalizedTitle:"4.3. 日志一致性",charIndex:6102},{level:4,title:"Leader 和 Follower 日志不一致的可能",slug:"leader-和-follower-日志不一致的可能",normalizedTitle:"leader 和 follower 日志不一致的可能",charIndex:6220},{level:4,title:"Leader 和 Follower 日志一致的保证",slug:"leader-和-follower-日志一致的保证",normalizedTitle:"leader 和 follower 日志一致的保证",charIndex:6673},{level:2,title:"5. 安全性",slug:"_5-安全性",normalizedTitle:"5. 安全性",charIndex:6963},{level:3,title:"5.1. 选举限制",slug:"_5-1-选举限制",normalizedTitle:"5.1. 选举限制",charIndex:7091},{level:3,title:"5.2. 提交旧任期的日志条目",slug:"_5-2-提交旧任期的日志条目",normalizedTitle:"5.2. 提交旧任期的日志条目",charIndex:7570},{level:2,title:"6. 日志压缩",slug:"_6-日志压缩",normalizedTitle:"6. 日志压缩",charIndex:8536},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:9048}],headersStr:"1. Raft 简介 1.1. 分布式一致性 1.2. 复制状态机 1.3. RAFT 应用 2. Raft 基础 2.1. 服务器角色 2.2. 任期 2.3. RPC 3. 选举 Leader 3.1. 选举规则 自己成为 Leader 其他的服务器成为 Leader 没有任何服务器成为 Leader 3.2. 单 Candidate 选举 3.3. 多 Candidate 选举 4. 日志复制 4.1. 日志格式 4.2. 日志复制流程 4.3. 日志一致性 Leader 和 Follower 日志不一致的可能 Leader 和 Follower 日志一致的保证 5. 安全性 5.1. 选举限制 5.2. 提交旧任期的日志条目 6. 日志压缩 7. 参考资料",content:"# 深入剖析共识性算法 Raft\n\n\n\n\n# 1. Raft 简介\n\nRaft 是一种为了管理日志复制的分布式一致性算法。\n\nRaft 出现之前，Paxos 一直是分布式一致性算法的标准。Paxos 难以理解，更难以实现。Raft 的设计目标是简化 Paxos，使得算法既容易理解，也容易实现。\n\nPaxos 和 Raft 都是分布式一致性算法，这个过程如同投票选举领袖（Leader），参选者（Candidate）需要说服大多数投票者（Follower）投票给他，一旦选举出领袖，就由领袖发号施令。Paxos 和 Raft 的区别在于选举的具体过程不同。\n\nRaft 可以解决分布式 CAP 理论中的 CP，即 一致性（C：Consistency） 和 分区容忍性（P：Partition Tolerance），并不能解决 可用性（A：Availability） 的问题。\n\n\n# 1.1. 分布式一致性\n\n分布式一致性 (distributed consensus) 是分布式系统中最基本的问题，用来保证一个分布式系统的可靠性以及容错能力。简单来说，分布式一致性是指多个服务器的保持状态一致。\n\n在分布式系统中，可能出现各种意外（断电、网络拥塞、CPU/内存耗尽等等），使得服务器宕机或无法访问，最终导致无法和其他服务器保持状态一致。为了应对这种情况，就需要有一种一致性协议来进行容错，使得分布式系统中即使有部分服务器宕机或无法访问，整体依然可以对外提供服务。\n\n以容错方式达成一致，自然不能要求所有服务器都达成一致状态，只要超过半数以上的服务器达成一致就可以了。假设有 N 台服务器， 大于等于 N/2 + 1 台服务器就算是半数以上了 。\n\n\n# 1.2. 复制状态机\n\n复制状态机（Replicated State Machines） 是指一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。\n\n\n\n复制状态机通常都是基于复制日志实现的，如上图。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。\n\n保证复制日志相同就是一致性算法的工作了。在一台服务器上，一致性模块接收客户端发送来的指令然后增加到自己的日志中去。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，尽管有些服务器会宕机。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。\n\n实际系统中使用的一致性算法通常含有以下特性：\n\n * 安全性保证（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确。\n * 可用性：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。他们当有稳定的存储的时候可以从状态中恢复回来并重新加入集群。\n * 不依赖时序来保证一致性：物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题。\n * 通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。\n\n\n# 1.3. RAFT 应用\n\nRAFT 可以做什么？\n\n通过 RAFT 提供的复制状态机，可以解决分布式系统的复制、修复、节点管理等问题。Raft 极大的简化当前分布式系统的设计与实现，让开发者只关注于业务逻辑，将其抽象实现成对应的状态机即可。基于这套框架，可以构建很多分布式应用：\n\n * 分布式锁服务，比如 Zookeeper\n * 分布式存储系统，比如分布式消息队列、分布式块系统、分布式文件系统、分布式表格系统等\n * 高可靠元信息管理，比如各类 Master 模块的 HA\n\n\n# 2. Raft 基础\n\nRaft 将一致性问题分解成了三个子问题：\n\n * 选举 Leader\n * 日志复制\n * 安全性\n\n在后续章节，会详细讲解这个子问题。现在，先了解一下 Raft 的一些核心概念。\n\n\n# 2.1. 服务器角色\n\n在 Raft 中，任何时刻，每个服务器都处于这三个角色之一 ：\n\n * Leader - 领导者，通常一个系统中是一主（Leader）多从（Follower）。Leader 负责处理所有的客户端请求。\n * Follower - 跟随者，不会发送任何请求，只是简单的 响应来自 Leader 或者 Candidate 的请求。\n * Candidate - 参选者，选举新 Leader 时的临时角色。\n\n\n\n> 💡 图示说明：\n> \n>  * Follower 只响应来自其他服务器的请求。在一定时限内，如果 Follower 接收不到消息，就会转变成 Candidate，并发起选举。\n>  * Candidate 向 Follower 发起投票请求，如果获得集群中半数以上的选票，就会转变为 Leader。\n>  * 在一个 Term 内，Leader 始终保持不变，直到下线了。Leader 需要周期性向所有 Follower 发送心跳消息，以阻止 Follower 转变为 Candidate。\n\n\n# 2.2. 任期\n\n\n\nRaft 把时间分割成任意长度的 任期（Term），任期用连续的整数标记。每一段任期从一次选举开始。Raft 保证了在一个给定的任期内，最多只有一个领导者。\n\n * 如果选举成功，Leader 会管理整个集群直到任期结束。\n * 如果选举失败，那么这个任期就会因为没有 Leader 而结束。\n\n不同服务器节点观察到的任期转换状态可能不一样：\n\n * 服务器节点可能观察到多次的任期转换。\n * 服务器节点也可能观察不到任何一次任期转换。\n\n任期在 Raft 算法中充当逻辑时钟的作用，使得服务器节点可以查明一些过期的信息（比如过期的 Leader）。每个服务器节点都会存储一个当前任期号，这一编号在整个时期内单调的增长。当服务器之间通信的时候会交换当前任期号。\n\n * 如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值。\n * 如果一个 Candidate 或者 Leader 发现自己的任期号过期了，那么他会立即恢复成跟随者状态。\n * 如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。\n\n\n# 2.3. RPC\n\nRaft 算法中服务器节点之间的通信使用 远程过程调用（RPC）。\n\n基本的一致性算法只需要两种 RPC：\n\n * RequestVote RPC - 请求投票 RPC，由 Candidate 在选举期间发起。\n * AppendEntries RPC - 附加条目 RPC，由 Leader 发起，用来复制日志和提供一种心跳机制。\n\n\n# 3. 选举 Leader\n\n\n# 3.1. 选举规则\n\nRaft 使用一种心跳机制来触发 Leader 选举。\n\nLeader 需要周期性的向所有 Follower 发送心跳消息，以此维持自己的权威并阻止新 Leader 的产生。\n\n每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms ~ 300ms，如果在竞选超时时间内没有收到 Leader 的心跳消息，就会认为当前 Term 没有可用的 Leader，并发起选举来选出新的 Leader。开始一次选举过程，Follower 先要增加自己的当前 Term 号，并转换为 Candidate。\n\nCandidate 会并行的向集群中的所有服务器节点发送投票请求（RequestVote RPC），它会保持当前状态直到以下三件事情之一发生：\n\n * 自己成为 Leader\n * 其他的服务器成为 Leader\n * 没有任何服务器成为 Leader\n\n# 自己成为 Leader\n\n * 当一个 Candidate 从整个集群半数以上的服务器节点获得了针对同一个 Term 的选票，那么它就赢得了这次选举并成为 Leader。每个服务器最多会对一个 Term 投出一张选票，按照先来先服务（FIFO）的原则。要求半数以上选票的规则确保了最多只会有一个 Candidate 赢得此次选举。\n * 一旦 Candidate 赢得选举，就立即成为 Leader。然后它会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生。\n\n# 其他的服务器成为 Leader\n\n等待投票期间，Candidate 可能会从其他的服务器接收到声明它是 Leader 的 AppendEntries RPC。\n\n * 如果这个 Leader 的 Term 号（包含在此次的 RPC 中）不小于 Candidate 当前的 Term，那么 Candidate 会承认 Leader 合法并回到 Follower 状态。\n * 如果此次 RPC 中的 Term 号比自己小，那么 Candidate 就会拒绝这个消息并继续保持 Candidate 状态。\n\n# 没有任何服务器成为 Leader\n\n如果有多个 Follower 同时成为 Candidate，那么选票可能会被瓜分以至于没有 Candidate 可以赢得半数以上的投票。当这种情况发生的时候，每一个 Candidate 都会竞选超时，然后通过增加当前 Term 号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。\n\nRaft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，竞选超时时间是一个随机的时间，在一个固定的区间（例如 150-300 毫秒）随机选择，这样可以把选举都分散开。\n\n * 以至于在大多数情况下，只有一个服务器会超时，然后它赢得选举，成为 Leader，并在其他服务器超时之前发送心跳包。\n * 同样的机制也被用在选票瓜分的情况下：每一个 Candidate 在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。\n\n----------------------------------------\n\n理解了上面的选举规则后，我们通过动图来加深认识。\n\n\n# 3.2. 单 Candidate 选举\n\n（1）下图表示一个分布式系统的最初阶段，此时只有 Follower，没有 Leader。Follower A 等待一个随机的选举超时时间之后，没收到 Leader 发来的心跳消息。因此，将 Term 由 0 增加为 1，转换为 Candidate，进入选举状态。\n\n\n\n（2）此时，A 向所有其他节点发送投票请求。\n\n\n\n（3）其它节点会对投票请求进行回复，如果超过半数以上的节点投票了，那么该 Candidate 就会立即变成 Term 为 1 的 Leader。\n\n\n\n（4）Leader 会周期性地发送心跳消息给所有 Follower，Follower 接收到心跳包，会重新开始计时。\n\n\n\n\n# 3.3. 多 Candidate 选举\n\n（1）如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Candidate B 和 Candidate D 都发起 Term 为 4 的选举，且都获得两票，因此需要重新开始投票。\n\n\n\n（2）当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 Candidate 并获得同样票数的概率很低。\n\n\n\n\n# 4. 日志复制\n\n\n# 4.1. 日志格式\n\n日志由含日志索引（log index）的日志条目（log entry）组成。每个日志条目包含它被创建时的 Term 号（下图中方框中的数字），和一个复制状态机需要执行的指令。如果一个日志条目被复制到半数以上的服务器上，就被认为可以提交（Commit）了。\n\n * 日志条目中的 Term 号被用来检查是否出现不一致的情况。\n * 日志条目中的日志索引（一个整数值）用来表明它在日志中的位置。\n\n\n\nRaft 日志同步保证如下两点：\n\n * 如果不同日志中的两个日志条目有着相同的日志索引和 Term，则它们所存储的命令是相同的。\n   * 这个特性基于这条原则：Leader 最多在一个 Term 内、在指定的一个日志索引上创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。\n * 如果不同日志中的两个日志条目有着相同的日志索引和 Term，则它们之前的所有条目都是完全一样的。\n   * 这个特性由 AppendEntries RPC 的一个简单的一致性检查所保证。在发送 AppendEntries RPC 时，Leader 会把新日志条目之前的日志条目的日志索引和 Term 号一起发送。如果 Follower 在它的日志中找不到包含相同日志索引和 Term 号的日志条目，它就会拒绝接收新的日志条目。\n\n\n# 4.2. 日志复制流程\n\n\n\n 1. Leader 负责处理所有客户端的请求。\n 2. Leader 把请求作为日志条目加入到它的日志中，然后并行的向其他服务器发送 AppendEntries RPC 请求，要求 Follower 复制日志条目。\n 3. Follower 复制成功后，返回确认消息。\n 4. 当这个日志条目被半数以上的服务器复制后，Leader 提交这个日志条目到它的复制状态机，并向客户端返回执行结果。\n\n> 注意：如果 Follower 崩溃或者运行缓慢，再或者网络丢包，Leader 会不断的重复尝试发送 AppendEntries RPC 请求 （尽管已经回复了客户端），直到所有的跟随者都最终复制了所有的日志条目。\n\n下面，通过一组动图来加深认识：\n\n（1）来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。\n\n\n\n（2）Leader 会把修改复制到所有 Follower。\n\n\n\n（3）Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。\n\n\n\n（4）此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。\n\n\n\n\n# 4.3. 日志一致性\n\n一般情况下，Leader 和 Followers 的日志保持一致，因此日志条目一致性检查通常不会失败。然而，Leader 崩溃可能会导致日志不一致：旧的 Leader 可能没有完全复制完日志中的所有条目。\n\n# Leader 和 Follower 日志不一致的可能\n\nLeader 和 Follower 可能存在多种日志不一致的可能。\n\n\n\n> 💡 图示说明：\n> \n> 上图阐述了 Leader 和 Follower 可能存在多种日志不一致的可能，每一个方框表示一个日志条目，里面的数字表示任期号 。\n> \n> 当一个 Leader 成功当选时，Follower 可能出现以下情况（a-f）：\n> \n>  * 存在未更新日志条目，如（a、b）。\n>  * 存在未提交日志条目，如（c、d）。\n>  * 或两种情况都存在，如（e、f）。\n> \n> 例如，场景 f 可能会这样发生，某服务器在 Term2 的时候是 Leader，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在 Term3 重新被选为 Leader，并且又增加了一些日志条目到自己的日志中；在 Term 2 和 Term 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。\n\n# Leader 和 Follower 日志一致的保证\n\nLeader 通过强制 Followers 复制它的日志来处理日志的不一致，Followers 上的不一致的日志会被 Leader 的日志覆盖。\n\n * Leader 为了使 Followers 的日志同自己的一致，Leader 需要找到 Followers 同它的日志一致的地方，然后覆盖 Followers 在该位置之后的条目。\n * Leader 会从后往前试，每次日志条目失败后尝试前一个日志条目，直到成功找到每个 Follower 的日志一致位点，然后向后逐条覆盖 Followers 在该位置之后的条目。\n\n\n# 5. 安全性\n\n前面描述了 Raft 算法是如何选举 Leader 和复制日志的。\n\nRaft 还增加了一些限制来完善 Raft 算法，以保证安全性：保证了任意 Leader 对于给定的 Term，都拥有了之前 Term 的所有被提交的日志条目。\n\n\n# 5.1. 选举限制\n\n拥有最新的已提交的日志条目的 Follower 才有资格成为 Leader。\n\nRaft 使用投票的方式来阻止一个 Candidate 赢得选举除非这个 Candidate 包含了所有已经提交的日志条目。 Candidate 为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果 Candidate 的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。\n\nRequestVote RPC 实现了这样的限制：RequestVote RPC 中包含了 Candidate 的日志信息， Follower 会拒绝掉那些日志没有自己新的投票请求。\n\n如何判断哪个日志条目比较新？\n\nRaft 通过比较两份日志中最后一条日志条目的日志索引和 Term 来判断哪个日志比较新。\n\n * 先判断 Term，哪个数值大即代表哪个日志比较新。\n * 如果 Term 相同，再比较 日志索引，哪个数值大即代表哪个日志比较新。\n\n\n# 5.2. 提交旧任期的日志条目\n\n一个当前 Term 的日志条目被复制到了半数以上的服务器上，Leader 就认为它是可以被提交的。如果这个 Leader 在提交日志条目前就下线了，后续的 Leader 可能会覆盖掉这个日志条目。\n\n\n\n> 💡 图示说明：\n> \n> 上图解释了为什么 Leader 无法对旧 Term 的日志条目进行提交。\n> \n>  * 阶段 (a) ，S1 是 Leader，且 S1 写入日志条目为 (Term 2，日志索引 2），只有 S2 复制了这个日志条目。\n>  * 阶段 (b)，S1 下线，S5 被选举为 Term3 的 Leader。S5 写入日志条目为 (Term 3，日志索引 2）。\n>  * 阶段 (c)，S5 下线，S1 重新上线，并被选举为 Term4 的 Leader。此时，Term 2 的那条日志条目已经被复制到了集群中的大多数节点上，但是还没有被提交。\n>  * 阶段 (d)，S1 再次下线，S5 重新上线，并被重新选举为 Term3 的 Leader。然后 S5 覆盖了日志索引 2 处的日志。\n>  * 阶段 (e)，如果阶段 (d) 还未发生，即 S1 再次下线之前，S1 把自己主导的日志条目复制到了大多数节点上，那么在后续 Term 里面这些新日志条目就会被提交。这样在同一时刻就同时保证了，之前的所有旧日志条目就会被提交。\n\nRaft 永远不会通过计算副本数目的方式去提交一个之前 Term 内的日志条目。只有 Leader 当前 Term 里的日志条目通过计算副本数目可以被提交；一旦当前 Term 的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。\n\n当 Leader 复制之前任期里的日志时，Raft 会为所有日志保留原始的 Term，这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。Raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，Raft 中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号）。\n\n\n# 6. 日志压缩\n\n在实际的系统中，不能让日志无限膨胀，否则系统重启时需要花很长的时间进行恢复，从而影响可用性。Raft 采用对整个系统进行快照来解决，快照之前的日志都可以丢弃。\n\n每个副本独立的对自己的系统状态生成快照，并且只能对已经提交的日志条目生成快照。\n\n快照包含以下内容：\n\n * 日志元数据。最后一条已提交的日志条目的日志索引和 Term。这两个值在快照之后的第一条日志条目的 AppendEntries RPC 的完整性检查的时候会被用上。\n * 系统当前状态。\n\n当 Leader 要发送某个日志条目，落后太多的 Follower 的日志条目会被丢弃，Leader 会将快照发给 Follower。或者新上线一台机器时，也会发送快照给它。\n\n\n\n生成快照的频率要适中，频率过高会消耗大量 I/O 带宽；频率过低，一旦需要执行恢复操作，会丢失大量数据，影响可用性。推荐当日志达到某个固定的大小时生成快照。\n\n生成一次快照可能耗时过长，影响正常日志同步。可以通过使用 copy-on-write 技术避免快照过程影响正常日志同步。\n\n> 说明：本文仅阐述 Raft 算法的核心内容，不包括算法论证、评估等\n\n\n# 7. 参考资料\n\n * Raft 一致性算法论文原文\n * Raft 一致性算法论文译文\n * Raft 作者讲解视频\n * Raft 作者讲解视频对应的 PPT\n * 分布式系统的 Raft 算法\n * Raft: Understandable Distributed Consensus - 一个动画教程\n * The Raft Consensus Algorithm - 一个交互式动画教程\n * sofa-jraft - 蚂蚁金服的 Raft 算法实现库（Java 版）",normalizedContent:"# 深入剖析共识性算法 raft\n\n\n\n\n# 1. raft 简介\n\nraft 是一种为了管理日志复制的分布式一致性算法。\n\nraft 出现之前，paxos 一直是分布式一致性算法的标准。paxos 难以理解，更难以实现。raft 的设计目标是简化 paxos，使得算法既容易理解，也容易实现。\n\npaxos 和 raft 都是分布式一致性算法，这个过程如同投票选举领袖（leader），参选者（candidate）需要说服大多数投票者（follower）投票给他，一旦选举出领袖，就由领袖发号施令。paxos 和 raft 的区别在于选举的具体过程不同。\n\nraft 可以解决分布式 cap 理论中的 cp，即 一致性（c：consistency） 和 分区容忍性（p：partition tolerance），并不能解决 可用性（a：availability） 的问题。\n\n\n# 1.1. 分布式一致性\n\n分布式一致性 (distributed consensus) 是分布式系统中最基本的问题，用来保证一个分布式系统的可靠性以及容错能力。简单来说，分布式一致性是指多个服务器的保持状态一致。\n\n在分布式系统中，可能出现各种意外（断电、网络拥塞、cpu/内存耗尽等等），使得服务器宕机或无法访问，最终导致无法和其他服务器保持状态一致。为了应对这种情况，就需要有一种一致性协议来进行容错，使得分布式系统中即使有部分服务器宕机或无法访问，整体依然可以对外提供服务。\n\n以容错方式达成一致，自然不能要求所有服务器都达成一致状态，只要超过半数以上的服务器达成一致就可以了。假设有 n 台服务器， 大于等于 n/2 + 1 台服务器就算是半数以上了 。\n\n\n# 1.2. 复制状态机\n\n复制状态机（replicated state machines） 是指一组服务器上的状态机产生相同状态的副本，并且在一些机器宕掉的情况下也可以继续运行。一致性算法管理着来自客户端指令的复制日志。状态机从日志中处理相同顺序的相同指令，所以产生的结果也是相同的。\n\n\n\n复制状态机通常都是基于复制日志实现的，如上图。每一个服务器存储一个包含一系列指令的日志，并且按照日志的顺序进行执行。每一个日志都按照相同的顺序包含相同的指令，所以每一个服务器都执行相同的指令序列。因为每个状态机都是确定的，每一次执行操作都产生相同的状态和同样的序列。\n\n保证复制日志相同就是一致性算法的工作了。在一台服务器上，一致性模块接收客户端发送来的指令然后增加到自己的日志中去。它和其他服务器上的一致性模块进行通信来保证每一个服务器上的日志最终都以相同的顺序包含相同的请求，尽管有些服务器会宕机。一旦指令被正确的复制，每一个服务器的状态机按照日志顺序处理他们，然后输出结果被返回给客户端。因此，服务器集群看起来形成一个高可靠的状态机。\n\n实际系统中使用的一致性算法通常含有以下特性：\n\n * 安全性保证（绝对不会返回一个错误的结果）：在非拜占庭错误情况下，包括网络延迟、分区、丢包、冗余和乱序等错误都可以保证正确。\n * 可用性：集群中只要有大多数的机器可运行并且能够相互通信、和客户端通信，就可以保证可用。因此，一个典型的包含 5 个节点的集群可以容忍两个节点的失败。服务器被停止就认为是失败。他们当有稳定的存储的时候可以从状态中恢复回来并重新加入集群。\n * 不依赖时序来保证一致性：物理时钟错误或者极端的消息延迟只有在最坏情况下才会导致可用性问题。\n * 通常情况下，一条指令可以尽可能快的在集群中大多数节点响应一轮远程过程调用时完成。小部分比较慢的节点不会影响系统整体的性能。\n\n\n# 1.3. raft 应用\n\nraft 可以做什么？\n\n通过 raft 提供的复制状态机，可以解决分布式系统的复制、修复、节点管理等问题。raft 极大的简化当前分布式系统的设计与实现，让开发者只关注于业务逻辑，将其抽象实现成对应的状态机即可。基于这套框架，可以构建很多分布式应用：\n\n * 分布式锁服务，比如 zookeeper\n * 分布式存储系统，比如分布式消息队列、分布式块系统、分布式文件系统、分布式表格系统等\n * 高可靠元信息管理，比如各类 master 模块的 ha\n\n\n# 2. raft 基础\n\nraft 将一致性问题分解成了三个子问题：\n\n * 选举 leader\n * 日志复制\n * 安全性\n\n在后续章节，会详细讲解这个子问题。现在，先了解一下 raft 的一些核心概念。\n\n\n# 2.1. 服务器角色\n\n在 raft 中，任何时刻，每个服务器都处于这三个角色之一 ：\n\n * leader - 领导者，通常一个系统中是一主（leader）多从（follower）。leader 负责处理所有的客户端请求。\n * follower - 跟随者，不会发送任何请求，只是简单的 响应来自 leader 或者 candidate 的请求。\n * candidate - 参选者，选举新 leader 时的临时角色。\n\n\n\n> 💡 图示说明：\n> \n>  * follower 只响应来自其他服务器的请求。在一定时限内，如果 follower 接收不到消息，就会转变成 candidate，并发起选举。\n>  * candidate 向 follower 发起投票请求，如果获得集群中半数以上的选票，就会转变为 leader。\n>  * 在一个 term 内，leader 始终保持不变，直到下线了。leader 需要周期性向所有 follower 发送心跳消息，以阻止 follower 转变为 candidate。\n\n\n# 2.2. 任期\n\n\n\nraft 把时间分割成任意长度的 任期（term），任期用连续的整数标记。每一段任期从一次选举开始。raft 保证了在一个给定的任期内，最多只有一个领导者。\n\n * 如果选举成功，leader 会管理整个集群直到任期结束。\n * 如果选举失败，那么这个任期就会因为没有 leader 而结束。\n\n不同服务器节点观察到的任期转换状态可能不一样：\n\n * 服务器节点可能观察到多次的任期转换。\n * 服务器节点也可能观察不到任何一次任期转换。\n\n任期在 raft 算法中充当逻辑时钟的作用，使得服务器节点可以查明一些过期的信息（比如过期的 leader）。每个服务器节点都会存储一个当前任期号，这一编号在整个时期内单调的增长。当服务器之间通信的时候会交换当前任期号。\n\n * 如果一个服务器的当前任期号比其他人小，那么他会更新自己的编号到较大的编号值。\n * 如果一个 candidate 或者 leader 发现自己的任期号过期了，那么他会立即恢复成跟随者状态。\n * 如果一个节点接收到一个包含过期的任期号的请求，那么他会直接拒绝这个请求。\n\n\n# 2.3. rpc\n\nraft 算法中服务器节点之间的通信使用 远程过程调用（rpc）。\n\n基本的一致性算法只需要两种 rpc：\n\n * requestvote rpc - 请求投票 rpc，由 candidate 在选举期间发起。\n * appendentries rpc - 附加条目 rpc，由 leader 发起，用来复制日志和提供一种心跳机制。\n\n\n# 3. 选举 leader\n\n\n# 3.1. 选举规则\n\nraft 使用一种心跳机制来触发 leader 选举。\n\nleader 需要周期性的向所有 follower 发送心跳消息，以此维持自己的权威并阻止新 leader 的产生。\n\n每个 follower 都设置了一个随机的竞选超时时间，一般为 150ms ~ 300ms，如果在竞选超时时间内没有收到 leader 的心跳消息，就会认为当前 term 没有可用的 leader，并发起选举来选出新的 leader。开始一次选举过程，follower 先要增加自己的当前 term 号，并转换为 candidate。\n\ncandidate 会并行的向集群中的所有服务器节点发送投票请求（requestvote rpc），它会保持当前状态直到以下三件事情之一发生：\n\n * 自己成为 leader\n * 其他的服务器成为 leader\n * 没有任何服务器成为 leader\n\n# 自己成为 leader\n\n * 当一个 candidate 从整个集群半数以上的服务器节点获得了针对同一个 term 的选票，那么它就赢得了这次选举并成为 leader。每个服务器最多会对一个 term 投出一张选票，按照先来先服务（fifo）的原则。要求半数以上选票的规则确保了最多只会有一个 candidate 赢得此次选举。\n * 一旦 candidate 赢得选举，就立即成为 leader。然后它会向其他的服务器发送心跳消息来建立自己的权威并且阻止新的领导人的产生。\n\n# 其他的服务器成为 leader\n\n等待投票期间，candidate 可能会从其他的服务器接收到声明它是 leader 的 appendentries rpc。\n\n * 如果这个 leader 的 term 号（包含在此次的 rpc 中）不小于 candidate 当前的 term，那么 candidate 会承认 leader 合法并回到 follower 状态。\n * 如果此次 rpc 中的 term 号比自己小，那么 candidate 就会拒绝这个消息并继续保持 candidate 状态。\n\n# 没有任何服务器成为 leader\n\n如果有多个 follower 同时成为 candidate，那么选票可能会被瓜分以至于没有 candidate 可以赢得半数以上的投票。当这种情况发生的时候，每一个 candidate 都会竞选超时，然后通过增加当前 term 号来开始一轮新的选举。然而，没有其他机制的话，选票可能会被无限的重复瓜分。\n\nraft 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况，就算发生也能很快的解决。为了阻止选票起初就被瓜分，竞选超时时间是一个随机的时间，在一个固定的区间（例如 150-300 毫秒）随机选择，这样可以把选举都分散开。\n\n * 以至于在大多数情况下，只有一个服务器会超时，然后它赢得选举，成为 leader，并在其他服务器超时之前发送心跳包。\n * 同样的机制也被用在选票瓜分的情况下：每一个 candidate 在开始一次选举的时候会重置一个随机的选举超时时间，然后在超时时间内等待投票的结果；这样减少了在新的选举中另外的选票瓜分的可能性。\n\n----------------------------------------\n\n理解了上面的选举规则后，我们通过动图来加深认识。\n\n\n# 3.2. 单 candidate 选举\n\n（1）下图表示一个分布式系统的最初阶段，此时只有 follower，没有 leader。follower a 等待一个随机的选举超时时间之后，没收到 leader 发来的心跳消息。因此，将 term 由 0 增加为 1，转换为 candidate，进入选举状态。\n\n\n\n（2）此时，a 向所有其他节点发送投票请求。\n\n\n\n（3）其它节点会对投票请求进行回复，如果超过半数以上的节点投票了，那么该 candidate 就会立即变成 term 为 1 的 leader。\n\n\n\n（4）leader 会周期性地发送心跳消息给所有 follower，follower 接收到心跳包，会重新开始计时。\n\n\n\n\n# 3.3. 多 candidate 选举\n\n（1）如果有多个 follower 成为 candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 candidate b 和 candidate d 都发起 term 为 4 的选举，且都获得两票，因此需要重新开始投票。\n\n\n\n（2）当重新开始投票时，由于每个节点设置的随机竞选超时时间不同，因此能下一次再次出现多个 candidate 并获得同样票数的概率很低。\n\n\n\n\n# 4. 日志复制\n\n\n# 4.1. 日志格式\n\n日志由含日志索引（log index）的日志条目（log entry）组成。每个日志条目包含它被创建时的 term 号（下图中方框中的数字），和一个复制状态机需要执行的指令。如果一个日志条目被复制到半数以上的服务器上，就被认为可以提交（commit）了。\n\n * 日志条目中的 term 号被用来检查是否出现不一致的情况。\n * 日志条目中的日志索引（一个整数值）用来表明它在日志中的位置。\n\n\n\nraft 日志同步保证如下两点：\n\n * 如果不同日志中的两个日志条目有着相同的日志索引和 term，则它们所存储的命令是相同的。\n   * 这个特性基于这条原则：leader 最多在一个 term 内、在指定的一个日志索引上创建一条日志条目，同时日志条目在日志中的位置也从来不会改变。\n * 如果不同日志中的两个日志条目有着相同的日志索引和 term，则它们之前的所有条目都是完全一样的。\n   * 这个特性由 appendentries rpc 的一个简单的一致性检查所保证。在发送 appendentries rpc 时，leader 会把新日志条目之前的日志条目的日志索引和 term 号一起发送。如果 follower 在它的日志中找不到包含相同日志索引和 term 号的日志条目，它就会拒绝接收新的日志条目。\n\n\n# 4.2. 日志复制流程\n\n\n\n 1. leader 负责处理所有客户端的请求。\n 2. leader 把请求作为日志条目加入到它的日志中，然后并行的向其他服务器发送 appendentries rpc 请求，要求 follower 复制日志条目。\n 3. follower 复制成功后，返回确认消息。\n 4. 当这个日志条目被半数以上的服务器复制后，leader 提交这个日志条目到它的复制状态机，并向客户端返回执行结果。\n\n> 注意：如果 follower 崩溃或者运行缓慢，再或者网络丢包，leader 会不断的重复尝试发送 appendentries rpc 请求 （尽管已经回复了客户端），直到所有的跟随者都最终复制了所有的日志条目。\n\n下面，通过一组动图来加深认识：\n\n（1）来自客户端的修改都会被传入 leader。注意该修改还未被提交，只是写入日志中。\n\n\n\n（2）leader 会把修改复制到所有 follower。\n\n\n\n（3）leader 会等待大多数的 follower 也进行了修改，然后才将修改提交。\n\n\n\n（4）此时 leader 会通知的所有 follower 让它们也提交修改，此时所有节点的值达成一致。\n\n\n\n\n# 4.3. 日志一致性\n\n一般情况下，leader 和 followers 的日志保持一致，因此日志条目一致性检查通常不会失败。然而，leader 崩溃可能会导致日志不一致：旧的 leader 可能没有完全复制完日志中的所有条目。\n\n# leader 和 follower 日志不一致的可能\n\nleader 和 follower 可能存在多种日志不一致的可能。\n\n\n\n> 💡 图示说明：\n> \n> 上图阐述了 leader 和 follower 可能存在多种日志不一致的可能，每一个方框表示一个日志条目，里面的数字表示任期号 。\n> \n> 当一个 leader 成功当选时，follower 可能出现以下情况（a-f）：\n> \n>  * 存在未更新日志条目，如（a、b）。\n>  * 存在未提交日志条目，如（c、d）。\n>  * 或两种情况都存在，如（e、f）。\n> \n> 例如，场景 f 可能会这样发生，某服务器在 term2 的时候是 leader，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在 term3 重新被选为 leader，并且又增加了一些日志条目到自己的日志中；在 term 2 和 term 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。\n\n# leader 和 follower 日志一致的保证\n\nleader 通过强制 followers 复制它的日志来处理日志的不一致，followers 上的不一致的日志会被 leader 的日志覆盖。\n\n * leader 为了使 followers 的日志同自己的一致，leader 需要找到 followers 同它的日志一致的地方，然后覆盖 followers 在该位置之后的条目。\n * leader 会从后往前试，每次日志条目失败后尝试前一个日志条目，直到成功找到每个 follower 的日志一致位点，然后向后逐条覆盖 followers 在该位置之后的条目。\n\n\n# 5. 安全性\n\n前面描述了 raft 算法是如何选举 leader 和复制日志的。\n\nraft 还增加了一些限制来完善 raft 算法，以保证安全性：保证了任意 leader 对于给定的 term，都拥有了之前 term 的所有被提交的日志条目。\n\n\n# 5.1. 选举限制\n\n拥有最新的已提交的日志条目的 follower 才有资格成为 leader。\n\nraft 使用投票的方式来阻止一个 candidate 赢得选举除非这个 candidate 包含了所有已经提交的日志条目。 candidate 为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目在这些服务器节点中肯定存在于至少一个节点上。如果 candidate 的日志至少和大多数的服务器节点一样新（这个新的定义会在下面讨论），那么他一定持有了所有已经提交的日志条目。\n\nrequestvote rpc 实现了这样的限制：requestvote rpc 中包含了 candidate 的日志信息， follower 会拒绝掉那些日志没有自己新的投票请求。\n\n如何判断哪个日志条目比较新？\n\nraft 通过比较两份日志中最后一条日志条目的日志索引和 term 来判断哪个日志比较新。\n\n * 先判断 term，哪个数值大即代表哪个日志比较新。\n * 如果 term 相同，再比较 日志索引，哪个数值大即代表哪个日志比较新。\n\n\n# 5.2. 提交旧任期的日志条目\n\n一个当前 term 的日志条目被复制到了半数以上的服务器上，leader 就认为它是可以被提交的。如果这个 leader 在提交日志条目前就下线了，后续的 leader 可能会覆盖掉这个日志条目。\n\n\n\n> 💡 图示说明：\n> \n> 上图解释了为什么 leader 无法对旧 term 的日志条目进行提交。\n> \n>  * 阶段 (a) ，s1 是 leader，且 s1 写入日志条目为 (term 2，日志索引 2），只有 s2 复制了这个日志条目。\n>  * 阶段 (b)，s1 下线，s5 被选举为 term3 的 leader。s5 写入日志条目为 (term 3，日志索引 2）。\n>  * 阶段 (c)，s5 下线，s1 重新上线，并被选举为 term4 的 leader。此时，term 2 的那条日志条目已经被复制到了集群中的大多数节点上，但是还没有被提交。\n>  * 阶段 (d)，s1 再次下线，s5 重新上线，并被重新选举为 term3 的 leader。然后 s5 覆盖了日志索引 2 处的日志。\n>  * 阶段 (e)，如果阶段 (d) 还未发生，即 s1 再次下线之前，s1 把自己主导的日志条目复制到了大多数节点上，那么在后续 term 里面这些新日志条目就会被提交。这样在同一时刻就同时保证了，之前的所有旧日志条目就会被提交。\n\nraft 永远不会通过计算副本数目的方式去提交一个之前 term 内的日志条目。只有 leader 当前 term 里的日志条目通过计算副本数目可以被提交；一旦当前 term 的日志条目以这种方式被提交，那么由于日志匹配特性，之前的日志条目也都会被间接的提交。\n\n当 leader 复制之前任期里的日志时，raft 会为所有日志保留原始的 term，这在提交规则上产生了额外的复杂性。在其他的一致性算法中，如果一个新的领导人要重新复制之前的任期里的日志时，它必须使用当前新的任期号。raft 使用的方法更加容易辨别出日志，因为它可以随着时间和日志的变化对日志维护着同一个任期编号。另外，和其他的算法相比，raft 中的新领导人只需要发送更少日志条目（其他算法中必须在他们被提交之前发送更多的冗余日志条目来为他们重新编号）。\n\n\n# 6. 日志压缩\n\n在实际的系统中，不能让日志无限膨胀，否则系统重启时需要花很长的时间进行恢复，从而影响可用性。raft 采用对整个系统进行快照来解决，快照之前的日志都可以丢弃。\n\n每个副本独立的对自己的系统状态生成快照，并且只能对已经提交的日志条目生成快照。\n\n快照包含以下内容：\n\n * 日志元数据。最后一条已提交的日志条目的日志索引和 term。这两个值在快照之后的第一条日志条目的 appendentries rpc 的完整性检查的时候会被用上。\n * 系统当前状态。\n\n当 leader 要发送某个日志条目，落后太多的 follower 的日志条目会被丢弃，leader 会将快照发给 follower。或者新上线一台机器时，也会发送快照给它。\n\n\n\n生成快照的频率要适中，频率过高会消耗大量 i/o 带宽；频率过低，一旦需要执行恢复操作，会丢失大量数据，影响可用性。推荐当日志达到某个固定的大小时生成快照。\n\n生成一次快照可能耗时过长，影响正常日志同步。可以通过使用 copy-on-write 技术避免快照过程影响正常日志同步。\n\n> 说明：本文仅阐述 raft 算法的核心内容，不包括算法论证、评估等\n\n\n# 7. 参考资料\n\n * raft 一致性算法论文原文\n * raft 一致性算法论文译文\n * raft 作者讲解视频\n * raft 作者讲解视频对应的 ppt\n * 分布式系统的 raft 算法\n * raft: understandable distributed consensus - 一个动画教程\n * the raft consensus algorithm - 一个交互式动画教程\n * sofa-jraft - 蚂蚁金服的 raft 算法实现库（java 版）",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"分布式算法 Gossip",frontmatter:{title:"分布式算法 Gossip",categories:["分布式","分布式理论"],tags:["分布式","分布式理论","共识性","Gossip"],abbrlink:"64f7c861",date:"2021-07-13T09:18:41.000Z",permalink:"/pages/d15993/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/02.%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/04.%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95Gossip.html",relativePath:"02.分布式/02.分布式理论/04.分布式算法Gossip.md",key:"v-0bf2fe55",path:"/pages/d15993/",headers:[{level:2,title:"1. 应用",slug:"_1-应用",normalizedTitle:"1. 应用",charIndex:466},{level:2,title:"2. Gossip 协议的执行过程",slug:"_2-gossip-协议的执行过程",normalizedTitle:"2. gossip 协议的执行过程",charIndex:616},{level:2,title:"3. Gossip 的特点",slug:"_3-gossip-的特点",normalizedTitle:"3. gossip 的特点",charIndex:1424},{level:3,title:"3.1. Gossip 的优点",slug:"_3-1-gossip-的优点",normalizedTitle:"3.1. gossip 的优点",charIndex:1442},{level:3,title:"3.2. Gossip 的缺陷",slug:"_3-2-gossip-的缺陷",normalizedTitle:"3.2. gossip 的缺陷",charIndex:1782},{level:2,title:"4. Gossip 类型",slug:"_4-gossip-类型",normalizedTitle:"4. gossip 类型",charIndex:2119},{level:2,title:"5. 参考资料",slug:"_5-参考资料",normalizedTitle:"5. 参考资料",charIndex:3195}],headersStr:"1. 应用 2. Gossip 协议的执行过程 3. Gossip 的特点 3.1. Gossip 的优点 3.2. Gossip 的缺陷 4. Gossip 类型 5. 参考资料",content:"# 分布式算法 Gossip\n\nGossip 也叫 Epidemic Protocol （流行病协议），这个协议基于最终一致性以及去中心化设计思想。主要用于分布式节点之间进行信息交换和数据同步，这种场景的一个最大特点就是组成的网络的节点都是对等节点，是非结构化网络（去中心化）。\n\nGossip 协议最早是在 1987 年发表在 ACM 上的论文 《Epidemic Algorithms for Replicated Database Maintenance》中被提出，其理论基础来源于流行病学的数学模型，这种场景的一个最大特点就是组成的网络的节点都是去中心化的对等节点，在信息同步过程中不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，实现最终一致性协议。\n\nGossip 协议是集群中节点相互通信的内部通信技术。 Gossip 是一种高效、轻量级、可靠的节点间广播协议，用于传播数据。它是去中心化的、“流行病”的、容错的和点对点通信协议。 Cassandra 使用八卦进行对等发现和元数据传播。\n\n\n# 1. 应用\n\n在 CASSANDRA 中，节点间使用 Gossip 协议交换信息，因此所有节点都可以快速了解集群中的所有其他节点。\n\nConsul 使用名为 SERF 的 Gossip 协议有两个作用：\n\n * 发现新节点和宕机的节点\n * 可靠且快速的事件广播，用于选举 Leader 等\n\n\n# 2. Gossip 协议的执行过程\n\nGossip 协议在概念上非常简单，代码也非常简单。它们背后的基本思想是：一个节点想要与网络中的其他节点共享一些信息。然后周期性地从节点集中随机选择一个节点并交换信息。接收信息的节点做同样的事情。信息定期发送到 N 个目标，N 称为扇出（Fanout）。\n\n循环：传播信息的回合数 扇出：一个节点在每个循环中闲聊的节点数。当一个节点想要广播一条消息时，它从系统中随机选择 t 个节点并将消息发送给它们。\n\nGossip 协议的执行过程：\n\nGossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。\n\n为了表述清楚，我们先做一些前提设定\n\n * 种子节点周期性的散播消息，把周期限定为 1 秒\n * 被感染节点随机选择 N 个邻接节点（fan-out）散播消息，这里把 fan-out 设置为 3，每次最多往 3 个节点散播。\n * 节点只接收消息不反馈结果。\n * 每次散播消息都选择尚未发送过的节点进行散播\n * 收到消息的节点不再往发送节点散播，比如 A -> B，那么 B 进行散播的时候，不再发给 A。\n\n注意：Gossip 过程是异步的，也就是说发消息的节点不会关注对方是否收到，即不等待响应；不管对方有没有收到，它都会每隔 1 秒向周围节点发消息。异步是它的优点，而消息冗余则是它的缺点。\n\nGoosip 协议的信息传播和扩散通常需要由种子节点发起。整个传播过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。\n\n\n\n\n# 3. Gossip 的特点\n\n\n# 3.1. Gossip 的优点\n\n * 扩展性：网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。\n * 容错：网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。\n * 去中心化：Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。\n * 一致性收敛：Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。\n * 简单：Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。\n\n\n# 3.2. Gossip 的缺陷\n\n分布式网络中，没有一种完美的解决方案，Gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：\n\n * 消息的延迟：由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。\n * 消息冗余：Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。\n\n\n# 4. Gossip 类型\n\nGossip 有两种类型：\n\n * Anti-Entropy(反熵)：以固定的概率传播所有的数据。Anti-Entropy 是 SI model，节点只有两种状态，Suspective 和 Infective，叫做 simple epidemics。\n * Rumor-Mongering(谣言传播)：仅传播新到达的数据。Rumor-Mongering 是 SIR model，节点有三种状态，Suspective，Infective 和 Removed，叫做 complex epidemics。\n\n熵是物理学上的一个概念，代表杂乱无章，而反熵就是在杂乱无章中寻求一致。\n\n在 SI model 下，一个节点会把所有的数据都跟其他节点共享，以便消除节点之间数据的任何不一致，它可以保证最终、完全的一致。\n\n由于在 SI model 下消息会不断反复的交换，因此消息数量是非常庞大的，无限制的（unbounded），这对一个系统来说是一个巨大的开销。\n\n但是在 Rumor Mongering（SIR Model） 模型下，消息可以发送得更频繁，因为消息只包含最新 update，体积更小。而且，一个 Rumor 消息在某个时间点之后会被标记为 removed，并且不再被传播，因此，SIR model 下，系统有一定的概率会不一致。\n\n而由于，SIR Model 下某个时间点之后消息不再传播，因此消息是有限的，系统开销小。\n\n一般来说，为了在通信代价和可靠性之间取得折中，需要将这两种方法结合使用。\n\nGossip 中的通信模式\n\n在 Gossip 协议下，网络中两个节点之间有三种通信方式:\n\n * Push: 节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据\n * Pull：A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地\n * Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地\n\n如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push/Pull 则需 3 次。虽然消息数增加了，但从效果上来讲，Push/Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的。\n\n\n# 5. 参考资料\n\n * Epidemic Algorithms for Replicated Database Maintenance\n * P2P 网络核心技术：Gossip 协议\n * INTRODUCTION TO GOSSIP\n * Goosip 协议仿真动画",normalizedContent:"# 分布式算法 gossip\n\ngossip 也叫 epidemic protocol （流行病协议），这个协议基于最终一致性以及去中心化设计思想。主要用于分布式节点之间进行信息交换和数据同步，这种场景的一个最大特点就是组成的网络的节点都是对等节点，是非结构化网络（去中心化）。\n\ngossip 协议最早是在 1987 年发表在 acm 上的论文 《epidemic algorithms for replicated database maintenance》中被提出，其理论基础来源于流行病学的数学模型，这种场景的一个最大特点就是组成的网络的节点都是去中心化的对等节点，在信息同步过程中不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，实现最终一致性协议。\n\ngossip 协议是集群中节点相互通信的内部通信技术。 gossip 是一种高效、轻量级、可靠的节点间广播协议，用于传播数据。它是去中心化的、“流行病”的、容错的和点对点通信协议。 cassandra 使用八卦进行对等发现和元数据传播。\n\n\n# 1. 应用\n\n在 cassandra 中，节点间使用 gossip 协议交换信息，因此所有节点都可以快速了解集群中的所有其他节点。\n\nconsul 使用名为 serf 的 gossip 协议有两个作用：\n\n * 发现新节点和宕机的节点\n * 可靠且快速的事件广播，用于选举 leader 等\n\n\n# 2. gossip 协议的执行过程\n\ngossip 协议在概念上非常简单，代码也非常简单。它们背后的基本思想是：一个节点想要与网络中的其他节点共享一些信息。然后周期性地从节点集中随机选择一个节点并交换信息。接收信息的节点做同样的事情。信息定期发送到 n 个目标，n 称为扇出（fanout）。\n\n循环：传播信息的回合数 扇出：一个节点在每个循环中闲聊的节点数。当一个节点想要广播一条消息时，它从系统中随机选择 t 个节点并将消息发送给它们。\n\ngossip 协议的执行过程：\n\ngossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。\n\n为了表述清楚，我们先做一些前提设定\n\n * 种子节点周期性的散播消息，把周期限定为 1 秒\n * 被感染节点随机选择 n 个邻接节点（fan-out）散播消息，这里把 fan-out 设置为 3，每次最多往 3 个节点散播。\n * 节点只接收消息不反馈结果。\n * 每次散播消息都选择尚未发送过的节点进行散播\n * 收到消息的节点不再往发送节点散播，比如 a -> b，那么 b 进行散播的时候，不再发给 a。\n\n注意：gossip 过程是异步的，也就是说发消息的节点不会关注对方是否收到，即不等待响应；不管对方有没有收到，它都会每隔 1 秒向周围节点发消息。异步是它的优点，而消息冗余则是它的缺点。\n\ngoosip 协议的信息传播和扩散通常需要由种子节点发起。整个传播过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。\n\n\n\n\n# 3. gossip 的特点\n\n\n# 3.1. gossip 的优点\n\n * 扩展性：网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。\n * 容错：网络中任何节点的宕机和重启都不会影响 gossip 消息的传播，gossip 协议具有天然的分布式系统容错特性。\n * 去中心化：gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。\n * 一致性收敛：gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logn。\n * 简单：gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。\n\n\n# 3.2. gossip 的缺陷\n\n分布式网络中，没有一种完美的解决方案，gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：\n\n * 消息的延迟：由于 gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。\n * 消息冗余：gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。\n\n\n# 4. gossip 类型\n\ngossip 有两种类型：\n\n * anti-entropy(反熵)：以固定的概率传播所有的数据。anti-entropy 是 si model，节点只有两种状态，suspective 和 infective，叫做 simple epidemics。\n * rumor-mongering(谣言传播)：仅传播新到达的数据。rumor-mongering 是 sir model，节点有三种状态，suspective，infective 和 removed，叫做 complex epidemics。\n\n熵是物理学上的一个概念，代表杂乱无章，而反熵就是在杂乱无章中寻求一致。\n\n在 si model 下，一个节点会把所有的数据都跟其他节点共享，以便消除节点之间数据的任何不一致，它可以保证最终、完全的一致。\n\n由于在 si model 下消息会不断反复的交换，因此消息数量是非常庞大的，无限制的（unbounded），这对一个系统来说是一个巨大的开销。\n\n但是在 rumor mongering（sir model） 模型下，消息可以发送得更频繁，因为消息只包含最新 update，体积更小。而且，一个 rumor 消息在某个时间点之后会被标记为 removed，并且不再被传播，因此，sir model 下，系统有一定的概率会不一致。\n\n而由于，sir model 下某个时间点之后消息不再传播，因此消息是有限的，系统开销小。\n\n一般来说，为了在通信代价和可靠性之间取得折中，需要将这两种方法结合使用。\n\ngossip 中的通信模式\n\n在 gossip 协议下，网络中两个节点之间有三种通信方式:\n\n * push: 节点 a 将数据 (key,value,version) 及对应的版本号推送给 b 节点，b 节点更新 a 中比自己新的数据\n * pull：a 仅将数据 key, version 推送给 b，b 将本地比 a 新的数据（key, value, version）推送给 a，a 更新本地\n * push/pull：与 pull 类似，只是多了一步，a 再将本地比 b 新的数据推送给 b，b 则更新本地\n\n如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push 需通信 1 次，pull 需 2 次，push/pull 则需 3 次。虽然消息数增加了，但从效果上来讲，push/pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，push/pull 的收敛速度也是最快的。\n\n\n# 5. 参考资料\n\n * epidemic algorithms for replicated database maintenance\n * p2p 网络核心技术：gossip 协议\n * introduction to gossip\n * goosip 协议仿真动画",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"流量控制",frontmatter:{title:"流量控制",categories:["分布式","分布式关键技术","流量调度"],tags:["分布式","流量调度","流量控制","限流","熔断","降级"],abbrlink:"2a553090",date:"2020-01-20T11:06:00.000Z",permalink:"/pages/282676/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/01.%E6%B5%81%E9%87%8F%E8%B0%83%E5%BA%A6/01.%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6.html",relativePath:"02.分布式/03.分布式关键技术/01.流量调度/01.流量控制.md",key:"v-1cd4c4a0",path:"/pages/282676/",headers:[{level:2,title:"1. 限流简介",slug:"_1-限流简介",normalizedTitle:"1. 限流简介",charIndex:76},{level:2,title:"2. 限流算法",slug:"_2-限流算法",normalizedTitle:"2. 限流算法",charIndex:277},{level:3,title:"2.1. 计数器法",slug:"_2-1-计数器法",normalizedTitle:"2.1. 计数器法",charIndex:289},{level:3,title:"2.2. 滑动窗口法",slug:"_2-2-滑动窗口法",normalizedTitle:"2.2. 滑动窗口法",charIndex:1873},{level:3,title:"2.3. 漏桶法",slug:"_2-3-漏桶法",normalizedTitle:"2.3. 漏桶法",charIndex:5061},{level:3,title:"2.4. 令牌桶法",slug:"_2-4-令牌桶法",normalizedTitle:"2.4. 令牌桶法",charIndex:5939},{level:2,title:"3. 限流工具",slug:"_3-限流工具",normalizedTitle:"3. 限流工具",charIndex:8224},{level:2,title:"4. 参考资料",slug:"_4-参考资料",normalizedTitle:"4. 参考资料",charIndex:8445}],headersStr:"1. 限流简介 2. 限流算法 2.1. 计数器法 2.2. 滑动窗口法 2.3. 漏桶法 2.4. 令牌桶法 3. 限流工具 4. 参考资料",content:'# 流量控制\n\n> 在高并发场景下，为了应对瞬时海量请求的压力，保障系统的平稳运行，必须预估系统的流量阈值，通过限流规则阻断处理不过来的请求。\n\n\n# 1. 限流简介\n\n限流可以认为是服务降级的一种。限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。\n\n限流规则包含三个部分：时间粒度，接口粒度，最大限流值。限流规则设置是否合理直接影响到限流是否合理有效。\n\n\n# 2. 限流算法\n\n\n# 2.1. 计数器法\n\n\n\n计数器法的原理是：设置一个计数器，用于统计指定时间段内的请求数量，并在指定时间段之后重置计数器。在这个过程中，如果请求量超过限定的阈值，则拒绝请求。\n\n这种算法的缺陷是：这种算法是针对一个时间段进行统计，如果请求分布不均匀，极端情况下，所有请求都在某一刻收到，还是可能压垮系统。例如，假设我们限流规则为每秒钟不超过 100 次接口请求，第一个 1s 时间窗口内，100 次接口请求都集中在最后的 10ms 内，在第二个 1s 的时间窗口内，100 次接口请求都集中在最开始的 10ms 内，虽然两个时间窗口内流量都符合限流要求，但是在这两个时间窗口临界的 20ms 内会集中有 200 次接口请求，如果不做限流，集中在这 20ms 内的 200 次请求就有可能压垮系统。\n\n【示例】使用 AtomicInteger 实现计数器法\n\npublic class Counter {\n    /**\n     * 最大访问数量\n     */\n    private final int limit = 10;\n    /**\n     * 访问时间差\n     */\n    private final long timeout = 1000;\n    /**\n     * 请求时间\n     */\n    private long time;\n    /**\n     * 当前计数器\n     */\n    private AtomicInteger reqCount = new AtomicInteger(0);\n\n    public boolean limit() {\n        long now = System.currentTimeMillis();\n        if (now < time + timeout) {\n            // 单位时间内\n            reqCount.addAndGet(1);\n            return reqCount.get() <= limit;\n        } else {\n            // 超出单位时间\n            time = now;\n            reqCount = new AtomicInteger(0);\n            return true;\n        }\n    }\n}\n\n\n【示例】基于 Redis Lua 计数限流算法的实现\n\n-- 实现原理\n-- 每次请求都将当前时间，精确到秒作为 key 放入 Redis 中，超时时间设置为 2s， Redis 将该 key 的值进行自增\n-- 当达到阈值时返回错误，表示请求被限流\n-- 写入 Redis 的操作用 Lua 脚本来完成，利用 Redis 的单线程机制可以保证每个 Redis 请求的原子性\n\n-- 资源唯一标志位\nlocal key = KEYS[1]\n-- 限流大小\nlocal limit = tonumber(ARGV[1])\n\n-- 获取当前流量大小\nlocal currentLimit = tonumber(redis.call(\'get\', key) or "0")\n\nif currentLimit + 1 > limit then\n    -- 达到限流大小 返回\n    return 0;\nelse\n    -- 没有达到阈值 value + 1\n    redis.call("INCRBY", key, 1)\n    -- 设置过期时间\n    redis.call("EXPIRE", key, 2)\n    return currentLimit + 1\nend\n\n\n\n# 2.2. 滑动窗口法\n\n\n\n滑动窗口法的原理：\n\n滑动窗口法是计数器算法的一种改进，增加一个时间粒度的度量单位，将原来的一个时间窗口划分成多个时间窗口，并且不断向右滑动该窗口。流量经过滑动时间窗口算法整形之后，可以保证任意时间窗口内，都不会超过最大允许的限流值，从流量曲线上来看会更加平滑，可以部分解决上面提到的临界突发流量问题。\n\n对比固定时间窗口限流算法，滑动时间窗口限流算法的时间窗口是持续滑动的，并且除了需要一个计数器来记录时间窗口内接口请求次数之外，还需要记录在时间窗口内每个接口请求到达的时间点，对内存的占用会比较多。 在临界位置的突发请求都会被算到时间窗口内，因此可以解决计数器算法的临界问题，\n\n比如在上文的例子中，通过滑动窗口算法整型后，第一个 1s 的时间窗口的 100 次请求都会通过，第二个时间窗口最开始的 10ms 内的 100 个请求都会被限流熔断。\n\n滑动窗口法的缺陷：基于时间窗口的限流算法，只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。\n\nimport java.util.Iterator;\nimport java.util.Random;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.stream.IntStream;\n\npublic class TimeWindow {\n    private ConcurrentLinkedQueue<Long> queue = new ConcurrentLinkedQueue<Long>();\n\n    /**\n     * 间隔秒数\n     */\n    private int seconds;\n\n    /**\n     * 最大限流\n     */\n    private int max;\n\n    public TimeWindow(int max, int seconds) {\n        this.seconds = seconds;\n        this.max = max;\n\n        /**\n         * 永续线程执行清理queue 任务\n         */\n        new Thread(() -> {\n            while (true) {\n                try {\n                    // 等待 间隔秒数-1 执行清理操作\n                    Thread.sleep((seconds - 1) * 1000L);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                clean();\n            }\n        }).start();\n\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        final TimeWindow timeWindow = new TimeWindow(10, 1);\n\n        // 测试3个线程\n        IntStream.range(0, 3).forEach((i) -> {\n            new Thread(() -> {\n\n                while (true) {\n\n                    try {\n                        Thread.sleep(new Random().nextInt(20) * 100);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    timeWindow.take();\n                }\n\n            }).start();\n\n        });\n\n    }\n\n    /**\n     * 获取令牌，并且添加时间\n     */\n    public void take() {\n\n\n        long start = System.currentTimeMillis();\n        try {\n\n\n            int size = sizeOfValid();\n            if (size > max) {\n                System.err.println("超限");\n\n            }\n            synchronized (queue) {\n                if (sizeOfValid() > max) {\n                    System.err.println("超限");\n                    System.err.println("queue中有 " + queue.size() + " 最大数量 " + max);\n                }\n                this.queue.offer(System.currentTimeMillis());\n            }\n            System.out.println("queue中有 " + queue.size() + " 最大数量 " + max);\n\n        }\n\n    }\n\n\n    public int sizeOfValid() {\n        Iterator<Long> it = queue.iterator();\n        Long ms = System.currentTimeMillis() - seconds * 1000;\n        int count = 0;\n        while (it.hasNext()) {\n            long t = it.next();\n            if (t > ms) {\n                // 在当前的统计时间范围内\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n\n    /**\n     * 清理过期的时间\n     */\n    public void clean() {\n        Long c = System.currentTimeMillis() - seconds * 1000;\n\n        Long tl = null;\n        while ((tl = queue.peek()) != null && tl < c) {\n            System.out.println("清理数据");\n            queue.poll();\n        }\n    }\n\n}\n\n\n\n# 2.3. 漏桶法\n\n\n\n漏桶算法内部有一个容器，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。\n\n漏桶算法的本质是，不管理请求量有多大，处理请求的速度始终是固定的。这种模式类似生活中的漏斗，上宽下窄。请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在漏斗里。漏斗本身也有容量上限，如果桶满了，那么新进来的请求就丢弃。\n\n漏桶算法的优点是：这种策略的好处是，做到了流量整形，即无论流量多大，即便是突发的大流量，输出依旧是一个稳定的流量。\n\n漏桶算法的缺点是：无法应对短时间的突刺流量。\n\n漏桶策略适用于间隔性突发流量且流量不用即时处理的场景。\n\n【示例】漏桶法实现\n\npublic class LeakBucket {\n    /**\n     * 时间\n     */\n    private long time;\n    /**\n     * 总量\n     */\n    private Double total;\n    /**\n     * 水流出去的速度\n     */\n    private Double rate;\n    /**\n     * 当前总量\n     */\n    private Double nowSize;\n\n\n    public boolean limit() {\n        long now = System.currentTimeMillis();\n        nowSize = Math.max(0, (nowSize - (now - time) * rate));\n        time = now;\n        if ((nowSize + 1) < total) {\n            nowSize++;\n            return true;\n        } else {\n            return false;\n        }\n\n    }\n}\n\n\n\n# 2.4. 令牌桶法\n\n\n\n令牌桶算法的原理：\n\n 1. 接口限制 T 秒内最大访问次数为 N，则每隔 T/N 秒会放一个 token 到桶中\n 2. 桶内最多存放 M 个 token，如果 token 到达时令牌桶已经满了，那么这个 token 就会被丢弃\n 3. 接口请求会先从令牌桶中取 token，拿到 token 则处理接口请求，拿不到 token 则进行限流处理\n\n因为令牌桶存放了很多令牌，那么大量的突发请求会被执行，但是它不会出现临界问题，在令牌用完之后，令牌是以一个恒定的速率添加到令牌桶中的，因此不能再次发送大量突发请求。\n\n规定固定容量的桶，token 以固定速度往桶内填充，当桶满时 token 不会被继续放入，每过来一个请求把 token 从桶中移除,如果桶中没有 token 不能请求。\n\n令牌桶算法适用于有突发特性的流量，且流量需要即时处理的场景。\n\n【示例】Java 实现令牌桶算法\n\npublic class TokenBucket {\n    /**\n     * 时间\n     */\n    private long time;\n    /**\n     * 总量\n     */\n    private Double total;\n    /**\n     * token 放入速度\n     */\n    private Double rate;\n    /**\n     * 当前总量\n     */\n    private Double nowSize;\n\n\n    public boolean limit() {\n        long now = System.currentTimeMillis();\n        nowSize = Math.min(total, nowSize + (now - time) * rate);\n        time = now;\n        if (nowSize < 1) {\n            // 桶里没有token\n            return false;\n        } else {\n            // 存在token\n            nowSize -= 1;\n            return true;\n        }\n    }\n}\n\n\n【示例】基于 Redis Lua 令牌桶限流算法实现\n\n-- 令牌桶限流\n\n-- 令牌的唯一标识\nlocal bucketKey = KEYS[1]\n-- 上次请求的时间\nlocal last_mill_request_key = KEYS[2]\n-- 令牌桶的容量\nlocal limit = tonumber(ARGV[1])\n-- 请求令牌的数量\nlocal permits = tonumber(ARGV[2])\n-- 令牌流入的速率\nlocal rate = tonumber(ARGV[3])\n-- 当前时间\nlocal curr_mill_time = tonumber(ARGV[4])\n\n-- 添加令牌\n\n-- 获取当前令牌的数量\nlocal current_limit = tonumber(redis.call(\'get\', bucketKey) or "0")\n-- 获取上次请求的时间\nlocal last_mill_request_time = tonumber(redis.call(\'get\', last_mill_request_key) or "0")\n-- 计算向桶里添加令牌的数量\nif last_mill_request_time == 0 then\n\t-- 令牌桶初始化\n\t-- 更新上次请求时间\n\tredis.call("HSET", last_mill_request_key, curr_mill_time)\n\treturn 0\nelse\n\tlocal add_token_num = math.floor((curr_mill_time - last_mill_request_time) * rate)\nend\n\n-- 更新令牌的数量\nif current_limit + add_token_num > limit then\n    current_limit = limit\nelse\n\tcurrent_limit = current_limit + add_token_num\nend\n\tredis.pcall("HSET",bucketKey, current_limit)\n-- 设置过期时间\nredis.call("EXPIRE", bucketKey, 2)\n\n-- 限流判断\n\nif current_limit - permits < 1 then\n    -- 达到限流大小\n    return 0\nelse\n    -- 没有达到限流大小\n\tcurrent_limit = current_limit - permits\n\tredis.pcall("HSET", bucketKey, current_limit)\n    -- 设置过期时间\n    redis.call("EXPIRE", bucketKey, 2)\n\t-- 更新上次请求的时间\n\tredis.call("HSET", last_mill_request_key, curr_mill_time)\nend\n\n\n\n# 3. 限流工具\n\n前面介绍了限流算法的基本原理和一些简单的实现。但在生产环境，我们一般应该使用更成熟的限流工具。\n\n * Guava 的 RateLimiter：RateLimiter 基于漏桶算法，但它参考了令牌桶算法。具体用法可以参考：RateLimiter 基于漏桶算法，但它参考了令牌桶算法\n * Hystrix：经典的限流、熔断工具，很值得借鉴学习。注：官方已停止发布版本。\n * Sentinel：阿里的限流、熔断工具。\n\n\n# 4. 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * 谈谈限流算法的几种实现\n * 如何限流？在工作中是怎么做的？说一下具体的实现？\n * 浅析限流算法\n * RateLimiter 基于漏桶算法，但它参考了令牌桶算法',normalizedContent:'# 流量控制\n\n> 在高并发场景下，为了应对瞬时海量请求的压力，保障系统的平稳运行，必须预估系统的流量阈值，通过限流规则阻断处理不过来的请求。\n\n\n# 1. 限流简介\n\n限流可以认为是服务降级的一种。限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。\n\n限流规则包含三个部分：时间粒度，接口粒度，最大限流值。限流规则设置是否合理直接影响到限流是否合理有效。\n\n\n# 2. 限流算法\n\n\n# 2.1. 计数器法\n\n\n\n计数器法的原理是：设置一个计数器，用于统计指定时间段内的请求数量，并在指定时间段之后重置计数器。在这个过程中，如果请求量超过限定的阈值，则拒绝请求。\n\n这种算法的缺陷是：这种算法是针对一个时间段进行统计，如果请求分布不均匀，极端情况下，所有请求都在某一刻收到，还是可能压垮系统。例如，假设我们限流规则为每秒钟不超过 100 次接口请求，第一个 1s 时间窗口内，100 次接口请求都集中在最后的 10ms 内，在第二个 1s 的时间窗口内，100 次接口请求都集中在最开始的 10ms 内，虽然两个时间窗口内流量都符合限流要求，但是在这两个时间窗口临界的 20ms 内会集中有 200 次接口请求，如果不做限流，集中在这 20ms 内的 200 次请求就有可能压垮系统。\n\n【示例】使用 atomicinteger 实现计数器法\n\npublic class counter {\n    /**\n     * 最大访问数量\n     */\n    private final int limit = 10;\n    /**\n     * 访问时间差\n     */\n    private final long timeout = 1000;\n    /**\n     * 请求时间\n     */\n    private long time;\n    /**\n     * 当前计数器\n     */\n    private atomicinteger reqcount = new atomicinteger(0);\n\n    public boolean limit() {\n        long now = system.currenttimemillis();\n        if (now < time + timeout) {\n            // 单位时间内\n            reqcount.addandget(1);\n            return reqcount.get() <= limit;\n        } else {\n            // 超出单位时间\n            time = now;\n            reqcount = new atomicinteger(0);\n            return true;\n        }\n    }\n}\n\n\n【示例】基于 redis lua 计数限流算法的实现\n\n-- 实现原理\n-- 每次请求都将当前时间，精确到秒作为 key 放入 redis 中，超时时间设置为 2s， redis 将该 key 的值进行自增\n-- 当达到阈值时返回错误，表示请求被限流\n-- 写入 redis 的操作用 lua 脚本来完成，利用 redis 的单线程机制可以保证每个 redis 请求的原子性\n\n-- 资源唯一标志位\nlocal key = keys[1]\n-- 限流大小\nlocal limit = tonumber(argv[1])\n\n-- 获取当前流量大小\nlocal currentlimit = tonumber(redis.call(\'get\', key) or "0")\n\nif currentlimit + 1 > limit then\n    -- 达到限流大小 返回\n    return 0;\nelse\n    -- 没有达到阈值 value + 1\n    redis.call("incrby", key, 1)\n    -- 设置过期时间\n    redis.call("expire", key, 2)\n    return currentlimit + 1\nend\n\n\n\n# 2.2. 滑动窗口法\n\n\n\n滑动窗口法的原理：\n\n滑动窗口法是计数器算法的一种改进，增加一个时间粒度的度量单位，将原来的一个时间窗口划分成多个时间窗口，并且不断向右滑动该窗口。流量经过滑动时间窗口算法整形之后，可以保证任意时间窗口内，都不会超过最大允许的限流值，从流量曲线上来看会更加平滑，可以部分解决上面提到的临界突发流量问题。\n\n对比固定时间窗口限流算法，滑动时间窗口限流算法的时间窗口是持续滑动的，并且除了需要一个计数器来记录时间窗口内接口请求次数之外，还需要记录在时间窗口内每个接口请求到达的时间点，对内存的占用会比较多。 在临界位置的突发请求都会被算到时间窗口内，因此可以解决计数器算法的临界问题，\n\n比如在上文的例子中，通过滑动窗口算法整型后，第一个 1s 的时间窗口的 100 次请求都会通过，第二个时间窗口最开始的 10ms 内的 100 个请求都会被限流熔断。\n\n滑动窗口法的缺陷：基于时间窗口的限流算法，只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。\n\nimport java.util.iterator;\nimport java.util.random;\nimport java.util.concurrent.concurrentlinkedqueue;\nimport java.util.stream.intstream;\n\npublic class timewindow {\n    private concurrentlinkedqueue<long> queue = new concurrentlinkedqueue<long>();\n\n    /**\n     * 间隔秒数\n     */\n    private int seconds;\n\n    /**\n     * 最大限流\n     */\n    private int max;\n\n    public timewindow(int max, int seconds) {\n        this.seconds = seconds;\n        this.max = max;\n\n        /**\n         * 永续线程执行清理queue 任务\n         */\n        new thread(() -> {\n            while (true) {\n                try {\n                    // 等待 间隔秒数-1 执行清理操作\n                    thread.sleep((seconds - 1) * 1000l);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n                clean();\n            }\n        }).start();\n\n    }\n\n    public static void main(string[] args) throws exception {\n\n        final timewindow timewindow = new timewindow(10, 1);\n\n        // 测试3个线程\n        intstream.range(0, 3).foreach((i) -> {\n            new thread(() -> {\n\n                while (true) {\n\n                    try {\n                        thread.sleep(new random().nextint(20) * 100);\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n                    timewindow.take();\n                }\n\n            }).start();\n\n        });\n\n    }\n\n    /**\n     * 获取令牌，并且添加时间\n     */\n    public void take() {\n\n\n        long start = system.currenttimemillis();\n        try {\n\n\n            int size = sizeofvalid();\n            if (size > max) {\n                system.err.println("超限");\n\n            }\n            synchronized (queue) {\n                if (sizeofvalid() > max) {\n                    system.err.println("超限");\n                    system.err.println("queue中有 " + queue.size() + " 最大数量 " + max);\n                }\n                this.queue.offer(system.currenttimemillis());\n            }\n            system.out.println("queue中有 " + queue.size() + " 最大数量 " + max);\n\n        }\n\n    }\n\n\n    public int sizeofvalid() {\n        iterator<long> it = queue.iterator();\n        long ms = system.currenttimemillis() - seconds * 1000;\n        int count = 0;\n        while (it.hasnext()) {\n            long t = it.next();\n            if (t > ms) {\n                // 在当前的统计时间范围内\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n\n    /**\n     * 清理过期的时间\n     */\n    public void clean() {\n        long c = system.currenttimemillis() - seconds * 1000;\n\n        long tl = null;\n        while ((tl = queue.peek()) != null && tl < c) {\n            system.out.println("清理数据");\n            queue.poll();\n        }\n    }\n\n}\n\n\n\n# 2.3. 漏桶法\n\n\n\n漏桶算法内部有一个容器，当请求进来时，相当于水倒入漏斗，然后从下端小口慢慢匀速的流出。不管上面流量多大，下面流出的速度始终保持不变。\n\n漏桶算法的本质是，不管理请求量有多大，处理请求的速度始终是固定的。这种模式类似生活中的漏斗，上宽下窄。请求进来的速度是未知的，可能突然进来很多请求，没来得及处理的请求就先放在漏斗里。漏斗本身也有容量上限，如果桶满了，那么新进来的请求就丢弃。\n\n漏桶算法的优点是：这种策略的好处是，做到了流量整形，即无论流量多大，即便是突发的大流量，输出依旧是一个稳定的流量。\n\n漏桶算法的缺点是：无法应对短时间的突刺流量。\n\n漏桶策略适用于间隔性突发流量且流量不用即时处理的场景。\n\n【示例】漏桶法实现\n\npublic class leakbucket {\n    /**\n     * 时间\n     */\n    private long time;\n    /**\n     * 总量\n     */\n    private double total;\n    /**\n     * 水流出去的速度\n     */\n    private double rate;\n    /**\n     * 当前总量\n     */\n    private double nowsize;\n\n\n    public boolean limit() {\n        long now = system.currenttimemillis();\n        nowsize = math.max(0, (nowsize - (now - time) * rate));\n        time = now;\n        if ((nowsize + 1) < total) {\n            nowsize++;\n            return true;\n        } else {\n            return false;\n        }\n\n    }\n}\n\n\n\n# 2.4. 令牌桶法\n\n\n\n令牌桶算法的原理：\n\n 1. 接口限制 t 秒内最大访问次数为 n，则每隔 t/n 秒会放一个 token 到桶中\n 2. 桶内最多存放 m 个 token，如果 token 到达时令牌桶已经满了，那么这个 token 就会被丢弃\n 3. 接口请求会先从令牌桶中取 token，拿到 token 则处理接口请求，拿不到 token 则进行限流处理\n\n因为令牌桶存放了很多令牌，那么大量的突发请求会被执行，但是它不会出现临界问题，在令牌用完之后，令牌是以一个恒定的速率添加到令牌桶中的，因此不能再次发送大量突发请求。\n\n规定固定容量的桶，token 以固定速度往桶内填充，当桶满时 token 不会被继续放入，每过来一个请求把 token 从桶中移除,如果桶中没有 token 不能请求。\n\n令牌桶算法适用于有突发特性的流量，且流量需要即时处理的场景。\n\n【示例】java 实现令牌桶算法\n\npublic class tokenbucket {\n    /**\n     * 时间\n     */\n    private long time;\n    /**\n     * 总量\n     */\n    private double total;\n    /**\n     * token 放入速度\n     */\n    private double rate;\n    /**\n     * 当前总量\n     */\n    private double nowsize;\n\n\n    public boolean limit() {\n        long now = system.currenttimemillis();\n        nowsize = math.min(total, nowsize + (now - time) * rate);\n        time = now;\n        if (nowsize < 1) {\n            // 桶里没有token\n            return false;\n        } else {\n            // 存在token\n            nowsize -= 1;\n            return true;\n        }\n    }\n}\n\n\n【示例】基于 redis lua 令牌桶限流算法实现\n\n-- 令牌桶限流\n\n-- 令牌的唯一标识\nlocal bucketkey = keys[1]\n-- 上次请求的时间\nlocal last_mill_request_key = keys[2]\n-- 令牌桶的容量\nlocal limit = tonumber(argv[1])\n-- 请求令牌的数量\nlocal permits = tonumber(argv[2])\n-- 令牌流入的速率\nlocal rate = tonumber(argv[3])\n-- 当前时间\nlocal curr_mill_time = tonumber(argv[4])\n\n-- 添加令牌\n\n-- 获取当前令牌的数量\nlocal current_limit = tonumber(redis.call(\'get\', bucketkey) or "0")\n-- 获取上次请求的时间\nlocal last_mill_request_time = tonumber(redis.call(\'get\', last_mill_request_key) or "0")\n-- 计算向桶里添加令牌的数量\nif last_mill_request_time == 0 then\n\t-- 令牌桶初始化\n\t-- 更新上次请求时间\n\tredis.call("hset", last_mill_request_key, curr_mill_time)\n\treturn 0\nelse\n\tlocal add_token_num = math.floor((curr_mill_time - last_mill_request_time) * rate)\nend\n\n-- 更新令牌的数量\nif current_limit + add_token_num > limit then\n    current_limit = limit\nelse\n\tcurrent_limit = current_limit + add_token_num\nend\n\tredis.pcall("hset",bucketkey, current_limit)\n-- 设置过期时间\nredis.call("expire", bucketkey, 2)\n\n-- 限流判断\n\nif current_limit - permits < 1 then\n    -- 达到限流大小\n    return 0\nelse\n    -- 没有达到限流大小\n\tcurrent_limit = current_limit - permits\n\tredis.pcall("hset", bucketkey, current_limit)\n    -- 设置过期时间\n    redis.call("expire", bucketkey, 2)\n\t-- 更新上次请求的时间\n\tredis.call("hset", last_mill_request_key, curr_mill_time)\nend\n\n\n\n# 3. 限流工具\n\n前面介绍了限流算法的基本原理和一些简单的实现。但在生产环境，我们一般应该使用更成熟的限流工具。\n\n * guava 的 ratelimiter：ratelimiter 基于漏桶算法，但它参考了令牌桶算法。具体用法可以参考：ratelimiter 基于漏桶算法，但它参考了令牌桶算法\n * hystrix：经典的限流、熔断工具，很值得借鉴学习。注：官方已停止发布版本。\n * sentinel：阿里的限流、熔断工具。\n\n\n# 4. 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * 谈谈限流算法的几种实现\n * 如何限流？在工作中是怎么做的？说一下具体的实现？\n * 浅析限流算法\n * ratelimiter 基于漏桶算法，但它参考了令牌桶算法',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"深入浅出负载均衡",frontmatter:{title:"深入浅出负载均衡",categories:["分布式","分布式关键技术","流量调度"],tags:["分布式","流量调度","负载均衡"],abbrlink:"7f98a6d0",date:"2018-07-05T15:50:00.000Z",permalink:"/pages/b7ca44/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/01.%E6%B5%81%E9%87%8F%E8%B0%83%E5%BA%A6/02.%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html",relativePath:"02.分布式/03.分布式关键技术/01.流量调度/02.负载均衡.md",key:"v-af744166",path:"/pages/b7ca44/",headers:[{level:2,title:"1. 负载均衡简介",slug:"_1-负载均衡简介",normalizedTitle:"1. 负载均衡简介",charIndex:17},{level:3,title:"1.1. 大型网站面临的挑战",slug:"_1-1-大型网站面临的挑战",normalizedTitle:"1.1. 大型网站面临的挑战",charIndex:31},{level:3,title:"1.2. 什么是负载均衡",slug:"_1-2-什么是负载均衡",normalizedTitle:"1.2. 什么是负载均衡",charIndex:438},{level:2,title:"2. 负载均衡的分类",slug:"_2-负载均衡的分类",normalizedTitle:"2. 负载均衡的分类",charIndex:783},{level:3,title:"2.1. 载体维度分类",slug:"_2-1-载体维度分类",normalizedTitle:"2.1. 载体维度分类",charIndex:828},{level:4,title:"硬件负载均衡",slug:"硬件负载均衡",normalizedTitle:"硬件负载均衡",charIndex:871},{level:4,title:"软件负载均衡",slug:"软件负载均衡",normalizedTitle:"软件负载均衡",charIndex:881},{level:3,title:"2.2. 网络通信分类",slug:"_2-2-网络通信分类",normalizedTitle:"2.2. 网络通信分类",charIndex:1536},{level:4,title:"DNS 负载均衡",slug:"dns-负载均衡",normalizedTitle:"dns 负载均衡",charIndex:1729},{level:4,title:"HTTP 负载均衡",slug:"http-负载均衡",normalizedTitle:"http 负载均衡",charIndex:2482},{level:4,title:"反向代理负载均衡",slug:"反向代理负载均衡",normalizedTitle:"反向代理负载均衡",charIndex:2776},{level:4,title:"IP 负载均衡",slug:"ip-负载均衡",normalizedTitle:"ip 负载均衡",charIndex:3611},{level:4,title:"数据链路层负载均衡",slug:"数据链路层负载均衡",normalizedTitle:"数据链路层负载均衡",charIndex:3932},{level:2,title:"3. 负载均衡算法",slug:"_3-负载均衡算法",normalizedTitle:"3. 负载均衡算法",charIndex:4618},{level:3,title:"3.1. 随机",slug:"_3-1-随机",normalizedTitle:"3.1. 随机",charIndex:5061},{level:4,title:"随机算法",slug:"随机算法",normalizedTitle:"随机算法",charIndex:5072},{level:4,title:"加权随机算法",slug:"加权随机算法",normalizedTitle:"加权随机算法",charIndex:6264},{level:3,title:"3.2. 轮询",slug:"_3-2-轮询",normalizedTitle:"3.2. 轮询",charIndex:7247},{level:4,title:"轮询算法",slug:"轮询算法",normalizedTitle:"轮询算法",charIndex:7258},{level:4,title:"加权轮询算法",slug:"加权轮询算法",normalizedTitle:"加权轮询算法",charIndex:7943},{level:3,title:"3.3. 最小活跃数",slug:"_3-3-最小活跃数",normalizedTitle:"3.3. 最小活跃数",charIndex:12853},{level:3,title:"3.4. 哈希",slug:"_3-4-哈希",normalizedTitle:"3.4. 哈希",charIndex:16332},{level:3,title:"3.5. 一致性哈希",slug:"_3-5-一致性哈希",normalizedTitle:"3.5. 一致性哈希",charIndex:16991},{level:2,title:"4. 参考资料",slug:"_4-参考资料",normalizedTitle:"4. 参考资料",charIndex:21807}],headersStr:"1. 负载均衡简介 1.1. 大型网站面临的挑战 1.2. 什么是负载均衡 2. 负载均衡的分类 2.1. 载体维度分类 硬件负载均衡 软件负载均衡 2.2. 网络通信分类 DNS 负载均衡 HTTP 负载均衡 反向代理负载均衡 IP 负载均衡 数据链路层负载均衡 3. 负载均衡算法 3.1. 随机 随机算法 加权随机算法 3.2. 轮询 轮询算法 加权轮询算法 3.3. 最小活跃数 3.4. 哈希 3.5. 一致性哈希 4. 参考资料",content:'# 深入浅出负载均衡\n\n\n\n\n# 1. 负载均衡简介\n\n\n# 1.1. 大型网站面临的挑战\n\n大型网站都要面对庞大的用户量，高并发，海量数据等挑战。\n\n为了提升系统整体的性能，可以采用垂直扩展和水平扩展两种方式。\n\n * 垂直扩展：在网站发展早期，可以从单机的角度通过增加硬件处理能力，比如 CPU 处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升。但是，单机是有性能瓶颈的，一旦触及瓶颈，再想提升，付出的成本和代价会极高。这显然不能满足大型分布式系统（网站）所有应对的大流量，高并发，海量数据等挑战。\n * 水平扩展：通过集群来分担大型网站的流量。集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点，这些节点共同分担访问压力。水平扩展有两个要点：\n   * 应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据。\n   * 负载均衡：将用户访问请求，通过某种算法，分发到集群中的节点。\n\n\n# 1.2. 什么是负载均衡\n\n负载均衡（Load Balance，简称 LB）是高并发、高可用系统必不可少的关键组件，目标是 尽力将网络流量平均分发到多个服务器上，以提高系统整体的响应速度和可用性。\n\n负载均衡的主要作用如下：\n\n * 高并发：负载均衡通过算法调整负载，尽力均匀的分配应用集群中各节点的工作量，以此提高应用集群的并发处理能力（吞吐量）。\n * 伸缩性：添加或减少服务器数量，然后由负载均衡进行分发控制。这使得应用集群具备伸缩性。\n * 高可用：负载均衡器可以监控候选服务器，当服务器不可用时，自动跳过，将请求分发给可用的服务器。这使得应用集群具备高可用的特性。\n * 安全防护：有些负载均衡软件或硬件提供了安全性功能，如：黑白名单处理、防火墙，防 DDos 攻击等。\n\n\n# 2. 负载均衡的分类\n\n支持负载均衡的技术很多，我们可以通过不同维度去进行分类。\n\n\n# 2.1. 载体维度分类\n\n从支持负载均衡的载体来看，可以将负载均衡分为两类：\n\n * 硬件负载均衡\n * 软件负载均衡\n\n# 硬件负载均衡\n\n硬件负载均衡，一般是在定制处理器上运行的独立负载均衡服务器，价格昂贵，土豪专属。\n\n硬件负载均衡的 主流产品 有：F5 和 A10。\n\n硬件负载均衡的 优点：\n\n * 功能强大：支持全局负载均衡并提供较全面的、复杂的负载均衡算法。\n * 性能强悍：硬件负载均衡由于是在专用处理器上运行，因此吞吐量大，可支持单机百万以上的并发。\n * 安全性高：往往具备防火墙，防 DDos 攻击等安全功能。\n\n硬件负载均衡的 缺点：\n\n * 成本昂贵：购买和维护硬件负载均衡的成本都很高。\n * 扩展性差：当访问量突增时，超过限度不能动态扩容。\n\n# 软件负载均衡\n\n软件负载均衡，应用最广泛，无论大公司还是小公司都会使用。\n\n软件负载均衡从软件层面实现负载均衡，一般可以在任何标准物理设备上运行。\n\n软件负载均衡的 主流产品 有：Nginx、HAProxy、LVS。\n\n * LVS 可以作为四层负载均衡器。其负载均衡的性能要优于 Nginx。\n * HAProxy 可以作为 HTTP 和 TCP 负载均衡器。\n * Nginx、HAProxy 可以作为四层或七层负载均衡器。\n\n软件负载均衡的 优点：\n\n * 扩展性好：适应动态变化，可以通过添加软件负载均衡实例，动态扩展到超出初始容量的能力。\n * 成本低廉：软件负载均衡可以在任何标准物理设备上运行，降低了购买和运维的成本。\n\n软件负载均衡的 缺点：\n\n * 性能略差：相比于硬件负载均衡，软件负载均衡的性能要略低一些。\n\n\n# 2.2. 网络通信分类\n\n软件负载均衡从通信层面来看，又可以分为四层和七层负载均衡。\n\n * 七层负载均衡：就是可以根据访问用户的 HTTP 请求头、URL 信息将请求转发到特定的主机。\n   * DNS 重定向\n   * HTTP 重定向\n   * 反向代理\n * 四层负载均衡：基于 IP 地址和端口进行请求的转发。\n   * 修改 IP 地址\n   * 修改 MAC 地址\n\n# DNS 负载均衡\n\nDNS 负载均衡一般用于互联网公司，复杂的业务系统不适合使用。大型网站一般使用 DNS 负载均衡作为 第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。DNS 负载均衡属于七层负载均衡。\n\nDNS 即 域名解析服务，是 OSI 第七层网络协议。DNS 被设计为一个树形结构的分布式应用，自上而下依次为：根域名服务器，一级域名服务器，二级域名服务器，... ，本地域名服务器。显然，如果所有数据都存储在根域名服务器，那么 DNS 查询的负载和开销会非常庞大。\n\n因此，DNS 查询相对于 DNS 层级结构，是一个逆向的递归流程，DNS 客户端依次请求本地 DNS 服务器，上一级 DNS 服务器，上上一级 DNS 服务器，... ，根 DNS 服务器（又叫权威 DNS 服务器），一旦命中，立即返回。为了减少查询次数，每一级 DNS 服务器都会设置 DNS 查询缓存。\n\nDNS 负载均衡的工作原理就是：基于 DNS 查询缓存，按照负载情况返回不同服务器的 IP 地址。\n\n\n\nDNS 重定向的 优点：\n\n * 使用简单：负载均衡工作，交给 DNS 服务器处理，省掉了负载均衡服务器维护的麻烦\n * 提高性能：可以支持基于地址的域名解析，解析成距离用户最近的服务器地址（类似 CDN 的原理），可以加快访问速度，改善性能；\n\nDNS 重定向的 缺点：\n\n * 可用性差：DNS 解析是多级解析，新增/修改 DNS 后，解析时间较长；解析过程中，用户访问网站将失败；\n * 扩展性低：DNS 负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展；\n * 维护性差：也不能反映服务器的当前运行状态；支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载）\n\n# HTTP 负载均衡\n\nHTTP 负载均衡是基于 HTTP 重定向实现的。HTTP 负载均衡属于七层负载均衡。\n\nHTTP 重定向原理是：根据用户的 HTTP 请求计算出一个真实的服务器地址，将该服务器地址写入 HTTP 重定向响应中，返回给浏览器，由浏览器重新进行访问。\n\n\n\nHTTP 重定向的 优点：方案简单。\n\nHTTP 重定向的 缺点：\n\n * 性能较差：每次访问需要两次请求服务器，增加了访问的延迟。\n * 降低搜索排名：使用重定向后，搜索引擎会视为 SEO 作弊。\n * 如果负载均衡器宕机，就无法访问该站点。\n\n由于其缺点比较明显，所以这种负载均衡策略实际应用较少。\n\n# 反向代理负载均衡\n\n反向代理（Reverse Proxy）方式是指以 代理服务器 来接受网络请求，然后 将请求转发给内网中的服务器，并将从内网中的服务器上得到的结果返回给网络请求的客户端。反向代理负载均衡属于七层负载均衡。\n\n反向代理服务的主流产品：Nginx、Apache。\n\n正向代理与反向代理有什么区别？\n\n * 正向代理：发生在 客户端，是由用户主动发起的。翻墙软件就是典型的正向代理，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。\n * 反向代理：发生在 服务端，用户不知道代理的存在。\n\n\n\n反向代理是如何实现负载均衡的呢？以 Nginx 为例，如下所示：\n\n\n\n首先，在代理服务器上设定好负载均衡规则。然后，当收到客户端请求，反向代理服务器拦截指定的域名或 IP 请求，根据负载均衡算法，将请求分发到候选服务器上。其次，如果某台候选服务器宕机，反向代理服务器会有容错处理，比如分发请求失败 3 次以上，将请求分发到其他候选服务器上。\n\n反向代理的 优点：\n\n * 多种负载均衡算法：支持多种负载均衡算法，以应对不同的场景需求。\n * 可以监控服务器：基于 HTTP 协议，可以监控转发服务器的状态，如：系统负载、响应时间、是否可用、连接数、流量等，从而根据这些数据调整负载均衡的策略。\n\n反向代理的 缺点：\n\n * 额外的转发开销：反向代理的转发操作本身是有性能开销的，可能会包括创建连接，等待连接响应，分析响应结果等操作。\n\n * 增加系统复杂度：反向代理常用于做分布式应用的水平扩展，但反向代理服务存在以下问题，为了解决以下问题会给系统整体增加额外的复杂度和运维成本：\n   \n   * 反向代理服务如果自身宕机，就无法访问站点，所以需要有 高可用 方案，常见的方案有：主备模式（一主一备）、双主模式（互为主备）。\n   * 反向代理服务自身也存在性能瓶颈，随着需要转发的请求量不断攀升，需要有 可扩展 方案。\n\n# IP 负载均衡\n\nIP 负载均衡是在网络层通过修改请求目的地址进行负载均衡。\n\n\n\n如上图所示，IP 均衡处理流程大致为：\n\n 1. 客户端请求 192.168.137.10，由负载均衡服务器接收到报文。\n 2. 负载均衡服务器根据算法选出一个服务节点 192.168.0.1，然后将报文请求地址改为该节点的 IP。\n 3. 真实服务节点收到请求报文，处理后，返回响应数据到负载均衡服务器。\n 4. 负载均衡服务器将响应数据的源地址改负载均衡服务器地址，返回给客户端。\n\nIP 负载均衡在内核进程完成数据分发，较反向代理负载均衡有更好的从处理性能。但是，由于所有请求响应都要经过负载均衡服务器，集群的吞吐量受制于负载均衡服务器的带宽。\n\n# 数据链路层负载均衡\n\n数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。\n\n\n\n在 Linux 平台上最好的链路层负载均衡开源产品是 LVS (Linux Virtual Server)。\n\nLVS 是基于 Linux 内核中 netfilter 框架实现的负载均衡系统。netfilter 是内核态的 Linux 防火墙机制，可以在数据包流经过程中，根据规则设置若干个关卡（hook 函数）来执行相关的操作。\n\nLVS 的工作流程大致如下：\n\n * 当用户访问 www.sina.com.cn 时，用户数据通过层层网络，最后通过交换机进入 LVS 服务器网卡，并进入内核网络层。\n * 进入 PREROUTING 后经过路由查找，确定访问的目的 VIP 是本机 IP 地址，所以数据包进入到 INPUT 链上\n * IPVS 是工作在 INPUT 链上，会根据访问的 vip+port 判断请求是否 IPVS 服务，如果是则调用注册的 IPVS HOOK 函数，进行 IPVS 相关主流程，强行修改数据包的相关数据，并将数据包发往 POSTROUTING 链上。\n * POSTROUTING 上收到数据包后，根据目标 IP 地址（后端服务器），通过路由选路，将数据包最终发往后端的服务器上。\n\n开源 LVS 版本有 3 种工作模式，每种模式工作原理截然不同，说各种模式都有自己的优缺点，分别适合不同的应用场景，不过最终本质的功能都是能实现均衡的流量调度和良好的扩展性。主要包括三种模式：DR 模式、NAT 模式、Tunnel 模式。\n\n\n# 3. 负载均衡算法\n\n负载均衡器的实现可以分为两个部分：\n\n * 根据负载均衡算法在候选服务器列表选出一个服务器；\n * 将请求数据发送到该服务器上。\n\n负载均衡算法是负载均衡服务核心中的核心。负载均衡产品多种多样，但是各种负载均衡算法原理是共性的。\n\n负载均衡算法有很多种，分别适用于不同的应用场景，本文仅介绍最为常见的负载均衡算法的特性及原理：轮询、随机、最小活跃数、源地址哈希、一致性哈希。\n\n> 注：负载均衡算法的实现，推荐阅读 Dubbo 官方负载均衡算法说明 ，源码讲解非常详细，非常值得借鉴。\n> \n> 下文中的各种算法的可执行示例已归档在 Github 仓库：https://github.com/dunwu/java-tutorial/tree/master/codes/java-distributed/java-load-balance，可以通过执行 io.github.dunwu.javatech.LoadBalanceDemo 查看各算法执行效果。\n\n\n# 3.1. 随机\n\n# 随机算法\n\n随机（Random） 算法 将请求随机分发到候选服务器。\n\n随机算法 适合服务器硬件相同的场景。学习过概率论的都知道，调用量较小的时候，可能负载并不均匀，调用量越大，负载越均衡。\n\n\n\n【示例】随机算法实现示例\n\n负载均衡接口\n\npublic interface LoadBalance<N extends Node> {\n\n    N select(List<N> nodes, String ip);\n\n}\n\n\n负载均衡抽象类\n\npublic abstract class BaseLoadBalance<N extends Node> implements LoadBalance<N> {\n\n    @Override\n    public N select(List<N> nodes, String ip) {\n        if (CollectionUtil.isEmpty(nodes)) {\n            return null;\n        }\n\n        // 如果 nodes 列表中仅有一个 node，直接返回即可，无需进行负载均衡\n        if (nodes.size() == 1) {\n            return nodes.get(0);\n        }\n\n        return doSelect(nodes, ip);\n    }\n\n    protected abstract N doSelect(List<N> nodes, String ip);\n\n}\n\n\n服务器节点类\n\npublic class Node implements Comparable<Node> {\n\n    protected String url;\n\n    protected Integer weight;\n\n    protected Integer active;\n\n    // ...\n}\n\n\n随机算法实现\n\npublic class RandomLoadBalance<N extends Node> extends BaseLoadBalance<N> implements LoadBalance<N> {\n\n    private final Random random = new Random();\n\n    @Override\n    protected N doSelect(List<N> nodes, String ip) {\n        // 在列表中随机选取一个节点\n        int index = random.nextInt(nodes.size());\n        return nodes.get(index);\n    }\n\n}\n\n\n# 加权随机算法\n\n加权随机（Weighted Random） 算法在随机算法的基础上，按照概率调整权重，进行负载分配。\n\n【示例】加权随机算法实现示例\n\npublic class WeightRandomLoadBalance<N extends Node> extends BaseLoadBalance<N> implements LoadBalance<N> {\n\n    private final Random random = ThreadLocalRandom.current();\n\n    @Override\n    protected N doSelect(List<N> nodes, String ip) {\n\n        int length = nodes.size();\n        AtomicInteger totalWeight = new AtomicInteger(0);\n        for (N node : nodes) {\n            Integer weight = node.getWeight();\n            totalWeight.getAndAdd(weight);\n        }\n\n        if (totalWeight.get() > 0) {\n            int offset = random.nextInt(totalWeight.get());\n            for (N node : nodes) {\n                // 让随机值 offset 减去权重值\n                offset -= node.getWeight();\n                if (offset < 0) {\n                    // 返回相应的 Node\n                    return node;\n                }\n            }\n        }\n\n        // 直接随机返回一个\n        return nodes.get(random.nextInt(length));\n    }\n\n}\n\n\n\n# 3.2. 轮询\n\n# 轮询算法\n\n轮询（Round Robin） 算法的策略是：将请求依次分发到候选服务器。\n\n如下图所示，负载均衡器收到来自客户端的 6 个请求，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。\n\n\n\n该算法适合场景：各服务器处理能力相近，且每个事务工作量差异不大。如果存在较大差异，那么处理较慢的服务器就可能会积压请求，最终无法承担过大的负载。\n\n\n\n【示例】轮询算法示例\n\n轮询负载均衡算法实现\n\npublic class RoundRobinLoadBalance<N extends Node> extends BaseLoadBalance<N> implements LoadBalance<N> {\n\n    private final AtomicInteger position = new AtomicInteger(0);\n\n    @Override\n    protected N doSelect(List<N> nodes, String ip) {\n        int length = nodes.size();\n        // 如果位置值已经等于节点数，重置为 0\n        position.compareAndSet(length, 0);\n        N node = nodes.get(position.get());\n        position.getAndIncrement();\n        return node;\n    }\n\n}\n\n\n# 加权轮询算法\n\n加权轮询（Weighted Round Robbin） 算法在轮询算法的基础上，增加了权重属性来调节转发服务器的请求数目。性能高、处理速度快的节点应该设置更高的权重，使得分发时优先将请求分发到权重较高的节点上。\n\n如下图所示，服务器 A 设置权重为 5，服务器 B 设置权重为 1，负载均衡器收到来自客户端的 6 个请求，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 A，(6) 请求会被发送到服务器 B。\n\n\n\n【示例】加权轮询算法实现示例\n\n以下实现基于 Dubbo 加权轮询算法做了一些简化。\n\npublic class WeightRoundRobinLoadBalance<N extends Node> extends BaseLoadBalance<N> implements LoadBalance<N> {\n\n    /**\n     * 60秒\n     */\n    private static final int RECYCLE_PERIOD = 60000;\n\n    /**\n     * Node hashcode 到 WeightedRoundRobin 的映射关系\n     */\n    private ConcurrentMap<Integer, WeightedRoundRobin> weightMap = new ConcurrentHashMap<>();\n\n    /**\n     * 原子更新锁\n     */\n    private AtomicBoolean updateLock = new AtomicBoolean();\n\n    @Override\n    protected N doSelect(List<N> nodes, String ip) {\n\n        int totalWeight = 0;\n        long maxCurrent = Long.MIN_VALUE;\n\n        // 获取当前时间\n        long now = System.currentTimeMillis();\n        N selectedNode = null;\n        WeightedRoundRobin selectedWRR = null;\n\n        // 下面这个循环主要做了这样几件事情：\n        //   1. 遍历 Node 列表，检测当前 Node 是否有相应的 WeightedRoundRobin，没有则创建\n        //   2. 检测 Node 权重是否发生了变化，若变化了，则更新 WeightedRoundRobin 的 weight 字段\n        //   3. 让 current 字段加上自身权重，等价于 current += weight\n        //   4. 设置 lastUpdate 字段，即 lastUpdate = now\n        //   5. 寻找具有最大 current 的 Node，以及 Node 对应的 WeightedRoundRobin，\n        //      暂存起来，留作后用\n        //   6. 计算权重总和\n        for (N node : nodes) {\n            int hashCode = node.hashCode();\n            WeightedRoundRobin weightedRoundRobin = weightMap.get(hashCode);\n            int weight = node.getWeight();\n            if (weight < 0) {\n                weight = 0;\n            }\n\n            // 检测当前 Node 是否有对应的 WeightedRoundRobin，没有则创建\n            if (weightedRoundRobin == null) {\n                weightedRoundRobin = new WeightedRoundRobin();\n                // 设置 Node 权重\n                weightedRoundRobin.setWeight(weight);\n                // 存储 url 唯一标识 identifyString 到 weightedRoundRobin 的映射关系\n                weightMap.putIfAbsent(hashCode, weightedRoundRobin);\n                weightedRoundRobin = weightMap.get(hashCode);\n            }\n            // Node 权重不等于 WeightedRoundRobin 中保存的权重，说明权重变化了，此时进行更新\n            if (weight != weightedRoundRobin.getWeight()) {\n                weightedRoundRobin.setWeight(weight);\n            }\n\n            // 让 current 加上自身权重，等价于 current += weight\n            long current = weightedRoundRobin.increaseCurrent();\n            // 设置 lastUpdate，表示近期更新过\n            weightedRoundRobin.setLastUpdate(now);\n            // 找出最大的 current\n            if (current > maxCurrent) {\n                maxCurrent = current;\n                // 将具有最大 current 权重的 Node 赋值给 selectedNode\n                selectedNode = node;\n                // 将 Node 对应的 weightedRoundRobin 赋值给 selectedWRR，留作后用\n                selectedWRR = weightedRoundRobin;\n            }\n\n            // 计算权重总和\n            totalWeight += weight;\n        }\n\n        // 对 weightMap 进行检查，过滤掉长时间未被更新的节点。\n        // 该节点可能挂了，nodes 中不包含该节点，所以该节点的 lastUpdate 长时间无法被更新。\n        // 若未更新时长超过阈值后，就会被移除掉，默认阈值为60秒。\n        if (!updateLock.get() && nodes.size() != weightMap.size()) {\n            if (updateLock.compareAndSet(false, true)) {\n                try {\n                    // 遍历修改，即移除过期记录\n                    weightMap.entrySet().removeIf(item -> now - item.getValue().getLastUpdate() > RECYCLE_PERIOD);\n                } finally {\n                    updateLock.set(false);\n                }\n            }\n        }\n\n        if (selectedNode != null) {\n            // 让 current 减去权重总和，等价于 current -= totalWeight\n            selectedWRR.decreaseCurrent(totalWeight);\n            // 返回具有最大 current 的 Node\n            return selectedNode;\n        }\n\n        // should not happen here\n        return nodes.get(0);\n    }\n\n    protected static class WeightedRoundRobin {\n\n        // 服务提供者权重\n        private int weight;\n        // 当前权重\n        private AtomicLong current = new AtomicLong(0);\n        // 最后一次更新时间\n        private long lastUpdate;\n\n        public long increaseCurrent() {\n            // current = current + weight；\n            return current.addAndGet(weight);\n        }\n\n        public long decreaseCurrent(int total) {\n            // current = current - total;\n            return current.addAndGet(-1 * total);\n        }\n\n        public int getWeight() {\n            return weight;\n        }\n\n        public void setWeight(int weight) {\n            this.weight = weight;\n            // 初始情况下，current = 0\n            current.set(0);\n        }\n\n        public AtomicLong getCurrent() {\n            return current;\n        }\n\n        public void setCurrent(AtomicLong current) {\n            this.current = current;\n        }\n\n        public long getLastUpdate() {\n            return lastUpdate;\n        }\n\n        public void setLastUpdate(long lastUpdate) {\n            this.lastUpdate = lastUpdate;\n        }\n\n    }\n\n}\n\n\n\n# 3.3. 最小活跃数\n\n最小活跃数（Least Active） 算法 将请求分发到连接数/请求数最少的候选服务器（目前处理请求最少的服务器）。\n\n * 特点：根据候选服务器当前的请求连接数，动态分配。\n * 场景：适用于对系统负载较为敏感或请求连接时长相差较大的场景。\n\n由于每个请求的连接时长不一样，如果采用简单的轮循或随机算法，都可能出现某些服务器当前连接数过大，而另一些服务器的连接过小的情况，这就造成了负载并非真正均衡。虽然，轮询或算法都可以通过加权重属性的方式进行负载调整，但加权方式难以应对动态变化。\n\n\n\n最小活跃数算法会记录当前时刻，每个候选节点正在处理的连接数，然后选择连接数最小的节点。该策略能够动态、实时地反应服务器的当前状况，较为合理地将负责分配均匀，适用于对当前系统负载较为敏感的场景。\n\n例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。\n\n\n\n加权最小活跃数（Weighted Least Connection）在最小活跃数的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。\n\n最小活跃数算法实现要点：活跃调用数越小，表明该服务节点处理能力越高，单位时间内可处理更多的请求，应优先将请求分发给该服务。在具体实现中，每个服务节点对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为 0。每收到一个请求，活跃数加 1，完成请求后则将活跃数减 1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。\n\n【示例】最小活跃数算法实现\n\n以下实现基于 Dubbo 最小活跃数负载均衡算法做了些许改动。\n\npublic class LeastActiveLoadBalance<N extends Node> extends BaseLoadBalance<N> implements LoadBalance<N> {\n\n    private final Random random = new Random();\n\n    @Override\n    protected N doSelect(List<N> nodes, String ip) {\n        int length = nodes.size();\n        // 最小的活跃数\n        int leastActive = -1;\n        // 具有相同“最小活跃数”的服务者提供者（以下用 Node 代称）数量\n        int leastCount = 0;\n        // leastIndexs 用于记录具有相同“最小活跃数”的 Node 在 nodes 列表中的下标信息\n        int[] leastIndexs = new int[length];\n        int totalWeight = 0;\n        // 第一个最小活跃数的 Node 权重值，用于与其他具有相同最小活跃数的 Node 的权重进行对比，\n        // 以检测是否“所有具有相同最小活跃数的 Node 的权重”均相等\n        int firstWeight = 0;\n        boolean sameWeight = true;\n\n        // 遍历 nodes 列表\n        for (int i = 0; i < length; i++) {\n            N node = nodes.get(i);\n            // 发现更小的活跃数，重新开始\n            if (leastActive == -1 || node.getActive() < leastActive) {\n                // 使用当前活跃数更新最小活跃数 leastActive\n                leastActive = node.getActive();\n                // 更新 leastCount 为 1\n                leastCount = 1;\n                // 记录当前下标值到 leastIndexs 中\n                leastIndexs[0] = i;\n                totalWeight = node.getWeight();\n                firstWeight = node.getWeight();\n                sameWeight = true;\n\n                // 当前 Node 的活跃数 node.getActive() 与最小活跃数 leastActive 相同\n            } else if (node.getActive() == leastActive) {\n                // 在 leastIndexs 中记录下当前 Node 在 nodes 集合中的下标\n                leastIndexs[leastCount++] = i;\n                // 累加权重\n                totalWeight += node.getWeight();\n                // 检测当前 Node 的权重与 firstWeight 是否相等，\n                // 不相等则将 sameWeight 置为 false\n                if (sameWeight && i > 0\n                    && node.getWeight() != firstWeight) {\n                    sameWeight = false;\n                }\n            }\n        }\n\n        // 当只有一个 Node 具有最小活跃数，此时直接返回该 Node 即可\n        if (leastCount == 1) {\n            return nodes.get(leastIndexs[0]);\n        }\n\n        // 有多个 Node 具有相同的最小活跃数，但它们之间的权重不同\n        if (!sameWeight && totalWeight > 0) {\n            // 随机生成一个 [0, totalWeight) 之间的数字\n            int offsetWeight = random.nextInt(totalWeight);\n            // 循环让随机数减去具有最小活跃数的 Node 的权重值，\n            // 当 offset 小于等于0时，返回相应的 Node\n            for (int i = 0; i < leastCount; i++) {\n                int leastIndex = leastIndexs[i];\n                // 获取权重值，并让随机数减去权重值\n                offsetWeight -= nodes.get(leastIndex).getWeight();\n                if (offsetWeight <= 0) {\n                    return nodes.get(leastIndex);\n                }\n            }\n        }\n        // 如果权重相同或权重为0时，随机返回一个 Node\n        return nodes.get(leastIndexs[random.nextInt(leastCount)]);\n    }\n\n}\n\n\n\n# 3.4. 哈希\n\n哈希（IP Hash） 算法根据一个 key （可以是唯一 ID、IP 等），通过哈希计算得到一个数值，用该数值在候选服务器列表的进行取模运算，得到的结果便是选中的服务器。\n\n\n\n可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）。\n\n * 特点：保证特定用户总是请求到相同的服务器，若服务器宕机，会话会丢失。\n\n【示例】源地址哈希算法实现示例\n\npublic class IpHashLoadBalance<N extends Node> extends BaseLoadBalance<N> implements LoadBalance<N> {\n\n    @Override\n    protected N doSelect(List<N> nodes, String ip) {\n        if (StrUtil.isBlank(ip)) {\n            ip = "127.0.0.1";\n        }\n\n        int length = nodes.size();\n        int index = hash(ip) % length;\n        return nodes.get(index);\n    }\n\n    public int hash(String text) {\n        return HashUtil.fnvHash(text);\n    }\n\n}\n\n\n\n# 3.5. 一致性哈希\n\n一致性哈希（Consistent Hash）算法的目标是：相同的请求尽可能落到同一个服务器上。\n\n一致性哈希 可以很好的解决 稳定性问题，可以将所有的 存储节点 排列在 首尾相接 的 Hash 环上，每个 key 在计算 Hash 后会 顺时针 找到 临接 的 存储节点 存放。而当有节点 加入 或 退出 时，仅影响该节点在 Hash 环上 顺时针相邻 的 后续节点。\n\n\n\n * 相同的请求是指：一般在使用一致性哈希时，需要指定一个 key 用于 hash 计算，可能是：\n   * 用户 ID\n   * 请求方 IP\n   * 请求服务名称，参数列表构成的串\n * 尽可能是指：服务器可能发生上下线，少数服务器的变化不应该影响大多数的请求。\n\n当某台候选服务器宕机时，原本发往该服务器的请求，会基于虚拟节点，平摊到其它候选服务器，不会引起剧烈变动。\n\n * 优点\n\n加入 和 删除 节点只影响 哈希环 中 顺时针方向 的 相邻的节点，对其他节点无影响。\n\n * 缺点\n\n加减节点 会造成 哈希环 中部分数据 无法命中。当使用 少量节点 时，节点变化 将大范围影响 哈希环 中 数据映射，不适合 少量数据节点 的分布式方案。普通 的 一致性哈希分区 在增减节点时需要 增加一倍 或 减去一半 节点才能保证 数据 和 负载的均衡。\n\n> 注意：因为 一致性哈希分区 的这些缺点，一些分布式系统采用 虚拟槽 对 一致性哈希 进行改进，比如 Dynamo 系统。\n\n【示例】一致性哈希算法示例\n\n以下示例基于 Dubbo 的一致性哈希负载均衡算法做了一些简化。\n\npublic class ConsistentHashLoadBalance<N extends Node> extends BaseLoadBalance<N> implements LoadBalance<N> {\n\n    private final ConcurrentMap<String, ConsistentHashSelector<?>> selectors = new ConcurrentHashMap<>();\n\n    @SuppressWarnings("unchecked")\n    @Override\n    protected N doSelect(List<N> nodes, String ip) {\n        // 分片数，这里设为节点数的 4 倍\n        Integer replicaNum = nodes.size() * 4;\n        // 获取 nodes 原始的 hashcode\n        int identityHashCode = System.identityHashCode(nodes);\n\n        // 如果 nodes 是一个新的 List 对象，意味着节点数量发生了变化\n        // 此时 selector.identityHashCode != identityHashCode 条件成立\n        ConsistentHashSelector<N> selector = (ConsistentHashSelector<N>) selectors.get(ip);\n        if (selector == null || selector.identityHashCode != identityHashCode) {\n            // 创建新的 ConsistentHashSelector\n            selectors.put(ip, new ConsistentHashSelector<>(nodes, identityHashCode, replicaNum));\n            selector = (ConsistentHashSelector<N>) selectors.get(ip);\n        }\n        // 调用 ConsistentHashSelector 的 select 方法选择 Node\n        return selector.select(ip);\n    }\n\n    /**\n     * 一致性哈希选择器\n     */\n    private static final class ConsistentHashSelector<N extends Node> {\n\n        /**\n         * 存储虚拟节点\n         */\n        private final TreeMap<Long, N> virtualNodes;\n\n        private final int identityHashCode;\n\n        /**\n         * 构造器\n         *\n         * @param nodes            节点列表\n         * @param identityHashCode hashcode\n         * @param replicaNum       分片数\n         */\n        ConsistentHashSelector(List<N> nodes, int identityHashCode, Integer replicaNum) {\n            this.virtualNodes = new TreeMap<>();\n            this.identityHashCode = identityHashCode;\n            // 获取虚拟节点数，默认为 100\n            if (replicaNum == null) {\n                replicaNum = 100;\n            }\n            for (N node : nodes) {\n                for (int i = 0; i < replicaNum / 4; i++) {\n                    // 对 url 进行 md5 运算，得到一个长度为16的字节数组\n                    byte[] digest = md5(node.getUrl());\n                    // 对 digest 部分字节进行 4 次 hash 运算，得到四个不同的 long 型正整数\n                    for (int j = 0; j < 4; j++) {\n                        // h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算\n                        // h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算\n                        // h = 2, h = 3 时过程同上\n                        long m = hash(digest, j);\n                        // 将 hash 到 node 的映射关系存储到 virtualNodes 中，\n                        // virtualNodes 需要提供高效的查询操作，因此选用 TreeMap 作为存储结构\n                        virtualNodes.put(m, node);\n                    }\n                }\n            }\n        }\n\n        public N select(String key) {\n            // 对参数 key 进行 md5 运算\n            byte[] digest = md5(key);\n            // 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，\n            // 寻找合适的 Node\n            return selectForKey(hash(digest, 0));\n        }\n\n        private N selectForKey(long hash) {\n            // 查找第一个大于或等于当前 hash 的节点\n            Map.Entry<Long, N> entry = virtualNodes.ceilingEntry(hash);\n            // 如果 hash 大于 Node 在哈希环上最大的位置，此时 entry = null，\n            // 需要将 TreeMap 的头节点赋值给 entry\n            if (entry == null) {\n                entry = virtualNodes.firstEntry();\n            }\n            // 返回 Node\n            return entry.getValue();\n        }\n\n    }\n\n    /**\n     * 计算 hash 值\n     */\n    public static long hash(byte[] digest, int number) {\n        return (((long) (digest[3 + number * 4] & 0xFF) << 24)\n            | ((long) (digest[2 + number * 4] & 0xFF) << 16)\n            | ((long) (digest[1 + number * 4] & 0xFF) << 8)\n            | (digest[number * 4] & 0xFF))\n            & 0xFFFFFFFFL;\n    }\n\n    /**\n     * 计算 MD5 值\n     */\n    public static byte[] md5(String value) {\n        MessageDigest md5;\n        try {\n            md5 = MessageDigest.getInstance("MD5");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n        md5.reset();\n        byte[] bytes = value.getBytes(StandardCharsets.UTF_8);\n        md5.update(bytes);\n        return md5.digest();\n    }\n\n}\n\n\n\n# 4. 参考资料\n\n * Comparing Load Balancing Algorithms\n * 《大型网站技术架构：核心原理与案例分析》\n * 大型网站架构系列：负载均衡详解（1）\n * 什么是负载均衡\n * What Is Load Balancing\n * Dubbo 官方负载均衡算法说明\n * 负载均衡算法及手段\n * 利用 dns 解析来实现网站的负载均衡',normalizedContent:'# 深入浅出负载均衡\n\n\n\n\n# 1. 负载均衡简介\n\n\n# 1.1. 大型网站面临的挑战\n\n大型网站都要面对庞大的用户量，高并发，海量数据等挑战。\n\n为了提升系统整体的性能，可以采用垂直扩展和水平扩展两种方式。\n\n * 垂直扩展：在网站发展早期，可以从单机的角度通过增加硬件处理能力，比如 cpu 处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升。但是，单机是有性能瓶颈的，一旦触及瓶颈，再想提升，付出的成本和代价会极高。这显然不能满足大型分布式系统（网站）所有应对的大流量，高并发，海量数据等挑战。\n * 水平扩展：通过集群来分担大型网站的流量。集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点，这些节点共同分担访问压力。水平扩展有两个要点：\n   * 应用集群：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据。\n   * 负载均衡：将用户访问请求，通过某种算法，分发到集群中的节点。\n\n\n# 1.2. 什么是负载均衡\n\n负载均衡（load balance，简称 lb）是高并发、高可用系统必不可少的关键组件，目标是 尽力将网络流量平均分发到多个服务器上，以提高系统整体的响应速度和可用性。\n\n负载均衡的主要作用如下：\n\n * 高并发：负载均衡通过算法调整负载，尽力均匀的分配应用集群中各节点的工作量，以此提高应用集群的并发处理能力（吞吐量）。\n * 伸缩性：添加或减少服务器数量，然后由负载均衡进行分发控制。这使得应用集群具备伸缩性。\n * 高可用：负载均衡器可以监控候选服务器，当服务器不可用时，自动跳过，将请求分发给可用的服务器。这使得应用集群具备高可用的特性。\n * 安全防护：有些负载均衡软件或硬件提供了安全性功能，如：黑白名单处理、防火墙，防 ddos 攻击等。\n\n\n# 2. 负载均衡的分类\n\n支持负载均衡的技术很多，我们可以通过不同维度去进行分类。\n\n\n# 2.1. 载体维度分类\n\n从支持负载均衡的载体来看，可以将负载均衡分为两类：\n\n * 硬件负载均衡\n * 软件负载均衡\n\n# 硬件负载均衡\n\n硬件负载均衡，一般是在定制处理器上运行的独立负载均衡服务器，价格昂贵，土豪专属。\n\n硬件负载均衡的 主流产品 有：f5 和 a10。\n\n硬件负载均衡的 优点：\n\n * 功能强大：支持全局负载均衡并提供较全面的、复杂的负载均衡算法。\n * 性能强悍：硬件负载均衡由于是在专用处理器上运行，因此吞吐量大，可支持单机百万以上的并发。\n * 安全性高：往往具备防火墙，防 ddos 攻击等安全功能。\n\n硬件负载均衡的 缺点：\n\n * 成本昂贵：购买和维护硬件负载均衡的成本都很高。\n * 扩展性差：当访问量突增时，超过限度不能动态扩容。\n\n# 软件负载均衡\n\n软件负载均衡，应用最广泛，无论大公司还是小公司都会使用。\n\n软件负载均衡从软件层面实现负载均衡，一般可以在任何标准物理设备上运行。\n\n软件负载均衡的 主流产品 有：nginx、haproxy、lvs。\n\n * lvs 可以作为四层负载均衡器。其负载均衡的性能要优于 nginx。\n * haproxy 可以作为 http 和 tcp 负载均衡器。\n * nginx、haproxy 可以作为四层或七层负载均衡器。\n\n软件负载均衡的 优点：\n\n * 扩展性好：适应动态变化，可以通过添加软件负载均衡实例，动态扩展到超出初始容量的能力。\n * 成本低廉：软件负载均衡可以在任何标准物理设备上运行，降低了购买和运维的成本。\n\n软件负载均衡的 缺点：\n\n * 性能略差：相比于硬件负载均衡，软件负载均衡的性能要略低一些。\n\n\n# 2.2. 网络通信分类\n\n软件负载均衡从通信层面来看，又可以分为四层和七层负载均衡。\n\n * 七层负载均衡：就是可以根据访问用户的 http 请求头、url 信息将请求转发到特定的主机。\n   * dns 重定向\n   * http 重定向\n   * 反向代理\n * 四层负载均衡：基于 ip 地址和端口进行请求的转发。\n   * 修改 ip 地址\n   * 修改 mac 地址\n\n# dns 负载均衡\n\ndns 负载均衡一般用于互联网公司，复杂的业务系统不适合使用。大型网站一般使用 dns 负载均衡作为 第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。dns 负载均衡属于七层负载均衡。\n\ndns 即 域名解析服务，是 osi 第七层网络协议。dns 被设计为一个树形结构的分布式应用，自上而下依次为：根域名服务器，一级域名服务器，二级域名服务器，... ，本地域名服务器。显然，如果所有数据都存储在根域名服务器，那么 dns 查询的负载和开销会非常庞大。\n\n因此，dns 查询相对于 dns 层级结构，是一个逆向的递归流程，dns 客户端依次请求本地 dns 服务器，上一级 dns 服务器，上上一级 dns 服务器，... ，根 dns 服务器（又叫权威 dns 服务器），一旦命中，立即返回。为了减少查询次数，每一级 dns 服务器都会设置 dns 查询缓存。\n\ndns 负载均衡的工作原理就是：基于 dns 查询缓存，按照负载情况返回不同服务器的 ip 地址。\n\n\n\ndns 重定向的 优点：\n\n * 使用简单：负载均衡工作，交给 dns 服务器处理，省掉了负载均衡服务器维护的麻烦\n * 提高性能：可以支持基于地址的域名解析，解析成距离用户最近的服务器地址（类似 cdn 的原理），可以加快访问速度，改善性能；\n\ndns 重定向的 缺点：\n\n * 可用性差：dns 解析是多级解析，新增/修改 dns 后，解析时间较长；解析过程中，用户访问网站将失败；\n * 扩展性低：dns 负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展；\n * 维护性差：也不能反映服务器的当前运行状态；支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载）\n\n# http 负载均衡\n\nhttp 负载均衡是基于 http 重定向实现的。http 负载均衡属于七层负载均衡。\n\nhttp 重定向原理是：根据用户的 http 请求计算出一个真实的服务器地址，将该服务器地址写入 http 重定向响应中，返回给浏览器，由浏览器重新进行访问。\n\n\n\nhttp 重定向的 优点：方案简单。\n\nhttp 重定向的 缺点：\n\n * 性能较差：每次访问需要两次请求服务器，增加了访问的延迟。\n * 降低搜索排名：使用重定向后，搜索引擎会视为 seo 作弊。\n * 如果负载均衡器宕机，就无法访问该站点。\n\n由于其缺点比较明显，所以这种负载均衡策略实际应用较少。\n\n# 反向代理负载均衡\n\n反向代理（reverse proxy）方式是指以 代理服务器 来接受网络请求，然后 将请求转发给内网中的服务器，并将从内网中的服务器上得到的结果返回给网络请求的客户端。反向代理负载均衡属于七层负载均衡。\n\n反向代理服务的主流产品：nginx、apache。\n\n正向代理与反向代理有什么区别？\n\n * 正向代理：发生在 客户端，是由用户主动发起的。翻墙软件就是典型的正向代理，客户端通过主动访问代理服务器，让代理服务器获得需要的外网数据，然后转发回客户端。\n * 反向代理：发生在 服务端，用户不知道代理的存在。\n\n\n\n反向代理是如何实现负载均衡的呢？以 nginx 为例，如下所示：\n\n\n\n首先，在代理服务器上设定好负载均衡规则。然后，当收到客户端请求，反向代理服务器拦截指定的域名或 ip 请求，根据负载均衡算法，将请求分发到候选服务器上。其次，如果某台候选服务器宕机，反向代理服务器会有容错处理，比如分发请求失败 3 次以上，将请求分发到其他候选服务器上。\n\n反向代理的 优点：\n\n * 多种负载均衡算法：支持多种负载均衡算法，以应对不同的场景需求。\n * 可以监控服务器：基于 http 协议，可以监控转发服务器的状态，如：系统负载、响应时间、是否可用、连接数、流量等，从而根据这些数据调整负载均衡的策略。\n\n反向代理的 缺点：\n\n * 额外的转发开销：反向代理的转发操作本身是有性能开销的，可能会包括创建连接，等待连接响应，分析响应结果等操作。\n\n * 增加系统复杂度：反向代理常用于做分布式应用的水平扩展，但反向代理服务存在以下问题，为了解决以下问题会给系统整体增加额外的复杂度和运维成本：\n   \n   * 反向代理服务如果自身宕机，就无法访问站点，所以需要有 高可用 方案，常见的方案有：主备模式（一主一备）、双主模式（互为主备）。\n   * 反向代理服务自身也存在性能瓶颈，随着需要转发的请求量不断攀升，需要有 可扩展 方案。\n\n# ip 负载均衡\n\nip 负载均衡是在网络层通过修改请求目的地址进行负载均衡。\n\n\n\n如上图所示，ip 均衡处理流程大致为：\n\n 1. 客户端请求 192.168.137.10，由负载均衡服务器接收到报文。\n 2. 负载均衡服务器根据算法选出一个服务节点 192.168.0.1，然后将报文请求地址改为该节点的 ip。\n 3. 真实服务节点收到请求报文，处理后，返回响应数据到负载均衡服务器。\n 4. 负载均衡服务器将响应数据的源地址改负载均衡服务器地址，返回给客户端。\n\nip 负载均衡在内核进程完成数据分发，较反向代理负载均衡有更好的从处理性能。但是，由于所有请求响应都要经过负载均衡服务器，集群的吞吐量受制于负载均衡服务器的带宽。\n\n# 数据链路层负载均衡\n\n数据链路层负载均衡是指在通信协议的数据链路层修改 mac 地址进行负载均衡。\n\n\n\n在 linux 平台上最好的链路层负载均衡开源产品是 lvs (linux virtual server)。\n\nlvs 是基于 linux 内核中 netfilter 框架实现的负载均衡系统。netfilter 是内核态的 linux 防火墙机制，可以在数据包流经过程中，根据规则设置若干个关卡（hook 函数）来执行相关的操作。\n\nlvs 的工作流程大致如下：\n\n * 当用户访问 www.sina.com.cn 时，用户数据通过层层网络，最后通过交换机进入 lvs 服务器网卡，并进入内核网络层。\n * 进入 prerouting 后经过路由查找，确定访问的目的 vip 是本机 ip 地址，所以数据包进入到 input 链上\n * ipvs 是工作在 input 链上，会根据访问的 vip+port 判断请求是否 ipvs 服务，如果是则调用注册的 ipvs hook 函数，进行 ipvs 相关主流程，强行修改数据包的相关数据，并将数据包发往 postrouting 链上。\n * postrouting 上收到数据包后，根据目标 ip 地址（后端服务器），通过路由选路，将数据包最终发往后端的服务器上。\n\n开源 lvs 版本有 3 种工作模式，每种模式工作原理截然不同，说各种模式都有自己的优缺点，分别适合不同的应用场景，不过最终本质的功能都是能实现均衡的流量调度和良好的扩展性。主要包括三种模式：dr 模式、nat 模式、tunnel 模式。\n\n\n# 3. 负载均衡算法\n\n负载均衡器的实现可以分为两个部分：\n\n * 根据负载均衡算法在候选服务器列表选出一个服务器；\n * 将请求数据发送到该服务器上。\n\n负载均衡算法是负载均衡服务核心中的核心。负载均衡产品多种多样，但是各种负载均衡算法原理是共性的。\n\n负载均衡算法有很多种，分别适用于不同的应用场景，本文仅介绍最为常见的负载均衡算法的特性及原理：轮询、随机、最小活跃数、源地址哈希、一致性哈希。\n\n> 注：负载均衡算法的实现，推荐阅读 dubbo 官方负载均衡算法说明 ，源码讲解非常详细，非常值得借鉴。\n> \n> 下文中的各种算法的可执行示例已归档在 github 仓库：https://github.com/dunwu/java-tutorial/tree/master/codes/java-distributed/java-load-balance，可以通过执行 io.github.dunwu.javatech.loadbalancedemo 查看各算法执行效果。\n\n\n# 3.1. 随机\n\n# 随机算法\n\n随机（random） 算法 将请求随机分发到候选服务器。\n\n随机算法 适合服务器硬件相同的场景。学习过概率论的都知道，调用量较小的时候，可能负载并不均匀，调用量越大，负载越均衡。\n\n\n\n【示例】随机算法实现示例\n\n负载均衡接口\n\npublic interface loadbalance<n extends node> {\n\n    n select(list<n> nodes, string ip);\n\n}\n\n\n负载均衡抽象类\n\npublic abstract class baseloadbalance<n extends node> implements loadbalance<n> {\n\n    @override\n    public n select(list<n> nodes, string ip) {\n        if (collectionutil.isempty(nodes)) {\n            return null;\n        }\n\n        // 如果 nodes 列表中仅有一个 node，直接返回即可，无需进行负载均衡\n        if (nodes.size() == 1) {\n            return nodes.get(0);\n        }\n\n        return doselect(nodes, ip);\n    }\n\n    protected abstract n doselect(list<n> nodes, string ip);\n\n}\n\n\n服务器节点类\n\npublic class node implements comparable<node> {\n\n    protected string url;\n\n    protected integer weight;\n\n    protected integer active;\n\n    // ...\n}\n\n\n随机算法实现\n\npublic class randomloadbalance<n extends node> extends baseloadbalance<n> implements loadbalance<n> {\n\n    private final random random = new random();\n\n    @override\n    protected n doselect(list<n> nodes, string ip) {\n        // 在列表中随机选取一个节点\n        int index = random.nextint(nodes.size());\n        return nodes.get(index);\n    }\n\n}\n\n\n# 加权随机算法\n\n加权随机（weighted random） 算法在随机算法的基础上，按照概率调整权重，进行负载分配。\n\n【示例】加权随机算法实现示例\n\npublic class weightrandomloadbalance<n extends node> extends baseloadbalance<n> implements loadbalance<n> {\n\n    private final random random = threadlocalrandom.current();\n\n    @override\n    protected n doselect(list<n> nodes, string ip) {\n\n        int length = nodes.size();\n        atomicinteger totalweight = new atomicinteger(0);\n        for (n node : nodes) {\n            integer weight = node.getweight();\n            totalweight.getandadd(weight);\n        }\n\n        if (totalweight.get() > 0) {\n            int offset = random.nextint(totalweight.get());\n            for (n node : nodes) {\n                // 让随机值 offset 减去权重值\n                offset -= node.getweight();\n                if (offset < 0) {\n                    // 返回相应的 node\n                    return node;\n                }\n            }\n        }\n\n        // 直接随机返回一个\n        return nodes.get(random.nextint(length));\n    }\n\n}\n\n\n\n# 3.2. 轮询\n\n# 轮询算法\n\n轮询（round robin） 算法的策略是：将请求依次分发到候选服务器。\n\n如下图所示，负载均衡器收到来自客户端的 6 个请求，(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。\n\n\n\n该算法适合场景：各服务器处理能力相近，且每个事务工作量差异不大。如果存在较大差异，那么处理较慢的服务器就可能会积压请求，最终无法承担过大的负载。\n\n\n\n【示例】轮询算法示例\n\n轮询负载均衡算法实现\n\npublic class roundrobinloadbalance<n extends node> extends baseloadbalance<n> implements loadbalance<n> {\n\n    private final atomicinteger position = new atomicinteger(0);\n\n    @override\n    protected n doselect(list<n> nodes, string ip) {\n        int length = nodes.size();\n        // 如果位置值已经等于节点数，重置为 0\n        position.compareandset(length, 0);\n        n node = nodes.get(position.get());\n        position.getandincrement();\n        return node;\n    }\n\n}\n\n\n# 加权轮询算法\n\n加权轮询（weighted round robbin） 算法在轮询算法的基础上，增加了权重属性来调节转发服务器的请求数目。性能高、处理速度快的节点应该设置更高的权重，使得分发时优先将请求分发到权重较高的节点上。\n\n如下图所示，服务器 a 设置权重为 5，服务器 b 设置权重为 1，负载均衡器收到来自客户端的 6 个请求，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 a，(6) 请求会被发送到服务器 b。\n\n\n\n【示例】加权轮询算法实现示例\n\n以下实现基于 dubbo 加权轮询算法做了一些简化。\n\npublic class weightroundrobinloadbalance<n extends node> extends baseloadbalance<n> implements loadbalance<n> {\n\n    /**\n     * 60秒\n     */\n    private static final int recycle_period = 60000;\n\n    /**\n     * node hashcode 到 weightedroundrobin 的映射关系\n     */\n    private concurrentmap<integer, weightedroundrobin> weightmap = new concurrenthashmap<>();\n\n    /**\n     * 原子更新锁\n     */\n    private atomicboolean updatelock = new atomicboolean();\n\n    @override\n    protected n doselect(list<n> nodes, string ip) {\n\n        int totalweight = 0;\n        long maxcurrent = long.min_value;\n\n        // 获取当前时间\n        long now = system.currenttimemillis();\n        n selectednode = null;\n        weightedroundrobin selectedwrr = null;\n\n        // 下面这个循环主要做了这样几件事情：\n        //   1. 遍历 node 列表，检测当前 node 是否有相应的 weightedroundrobin，没有则创建\n        //   2. 检测 node 权重是否发生了变化，若变化了，则更新 weightedroundrobin 的 weight 字段\n        //   3. 让 current 字段加上自身权重，等价于 current += weight\n        //   4. 设置 lastupdate 字段，即 lastupdate = now\n        //   5. 寻找具有最大 current 的 node，以及 node 对应的 weightedroundrobin，\n        //      暂存起来，留作后用\n        //   6. 计算权重总和\n        for (n node : nodes) {\n            int hashcode = node.hashcode();\n            weightedroundrobin weightedroundrobin = weightmap.get(hashcode);\n            int weight = node.getweight();\n            if (weight < 0) {\n                weight = 0;\n            }\n\n            // 检测当前 node 是否有对应的 weightedroundrobin，没有则创建\n            if (weightedroundrobin == null) {\n                weightedroundrobin = new weightedroundrobin();\n                // 设置 node 权重\n                weightedroundrobin.setweight(weight);\n                // 存储 url 唯一标识 identifystring 到 weightedroundrobin 的映射关系\n                weightmap.putifabsent(hashcode, weightedroundrobin);\n                weightedroundrobin = weightmap.get(hashcode);\n            }\n            // node 权重不等于 weightedroundrobin 中保存的权重，说明权重变化了，此时进行更新\n            if (weight != weightedroundrobin.getweight()) {\n                weightedroundrobin.setweight(weight);\n            }\n\n            // 让 current 加上自身权重，等价于 current += weight\n            long current = weightedroundrobin.increasecurrent();\n            // 设置 lastupdate，表示近期更新过\n            weightedroundrobin.setlastupdate(now);\n            // 找出最大的 current\n            if (current > maxcurrent) {\n                maxcurrent = current;\n                // 将具有最大 current 权重的 node 赋值给 selectednode\n                selectednode = node;\n                // 将 node 对应的 weightedroundrobin 赋值给 selectedwrr，留作后用\n                selectedwrr = weightedroundrobin;\n            }\n\n            // 计算权重总和\n            totalweight += weight;\n        }\n\n        // 对 weightmap 进行检查，过滤掉长时间未被更新的节点。\n        // 该节点可能挂了，nodes 中不包含该节点，所以该节点的 lastupdate 长时间无法被更新。\n        // 若未更新时长超过阈值后，就会被移除掉，默认阈值为60秒。\n        if (!updatelock.get() && nodes.size() != weightmap.size()) {\n            if (updatelock.compareandset(false, true)) {\n                try {\n                    // 遍历修改，即移除过期记录\n                    weightmap.entryset().removeif(item -> now - item.getvalue().getlastupdate() > recycle_period);\n                } finally {\n                    updatelock.set(false);\n                }\n            }\n        }\n\n        if (selectednode != null) {\n            // 让 current 减去权重总和，等价于 current -= totalweight\n            selectedwrr.decreasecurrent(totalweight);\n            // 返回具有最大 current 的 node\n            return selectednode;\n        }\n\n        // should not happen here\n        return nodes.get(0);\n    }\n\n    protected static class weightedroundrobin {\n\n        // 服务提供者权重\n        private int weight;\n        // 当前权重\n        private atomiclong current = new atomiclong(0);\n        // 最后一次更新时间\n        private long lastupdate;\n\n        public long increasecurrent() {\n            // current = current + weight；\n            return current.addandget(weight);\n        }\n\n        public long decreasecurrent(int total) {\n            // current = current - total;\n            return current.addandget(-1 * total);\n        }\n\n        public int getweight() {\n            return weight;\n        }\n\n        public void setweight(int weight) {\n            this.weight = weight;\n            // 初始情况下，current = 0\n            current.set(0);\n        }\n\n        public atomiclong getcurrent() {\n            return current;\n        }\n\n        public void setcurrent(atomiclong current) {\n            this.current = current;\n        }\n\n        public long getlastupdate() {\n            return lastupdate;\n        }\n\n        public void setlastupdate(long lastupdate) {\n            this.lastupdate = lastupdate;\n        }\n\n    }\n\n}\n\n\n\n# 3.3. 最小活跃数\n\n最小活跃数（least active） 算法 将请求分发到连接数/请求数最少的候选服务器（目前处理请求最少的服务器）。\n\n * 特点：根据候选服务器当前的请求连接数，动态分配。\n * 场景：适用于对系统负载较为敏感或请求连接时长相差较大的场景。\n\n由于每个请求的连接时长不一样，如果采用简单的轮循或随机算法，都可能出现某些服务器当前连接数过大，而另一些服务器的连接过小的情况，这就造成了负载并非真正均衡。虽然，轮询或算法都可以通过加权重属性的方式进行负载调整，但加权方式难以应对动态变化。\n\n\n\n最小活跃数算法会记录当前时刻，每个候选节点正在处理的连接数，然后选择连接数最小的节点。该策略能够动态、实时地反应服务器的当前状况，较为合理地将负责分配均匀，适用于对当前系统负载较为敏感的场景。\n\n例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。\n\n\n\n加权最小活跃数（weighted least connection）在最小活跃数的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。\n\n最小活跃数算法实现要点：活跃调用数越小，表明该服务节点处理能力越高，单位时间内可处理更多的请求，应优先将请求分发给该服务。在具体实现中，每个服务节点对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为 0。每收到一个请求，活跃数加 1，完成请求后则将活跃数减 1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。\n\n【示例】最小活跃数算法实现\n\n以下实现基于 dubbo 最小活跃数负载均衡算法做了些许改动。\n\npublic class leastactiveloadbalance<n extends node> extends baseloadbalance<n> implements loadbalance<n> {\n\n    private final random random = new random();\n\n    @override\n    protected n doselect(list<n> nodes, string ip) {\n        int length = nodes.size();\n        // 最小的活跃数\n        int leastactive = -1;\n        // 具有相同“最小活跃数”的服务者提供者（以下用 node 代称）数量\n        int leastcount = 0;\n        // leastindexs 用于记录具有相同“最小活跃数”的 node 在 nodes 列表中的下标信息\n        int[] leastindexs = new int[length];\n        int totalweight = 0;\n        // 第一个最小活跃数的 node 权重值，用于与其他具有相同最小活跃数的 node 的权重进行对比，\n        // 以检测是否“所有具有相同最小活跃数的 node 的权重”均相等\n        int firstweight = 0;\n        boolean sameweight = true;\n\n        // 遍历 nodes 列表\n        for (int i = 0; i < length; i++) {\n            n node = nodes.get(i);\n            // 发现更小的活跃数，重新开始\n            if (leastactive == -1 || node.getactive() < leastactive) {\n                // 使用当前活跃数更新最小活跃数 leastactive\n                leastactive = node.getactive();\n                // 更新 leastcount 为 1\n                leastcount = 1;\n                // 记录当前下标值到 leastindexs 中\n                leastindexs[0] = i;\n                totalweight = node.getweight();\n                firstweight = node.getweight();\n                sameweight = true;\n\n                // 当前 node 的活跃数 node.getactive() 与最小活跃数 leastactive 相同\n            } else if (node.getactive() == leastactive) {\n                // 在 leastindexs 中记录下当前 node 在 nodes 集合中的下标\n                leastindexs[leastcount++] = i;\n                // 累加权重\n                totalweight += node.getweight();\n                // 检测当前 node 的权重与 firstweight 是否相等，\n                // 不相等则将 sameweight 置为 false\n                if (sameweight && i > 0\n                    && node.getweight() != firstweight) {\n                    sameweight = false;\n                }\n            }\n        }\n\n        // 当只有一个 node 具有最小活跃数，此时直接返回该 node 即可\n        if (leastcount == 1) {\n            return nodes.get(leastindexs[0]);\n        }\n\n        // 有多个 node 具有相同的最小活跃数，但它们之间的权重不同\n        if (!sameweight && totalweight > 0) {\n            // 随机生成一个 [0, totalweight) 之间的数字\n            int offsetweight = random.nextint(totalweight);\n            // 循环让随机数减去具有最小活跃数的 node 的权重值，\n            // 当 offset 小于等于0时，返回相应的 node\n            for (int i = 0; i < leastcount; i++) {\n                int leastindex = leastindexs[i];\n                // 获取权重值，并让随机数减去权重值\n                offsetweight -= nodes.get(leastindex).getweight();\n                if (offsetweight <= 0) {\n                    return nodes.get(leastindex);\n                }\n            }\n        }\n        // 如果权重相同或权重为0时，随机返回一个 node\n        return nodes.get(leastindexs[random.nextint(leastcount)]);\n    }\n\n}\n\n\n\n# 3.4. 哈希\n\n哈希（ip hash） 算法根据一个 key （可以是唯一 id、ip 等），通过哈希计算得到一个数值，用该数值在候选服务器列表的进行取模运算，得到的结果便是选中的服务器。\n\n\n\n可以保证同一 ip 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（sticky session）。\n\n * 特点：保证特定用户总是请求到相同的服务器，若服务器宕机，会话会丢失。\n\n【示例】源地址哈希算法实现示例\n\npublic class iphashloadbalance<n extends node> extends baseloadbalance<n> implements loadbalance<n> {\n\n    @override\n    protected n doselect(list<n> nodes, string ip) {\n        if (strutil.isblank(ip)) {\n            ip = "127.0.0.1";\n        }\n\n        int length = nodes.size();\n        int index = hash(ip) % length;\n        return nodes.get(index);\n    }\n\n    public int hash(string text) {\n        return hashutil.fnvhash(text);\n    }\n\n}\n\n\n\n# 3.5. 一致性哈希\n\n一致性哈希（consistent hash）算法的目标是：相同的请求尽可能落到同一个服务器上。\n\n一致性哈希 可以很好的解决 稳定性问题，可以将所有的 存储节点 排列在 首尾相接 的 hash 环上，每个 key 在计算 hash 后会 顺时针 找到 临接 的 存储节点 存放。而当有节点 加入 或 退出 时，仅影响该节点在 hash 环上 顺时针相邻 的 后续节点。\n\n\n\n * 相同的请求是指：一般在使用一致性哈希时，需要指定一个 key 用于 hash 计算，可能是：\n   * 用户 id\n   * 请求方 ip\n   * 请求服务名称，参数列表构成的串\n * 尽可能是指：服务器可能发生上下线，少数服务器的变化不应该影响大多数的请求。\n\n当某台候选服务器宕机时，原本发往该服务器的请求，会基于虚拟节点，平摊到其它候选服务器，不会引起剧烈变动。\n\n * 优点\n\n加入 和 删除 节点只影响 哈希环 中 顺时针方向 的 相邻的节点，对其他节点无影响。\n\n * 缺点\n\n加减节点 会造成 哈希环 中部分数据 无法命中。当使用 少量节点 时，节点变化 将大范围影响 哈希环 中 数据映射，不适合 少量数据节点 的分布式方案。普通 的 一致性哈希分区 在增减节点时需要 增加一倍 或 减去一半 节点才能保证 数据 和 负载的均衡。\n\n> 注意：因为 一致性哈希分区 的这些缺点，一些分布式系统采用 虚拟槽 对 一致性哈希 进行改进，比如 dynamo 系统。\n\n【示例】一致性哈希算法示例\n\n以下示例基于 dubbo 的一致性哈希负载均衡算法做了一些简化。\n\npublic class consistenthashloadbalance<n extends node> extends baseloadbalance<n> implements loadbalance<n> {\n\n    private final concurrentmap<string, consistenthashselector<?>> selectors = new concurrenthashmap<>();\n\n    @suppresswarnings("unchecked")\n    @override\n    protected n doselect(list<n> nodes, string ip) {\n        // 分片数，这里设为节点数的 4 倍\n        integer replicanum = nodes.size() * 4;\n        // 获取 nodes 原始的 hashcode\n        int identityhashcode = system.identityhashcode(nodes);\n\n        // 如果 nodes 是一个新的 list 对象，意味着节点数量发生了变化\n        // 此时 selector.identityhashcode != identityhashcode 条件成立\n        consistenthashselector<n> selector = (consistenthashselector<n>) selectors.get(ip);\n        if (selector == null || selector.identityhashcode != identityhashcode) {\n            // 创建新的 consistenthashselector\n            selectors.put(ip, new consistenthashselector<>(nodes, identityhashcode, replicanum));\n            selector = (consistenthashselector<n>) selectors.get(ip);\n        }\n        // 调用 consistenthashselector 的 select 方法选择 node\n        return selector.select(ip);\n    }\n\n    /**\n     * 一致性哈希选择器\n     */\n    private static final class consistenthashselector<n extends node> {\n\n        /**\n         * 存储虚拟节点\n         */\n        private final treemap<long, n> virtualnodes;\n\n        private final int identityhashcode;\n\n        /**\n         * 构造器\n         *\n         * @param nodes            节点列表\n         * @param identityhashcode hashcode\n         * @param replicanum       分片数\n         */\n        consistenthashselector(list<n> nodes, int identityhashcode, integer replicanum) {\n            this.virtualnodes = new treemap<>();\n            this.identityhashcode = identityhashcode;\n            // 获取虚拟节点数，默认为 100\n            if (replicanum == null) {\n                replicanum = 100;\n            }\n            for (n node : nodes) {\n                for (int i = 0; i < replicanum / 4; i++) {\n                    // 对 url 进行 md5 运算，得到一个长度为16的字节数组\n                    byte[] digest = md5(node.geturl());\n                    // 对 digest 部分字节进行 4 次 hash 运算，得到四个不同的 long 型正整数\n                    for (int j = 0; j < 4; j++) {\n                        // h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算\n                        // h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算\n                        // h = 2, h = 3 时过程同上\n                        long m = hash(digest, j);\n                        // 将 hash 到 node 的映射关系存储到 virtualnodes 中，\n                        // virtualnodes 需要提供高效的查询操作，因此选用 treemap 作为存储结构\n                        virtualnodes.put(m, node);\n                    }\n                }\n            }\n        }\n\n        public n select(string key) {\n            // 对参数 key 进行 md5 运算\n            byte[] digest = md5(key);\n            // 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectforkey 方法，\n            // 寻找合适的 node\n            return selectforkey(hash(digest, 0));\n        }\n\n        private n selectforkey(long hash) {\n            // 查找第一个大于或等于当前 hash 的节点\n            map.entry<long, n> entry = virtualnodes.ceilingentry(hash);\n            // 如果 hash 大于 node 在哈希环上最大的位置，此时 entry = null，\n            // 需要将 treemap 的头节点赋值给 entry\n            if (entry == null) {\n                entry = virtualnodes.firstentry();\n            }\n            // 返回 node\n            return entry.getvalue();\n        }\n\n    }\n\n    /**\n     * 计算 hash 值\n     */\n    public static long hash(byte[] digest, int number) {\n        return (((long) (digest[3 + number * 4] & 0xff) << 24)\n            | ((long) (digest[2 + number * 4] & 0xff) << 16)\n            | ((long) (digest[1 + number * 4] & 0xff) << 8)\n            | (digest[number * 4] & 0xff))\n            & 0xffffffffl;\n    }\n\n    /**\n     * 计算 md5 值\n     */\n    public static byte[] md5(string value) {\n        messagedigest md5;\n        try {\n            md5 = messagedigest.getinstance("md5");\n        } catch (nosuchalgorithmexception e) {\n            throw new illegalstateexception(e.getmessage(), e);\n        }\n        md5.reset();\n        byte[] bytes = value.getbytes(standardcharsets.utf_8);\n        md5.update(bytes);\n        return md5.digest();\n    }\n\n}\n\n\n\n# 4. 参考资料\n\n * comparing load balancing algorithms\n * 《大型网站技术架构：核心原理与案例分析》\n * 大型网站架构系列：负载均衡详解（1）\n * 什么是负载均衡\n * what is load balancing\n * dubbo 官方负载均衡算法说明\n * 负载均衡算法及手段\n * 利用 dns 解析来实现网站的负载均衡',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"服务路由",frontmatter:{title:"服务路由",categories:["分布式","分布式关键技术","服务治理"],tags:["分布式","服务治理","流量调度","路由"],abbrlink:"6492e9b5",date:"2022-04-19T15:54:25.000Z",permalink:"/pages/d04ece/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/01.%E6%B5%81%E9%87%8F%E8%B0%83%E5%BA%A6/03.%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1.html",relativePath:"02.分布式/03.分布式关键技术/01.流量调度/03.服务路由.md",key:"v-5a6ba150",path:"/pages/d04ece/",headers:[{level:2,title:"1. 服务路由简介",slug:"_1-服务路由简介",normalizedTitle:"1. 服务路由简介",charIndex:11},{level:3,title:"1.1. 什么是服务路由",slug:"_1-1-什么是服务路由",normalizedTitle:"1.1. 什么是服务路由",charIndex:25},{level:3,title:"1.2. 为什么需要服务路由",slug:"_1-2-为什么需要服务路由",normalizedTitle:"1.2. 为什么需要服务路由",charIndex:100},{level:2,title:"2. 服务路由的规则",slug:"_2-服务路由的规则",normalizedTitle:"2. 服务路由的规则",charIndex:1128},{level:3,title:"2.1. 条件路由",slug:"_2-1-条件路由",normalizedTitle:"2.1. 条件路由",charIndex:1173},{level:3,title:"2.2. 脚本路由",slug:"_2-2-脚本路由",normalizedTitle:"2.2. 脚本路由",charIndex:3204},{level:3,title:"2.3. 标签路由",slug:"_2-3-标签路由",normalizedTitle:"2.3. 标签路由",charIndex:3820},{level:3,title:"2.4. 路由规则获取方式",slug:"_2-4-路由规则获取方式",normalizedTitle:"2.4. 路由规则获取方式",charIndex:4766},{level:2,title:"3. 参考资料",slug:"_3-参考资料",normalizedTitle:"3. 参考资料",charIndex:5386}],headersStr:"1. 服务路由简介 1.1. 什么是服务路由 1.2. 为什么需要服务路由 2. 服务路由的规则 2.1. 条件路由 2.2. 脚本路由 2.3. 标签路由 2.4. 路由规则获取方式 3. 参考资料",content:'# 服务路由\n\n\n# 1. 服务路由简介\n\n\n# 1.1. 什么是服务路由\n\n服务消费者在发起服务调用时，如果面对多个服务提供者，需要通过一定的规则来选择调用哪个服务提供者，这就是服务路由。\n\n\n# 1.2. 为什么需要服务路由\n\n负载均衡的作用和服务路由的功能看上去很近似，二者有什么区别呢？\n\n负载均衡的目标是提供服务分发而不是解决路由问题，常见的静态、动态负载均衡算法也无法实现精细化的路由管理，但是负载均衡也可以简单看做是路由方案的一种。\n\n服务路由通常用于以下场景，目的在于实现流量隔离：\n\n * 分组调用：一般来讲，为了保证服务的高可用性，实现异地多活的需求，一个服务往往不止部署在一个数据中心，而且出于节省成本等考虑，有些业务可能不仅在私有机房部署，还会采用公有云部署，甚至采用多家公有云部署。服务节点也会按照不同的数据中心分成不同的分组，这时对于服务消费者来说，选择哪一个分组调用，就必须有相应的路由规则。\n * 蓝绿发布：蓝绿发布场景中，一共有两套服务群组：一套是提供旧版功能的服务群组，标记为绿色；另一套是提供新版功能的服务群组，标记为蓝色。两套服务群组都是功能完善的，并且正在运行的系统，只是服务版本和访问流量不同。新版群组（蓝色）通常是为了做内部测试、验收，不对外部用户暴露。\n   * 如果新版群组（蓝色）运行稳定，并测试、验收通过后，则通过服务路由、负载均衡等手段逐步将外部用户流量导向新版群组（蓝色）。\n   * 如果新版群组（蓝色）运行不稳定，或测试、验收不通过，则排查、解决问题后，再继续测试、验收。\n * 灰度发布：灰度发布（又名金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行 A/B 测试，即让一部分用户使用特性 A，一部分用户使用特性 B：如果用户对 B 没有什么反对意见，那么逐步扩大发布范围，直到把所有用户都迁移到 B 上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。要支持灰度发布，就要求服务能够根据一定的规则，将流量隔离。\n * 流量切换：在业务线上运行过程中，经常会遇到一些不可抗力因素导致业务故障，比如某个机房的光缆被挖断，或者发生着火等事故导致整个机房的服务都不可用。这个时候就需要按照某个指令，能够把原来调用这个机房服务的流量切换到其他正常的机房。\n * 线下测试联调：线下测试时，可能会缺少相应环境。可以将测试应用注册到线上，然后开启路由规则，在本地进行测试。\n * 读写分离。对于大多数互联网业务来说都是读多写少，所以在进行服务部署的时候，可以把读写分开部署，所有写接口可以部署在一起，而读接口部署在另外的节点上。\n\n\n# 2. 服务路由的规则\n\n服务路由主要有两种规则：一种是条件路由，一种是脚本路由。\n\n\n# 2.1. 条件路由\n\n条件路由是基于条件表达式的路由规则。各个 RPC 框架的条件路由表达式各不相同。\n\n我们不妨参考一下 Dubbo 的条件路由。Dubbo 的条件路由有两种配置粒度，如下：\n\n * 应用粒度\n   \n   # app1的消费者只能消费所有端口为20880的服务实例\n   # app2的消费者只能消费所有端口为20881的服务实例\n   ---\n   scope: application\n   force: true\n   runtime: true\n   enabled: true\n   key: governance-conditionrouter-consumer\n   conditions:\n     - application=app1 => address=*:20880\n     - application=app2 => address=*:20881\n   \n\n * 服务粒度\n   \n   # DemoService的sayHello方法只能消费所有端口为20880的服务实例\n   # DemoService的sayHi方法只能消费所有端口为20881的服务实例\n   ---\n   scope: service\n   force: true\n   runtime: true\n   enabled: true\n   key: org.apache.dubbo.samples.governance.api.DemoService\n   conditions:\n     - method=sayHello => address=*:20880\n     - method=sayHi => address=*:20881\n   \n\n> 其中，conditions 定义具体的路由规则内容。conditions 部分是规则的主体，由 1 到任意多条规则组成。详见：Dubbo 路由规则\n\nDubbo 的条件路由规则由两个条件组成，分别用于对服务消费者和提供者进行匹配。条件路由规则的格式如下：\n\n[服务消费者匹配条件] => [服务提供者匹配条件]\n\n\n * 服务消费者匹配条件：所有参数和消费者的 URL 进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。\n * 服务提供者匹配条件：所有参数和提供者的 URL 进行对比，消费者最终只拿到过滤后的地址列表。\n\ncondition:// 代表了这是一段用条件表达式编写的路由规则，下面是一个条件路由规则示例：\n\nhost = 10.20.153.10 => host = 10.20.153.11\n\n\n该条规则表示 IP 为 10.20.153.10 的服务消费者只可调用 IP 为 10.20.153.11 机器上的服务，不可调用其他机器上的服务。\n\n下面列举一些 Dubbo 条件路由的典型应用场景：\n\n * 如果服务消费者的匹配条件为空，就表示所有的服务消费者都可以访问，就像下面的表达式一样。\n\n=> host != 10.20.153.11\n\n\n * 如果服务提供者的过滤条件为空，就表示禁止所有的服务消费者访问，就像下面的表达式一样。\n\nhost = 10.20.153.10 =>\n\n\n * 排除某个服务节点\n\n=> host != 172.22.3.91\n\n\n * 白名单\n\nregister.ip != 10.20.153.10,10.20.153.11 =>\n\n\n * 黑名单\n\nregister.ip = 10.20.153.10,10.20.153.11 =>\n\n\n * 只暴露部分机器节点\n\n=> host = 172.22.3.1*,172.22.3.2*\n\n\n * 为重要应用提供额外的机器节点\n\napplication != kylin => host != 172.22.3.95,172.22.3.96\n\n\n * 读写分离\n\nmethod = find*,list*,get*,is* => host = 172.22.3.94,172.22.3.95,172.22.3.96\nmethod != find*,list*,get*,is* => host = 172.22.3.97,172.22.3.98\n\n\n * 前后台分离\n\napplication = bops => host = 172.22.3.91,172.22.3.92,172.22.3.93\napplication != bops => host = 172.22.3.94,172.22.3.95,172.22.3.96\n\n\n * 隔离不同机房网段\n\nhost != 172.22.3.* => host != 172.22.3.*\n\n\n * 提供者与消费者部署在同集群内，本机只访问本机的服务\n\n=> host = $host\n\n\n\n# 2.2. 脚本路由\n\n脚本路由是基于脚本语言的路由规则，常用的脚本语言比如 JavaScript、Groovy、JRuby 等。\n\n"script://0.0.0.0/com.foo.BarService?category=routers&dynamic=false&rule=" + URL.encode("（function route(invokers) { ... } (invokers)）")\n\n\n这里面 script:// 就代表了这是一段脚本语言编写的路由规则，具体规则定义在脚本语言的 route 方法实现里，比如下面这段用 JavaScript 编写的 route() 方法表达的意思是，只有 IP 为 10.20.153.10 的服务消费者可以发起服务调用。\n\nfunction route(invokers){\n  var result = new java.util.ArrayList(invokers.size());\n  for(i =0; i < invokers.size(); i ++){\n    if("10.20.153.10".equals(invokers.get(i).getUrl().getHost())){\n       result.add(invokers.get(i));\n    }\n  }\n  return result;\n } (invokers)）;\n\n\n\n# 2.3. 标签路由\n\n标签路由通过将某一个或多个服务的提供者划分到同一个分组，约束流量只在指定分组中流转，从而实现流量隔离的目的，可以作为蓝绿发布、灰度发布等场景的能力基础。\n\n标签主要是指对服务提供者的分组，目前有两种方式可以完成实例分组，分别是动态规则打标和静态规则打标。一般，动态规则优先级比静态规则更高，当两种规则同时存在且出现冲突时，将以动态规则为准。\n\n以 Dubbo 的标签路由用法为例\n\n（1）动态规则打标，可随时在服务治理控制台下发标签归组规则\n\n# governance-tagrouter-provider应用增加了两个标签分组tag1和tag2\n# tag1包含一个实例 127.0.0.1:20880\n# tag2包含一个实例 127.0.0.1:20881\n---\n  force: false\n  runtime: true\n  enabled: true\n  key: governance-tagrouter-provider\n  tags:\n    - name: tag1\n      addresses: ["127.0.0.1:20880"]\n    - name: tag2\n      addresses: ["127.0.0.1:20881"]\n ...\n\n\n（2）静态规则打标\n\n<dubbo:provider tag="tag1"/>\n\n\nor\n\n<dubbo:service tag="tag1"/>\n\n\nor\n\njava -jar xxx-provider.jar -Ddubbo.provider.tag={the tag you want, may come from OS ENV}\n\n\n（3）服务消费者指定标签路由\n\nRpcContext.getContext().setAttachment(Constants.REQUEST_TAG_KEY,"tag1");\n\n\n请求标签的作用域为每一次 invocation，使用 attachment 来传递请求标签，注意保存在 attachment 中的值将会在一次完整的远程调用中持续传递，得益于这样的特性，我们只需要在起始调用时，通过一行代码的设置，达到标签的持续传递。\n\n\n# 2.4. 路由规则获取方式\n\n路由规则的获取方式主要有三种：\n\n * 本地静态配置：顾名思义就是路由规则存储在服务消费者本地上。服务消费者发起调用时，从本地固定位置读取路由规则，然后按照路由规则选取一个服务节点发起调用。\n * 配置中心管理：这种方式下，所有的服务消费者都从配置中心获取路由规则，由配置中心来统一管理。\n * 注册中心动态下发：这种方式下，一般是运维人员或者开发人员，通过服务治理平台修改路由规则，服务治理平台调用配置中心接口，把修改后的路由规则持久化到配置中心。因为服务消费者订阅了路由规则的变更，于是就会从配置中心获取最新的路由规则，按照最新的路由规则来执行。\n\n一般来讲，服务路由最好是存储在配置中心，由配置中心来统一管理。这样的话，所有的服务消费者就不需要在本地管理服务路由，因为大部分的服务消费者并不关心服务路由的问题，或者说也不需要去了解其中的细节。通过配置中心，统一给各个服务消费者下发统一的服务路由，节省了沟通和管理成本。\n\n但也不排除某些服务消费者有特定的需求，需要定制自己的路由规则，这个时候就适合通过本地配置来定制。\n\n而动态下发可以理解为一种高级功能，它能够动态地修改路由规则，在某些业务场景下十分有用。比如某个数据中心存在问题，需要把调用这个数据中心的服务消费者都切换到其他数据中心，这时就可以通过动态下发的方式，向配置中心下发一条路由规则，将所有调用这个数据中心的请求都迁移到别的地方。\n\n\n# 3. 参考资料\n\n * 从 0 开始学微服务\n * RPC 实战与核心原理\n * 微服务架构核心 20 讲',normalizedContent:'# 服务路由\n\n\n# 1. 服务路由简介\n\n\n# 1.1. 什么是服务路由\n\n服务消费者在发起服务调用时，如果面对多个服务提供者，需要通过一定的规则来选择调用哪个服务提供者，这就是服务路由。\n\n\n# 1.2. 为什么需要服务路由\n\n负载均衡的作用和服务路由的功能看上去很近似，二者有什么区别呢？\n\n负载均衡的目标是提供服务分发而不是解决路由问题，常见的静态、动态负载均衡算法也无法实现精细化的路由管理，但是负载均衡也可以简单看做是路由方案的一种。\n\n服务路由通常用于以下场景，目的在于实现流量隔离：\n\n * 分组调用：一般来讲，为了保证服务的高可用性，实现异地多活的需求，一个服务往往不止部署在一个数据中心，而且出于节省成本等考虑，有些业务可能不仅在私有机房部署，还会采用公有云部署，甚至采用多家公有云部署。服务节点也会按照不同的数据中心分成不同的分组，这时对于服务消费者来说，选择哪一个分组调用，就必须有相应的路由规则。\n * 蓝绿发布：蓝绿发布场景中，一共有两套服务群组：一套是提供旧版功能的服务群组，标记为绿色；另一套是提供新版功能的服务群组，标记为蓝色。两套服务群组都是功能完善的，并且正在运行的系统，只是服务版本和访问流量不同。新版群组（蓝色）通常是为了做内部测试、验收，不对外部用户暴露。\n   * 如果新版群组（蓝色）运行稳定，并测试、验收通过后，则通过服务路由、负载均衡等手段逐步将外部用户流量导向新版群组（蓝色）。\n   * 如果新版群组（蓝色）运行不稳定，或测试、验收不通过，则排查、解决问题后，再继续测试、验收。\n * 灰度发布：灰度发布（又名金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行 a/b 测试，即让一部分用户使用特性 a，一部分用户使用特性 b：如果用户对 b 没有什么反对意见，那么逐步扩大发布范围，直到把所有用户都迁移到 b 上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。要支持灰度发布，就要求服务能够根据一定的规则，将流量隔离。\n * 流量切换：在业务线上运行过程中，经常会遇到一些不可抗力因素导致业务故障，比如某个机房的光缆被挖断，或者发生着火等事故导致整个机房的服务都不可用。这个时候就需要按照某个指令，能够把原来调用这个机房服务的流量切换到其他正常的机房。\n * 线下测试联调：线下测试时，可能会缺少相应环境。可以将测试应用注册到线上，然后开启路由规则，在本地进行测试。\n * 读写分离。对于大多数互联网业务来说都是读多写少，所以在进行服务部署的时候，可以把读写分开部署，所有写接口可以部署在一起，而读接口部署在另外的节点上。\n\n\n# 2. 服务路由的规则\n\n服务路由主要有两种规则：一种是条件路由，一种是脚本路由。\n\n\n# 2.1. 条件路由\n\n条件路由是基于条件表达式的路由规则。各个 rpc 框架的条件路由表达式各不相同。\n\n我们不妨参考一下 dubbo 的条件路由。dubbo 的条件路由有两种配置粒度，如下：\n\n * 应用粒度\n   \n   # app1的消费者只能消费所有端口为20880的服务实例\n   # app2的消费者只能消费所有端口为20881的服务实例\n   ---\n   scope: application\n   force: true\n   runtime: true\n   enabled: true\n   key: governance-conditionrouter-consumer\n   conditions:\n     - application=app1 => address=*:20880\n     - application=app2 => address=*:20881\n   \n\n * 服务粒度\n   \n   # demoservice的sayhello方法只能消费所有端口为20880的服务实例\n   # demoservice的sayhi方法只能消费所有端口为20881的服务实例\n   ---\n   scope: service\n   force: true\n   runtime: true\n   enabled: true\n   key: org.apache.dubbo.samples.governance.api.demoservice\n   conditions:\n     - method=sayhello => address=*:20880\n     - method=sayhi => address=*:20881\n   \n\n> 其中，conditions 定义具体的路由规则内容。conditions 部分是规则的主体，由 1 到任意多条规则组成。详见：dubbo 路由规则\n\ndubbo 的条件路由规则由两个条件组成，分别用于对服务消费者和提供者进行匹配。条件路由规则的格式如下：\n\n[服务消费者匹配条件] => [服务提供者匹配条件]\n\n\n * 服务消费者匹配条件：所有参数和消费者的 url 进行对比，当消费者满足匹配条件时，对该消费者执行后面的过滤规则。\n * 服务提供者匹配条件：所有参数和提供者的 url 进行对比，消费者最终只拿到过滤后的地址列表。\n\ncondition:// 代表了这是一段用条件表达式编写的路由规则，下面是一个条件路由规则示例：\n\nhost = 10.20.153.10 => host = 10.20.153.11\n\n\n该条规则表示 ip 为 10.20.153.10 的服务消费者只可调用 ip 为 10.20.153.11 机器上的服务，不可调用其他机器上的服务。\n\n下面列举一些 dubbo 条件路由的典型应用场景：\n\n * 如果服务消费者的匹配条件为空，就表示所有的服务消费者都可以访问，就像下面的表达式一样。\n\n=> host != 10.20.153.11\n\n\n * 如果服务提供者的过滤条件为空，就表示禁止所有的服务消费者访问，就像下面的表达式一样。\n\nhost = 10.20.153.10 =>\n\n\n * 排除某个服务节点\n\n=> host != 172.22.3.91\n\n\n * 白名单\n\nregister.ip != 10.20.153.10,10.20.153.11 =>\n\n\n * 黑名单\n\nregister.ip = 10.20.153.10,10.20.153.11 =>\n\n\n * 只暴露部分机器节点\n\n=> host = 172.22.3.1*,172.22.3.2*\n\n\n * 为重要应用提供额外的机器节点\n\napplication != kylin => host != 172.22.3.95,172.22.3.96\n\n\n * 读写分离\n\nmethod = find*,list*,get*,is* => host = 172.22.3.94,172.22.3.95,172.22.3.96\nmethod != find*,list*,get*,is* => host = 172.22.3.97,172.22.3.98\n\n\n * 前后台分离\n\napplication = bops => host = 172.22.3.91,172.22.3.92,172.22.3.93\napplication != bops => host = 172.22.3.94,172.22.3.95,172.22.3.96\n\n\n * 隔离不同机房网段\n\nhost != 172.22.3.* => host != 172.22.3.*\n\n\n * 提供者与消费者部署在同集群内，本机只访问本机的服务\n\n=> host = $host\n\n\n\n# 2.2. 脚本路由\n\n脚本路由是基于脚本语言的路由规则，常用的脚本语言比如 javascript、groovy、jruby 等。\n\n"script://0.0.0.0/com.foo.barservice?category=routers&dynamic=false&rule=" + url.encode("（function route(invokers) { ... } (invokers)）")\n\n\n这里面 script:// 就代表了这是一段脚本语言编写的路由规则，具体规则定义在脚本语言的 route 方法实现里，比如下面这段用 javascript 编写的 route() 方法表达的意思是，只有 ip 为 10.20.153.10 的服务消费者可以发起服务调用。\n\nfunction route(invokers){\n  var result = new java.util.arraylist(invokers.size());\n  for(i =0; i < invokers.size(); i ++){\n    if("10.20.153.10".equals(invokers.get(i).geturl().gethost())){\n       result.add(invokers.get(i));\n    }\n  }\n  return result;\n } (invokers)）;\n\n\n\n# 2.3. 标签路由\n\n标签路由通过将某一个或多个服务的提供者划分到同一个分组，约束流量只在指定分组中流转，从而实现流量隔离的目的，可以作为蓝绿发布、灰度发布等场景的能力基础。\n\n标签主要是指对服务提供者的分组，目前有两种方式可以完成实例分组，分别是动态规则打标和静态规则打标。一般，动态规则优先级比静态规则更高，当两种规则同时存在且出现冲突时，将以动态规则为准。\n\n以 dubbo 的标签路由用法为例\n\n（1）动态规则打标，可随时在服务治理控制台下发标签归组规则\n\n# governance-tagrouter-provider应用增加了两个标签分组tag1和tag2\n# tag1包含一个实例 127.0.0.1:20880\n# tag2包含一个实例 127.0.0.1:20881\n---\n  force: false\n  runtime: true\n  enabled: true\n  key: governance-tagrouter-provider\n  tags:\n    - name: tag1\n      addresses: ["127.0.0.1:20880"]\n    - name: tag2\n      addresses: ["127.0.0.1:20881"]\n ...\n\n\n（2）静态规则打标\n\n<dubbo:provider tag="tag1"/>\n\n\nor\n\n<dubbo:service tag="tag1"/>\n\n\nor\n\njava -jar xxx-provider.jar -ddubbo.provider.tag={the tag you want, may come from os env}\n\n\n（3）服务消费者指定标签路由\n\nrpccontext.getcontext().setattachment(constants.request_tag_key,"tag1");\n\n\n请求标签的作用域为每一次 invocation，使用 attachment 来传递请求标签，注意保存在 attachment 中的值将会在一次完整的远程调用中持续传递，得益于这样的特性，我们只需要在起始调用时，通过一行代码的设置，达到标签的持续传递。\n\n\n# 2.4. 路由规则获取方式\n\n路由规则的获取方式主要有三种：\n\n * 本地静态配置：顾名思义就是路由规则存储在服务消费者本地上。服务消费者发起调用时，从本地固定位置读取路由规则，然后按照路由规则选取一个服务节点发起调用。\n * 配置中心管理：这种方式下，所有的服务消费者都从配置中心获取路由规则，由配置中心来统一管理。\n * 注册中心动态下发：这种方式下，一般是运维人员或者开发人员，通过服务治理平台修改路由规则，服务治理平台调用配置中心接口，把修改后的路由规则持久化到配置中心。因为服务消费者订阅了路由规则的变更，于是就会从配置中心获取最新的路由规则，按照最新的路由规则来执行。\n\n一般来讲，服务路由最好是存储在配置中心，由配置中心来统一管理。这样的话，所有的服务消费者就不需要在本地管理服务路由，因为大部分的服务消费者并不关心服务路由的问题，或者说也不需要去了解其中的细节。通过配置中心，统一给各个服务消费者下发统一的服务路由，节省了沟通和管理成本。\n\n但也不排除某些服务消费者有特定的需求，需要定制自己的路由规则，这个时候就适合通过本地配置来定制。\n\n而动态下发可以理解为一种高级功能，它能够动态地修改路由规则，在某些业务场景下十分有用。比如某个数据中心存在问题，需要把调用这个数据中心的服务消费者都切换到其他数据中心，这时就可以通过动态下发的方式，向配置中心下发一条路由规则，将所有调用这个数据中心的请求都迁移到别的地方。\n\n\n# 3. 参考资料\n\n * 从 0 开始学微服务\n * rpc 实战与核心原理\n * 微服务架构核心 20 讲',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"分布式会话基本原理",frontmatter:{title:"分布式会话基本原理",categories:["分布式","分布式关键技术","流量调度"],tags:["分布式","流量调度","会话"],abbrlink:"4418249f",date:"2019-06-04T23:42:00.000Z",permalink:"/pages/3e66c2/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/01.%E6%B5%81%E9%87%8F%E8%B0%83%E5%BA%A6/10.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D.html",relativePath:"02.分布式/03.分布式关键技术/01.流量调度/10.分布式会话.md",key:"v-278d74e8",path:"/pages/3e66c2/",headers:[{level:2,title:"1. Cookie",slug:"_1-cookie",normalizedTitle:"1. cookie",charIndex:122},{level:3,title:"1.1. 什么是 Cookie",slug:"_1-1-什么是-cookie",normalizedTitle:"1.1. 什么是 cookie",charIndex:278},{level:3,title:"1.2. Cookie 的工作步骤",slug:"_1-2-cookie-的工作步骤",normalizedTitle:"1.2. cookie 的工作步骤",charIndex:526},{level:3,title:"1.3. Cookie 的作用",slug:"_1-3-cookie-的作用",normalizedTitle:"1.3. cookie 的作用",charIndex:701},{level:3,title:"1.4. Cookie 的重要属性",slug:"_1-4-cookie-的重要属性",normalizedTitle:"1.4. cookie 的重要属性",charIndex:892},{level:2,title:"2. Session",slug:"_2-session",normalizedTitle:"2. session",charIndex:1796},{level:3,title:"2.1. 什么是 Session",slug:"_2-1-什么是-session",normalizedTitle:"2.1. 什么是 session",charIndex:1811},{level:3,title:"2.2. Session 的工作步骤",slug:"_2-2-session-的工作步骤",normalizedTitle:"2.2. session 的工作步骤",charIndex:2090},{level:2,title:"3. Cookie 和 Session 的区别",slug:"_3-cookie-和-session-的区别",normalizedTitle:"3. cookie 和 session 的区别",charIndex:2538},{level:2,title:"4. 如果禁用 Cookie 怎么办",slug:"_4-如果禁用-cookie-怎么办",normalizedTitle:"4. 如果禁用 cookie 怎么办",charIndex:2986},{level:2,title:"5. 分布式 Session",slug:"_5-分布式-session",normalizedTitle:"5. 分布式 session",charIndex:3395},{level:3,title:"5.1. 粘性 Session",slug:"_5-1-粘性-session",normalizedTitle:"5.1. 粘性 session",charIndex:3625},{level:3,title:"5.2. Session 复制共享",slug:"_5-2-session-复制共享",normalizedTitle:"5.2. session 复制共享",charIndex:3782},{level:3,title:"5.3. 基于缓存的 session 共享",slug:"_5-3-基于缓存的-session-共享",normalizedTitle:"5.3. 基于缓存的 session 共享",charIndex:3924},{level:2,title:"6. 具体实现",slug:"_6-具体实现",normalizedTitle:"6. 具体实现",charIndex:4061},{level:3,title:"6.1. JWT Token",slug:"_6-1-jwt-token",normalizedTitle:"6.1. jwt token",charIndex:4073},{level:3,title:"6.2. tomcat + redis",slug:"_6-2-tomcat-redis",normalizedTitle:"6.2. tomcat + redis",charIndex:4158},{level:3,title:"6.3. spring session + redis",slug:"_6-3-spring-session-redis",normalizedTitle:"6.3. spring session + redis",charIndex:5047},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:7598}],headersStr:"1. Cookie 1.1. 什么是 Cookie 1.2. Cookie 的工作步骤 1.3. Cookie 的作用 1.4. Cookie 的重要属性 2. Session 2.1. 什么是 Session 2.2. Session 的工作步骤 3. Cookie 和 Session 的区别 4. 如果禁用 Cookie 怎么办 5. 分布式 Session 5.1. 粘性 Session 5.2. Session 复制共享 5.3. 基于缓存的 session 共享 6. 具体实现 6.1. JWT Token 6.2. tomcat + redis 6.3. spring session + redis 7. 参考资料",content:'# 分布式会话基本原理\n\n> 由于 Http 是一种无状态的协议，服务器单单从网络连接上无从知道客户身份。\n> \n> 会话跟踪是 Web 程序中常用的技术，用来跟踪用户的整个会话。常用会话跟踪技术是 Cookie 与 Session。\n\n\n# 1. Cookie\n\n由于 Http 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。\n\n所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。\n\n\n# 1.1. 什么是 Cookie\n\nCookie 实际上是存储在用户浏览器上的文本信息，并保留了各种跟踪的信息。\n\n一个简单的 cookie 设置如下：\n\nSet-Cookie: <cookie-name>=<cookie-value>\n\n\nHTTP/2.0 200 OK\nContent-Type: text/html\nSet-Cookie: yummy_cookie=choco\nSet-Cookie: tasty_cookie=strawberry\n\n[page content]\n\n\n\n# 1.2. Cookie 的工作步骤\n\n 1. 浏览器请求服务器，如果服务器需要记录该用户的状态，就是用 response 向浏览器颁发一个 Cookie。\n 2. 浏览器会把 Cookie 保存下来。\n 3. 当浏览器再请求该网站时，浏览器把该请求的网址连同 Cookie 一同提交给服务器。服务器检查该 Cookie，以此来辨认用户状态。\n\n\n# 1.3. Cookie 的作用\n\nCookie 主要用于以下三个方面：\n\n * 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n * 个性化设置（如用户自定义设置、主题等）\n * 浏览器行为跟踪（如跟踪分析用户行为等）\n\n注：Cookie 功能需要浏览器的支持，如果浏览器不支持 Cookie 或者 Cookie 禁用了，Cookie 功能就会失效。\n\n\n# 1.4. Cookie 的重要属性\n\n属性           说明\nname=value   键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型 - 如果值为 Unicode 字符，需要为字符编码。\n             - 如果值为二进制数据，则需要使用 BASE64 编码。\ndomain       指定 cookie 所属域名，默认是当前域名\npath         指定 cookie 在哪个路径（路由）下生效，默认是 \'/\'。 如果设置为 /abc，则只有 /abc\n             下的路由可以访问到该 cookie，如：/abc/read。\nmaxAge       cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该\n             cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为\n             0，表示删除该 cookie 。默认为 -1。 - 比 expires 好用。\nexpires      过期时间，在设置的某个时间点后该 cookie 就会失效。 一般浏览器的 cookie\n             都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除\nsecure       该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为\n             false。 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。\nhttpOnly     如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie\n             的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS\n             攻击，不是绝对的安全\n\n\n# 2. Session\n\n\n# 2.1. 什么是 Session\n\nSession 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。\n\n * session 是另一种记录服务器和客户端会话状态的机制\n * session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中\n\n\n\n\n# 2.2. Session 的工作步骤\n\n 1. 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session。\n 2. 请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器。\n 3. 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。\n 4. 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。\n\n根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。\n\n\n# 3. Cookie 和 Session 的区别\n\nCookie 和 Session 的主要区别可以参考以下表格：\n\n       COOKIE                 SESSION\n作用范围   保存在客户端（浏览器）            保存在服务器端\n隐私策略   存储在客户端，比较容易遭到非法获取      存储在服务端，安全性相对 Cookie 要好一些\n存储方式   只能保存 ASCII             可以保存任意数据类型。\n                              一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。\n存储大小   不能超过 4K                存储大小远高于 Cookie\n生命周期   可设置为永久保存               一般失效时间较短\n       比如我们经常使用的默认登录（记住我）功能   客户端关闭或者 Session 超时都会失效。\n\n\n# 4. 如果禁用 Cookie 怎么办\n\n既然服务端是根据 Cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 Cookie，如何保障整个机制的正常运转。\n\n第一种方案，每次请求中都携带一个 SessionID 的参数，也可以 Post 的方式提交，也可以在请求的地址后面拼接 xxx?SessionID=123456...。\n\n第二种方案，Token 机制。Token 机制多用于 App 客户端和服务器交互的模式，也可以用于 Web 端做用户状态管理。\n\nToken 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。Token 机制和 Cookie 和 Session 的使用机制比较类似。\n\n当用户第一次登录后，服务器根据提交的用户信息生成一个 Token，响应时将 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次登录验证。\n\n\n# 5. 分布式 Session\n\n在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。\n\n分布式 Session 的几种实现策略：\n\n 1. 粘性 session\n 2. 应用服务器间的 session 复制共享\n 3. 基于缓存的 session 共享 ✅\n\n> 推荐：基于缓存的 session 共享\n\n\n# 5.1. 粘性 Session\n\n> 粘性 Session（Sticky Sessions）需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 Session 存放在该服务器节点中。\n> \n> 缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 Session。\n\n\n\n\n# 5.2. Session 复制共享\n\n> Session 复制共享（Session Replication）在服务器节点之间进行 Session 同步操作，这样的话用户可以访问任何一个服务器节点。\n> \n> 缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。\n\n\n\n\n# 5.3. 基于缓存的 session 共享\n\n> 使用一个单独的存储服务器存储 Session 数据，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。\n> \n> 缺点：需要去实现存取 Session 的代码。\n\n\n\n\n# 6. 具体实现\n\n\n# 6.1. JWT Token\n\n使用 JWT Token 储存用户身份，然后再从数据库或者 cache 中获取其他的信息。这样无论请求分配到哪个服务器都无所谓。\n\n\n# 6.2. tomcat + redis\n\n这个其实还挺方便的，就是使用 session 的代码，跟以前一样，还是基于 tomcat 原生的 session 支持即可，然后就是用一个叫做 Tomcat RedisSessionManager 的东西，让所有我们部署的 tomcat 都将 session 数据存储到 redis 即可。\n\n在 tomcat 的配置文件中配置：\n\n<Valve className="com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve" />\n\n<Manager className="com.orangefunction.tomcat.redissessions.RedisSessionManager"\n         host="{redis.host}"\n         port="{redis.port}"\n         database="{redis.dbnum}"\n         maxInactiveInterval="60"/>\n\n\n然后指定 redis 的 host 和 port 就 ok 了。\n\n<Valve className="com.orangefunction.tomcat.redissessions.RedisSessionHandlerValve" />\n<Manager className="com.orangefunction.tomcat.redissessions.RedisSessionManager"\n\t sentinelMaster="mymaster"\n\t sentinels="<sentinel1-ip>:26379,<sentinel2-ip>:26379,<sentinel3-ip>:26379"\n\t maxInactiveInterval="60"/>\n\n\n还可以用上面这种方式基于 redis 哨兵支持的 redis 高可用集群来保存 session 数据，都是 ok 的。\n\n\n# 6.3. spring session + redis\n\n上面那种 tomcat + redis 的方式好用，但是会严重依赖于 web 容器，不好将代码移植到其他 web 容器上去，尤其是你要是换了技术栈咋整？比如换成了 spring cloud 或者是 spring boot 之类的呢？\n\n所以现在比较好的还是基于 Java 一站式解决方案，也就是 spring。人家 spring 基本上承包了大部分我们需要使用的框架，spirng cloud 做微服务，spring boot 做脚手架，所以用 sping session 是一个很好的选择。\n\n在 pom.xml 中配置：\n\n<dependency>\n  <groupId>org.springframework.session</groupId>\n  <artifactId>spring-session-data-redis</artifactId>\n  <version>1.2.1.RELEASE</version>\n</dependency>\n<dependency>\n  <groupId>redis.clients</groupId>\n  <artifactId>jedis</artifactId>\n  <version>2.8.1</version>\n</dependency>\n\n\n在 spring 配置文件中配置：\n\n<bean id="redisHttpSessionConfiguration"\n     class="org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration">\n    <property name="maxInactiveIntervalInSeconds" value="600"/>\n</bean>\n\n<bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig">\n    <property name="maxTotal" value="100" />\n    <property name="maxIdle" value="10" />\n</bean>\n\n<bean id="jedisConnectionFactory"\n      class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" destroy-method="destroy">\n    <property name="hostName" value="${redis_hostname}"/>\n    <property name="port" value="${redis_port}"/>\n    <property name="password" value="${redis_pwd}" />\n    <property name="timeout" value="3000"/>\n    <property name="usePool" value="true"/>\n    <property name="poolConfig" ref="jedisPoolConfig"/>\n</bean>\n\n\n在 web.xml 中配置：\n\n<filter>\n    <filter-name>springSessionRepositoryFilter</filter-name>\n    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>springSessionRepositoryFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n示例代码：\n\n@RestController\n@RequestMapping("/test")\npublic class TestController {\n\n    @RequestMapping("/putIntoSession")\n    public String putIntoSession(HttpServletRequest request, String username) {\n        request.getSession().setAttribute("name",  "leo");\n        return "ok";\n    }\n\n    @RequestMapping("/getFromSession")\n    public String getFromSession(HttpServletRequest request, Model model){\n        String name = request.getSession().getAttribute("name");\n        return name;\n    }\n}\n\n\n上面的代码就是 ok 的，给 sping session 配置基于 redis 来存储 session 数据，然后配置了一个 spring session 的过滤器，这样的话，session 相关操作都会交给 spring session 来管了。接着在代码中，就用原生的 session 操作，就是直接基于 spring sesion 从 redis 中获取数据了。\n\n实现分布式的会话有很多种方式，我说的只不过是比较常见的几种方式，tomcat + redis 早期比较常用，但是会重耦合到 tomcat 中；近些年，通过 spring session 来实现。\n\n\n# 7. 参考资料\n\n * 集群/分布式环境 Session 的几种策略\n * 你真的了解 Cookie 和 Session 吗\n * 聊一聊 session 和 cookie\n * YouTube 视频 - What is a cookie?\n * YouTube 视频 - How cookies can track you (Simply Explained)\n * MDN HTTP cookies',normalizedContent:'# 分布式会话基本原理\n\n> 由于 http 是一种无状态的协议，服务器单单从网络连接上无从知道客户身份。\n> \n> 会话跟踪是 web 程序中常用的技术，用来跟踪用户的整个会话。常用会话跟踪技术是 cookie 与 session。\n\n\n# 1. cookie\n\n由于 http 是一种无状态的协议，服务器单从网络连接上无从知道客户身份。\n\n所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。\n\n\n# 1.1. 什么是 cookie\n\ncookie 实际上是存储在用户浏览器上的文本信息，并保留了各种跟踪的信息。\n\n一个简单的 cookie 设置如下：\n\nset-cookie: <cookie-name>=<cookie-value>\n\n\nhttp/2.0 200 ok\ncontent-type: text/html\nset-cookie: yummy_cookie=choco\nset-cookie: tasty_cookie=strawberry\n\n[page content]\n\n\n\n# 1.2. cookie 的工作步骤\n\n 1. 浏览器请求服务器，如果服务器需要记录该用户的状态，就是用 response 向浏览器颁发一个 cookie。\n 2. 浏览器会把 cookie 保存下来。\n 3. 当浏览器再请求该网站时，浏览器把该请求的网址连同 cookie 一同提交给服务器。服务器检查该 cookie，以此来辨认用户状态。\n\n\n# 1.3. cookie 的作用\n\ncookie 主要用于以下三个方面：\n\n * 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）\n * 个性化设置（如用户自定义设置、主题等）\n * 浏览器行为跟踪（如跟踪分析用户行为等）\n\n注：cookie 功能需要浏览器的支持，如果浏览器不支持 cookie 或者 cookie 禁用了，cookie 功能就会失效。\n\n\n# 1.4. cookie 的重要属性\n\n属性           说明\nname=value   键值对，设置 cookie 的名称及相对应的值，都必须是字符串类型 - 如果值为 unicode 字符，需要为字符编码。\n             - 如果值为二进制数据，则需要使用 base64 编码。\ndomain       指定 cookie 所属域名，默认是当前域名\npath         指定 cookie 在哪个路径（路由）下生效，默认是 \'/\'。 如果设置为 /abc，则只有 /abc\n             下的路由可以访问到该 cookie，如：/abc/read。\nmaxage       cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxage 秒后失效。如果为负数，该\n             cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为\n             0，表示删除该 cookie 。默认为 -1。 - 比 expires 好用。\nexpires      过期时间，在设置的某个时间点后该 cookie 就会失效。 一般浏览器的 cookie\n             都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除\nsecure       该 cookie 是否仅被使用安全协议传输。安全协议有 https，ssl 等，在网络上传输数据之前先将数据加密。默认为\n             false。 当 secure 值为 true 时，cookie 在 http 中是无效，在 https 中才有效。\nhttponly     如果给某个 cookie 设置了 httponly 属性，则无法通过 js 脚本 读取到该 cookie\n             的信息，但还是能通过 application 中手动修改 cookie，所以只是在一定程度上可以防止 xss\n             攻击，不是绝对的安全\n\n\n# 2. session\n\n\n# 2.1. 什么是 session\n\nsession 代表着服务器和客户端一次会话的过程。session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 web 页之间跳转时，存储在 session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 session 超时失效时会话结束。\n\n * session 是另一种记录服务器和客户端会话状态的机制\n * session 是基于 cookie 实现的，session 存储在服务器端，sessionid 会被存储到客户端的 cookie 中\n\n\n\n\n# 2.2. session 的工作步骤\n\n 1. 用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 session。\n 2. 请求返回时将此 session 的唯一标识信息 sessionid 返回给浏览器。\n 3. 浏览器接收到服务器返回的 sessionid 信息后，会将此信息存入到 cookie 中，同时 cookie 记录此 sessionid 属于哪个域名。\n 4. 当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 cookie 信息，如果存在自动将 cookie 信息也发送给服务端，服务端会从 cookie 中获取 sessionid，再根据 sessionid 查找对应的 session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 session 证明用户已经登录可执行后面操作。\n\n根据以上流程可知，sessionid 是连接 cookie 和 session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。\n\n\n# 3. cookie 和 session 的区别\n\ncookie 和 session 的主要区别可以参考以下表格：\n\n       cookie                 session\n作用范围   保存在客户端（浏览器）            保存在服务器端\n隐私策略   存储在客户端，比较容易遭到非法获取      存储在服务端，安全性相对 cookie 要好一些\n存储方式   只能保存 ascii             可以保存任意数据类型。\n                              一般情况下我们可以在 session 中保持一些常用变量信息，比如说 userid 等。\n存储大小   不能超过 4k                存储大小远高于 cookie\n生命周期   可设置为永久保存               一般失效时间较短\n       比如我们经常使用的默认登录（记住我）功能   客户端关闭或者 session 超时都会失效。\n\n\n# 4. 如果禁用 cookie 怎么办\n\n既然服务端是根据 cookie 中的信息判断用户是否登录，那么如果浏览器中禁止了 cookie，如何保障整个机制的正常运转。\n\n第一种方案，每次请求中都携带一个 sessionid 的参数，也可以 post 的方式提交，也可以在请求的地址后面拼接 xxx?sessionid=123456...。\n\n第二种方案，token 机制。token 机制多用于 app 客户端和服务器交互的模式，也可以用于 web 端做用户状态管理。\n\ntoken 的意思是“令牌”，是服务端生成的一串字符串，作为客户端进行请求的一个标识。token 机制和 cookie 和 session 的使用机制比较类似。\n\n当用户第一次登录后，服务器根据提交的用户信息生成一个 token，响应时将 token 返回给客户端，以后客户端只需带上这个 token 前来请求数据即可，无需再次登录验证。\n\n\n# 5. 分布式 session\n\n在分布式场景下，一个用户的 session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 session，就可能导致用户需要重新进行登录等操作。\n\n分布式 session 的几种实现策略：\n\n 1. 粘性 session\n 2. 应用服务器间的 session 复制共享\n 3. 基于缓存的 session 共享 ✅\n\n> 推荐：基于缓存的 session 共享\n\n\n# 5.1. 粘性 session\n\n> 粘性 session（sticky sessions）需要配置负载均衡器，使得一个用户的所有请求都路由到一个服务器节点上，这样就可以把用户的 session 存放在该服务器节点中。\n> \n> 缺点：当服务器节点宕机时，将丢失该服务器节点上的所有 session。\n\n\n\n\n# 5.2. session 复制共享\n\n> session 复制共享（session replication）在服务器节点之间进行 session 同步操作，这样的话用户可以访问任何一个服务器节点。\n> \n> 缺点：占用过多内存；同步过程占用网络带宽以及服务器处理器时间。\n\n\n\n\n# 5.3. 基于缓存的 session 共享\n\n> 使用一个单独的存储服务器存储 session 数据，可以存在 mysql 数据库上，也可以存在 redis 或者 memcached 这种内存型数据库。\n> \n> 缺点：需要去实现存取 session 的代码。\n\n\n\n\n# 6. 具体实现\n\n\n# 6.1. jwt token\n\n使用 jwt token 储存用户身份，然后再从数据库或者 cache 中获取其他的信息。这样无论请求分配到哪个服务器都无所谓。\n\n\n# 6.2. tomcat + redis\n\n这个其实还挺方便的，就是使用 session 的代码，跟以前一样，还是基于 tomcat 原生的 session 支持即可，然后就是用一个叫做 tomcat redissessionmanager 的东西，让所有我们部署的 tomcat 都将 session 数据存储到 redis 即可。\n\n在 tomcat 的配置文件中配置：\n\n<valve classname="com.orangefunction.tomcat.redissessions.redissessionhandlervalve" />\n\n<manager classname="com.orangefunction.tomcat.redissessions.redissessionmanager"\n         host="{redis.host}"\n         port="{redis.port}"\n         database="{redis.dbnum}"\n         maxinactiveinterval="60"/>\n\n\n然后指定 redis 的 host 和 port 就 ok 了。\n\n<valve classname="com.orangefunction.tomcat.redissessions.redissessionhandlervalve" />\n<manager classname="com.orangefunction.tomcat.redissessions.redissessionmanager"\n\t sentinelmaster="mymaster"\n\t sentinels="<sentinel1-ip>:26379,<sentinel2-ip>:26379,<sentinel3-ip>:26379"\n\t maxinactiveinterval="60"/>\n\n\n还可以用上面这种方式基于 redis 哨兵支持的 redis 高可用集群来保存 session 数据，都是 ok 的。\n\n\n# 6.3. spring session + redis\n\n上面那种 tomcat + redis 的方式好用，但是会严重依赖于 web 容器，不好将代码移植到其他 web 容器上去，尤其是你要是换了技术栈咋整？比如换成了 spring cloud 或者是 spring boot 之类的呢？\n\n所以现在比较好的还是基于 java 一站式解决方案，也就是 spring。人家 spring 基本上承包了大部分我们需要使用的框架，spirng cloud 做微服务，spring boot 做脚手架，所以用 sping session 是一个很好的选择。\n\n在 pom.xml 中配置：\n\n<dependency>\n  <groupid>org.springframework.session</groupid>\n  <artifactid>spring-session-data-redis</artifactid>\n  <version>1.2.1.release</version>\n</dependency>\n<dependency>\n  <groupid>redis.clients</groupid>\n  <artifactid>jedis</artifactid>\n  <version>2.8.1</version>\n</dependency>\n\n\n在 spring 配置文件中配置：\n\n<bean id="redishttpsessionconfiguration"\n     class="org.springframework.session.data.redis.config.annotation.web.http.redishttpsessionconfiguration">\n    <property name="maxinactiveintervalinseconds" value="600"/>\n</bean>\n\n<bean id="jedispoolconfig" class="redis.clients.jedis.jedispoolconfig">\n    <property name="maxtotal" value="100" />\n    <property name="maxidle" value="10" />\n</bean>\n\n<bean id="jedisconnectionfactory"\n      class="org.springframework.data.redis.connection.jedis.jedisconnectionfactory" destroy-method="destroy">\n    <property name="hostname" value="${redis_hostname}"/>\n    <property name="port" value="${redis_port}"/>\n    <property name="password" value="${redis_pwd}" />\n    <property name="timeout" value="3000"/>\n    <property name="usepool" value="true"/>\n    <property name="poolconfig" ref="jedispoolconfig"/>\n</bean>\n\n\n在 web.xml 中配置：\n\n<filter>\n    <filter-name>springsessionrepositoryfilter</filter-name>\n    <filter-class>org.springframework.web.filter.delegatingfilterproxy</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>springsessionrepositoryfilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n示例代码：\n\n@restcontroller\n@requestmapping("/test")\npublic class testcontroller {\n\n    @requestmapping("/putintosession")\n    public string putintosession(httpservletrequest request, string username) {\n        request.getsession().setattribute("name",  "leo");\n        return "ok";\n    }\n\n    @requestmapping("/getfromsession")\n    public string getfromsession(httpservletrequest request, model model){\n        string name = request.getsession().getattribute("name");\n        return name;\n    }\n}\n\n\n上面的代码就是 ok 的，给 sping session 配置基于 redis 来存储 session 数据，然后配置了一个 spring session 的过滤器，这样的话，session 相关操作都会交给 spring session 来管了。接着在代码中，就用原生的 session 操作，就是直接基于 spring sesion 从 redis 中获取数据了。\n\n实现分布式的会话有很多种方式，我说的只不过是比较常见的几种方式，tomcat + redis 早期比较常用，但是会重耦合到 tomcat 中；近些年，通过 spring session 来实现。\n\n\n# 7. 参考资料\n\n * 集群/分布式环境 session 的几种策略\n * 你真的了解 cookie 和 session 吗\n * 聊一聊 session 和 cookie\n * youtube 视频 - what is a cookie?\n * youtube 视频 - how cookies can track you (simply explained)\n * mdn http cookies',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"缓存基本原理",frontmatter:{title:"缓存基本原理",categories:["分布式","分布式关键技术","数据调度"],tags:["分布式","数据调度","缓存"],abbrlink:"412ad09",date:"2019-06-27T15:36:00.000Z",permalink:"/pages/471208/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/02.%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%A6/01.%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98.html",relativePath:"02.分布式/03.分布式关键技术/02.数据调度/01.数据缓存.md",key:"v-6091d31b",path:"/pages/471208/",headers:[{level:2,title:"1. 缓存简介",slug:"_1-缓存简介",normalizedTitle:"1. 缓存简介",charIndex:44},{level:3,title:"1.1. 为什么需要缓存",slug:"_1-1-为什么需要缓存",normalizedTitle:"1.1. 为什么需要缓存",charIndex:56},{level:3,title:"1.2. 什么是缓存",slug:"_1-2-什么是缓存",normalizedTitle:"1.2. 什么是缓存",charIndex:426},{level:3,title:"1.3. 何时需要缓存",slug:"_1-3-何时需要缓存",normalizedTitle:"1.3. 何时需要缓存",charIndex:765},{level:3,title:"1.4. 缓存的基本原理",slug:"_1-4-缓存的基本原理",normalizedTitle:"1.4. 缓存的基本原理",charIndex:1062},{level:3,title:"1.5. 缓存淘汰策略",slug:"_1-5-缓存淘汰策略",normalizedTitle:"1.5. 缓存淘汰策略",charIndex:1230},{level:2,title:"2. 缓存的分类",slug:"_2-缓存的分类",normalizedTitle:"2. 缓存的分类",charIndex:1961},{level:3,title:"2.1. HTTP 缓存",slug:"_2-1-http-缓存",normalizedTitle:"2.1. http 缓存",charIndex:2396},{level:3,title:"2.2. CDN 缓存",slug:"_2-2-cdn-缓存",normalizedTitle:"2.2. cdn 缓存",charIndex:2679},{level:4,title:"2.2.1. CDN 原理",slug:"_2-2-1-cdn-原理",normalizedTitle:"2.2.1. cdn 原理",charIndex:2870},{level:4,title:"2.2.2. CDN 特点",slug:"_2-2-2-cdn-特点",normalizedTitle:"2.2.2. cdn 特点",charIndex:3305},{level:3,title:"2.3. 反向代理缓存",slug:"_2-3-反向代理缓存",normalizedTitle:"2.3. 反向代理缓存",charIndex:3851},{level:4,title:"2.3.1. 反向代理缓存原理",slug:"_2-3-1-反向代理缓存原理",normalizedTitle:"2.3.1. 反向代理缓存原理",charIndex:3997},{level:4,title:"2.3.2. 反向代理缓存比较",slug:"_2-3-2-反向代理缓存比较",normalizedTitle:"2.3.2. 反向代理缓存比较",charIndex:4262},{level:2,title:"3. 进程内缓存",slug:"_3-进程内缓存",normalizedTitle:"3. 进程内缓存",charIndex:4627},{level:3,title:"3.1. ConcurrentHashMap",slug:"_3-1-concurrenthashmap",normalizedTitle:"3.1. concurrenthashmap",charIndex:4904},{level:3,title:"3.2. LRUHashMap",slug:"_3-2-lruhashmap",normalizedTitle:"3.2. lruhashmap",charIndex:5028},{level:3,title:"3.3. Guava Cache",slug:"_3-3-guava-cache",normalizedTitle:"3.3. guava cache",charIndex:5177},{level:3,title:"3.4. Caffeine",slug:"_3-4-caffeine",normalizedTitle:"3.4. caffeine",charIndex:5396},{level:3,title:"3.5. Ehcache",slug:"_3-5-ehcache",normalizedTitle:"3.5. ehcache",charIndex:5510},{level:3,title:"3.6. 进程内缓存对比",slug:"_3-6-进程内缓存对比",normalizedTitle:"3.6. 进程内缓存对比",charIndex:5876},{level:2,title:"4. 分布式缓存",slug:"_4-分布式缓存",normalizedTitle:"4. 分布式缓存",charIndex:7334},{level:3,title:"4.1. Memcached",slug:"_4-1-memcached",normalizedTitle:"4.1. memcached",charIndex:7519},{level:4,title:"4.1.1. Memcached 特性",slug:"_4-1-1-memcached-特性",normalizedTitle:"4.1.1. memcached 特性",charIndex:7674},{level:4,title:"4.1.2. Memcached 工作原理",slug:"_4-1-2-memcached-工作原理",normalizedTitle:"4.1.2. memcached 工作原理",charIndex:8536},{level:3,title:"4.2. Redis",slug:"_4-2-redis",normalizedTitle:"4.2. redis",charIndex:9492},{level:4,title:"4.2.1. Redis 特性",slug:"_4-2-1-redis-特性",normalizedTitle:"4.2.1. redis 特性",charIndex:9764},{level:4,title:"4.2.2. Redis 原理",slug:"_4-2-2-redis-原理",normalizedTitle:"4.2.2. redis 原理",charIndex:10147},{level:3,title:"4.3. 分布式缓存对比",slug:"_4-3-分布式缓存对比",normalizedTitle:"4.3. 分布式缓存对比",charIndex:10916},{level:2,title:"5. 多级缓存",slug:"_5-多级缓存",normalizedTitle:"5. 多级缓存",charIndex:11759},{level:3,title:"5.1. 整体缓存框架",slug:"_5-1-整体缓存框架",normalizedTitle:"5.1. 整体缓存框架",charIndex:11771},{level:3,title:"5.2. 使用进程内缓存",slug:"_5-2-使用进程内缓存",normalizedTitle:"5.2. 使用进程内缓存",charIndex:12077},{level:3,title:"5.3. 使用分布式缓存",slug:"_5-3-使用分布式缓存",normalizedTitle:"5.3. 使用分布式缓存",charIndex:12350},{level:3,title:"5.4. 使用多级缓存",slug:"_5-4-使用多级缓存",normalizedTitle:"5.4. 使用多级缓存",charIndex:12565},{level:4,title:"5.4.1. 多级缓存查询",slug:"_5-4-1-多级缓存查询",normalizedTitle:"5.4.1. 多级缓存查询",charIndex:12922},{level:4,title:"5.4.2. 多级缓存更新",slug:"_5-4-2-多级缓存更新",normalizedTitle:"5.4.2. 多级缓存更新",charIndex:13089},{level:2,title:"6. 缓存问题",slug:"_6-缓存问题",normalizedTitle:"6. 缓存问题",charIndex:13397},{level:3,title:"6.1. 缓存雪崩",slug:"_6-1-缓存雪崩",normalizedTitle:"6.1. 缓存雪崩",charIndex:13409},{level:3,title:"6.2. 缓存穿透",slug:"_6-2-缓存穿透",normalizedTitle:"6.2. 缓存穿透",charIndex:14149},{level:3,title:"6.3. 缓存击穿",slug:"_6-3-缓存击穿",normalizedTitle:"6.3. 缓存击穿",charIndex:14708},{level:3,title:"6.4. 小结",slug:"_6-4-小结",normalizedTitle:"6.4. 小结",charIndex:14964},{level:2,title:"7. 缓存策略",slug:"_7-缓存策略",normalizedTitle:"7. 缓存策略",charIndex:15320},{level:3,title:"7.1. 缓存预热",slug:"_7-1-缓存预热",normalizedTitle:"7.1. 缓存预热",charIndex:15332},{level:3,title:"7.2. 如何缓存",slug:"_7-2-如何缓存",normalizedTitle:"7.2. 如何缓存",charIndex:15493},{level:4,title:"7.2.1. 不过期缓存",slug:"_7-2-1-不过期缓存",normalizedTitle:"7.2.1. 不过期缓存",charIndex:15506},{level:4,title:"7.2.2. 过期缓存",slug:"_7-2-2-过期缓存",normalizedTitle:"7.2.2. 过期缓存",charIndex:15714},{level:3,title:"7.3. 缓存更新",slug:"_7-3-缓存更新",normalizedTitle:"7.3. 缓存更新",charIndex:15765},{level:4,title:"7.3.1. Cache Aside",slug:"_7-3-1-cache-aside",normalizedTitle:"7.3.1. cache aside",charIndex:16037},{level:5,title:"7.3.1.1. 为什么不能先更新数据库，再更新缓存？",slug:"_7-3-1-1-为什么不能先更新数据库-再更新缓存",normalizedTitle:"7.3.1.1. 为什么不能先更新数据库，再更新缓存？",charIndex:16205},{level:5,title:"7.3.1.2. 为什么不能先删缓存，再更新数据库？",slug:"_7-3-1-2-为什么不能先删缓存-再更新数据库",normalizedTitle:"7.3.1.2. 为什么不能先删缓存，再更新数据库？",charIndex:16371},{level:5,title:"7.3.1.3. 先更新数据库，再删除缓存就没问题了吗",slug:"_7-3-1-3-先更新数据库-再删除缓存就没问题了吗",normalizedTitle:"7.3.1.3. 先更新数据库，再删除缓存就没问题了吗",charIndex:16487},{level:4,title:"7.3.2. Read/Write Through",slug:"_7-3-2-read-write-through",normalizedTitle:"7.3.2. read/write through",charIndex:16747},{level:4,title:"7.3.3. Write behind",slug:"_7-3-3-write-behind",normalizedTitle:"7.3.3. write behind",charIndex:17019},{level:2,title:"8. 总结",slug:"_8-总结",normalizedTitle:"8. 总结",charIndex:17239},{level:2,title:"9. 参考资料",slug:"_9-参考资料",normalizedTitle:"9. 参考资料",charIndex:17295}],headersStr:"1. 缓存简介 1.1. 为什么需要缓存 1.2. 什么是缓存 1.3. 何时需要缓存 1.4. 缓存的基本原理 1.5. 缓存淘汰策略 2. 缓存的分类 2.1. HTTP 缓存 2.2. CDN 缓存 2.2.1. CDN 原理 2.2.2. CDN 特点 2.3. 反向代理缓存 2.3.1. 反向代理缓存原理 2.3.2. 反向代理缓存比较 3. 进程内缓存 3.1. ConcurrentHashMap 3.2. LRUHashMap 3.3. Guava Cache 3.4. Caffeine 3.5. Ehcache 3.6. 进程内缓存对比 4. 分布式缓存 4.1. Memcached 4.1.1. Memcached 特性 4.1.2. Memcached 工作原理 4.2. Redis 4.2.1. Redis 特性 4.2.2. Redis 原理 4.3. 分布式缓存对比 5. 多级缓存 5.1. 整体缓存框架 5.2. 使用进程内缓存 5.3. 使用分布式缓存 5.4. 使用多级缓存 5.4.1. 多级缓存查询 5.4.2. 多级缓存更新 6. 缓存问题 6.1. 缓存雪崩 6.2. 缓存穿透 6.3. 缓存击穿 6.4. 小结 7. 缓存策略 7.1. 缓存预热 7.2. 如何缓存 7.2.1. 不过期缓存 7.2.2. 过期缓存 7.3. 缓存更新 7.3.1. Cache Aside 7.3.1.1. 为什么不能先更新数据库，再更新缓存？ 7.3.1.2. 为什么不能先删缓存，再更新数据库？ 7.3.1.3. 先更新数据库，再删除缓存就没问题了吗 7.3.2. Read/Write Through 7.3.3. Write behind 8. 总结 9. 参考资料",content:"# 缓存基本原理\n\n> 缓存是一种利用空间换时间的设计，其目标就是更快、更近。\n\n\n# 1. 缓存简介\n\n\n# 1.1. 为什么需要缓存\n\n众所周知，当今是一个互联网时代，而互联网应用几乎遍及我们日常生活的方方面面。一般而言，一个互联网应用的请求/响应流程会有以下几个主要流程：\n\n * 客户端发起请求，请求经过网络 I/O，分发到服务层。\n * 服务层可能有多级服务，请求需要被多个服务层层处理。\n * 不同服务根据请求进行计算时，可能依赖于不同数据库的数据，需要通过网络 I/O 读写数据库。\n\n显然，这一套流程下来，可能需要消耗大量的计算机资源，并且响应时间也可能很久。如果并发请求量很大的话，可能会进一步加剧这种问题。\n\n\n\n为了解决以上问题，最直接的方式就是引入缓存。缓存可以作用于请求/响应流程的任意环节，并有效减少后续环节的执行次数，从而大大提升性能。\n\n实际上，缓存作为性能优化的第一手段，被广泛应用于计算机的硬件、软件领域。\n\n\n# 1.2. 什么是缓存\n\n缓存就是数据交换的缓冲区，用于将频繁访问的数据暂存。缓存的本质是一个内存 Hash。\n\n缓存的本质是一种利用空间换时间的设计：牺牲一定的数据实时性，使得访问更快、更近：\n\n * 将数据存储到读取速度更快的存储（设备）；\n * 将数据存储到离应用最近的位置；\n * 将数据存储到离用户最近的位置。\n\n缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。典型的应用场景：有 cpu cache, 磁盘 cache 等。本文中提及到缓存主要是指互联网应用中所使用的缓存组件。\n\n缓存命中率是缓存的重要度量指标，命中率越高越好。\n\n缓存命中率 = 从缓存中读取次数 / 总读取次数\n\n\n\n# 1.3. 何时需要缓存\n\n引入缓存，会增加系统的复杂度，并牺牲一定的数据实时性。所以，引入缓存前，需要先权衡是否值得，考量点如下：\n\n * CPU 开销 - 如果应用某个计算需要消耗大量 CPU，可以考虑缓存其计算结果。典型场景：复杂的、频繁调用的正则计算；分布式计算中间状态等。\n * IO 开销 - 如果数据库连接池比较繁忙，可以考虑缓存其查询结果。\n\n在数据层引入缓存，有以下几个好处：\n\n * 提升数据读取速度。\n * 提升系统扩展能力，通过扩展缓存，提升系统承载能力。\n * 降低存储成本，Cache+DB 的方式可以承担原有需要多台 DB 才能承担的请求量，节省机器成本。\n\n\n# 1.4. 缓存的基本原理\n\n根据业务场景，通常缓存有以下几种使用方式：\n\n * 懒汉式(读时触发)：先查询 DB 里的数据, 然后把相关的数据写入 Cache。\n * 饥饿式(写时触发)：写入 DB 后, 然后把相关的数据也写入 Cache。\n * 定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性。\n\n\n# 1.5. 缓存淘汰策略\n\n缓存淘汰的类型：\n\n * 基于空间 - 设置缓存空间大小。\n * 基于容量 - 设置缓存存储记录数。\n * 基于时间\n   * TTL（Time To Live，即存活期）缓存数据从创建到过期的时间。\n   * TTI（Time To Idle，即空闲期）缓存数据多久没被访问的时间。\n\n缓存淘汰算法：\n\n * FIFO (first in first out) - 先进先出。在这种淘汰算法中，先进入缓存的会先被淘汰。这种可谓是最简单的了，但是会导致我们命中率很低。试想一下我们如果有个访问频率很高的数据是所有数据第一个访问的，而那些不是很高的是后面再访问的，那这样就会把我们的首个数据但是他的访问频率很高给挤出。\n * LRU (least recently used) - 最近最少使用算法。这种算法避免了 FIFO 命中率不高的问题：每次访问数据都会将其放在我们的队尾，如果需要淘汰数据，就只需要淘汰队首即可。但是这个算法依然有缺点：假设，缓存只保留 1 分钟以内的热点数据。如果有个数据在 1 个小时的前 59 分钟访问了 1 万次（可见这是个热点数据），最后一分钟没有任何访问；但是，其他的数据有被访问，就会导致这个热点数据被淘汰。\n * LFU (less frequently used) - 最近最少频率使用。在这种算法中又对上面进行了优化，利用额外的空间记录每个数据的使用频率，然后选出频率最低进行淘汰。这样就避免了 LRU 不能处理时间段的问题。\n\n这三种缓存淘汰算法，实现复杂度一个比一个高，同样的命中率也是一个比一个好。而我们一般来说选择的方案居中即可，即实现成本不是太高，而命中率也还行的 LRU。\n\n\n# 2. 缓存的分类\n\n缓存从部署角度，可以分为客户端缓存和服务端缓存。\n\n客户端缓存\n\n * Http 缓存：HTTP/1.1 中的 Cache-Control、HTTP/1 中的 Expires\n * 浏览器缓存：HTML5 提供的 SessionStorage 和 LocalStorage、Cookie\n * APP 缓存\n   * Android\n   * IOS\n\n服务端缓存\n\n * CDN 缓存 - 存放 HTML、CSS、JS 等静态资源。\n * 反向代理缓存 - 动静分离，只缓存用户请求的静态资源。\n * 数据库缓存 - 数据库（如 Mysql）自身一般也有缓存，但因为命中率和更新频率问题，不推荐使用。\n * 进程内缓存 - 缓存应用字典等常用数据。\n * 分布式缓存 - 缓存数据库中的热点数据。\n\n> 其中，CDN 缓存、反向代理缓存、数据库缓存一般由专职人员维护（运维、DBA）。\n> \n> 后端开发一般聚焦于进程内缓存、分布式缓存。\n\n\n# 2.1. HTTP 缓存\n\n 1. 浏览器发送请求前，根据请求头的 expires (HTTP/1) 和 cache-control (HTTP/1.1) 判断是否命中（包括是否过期）强缓存策略，\n    \n    1. 如果命中，直接从缓存获取资源，并不会发送请求。\n    2. 如果没有命中，则进入下一步。\n\n 2. 没有命中强缓存规则，浏览器会发送请求，根据请求头的 last-modified 和 etag 判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。\n\n 3. 如果前两步都没有命中，则直接从服务端获取资源。\n\n\n# 2.2. CDN 缓存\n\n> CDN 将数据缓存到离用户物理距离最近的服务器，使得用户可以就近获取请求内容。CDN 一般缓存静态资源文件（页面，脚本，图片，视频，文件等）。\n> \n> 国内网络异常复杂，跨运营商的网络访问会很慢。为了解决跨运营商或各地用户访问问题，可以在重要的城市，部署 CDN 应用。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。\n\n\n\n# 2.2.1. CDN 原理\n\nCDN 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。\n\n（1）未部署 CDN 应用前的网络路径：\n\n * 请求：本机网络（局域网）=> 运营商网络 => 应用服务器机房\n * 响应：应用服务器机房 => 运营商网络 => 本机网络（局域网）\n\n在不考虑复杂网络的情况下，从请求到响应需要经过 3 个节点，6 个步骤完成一次用户访问操作。\n\n（2）部署 CDN 应用后网络路径：\n\n * 请求：本机网络（局域网） => 运营商网络\n * 响应：运营商网络 => 本机网络（局域网）\n\n在不考虑复杂网络的情况下，从请求到响应需要经过 2 个节点，2 个步骤完成一次用户访问操作。\n\n与不部署 CDN 服务相比，减少了 1 个节点，4 个步骤的访问。极大的提高了系统的响应速度。\n\n# 2.2.2. CDN 特点\n\n优点\n\n * 本地 Cache 加速 - 提升访问速度，尤其含有大量图片和静态页面站点；\n * 实现跨运营商的网络加速 - 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；\n * 远程加速 - 远程访问用户根据 DNS 负载均衡技术智能自动选择 Cache 服务器，选择最快的 Cache 服务器，加快远程访问的速度；\n * 带宽优化 - 自动生成服务器的远程 Mirror（镜像）cache 服务器，远程用户访问时从 cache 服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点 WEB 服务器负载等功能。\n * 集群抗攻击 - 广泛分布的 CDN 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种 D.D.o.S 攻击对网站的影响，同时保证较好的服务质量。\n\n缺点\n\n * 不适宜缓存动态资源\n   * 解决方案：主要缓存静态资源，动态资源建立多级缓存或准实时同步；\n * 存在数据的一致性问题\n   * 解决方案（主要是在性能和数据一致性二者间寻找一个平衡）\n   * 设置缓存失效时间（1 个小时，过期后同步数据）。\n   * 针对资源设置版本号。\n\n\n# 2.3. 反向代理缓存\n\n> 反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n\n\n# 2.3.1. 反向代理缓存原理\n\n反向代理位于应用服务器同一网络，处理所有对 WEB 服务器的请求。\n\n反向代理缓存的原理：\n\n * 如果用户请求的页面在代理服务器上有缓存的话，代理服务器直接将缓存内容发送给用户。\n * 如果没有缓存则先向 WEB 服务器发出请求，取回数据，本地缓存后再发送给用户。\n\n这种方式通过降低向 WEB 服务器的请求数，从而降低了 WEB 服务器的负载。\n\n反向代理缓存一般针对的是静态资源，而将动态资源请求转发到应用服务器处理。常用的缓存应用服务器有 Varnish，Ngnix，Squid。\n\n# 2.3.2. 反向代理缓存比较\n\n常用的代理缓存有 Varnish，Squid，Ngnix，简单比较如下：\n\n * Varnish 和 Squid 是专业的 cache 服务，Ngnix 需要第三方模块支持；\n * Varnish 采用内存型缓存，避免了频繁在内存、磁盘中交换文件，性能比 Squid 高；\n * Varnish 由于是内存 cache，所以对小文件如 css、js、小图片的支持很棒，后端的持久化缓存可以采用的是 Squid 或 ATS；\n * Squid 功能全而大，适合于各种静态的文件缓存，一般会在前端挂一个 HAProxy 或 Ngnix 做负载均衡跑多个实例；\n * Nginx 采用第三方模块 ncache 做的缓冲，性能基本达到 Varnish，一般作为反向代理使用，可以实现简单的缓存。\n\n\n# 3. 进程内缓存\n\n> 进程内缓存是指应用内部的缓存，标准的分布式系统，一般有多级缓存构成。本地缓存是离应用最近的缓存，一般可以将数据缓存到硬盘或内存。\n\n * 硬盘缓存 - 将数据缓存到硬盘中，读取时从硬盘读取。原理是直接读取本机文件，减少了网络传输消耗，比通过网络读取数据库速度更快。可以应用在对速度要求不是很高，但需要大量缓存存储的场景。\n * 内存缓存 - 直接将数据存储到本机内存中，通过程序直接维护缓存对象，是访问速度最快的方式。\n\n常见的本地缓存实现方案：HashMap、Guava Cache、Caffeine、Ehcache。\n\n\n# 3.1. ConcurrentHashMap\n\n最简单的进程内缓存可以通过 JDK 自带的 HashMap 或 ConcurrentHashMap 实现。\n\n适用场景：不需要淘汰的缓存数据。\n\n缺点：无法进行缓存淘汰，内存会无限制的增长。\n\n\n# 3.2. LRUHashMap\n\n可以通过继承 LinkedHashMap 来实现一个简单的 LRUHashMap。重写 removeEldestEntry 方法，即可完成一个简单的最近最少使用算法。\n\n缺点：\n\n * 锁竞争严重，性能比较低。\n * 不支持过期时间\n * 不支持自动刷新\n\n\n# 3.3. Guava Cache\n\n解决了 LRUHashMap 中的几个缺点。\n\nGuava Cache 采用了类似 ConcurrentHashMap 的思想，分段加锁，减少锁竞争。\n\nGuava Cache 对于过期的 Entry 并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。\n\n直接通过查询，判断其是否满足刷新条件，进行刷新。\n\n\n# 3.4. Caffeine\n\nCaffeine 实现了 W-TinyLFU(LFU + LRU 算法的变种)，其命中率和读写吞吐量大大优于 Guava Cache。\n\n其实现原理较复杂，可以参考你应该知道的缓存进化史。\n\n\n# 3.5. Ehcache\n\nEhCache 是一个纯 Java 的进程内缓存框架，具有快速、精干等特点，是 Hibernate 中默认的 CacheProvider。\n\n优点\n\n * 快速、简单\n * 支持多种缓存策略：LRU、LFU、FIFO 淘汰算法\n * 缓存数据有两级：内存和磁盘，因此无需担心容量问题\n * 缓存数据会在虚拟机重启的过程中写入磁盘\n * 可以通过 RMI、可插入 API 等方式进行分布式缓存\n * 具有缓存和缓存管理器的侦听接口\n * 支持多缓存管理器实例，以及一个实例的多个缓存区域\n * 提供 Hibernate 的缓存实现\n\n缺点\n\n * 使用磁盘 Cache 的时候非常占用磁盘空间\n * 不保证数据的安全\n * 虽然支持分布式缓存，但效率不高（通过组播方式，在不同节点之间同步数据）。\n\n\n# 3.6. 进程内缓存对比\n\n常用进程内缓存技术对比：\n\n比较项      CONCURRENTHASHMAP   LRUMAP                EHCACHE                 GUAVA CACHE             CAFFEINE\n读写性能     很好，分段锁              一般，全局加锁               好                       好，需要做淘汰操作               很好\n淘汰算法     无                   LRU，一般                支持多种淘汰算法,LRU,LFU,FIFO   LRU，一般                  W-TinyLFU, 很好\n功能丰富程度   功能比较简单              功能比较单一                功能很丰富                   功能很丰富，支持刷新和虚引用等         功能和 Guava Cache 类似\n工具大小     jdk 自带类，很小          基于 LinkedHashMap，较小   很大，最新版本 1.4MB           是 Guava 工具类中的一个小部分，较小   一般，最新版本 644KB\n是否持久化    否                   否                     是                       否                       否\n是否支持集群   否                   否                     是                       否                       否\n\n * ConcurrentHashMap - 比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是 JDK 自带的类，在各种框架中依然有大量的使用，比如我们可以用来缓存我们反射的 Method，Field 等等；也可以缓存一些链接，防止其重复建立。在 Caffeine 中也是使用的 ConcurrentHashMap 来存储元素。\n * LRUMap - 如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。\n * Ehcache - 由于其 jar 包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择 Ehcache。需要注意的是，虽然 Ehcache 也支持分布式缓存，但是由于其节点间通信方式为 rmi，表现不如 Redis，所以一般不建议用它来作为分布式缓存。\n * Guava Cache - Guava 这个 jar 包在很多 Java 应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解 Caffeine 的情况下可以选择 Guava Cache。\n * Caffeine - 其在命中率，读写性能上都比 Guava Cache 好很多，并且其 API 和 Guava cache 基本一致，甚至会多一点。在真实环境中使用 Caffeine，取得过不错的效果。\n\n总结一下：如果不需要淘汰算法则选择 ConcurrentHashMap，如果需要淘汰算法和一些丰富的 API，推荐选择 Caffeine。\n\n\n# 4. 分布式缓存\n\n> 分布式缓存解决了进程内缓存最大的问题：如果应用是分布式系统，节点之间无法共享彼此的进程内缓存。\n> \n> 分布式缓存的应用场景：\n> \n>  * 缓存经过复杂计算得到的数据\n>  * 缓存系统中频繁访问的热点数据，减轻数据库压力\n\n不同分布式缓存的实现原理往往有比较大的差异。本文主要针对 Memcached 和 Redis 进行说明。\n\n\n# 4.1. Memcached\n\n> Memcached 是一个高性能，分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的 hash 表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。\n> \n> 简单的说就是：将数据缓存到内存中，然后从内存中读取，从而大大提高读取速度。\n\n# 4.1.1. Memcached 特性\n\n * 使用物理内存作为缓存区，可独立运行在服务器上。每个进程最大 2G，如果想缓存更多的数据，可以开辟更多的 Memcached 进程（不同端口）或者使用分布式 Memcached 进行缓存，将数据缓存到不同的物理机或者虚拟机上。\n * 使用 key-value 的方式来存储数据。这是一种单索引的结构化数据组织形式，可使数据项查询时间复杂度为 O(1)。\n * 协议简单，基于文本行的协议。直接通过 telnet 在 Memcached 服务器上可进行存取数据操作，简单，方便多种缓存参考此协议；\n * 基于 libevent 高性能通信。Libevent 是一套利用 C 开发的程序库，它将 BSD 系统的 kqueue,Linux 系统的 epoll 等事件处理功能封装成一个接口，与传统的 select 相比，提高了性能。\n * 分布式能力取决于 Memcached 客户端，服务器之间互不通信。各个 Memcached 服务器之间互不通信，各自独立存取数据，不共享任何信息。服务器并不具有分布式功能，分布式部署取决于 Memcached 客户端。\n * 采用 LRU 缓存淘汰策略。在 Memcached 内存储数据项时，可以指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后也是最近未使用的数据。在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略，自己不会监控存入的 key/vlue 对是否过期，而是在获取 key 值时查看记录的时间戳，检查 key/value 对空间是否过期，这样可减轻服务器的负载。\n * 内置了一套高效的内存管理算法。这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。当内存满后，通过 LRU 算法自动删除不使用的缓存。\n * 不支持持久化。Memcached 没有考虑数据的容灾问题，重启服务，所有数据会丢失。\n\n# 4.1.2. Memcached 工作原理\n\n（1）内存管理\n\nMemcached 利用 slab allocation 机制来分配和管理内存，它按照预先规定的大小，将分配的内存分割成特定长度的内存块，再把尺寸相同的内存块分成组，数据在存放时，根据键值 大小去匹配 slab 大小，找就近的 slab 存放，所以存在空间浪费现象。\n\n这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。\n\n（2）缓存淘汰策略\n\nMemcached 的缓存淘汰策略是 LRU + 到期失效策略。\n\n当你在 Memcached 内存储数据项时，你有可能会指定它在缓存的失效时间，默认为永久。当 Memcached 服务器用完分配的内时，失效的数据被首先替换，然后是最近未使用的数据。\n\n在 LRU 中，Memcached 使用的是一种 Lazy Expiration 策略：Memcached 不会监控存入的 key/vlue 对是否过期，而是在获取 key 值时查看记录的时间戳，检查 key/value 对空间是否过期，这样可减轻服务器的负载。\n\n（3）分区\n\nMemcached 服务器之间彼此不通信，它的分布式能力是依赖客户端来实现。\n\n具体来说，就是在客户端实现一种算法，根据 key 来计算出数据应该向哪个服务器节点读/写。\n\n而这种选取集群节点的算法常见的有三种：\n\n * 哈希取余算法 - 使用公式：hash（key）% N 计算出 哈希值 来决定数据映射到哪一个节点。\n * 一致性哈希算法 - 可以很好的解决 稳定性问题，可以将所有的 存储节点 排列在 首尾相接 的 Hash 环上，每个 key 在计算 Hash 后会 顺时针 找到 临接 的 存储节点 存放。而当有节点 加入 或 退出 时，仅影响该节点在 Hash 环上 顺时针相邻 的 后续节点。\n * 虚拟 Hash 槽算法 - 使用 分散度良好 的 哈希函数 把所有数据 映射 到一个 固定范围 的 整数集合 中，整数定义为 槽（slot），这个范围一般 远远大于 节点数。槽 是集群内 数据管理 和 迁移 的 基本单位。采用 大范围槽 的主要目的是为了方便 数据拆分 和 集群扩展。每个节点会负责 一定数量的槽。\n\n\n# 4.2. Redis\n\n> Redis 是一个开源（BSD 许可）的，基于内存的，多数据结构存储系统。可以用作数据库、缓存和消息中间件。\n> \n> Redis 还可以使用客户端分片来扩展写性能。内置了 复制（replication），LUA 脚本（Lua scripting），LRU 驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis 哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。\n\n# 4.2.1. Redis 特性\n\n * 支持多种数据类型 - string、hash、list、set、sorted set。\n\n * 支持多种数据淘汰策略\n   \n   * volatile-lru - 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰\n   * volatile-ttl - 从已设置过期时间的数据集中挑选将要过期的数据淘汰\n   * volatile-random - 从已设置过期时间的数据集中任意选择数据淘汰\n   * allkeys-lru - 从所有数据集中挑选最近最少使用的数据淘汰\n   * allkeys-random - 从所有数据集中任意选择数据进行淘汰\n   * noeviction - 禁止驱逐数据\n\n * 提供两种持久化方式 - RDB 和 AOF\n\n * 通过 Redis cluster 提供集群模式。\n\n# 4.2.2. Redis 原理\n\n * 缓存淘汰\n   * Redis 有两种数据淘汰实现\n     * 消极方式 - 访问 Redis key 时，如果发现它已经失效，则删除它\n     * 积极方式 - 周期性从设置了失效时间的 key 中，根据淘汰策略，选择一部分失效的 key 进行删除。\n * 分区\n   * Redis Cluster 集群包含 16384 个虚拟 Hash 槽，它通过一个高效的算法来计算 key 属于哪个 Hash 槽。\n   * Redis Cluster 支持请求分发 - 节点在接到一个命令请求时，会先检测这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个 MOVED 错误，MOVED 错误携带的信息可以指引客户端将请求重定向至正在负责相关槽的节点。\n * 主从复制\n   * Redis 2.8 后支持异步复制。它有两种模式：\n     * 完整重同步（full resychronization） - 用于初次复制。执行步骤与 SYNC 命令基本一致。\n     * 部分重同步（partial resychronization） - 用于断线后重复制。如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。\n   * 集群中每个节点都会定期向集群中的其他节点发送 PING 消息，以此来检测对方是否在线。\n   * 如果一个主节点被认为下线，则在其从节点中，根据 Raft 算法，选举出一个节点，升级为主节点。\n * 数据一致性\n   * Redis 不保证强一致性，因为这会使得集群性能大大降低。\n   * Redis 是通过异步复制来实现最终一致性。\n\n\n# 4.3. 分布式缓存对比\n\n不同的分布式缓存功能特性和实现原理方面有很大的差异，因此他们所适应的场景也有所不同。\n\n\n\n这里选取三个比较出名的分布式缓存（MemCache，Redis，Tair）来作为比较：\n\n比较项    MEMCACHE              REDIS                                TAIR\n数据结构   只支持简单的 Key-Value 结构   String,Hash, List, Set, Sorted Set   String,HashMap, List，Set\n持久化    不支持                   支持                                   支持\n容量大小   数据纯内存，数据存储不宜过多        数据全内存，资源成本考量不宜超过 100GB               可以配置全内存或内存+磁盘引擎，数据容量可无限扩充\n读写性能   很高                    很高(RT0.5ms 左右)                       String 类型比较高(RT1ms 左右)，复杂类型比较慢(RT5ms 左右)\n过期策略   过期后，不删除缓存             有六种策略来处理过期数据                         支持\n\n * MemCache - 只适合基于内存的缓存框架；且不支持数据持久化和容灾。\n * Redis - 支持丰富的数据结构，读写性能很高，但是数据全内存，必须要考虑资源成本，支持持久化。\n * Tair - 支持丰富的数据结构，读写性能较高，部分类型比较慢，理论上容量可以无限扩充。\n\n总结：如果服务对延迟比较敏感，Map/Set 数据也比较多的话，比较适合 Redis。如果服务需要放入缓存量的数据很大，对延迟又不是特别敏感的话，那就可以选择 Memcached。\n\n\n# 5. 多级缓存\n\n\n# 5.1. 整体缓存框架\n\n通常，一个大型软件系统的缓存采用多级缓存方案：\n\n\n\n请求过程：\n\n 1. 浏览器向客户端发起请求，如果 CDN 有缓存则直接返回；\n 2. 如果 CDN 无缓存，则访问反向代理服务器；\n 3. 如果反向代理服务器有缓存则直接返回；\n 4. 如果反向代理服务器无缓存或动态请求，则访问应用服务器；\n 5. 应用服务器访问进程内缓存；如果有缓存，则返回代理服务器，并缓存数据；（动态请求不缓存）\n 6. 如果进程内缓存无数据，则读取分布式缓存；并返回应用服务器；应用服务器将数据缓存到本地缓存（部分）；\n 7. 如果分布式缓存无数据，则应用程序读取数据库数据，并放入分布式缓存；\n\n\n# 5.2. 使用进程内缓存\n\n如果应用服务是单点应用，那么进程内缓存当然是缓存的首选方案。\n\n对于进程内缓存，其本来受限于内存的大小的限制，以及进程缓存更新后其他缓存无法得知，所以一般来说进程缓存适用于:\n\n * 数据量不是很大且更新频率较低的数据。\n * 如果更新频繁的数据，也想使用进程内缓存，那么可以将其过期时间设置为较短的时间，或者设置较短的自动刷新时间。\n\n这种方案存在以下问题：\n\n * 如果应用服务是分布式系统，应用节点之间无法共享缓存，存在数据不一致问题。\n * 由于进程内缓存受限于内存大小的限制，所以缓存不能无限扩展。\n\n\n# 5.3. 使用分布式缓存\n\n如果应用服务是分布式系统，那么最简单的缓存方案就是直接使用分布式缓存。\n\n其应用场景如图所示：\n\n\n\nRedis 用来存储热点数据，如果缓存不命中，则去查询数据库，并更新缓存。\n\n这种方案存在以下问题：\n\n 1. 缓存服务如果挂了，这时应用只能访问数据库，容易造成缓存雪崩。\n 2. 访问分布式缓存服务会有一定的 I/O 以及序列化反序列化的开销，虽然性能很高，但是其终究没有在内存中查询快。\n\n\n# 5.4. 使用多级缓存\n\n单纯使用进程内缓存和分布式缓存都存在各自的不足。如果需要更高的性能以及更好的可用性，我们可以将缓存设计为多级结构。将最热的数据使用进程内缓存存储在内存中，进一步提升访问速度。\n\n这个设计思路在计算机系统中也存在，比如 CPU 使用 L1、L2、L3 多级缓存，用来减少对内存的直接访问，从而加快访问速度。\n\n一般来说，多级缓存架构使用二级缓存已可以满足大部分业务需求，过多的分级会增加系统的复杂度以及维护的成本。因此，多级缓存不是分级越多越好，需要根据实际情况进行权衡。\n\n一个典型的二级缓存架构，可以使用进程内缓存（如： Caffeine/Google Guava/Ehcache/HashMap）作为一级缓存；使用分布式缓存（如：Redis/Memcached）作为二级缓存。\n\n# 5.4.1. 多级缓存查询\n\n\n\n多级缓存查询流程如下：\n\n 1. 首先，查询 L1 缓存，如果缓存命中，直接返回结果；如果没有命中，执行下一步。\n 2. 接下来，查询 L2 缓存，如果缓存命中，直接返回结果并回填 L1 缓存；如果没有命中，执行下一步。\n 3. 最后，查询数据库，返回结果并依次回填 L2 缓存、L1 缓存。\n\n# 5.4.2. 多级缓存更新\n\n对于 L1 缓存，如果有数据更新，只能删除并更新所在机器上的缓存，其他机器只能通过超时机制来刷新缓存。超时设定可以有两种策略:\n\n * 设置成写入后多少时间后过期\n * 设置成写入后多少时间刷新\n\n对于 L2 缓存，如果有数据更新，其他机器立马可见。但是，也必须要设置超时时间，其时间应该比 L1 缓存的有效时间长。\n\n为了解决进程内缓存不一致的问题，设计可以进一步优化:\n\n\n\n通过消息队列的发布、订阅机制，可以通知其他应用节点对进程内缓存进行更新。使用这种方案，即使消息队列服务挂了或不可靠，由于先执行了数据库更新，但进程内缓存过期，刷新缓存时，也能保证数据的最终一致性。\n\n\n# 6. 缓存问题\n\n\n# 6.1. 缓存雪崩\n\n缓存雪崩是指缓存不可用或者大量缓存由于超时时间相同在同一时间段失效，大量请求直接访问数据库，数据库压力过大导致系统雪崩。\n\n举例来说，对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。\n\n解决缓存雪崩的主要手段如下：\n\n * 增加缓存系统可用性（事前）。例如：部署 Redis Cluster（主从+哨兵），以实现 Redis 的高可用，避免全盘崩溃。\n * 采用多级缓存方案（事中）。例如：本地缓存（Ehcache/Caffine/Guava Cache） + 分布式缓存（Redis/ Memcached）。\n * 限流、降级、熔断方案（事中），避免被流量打死。如：使用 Hystrix 进行熔断、降级。\n * 缓存如果支持持久化，可以在恢复工作后恢复数据（事后）。如：Redis 支持持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。\n\n上面的解决方案简单来说，就是多级缓存方案。系统收到一个查询请求，先查本地缓存，再查分布式缓存，最后查数据库，只要命中，立即返回。\n\n解决缓存雪崩的辅助手段如下：\n\n * 监控缓存，弹性扩容。\n * 缓存的过期时间可以取个随机值。这么做是为避免缓存同时失效，使得数据库 IO 骤升。比如：以前是设置 10 分钟的超时时间，那每个 Key 都可以随机 8-13 分钟过期，尽量让不同 Key 的过期时间不同。\n\n\n# 6.2. 缓存穿透\n\n> 缓存穿透是指：查询的数据在数据库中不存在，那么缓存中自然也不存在。所以，应用在缓存中查不到，则会去查询数据库。当这样的请求多了后，数据库的压力就会增大。\n\n解决缓存穿透，一般有两种方法：\n\n（一）缓存空值\n\n对于返回为 NULL 的依然缓存，对于抛出异常的返回不进行缓存。\n\n\n\n采用这种手段的会增加我们缓存的维护成本，需要在插入缓存的时候删除这个空缓存，当然我们可以通过设置较短的超时时间来解决这个问题。\n\n（二）过滤不可能存在的数据\n\n\n\n制定一些规则过滤一些不可能存在的数据。可以使用布隆过滤器（针对二进制操作的数据结构，所以性能高），比如你的订单 ID 明显是在一个范围 1-1000，如果不是 1-1000 之内的数据那其实可以直接给过滤掉。\n\n> 针对于一些恶意攻击，攻击带过来的大量 key 是不存在的，那么我们采用第一种方案就会缓存大量不存在 key 的数据。\n> \n> 此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些 key。\n> \n> 针对这种 key 异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。\n> \n> 而对于空数据的 key 有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。\n\n\n# 6.3. 缓存击穿\n\n缓存击穿是指，热点数据失效瞬间，大量请求直接访问数据库。例如，某些 key 是热点数据，访问非常频繁。如果某个 key 失效的瞬间，大量的请求过来，缓存未命中，然后去数据库访问，此时数据库访问量会急剧增加。\n\n为了避免这个问题，我们可以采取下面的两个手段:\n\n * 分布式锁 - 锁住热点数据的 key，避免大量线程同时访问同一个 key。\n * 定时异步刷新 - 可以对部分数据采取失效前自动刷新的策略，而不是到期自动淘汰。淘汰其实也是为了数据的时效性，所以采用自动刷新也可以。\n\n\n# 6.4. 小结\n\n上面逐一介绍了缓存使用中常见的问题。这里，从发生时间段的角度整体归纳一下缓存问题解决方案。\n\n * 事前：Redis 高可用方案（Redis Cluster + 主从 + 哨兵），避免缓存全面崩溃。\n * 事中：（一）采用多级缓存方案，本地缓存（Ehcache/Caffine/Guava Cache） + 分布式缓存（Redis/ Memcached）。（二）限流 + 熔断 + 降级（Hystrix），避免极端情况下，数据库被打死。\n * 事后：Redis 持久化（RDB+AOF），一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。\n\n> 分布式缓存 Memcached ，由于数据类型不如 Redis 丰富，并且不支持持久化、容灾。所以，一般会选择 Redis 做分布式缓存。\n\n\n# 7. 缓存策略\n\n\n# 7.1. 缓存预热\n\n缓存预热是指系统启动后，直接查询热点数据并缓存。这样就可以避免用户请求的时候，先查询数据库，然后再更新缓存的问题。\n\n解决方案：\n\n * 手动刷新缓存：直接写个缓存刷新页面，上线时手工操作下。\n * 应用启动时刷新缓存：数据量不大，可以在项目启动的时候自动进行加载。\n * 定时异步刷新缓存\n\n\n# 7.2. 如何缓存\n\n# 7.2.1. 不过期缓存\n\n缓存更新模式：\n\n 1. 开启事务\n 2. 写 SQL\n 3. 提交事务\n 4. 写缓存\n\n不要把写缓存操作放在事务中，尤其是写分布式缓存。因为网络抖动可能导致写缓存响应时间很慢，引起数据库事务阻塞。如果对缓存数据一致性要求不是那么高，数据量也不是很大，可以考虑定期全量同步缓存。\n\n这种模式存在这样的情况：存在事务成功，但缓存写失败的可能。但这种情况相对于上面的问题，影响较小。\n\n# 7.2.2. 过期缓存\n\n采用懒加载。对于热点数据，可以设置较短的缓存时间，并定期异步加载。\n\n\n# 7.3. 缓存更新\n\n一般来说，系统如果不是严格要求缓存和数据库保持一致性的话，尽量不要将读请求和写请求串行化。串行化可以保证一定不会出现数据不一致的情况，但是它会导致系统的吞吐量大幅度下降。\n\n缓存更新的策略有几种模式：\n\n * Cache Aside\n * Read/Write Through\n\n需要注意的是：以上几种缓存更新策略，都无法保证数据强一致。如果一定要保证强一致性，可以通过两阶段提交（2PC）或 Paxos 协议来实现。但是 2PC 太慢，而 Paxos 太复杂，所以如果不是非常重要的数据，不建议使用强一致性方案。\n\n# 7.3.1. Cache Aside\n\nCache Aside 应该是最常见的缓存更新策略了。\n\nCache Aside 的思路是：先更新数据库，再删除缓存。具体来说：\n\n * 失效：尝试读缓存，如果不命中，则读数据库，然后更新缓存。\n\n * 命中：尝试读缓存，命中则直接返回数据。\n\n * 更新：先更新数据库，再删除缓存。\n\n\n\n# 7.3.1.1. 为什么不能先更新数据库，再更新缓存？\n\n多个并发的写操作可能导致脏数据：当有多个并发的写请求时，无法保证更新数据库的顺序和更新缓存的顺序一致，从而导致数据库和缓存数据不一致的问题。\n\n\n\n> 说明：如上图的场景中，两个写线程由于执行顺序，导致数据库中 val = 2，而缓存中 val = 1，数据不一致。\n\n# 7.3.1.2. 为什么不能先删缓存，再更新数据库？\n\n存在并发读请求和写请求时，可能导致脏数据。\n\n\n\n> 说明：如上图的场景中，读线程和写线程并行执行，导致数据库中 val = 2，而缓存中 val = 1，数据不一致。\n\n# 7.3.1.3. 先更新数据库，再删除缓存就没问题了吗\n\n存在并发读请求和写请求时，可能导致脏数据。\n\n\n\n> 上图中问题发生的概率非常低：因为通常数据库更新操作比内存操作耗时多出几个数量级，最后一步回写缓存速度非常快，通常会在更新数据库之前完成。所以 Cache Aside 模式选择先更新数据库，再删除缓存，而不是先删缓存，再更新数据库。\n> \n> 不过，如果真的出现了这种场景，为了避免缓存中一直保留着脏数据，可以为缓存设置过期时间，过期后缓存自动失效。通常，业务系统中允许少量数据短时间出现不一致的情况。\n\n# 7.3.2. Read/Write Through\n\n\n\nRead Through 的思路是：查询时更新缓存。当缓存失效时，缓存服务自己进行加载。\n\nWrite Through 的思路是：当数据更新时，缓存服务负责更新缓存。\n\nThrough vs. Cache Aside\n\nRead Through vs. Cache Aside\n\n * Cache Aside 模式中，应用需要维护两个数据源头：一个是缓存，一个是数据库。\n * Read-Through 模式中，应用无需管理缓存和数据库，只需要将数据库的同步委托给缓存服务即可。\n\n# 7.3.3. Write behind\n\nWrite Behind 又叫 Write Back。Write Behind 的思路是：应用更新数据时，只更新缓存， 缓存服务每隔一段时间将缓存数据批量更新到数据库中，即延迟写入。这个设计的好处就是让提高 I/O 效率，因为异步，Write Behind 还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。\n\n> 更详细的分析可以参考：分布式之数据库和缓存双写一致性方案解析\n\n\n# 8. 总结\n\n最后，通过一张思维导图来总结一下本文所述的知识点，帮助大家对缓存有一个系统性的认识。\n\n\n\n\n# 9. 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * 你应该知道的缓存进化史\n * 如何优雅的设计和使用缓存？\n * 理解分布式系统中的缓存架构(上)\n * 缓存那些事\n * 分布式之数据库和缓存双写一致性方案解析\n * Cache 的基本原理\n * 5 分钟看懂系列：HTTP 缓存机制详解\n * 浏览器缓存看这一篇就够了",normalizedContent:"# 缓存基本原理\n\n> 缓存是一种利用空间换时间的设计，其目标就是更快、更近。\n\n\n# 1. 缓存简介\n\n\n# 1.1. 为什么需要缓存\n\n众所周知，当今是一个互联网时代，而互联网应用几乎遍及我们日常生活的方方面面。一般而言，一个互联网应用的请求/响应流程会有以下几个主要流程：\n\n * 客户端发起请求，请求经过网络 i/o，分发到服务层。\n * 服务层可能有多级服务，请求需要被多个服务层层处理。\n * 不同服务根据请求进行计算时，可能依赖于不同数据库的数据，需要通过网络 i/o 读写数据库。\n\n显然，这一套流程下来，可能需要消耗大量的计算机资源，并且响应时间也可能很久。如果并发请求量很大的话，可能会进一步加剧这种问题。\n\n\n\n为了解决以上问题，最直接的方式就是引入缓存。缓存可以作用于请求/响应流程的任意环节，并有效减少后续环节的执行次数，从而大大提升性能。\n\n实际上，缓存作为性能优化的第一手段，被广泛应用于计算机的硬件、软件领域。\n\n\n# 1.2. 什么是缓存\n\n缓存就是数据交换的缓冲区，用于将频繁访问的数据暂存。缓存的本质是一个内存 hash。\n\n缓存的本质是一种利用空间换时间的设计：牺牲一定的数据实时性，使得访问更快、更近：\n\n * 将数据存储到读取速度更快的存储（设备）；\n * 将数据存储到离应用最近的位置；\n * 将数据存储到离用户最近的位置。\n\n缓存是用于存储数据的硬件或软件的组成部分，以使得后续更快访问相应的数据。缓存中的数据可能是提前计算好的结果、数据的副本等。典型的应用场景：有 cpu cache, 磁盘 cache 等。本文中提及到缓存主要是指互联网应用中所使用的缓存组件。\n\n缓存命中率是缓存的重要度量指标，命中率越高越好。\n\n缓存命中率 = 从缓存中读取次数 / 总读取次数\n\n\n\n# 1.3. 何时需要缓存\n\n引入缓存，会增加系统的复杂度，并牺牲一定的数据实时性。所以，引入缓存前，需要先权衡是否值得，考量点如下：\n\n * cpu 开销 - 如果应用某个计算需要消耗大量 cpu，可以考虑缓存其计算结果。典型场景：复杂的、频繁调用的正则计算；分布式计算中间状态等。\n * io 开销 - 如果数据库连接池比较繁忙，可以考虑缓存其查询结果。\n\n在数据层引入缓存，有以下几个好处：\n\n * 提升数据读取速度。\n * 提升系统扩展能力，通过扩展缓存，提升系统承载能力。\n * 降低存储成本，cache+db 的方式可以承担原有需要多台 db 才能承担的请求量，节省机器成本。\n\n\n# 1.4. 缓存的基本原理\n\n根据业务场景，通常缓存有以下几种使用方式：\n\n * 懒汉式(读时触发)：先查询 db 里的数据, 然后把相关的数据写入 cache。\n * 饥饿式(写时触发)：写入 db 后, 然后把相关的数据也写入 cache。\n * 定期刷新：适合周期性的跑数据的任务，或者列表型的数据，而且不要求绝对实时性。\n\n\n# 1.5. 缓存淘汰策略\n\n缓存淘汰的类型：\n\n * 基于空间 - 设置缓存空间大小。\n * 基于容量 - 设置缓存存储记录数。\n * 基于时间\n   * ttl（time to live，即存活期）缓存数据从创建到过期的时间。\n   * tti（time to idle，即空闲期）缓存数据多久没被访问的时间。\n\n缓存淘汰算法：\n\n * fifo (first in first out) - 先进先出。在这种淘汰算法中，先进入缓存的会先被淘汰。这种可谓是最简单的了，但是会导致我们命中率很低。试想一下我们如果有个访问频率很高的数据是所有数据第一个访问的，而那些不是很高的是后面再访问的，那这样就会把我们的首个数据但是他的访问频率很高给挤出。\n * lru (least recently used) - 最近最少使用算法。这种算法避免了 fifo 命中率不高的问题：每次访问数据都会将其放在我们的队尾，如果需要淘汰数据，就只需要淘汰队首即可。但是这个算法依然有缺点：假设，缓存只保留 1 分钟以内的热点数据。如果有个数据在 1 个小时的前 59 分钟访问了 1 万次（可见这是个热点数据），最后一分钟没有任何访问；但是，其他的数据有被访问，就会导致这个热点数据被淘汰。\n * lfu (less frequently used) - 最近最少频率使用。在这种算法中又对上面进行了优化，利用额外的空间记录每个数据的使用频率，然后选出频率最低进行淘汰。这样就避免了 lru 不能处理时间段的问题。\n\n这三种缓存淘汰算法，实现复杂度一个比一个高，同样的命中率也是一个比一个好。而我们一般来说选择的方案居中即可，即实现成本不是太高，而命中率也还行的 lru。\n\n\n# 2. 缓存的分类\n\n缓存从部署角度，可以分为客户端缓存和服务端缓存。\n\n客户端缓存\n\n * http 缓存：http/1.1 中的 cache-control、http/1 中的 expires\n * 浏览器缓存：html5 提供的 sessionstorage 和 localstorage、cookie\n * app 缓存\n   * android\n   * ios\n\n服务端缓存\n\n * cdn 缓存 - 存放 html、css、js 等静态资源。\n * 反向代理缓存 - 动静分离，只缓存用户请求的静态资源。\n * 数据库缓存 - 数据库（如 mysql）自身一般也有缓存，但因为命中率和更新频率问题，不推荐使用。\n * 进程内缓存 - 缓存应用字典等常用数据。\n * 分布式缓存 - 缓存数据库中的热点数据。\n\n> 其中，cdn 缓存、反向代理缓存、数据库缓存一般由专职人员维护（运维、dba）。\n> \n> 后端开发一般聚焦于进程内缓存、分布式缓存。\n\n\n# 2.1. http 缓存\n\n 1. 浏览器发送请求前，根据请求头的 expires (http/1) 和 cache-control (http/1.1) 判断是否命中（包括是否过期）强缓存策略，\n    \n    1. 如果命中，直接从缓存获取资源，并不会发送请求。\n    2. 如果没有命中，则进入下一步。\n\n 2. 没有命中强缓存规则，浏览器会发送请求，根据请求头的 last-modified 和 etag 判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。\n\n 3. 如果前两步都没有命中，则直接从服务端获取资源。\n\n\n# 2.2. cdn 缓存\n\n> cdn 将数据缓存到离用户物理距离最近的服务器，使得用户可以就近获取请求内容。cdn 一般缓存静态资源文件（页面，脚本，图片，视频，文件等）。\n> \n> 国内网络异常复杂，跨运营商的网络访问会很慢。为了解决跨运营商或各地用户访问问题，可以在重要的城市，部署 cdn 应用。使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。\n\n\n\n# 2.2.1. cdn 原理\n\ncdn 的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。\n\n（1）未部署 cdn 应用前的网络路径：\n\n * 请求：本机网络（局域网）=> 运营商网络 => 应用服务器机房\n * 响应：应用服务器机房 => 运营商网络 => 本机网络（局域网）\n\n在不考虑复杂网络的情况下，从请求到响应需要经过 3 个节点，6 个步骤完成一次用户访问操作。\n\n（2）部署 cdn 应用后网络路径：\n\n * 请求：本机网络（局域网） => 运营商网络\n * 响应：运营商网络 => 本机网络（局域网）\n\n在不考虑复杂网络的情况下，从请求到响应需要经过 2 个节点，2 个步骤完成一次用户访问操作。\n\n与不部署 cdn 服务相比，减少了 1 个节点，4 个步骤的访问。极大的提高了系统的响应速度。\n\n# 2.2.2. cdn 特点\n\n优点\n\n * 本地 cache 加速 - 提升访问速度，尤其含有大量图片和静态页面站点；\n * 实现跨运营商的网络加速 - 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量；\n * 远程加速 - 远程访问用户根据 dns 负载均衡技术智能自动选择 cache 服务器，选择最快的 cache 服务器，加快远程访问的速度；\n * 带宽优化 - 自动生成服务器的远程 mirror（镜像）cache 服务器，远程用户访问时从 cache 服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点 web 服务器负载等功能。\n * 集群抗攻击 - 广泛分布的 cdn 节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种 d.d.o.s 攻击对网站的影响，同时保证较好的服务质量。\n\n缺点\n\n * 不适宜缓存动态资源\n   * 解决方案：主要缓存静态资源，动态资源建立多级缓存或准实时同步；\n * 存在数据的一致性问题\n   * 解决方案（主要是在性能和数据一致性二者间寻找一个平衡）\n   * 设置缓存失效时间（1 个小时，过期后同步数据）。\n   * 针对资源设置版本号。\n\n\n# 2.3. 反向代理缓存\n\n> 反向代理（reverse proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n\n\n# 2.3.1. 反向代理缓存原理\n\n反向代理位于应用服务器同一网络，处理所有对 web 服务器的请求。\n\n反向代理缓存的原理：\n\n * 如果用户请求的页面在代理服务器上有缓存的话，代理服务器直接将缓存内容发送给用户。\n * 如果没有缓存则先向 web 服务器发出请求，取回数据，本地缓存后再发送给用户。\n\n这种方式通过降低向 web 服务器的请求数，从而降低了 web 服务器的负载。\n\n反向代理缓存一般针对的是静态资源，而将动态资源请求转发到应用服务器处理。常用的缓存应用服务器有 varnish，ngnix，squid。\n\n# 2.3.2. 反向代理缓存比较\n\n常用的代理缓存有 varnish，squid，ngnix，简单比较如下：\n\n * varnish 和 squid 是专业的 cache 服务，ngnix 需要第三方模块支持；\n * varnish 采用内存型缓存，避免了频繁在内存、磁盘中交换文件，性能比 squid 高；\n * varnish 由于是内存 cache，所以对小文件如 css、js、小图片的支持很棒，后端的持久化缓存可以采用的是 squid 或 ats；\n * squid 功能全而大，适合于各种静态的文件缓存，一般会在前端挂一个 haproxy 或 ngnix 做负载均衡跑多个实例；\n * nginx 采用第三方模块 ncache 做的缓冲，性能基本达到 varnish，一般作为反向代理使用，可以实现简单的缓存。\n\n\n# 3. 进程内缓存\n\n> 进程内缓存是指应用内部的缓存，标准的分布式系统，一般有多级缓存构成。本地缓存是离应用最近的缓存，一般可以将数据缓存到硬盘或内存。\n\n * 硬盘缓存 - 将数据缓存到硬盘中，读取时从硬盘读取。原理是直接读取本机文件，减少了网络传输消耗，比通过网络读取数据库速度更快。可以应用在对速度要求不是很高，但需要大量缓存存储的场景。\n * 内存缓存 - 直接将数据存储到本机内存中，通过程序直接维护缓存对象，是访问速度最快的方式。\n\n常见的本地缓存实现方案：hashmap、guava cache、caffeine、ehcache。\n\n\n# 3.1. concurrenthashmap\n\n最简单的进程内缓存可以通过 jdk 自带的 hashmap 或 concurrenthashmap 实现。\n\n适用场景：不需要淘汰的缓存数据。\n\n缺点：无法进行缓存淘汰，内存会无限制的增长。\n\n\n# 3.2. lruhashmap\n\n可以通过继承 linkedhashmap 来实现一个简单的 lruhashmap。重写 removeeldestentry 方法，即可完成一个简单的最近最少使用算法。\n\n缺点：\n\n * 锁竞争严重，性能比较低。\n * 不支持过期时间\n * 不支持自动刷新\n\n\n# 3.3. guava cache\n\n解决了 lruhashmap 中的几个缺点。\n\nguava cache 采用了类似 concurrenthashmap 的思想，分段加锁，减少锁竞争。\n\nguava cache 对于过期的 entry 并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。\n\n直接通过查询，判断其是否满足刷新条件，进行刷新。\n\n\n# 3.4. caffeine\n\ncaffeine 实现了 w-tinylfu(lfu + lru 算法的变种)，其命中率和读写吞吐量大大优于 guava cache。\n\n其实现原理较复杂，可以参考你应该知道的缓存进化史。\n\n\n# 3.5. ehcache\n\nehcache 是一个纯 java 的进程内缓存框架，具有快速、精干等特点，是 hibernate 中默认的 cacheprovider。\n\n优点\n\n * 快速、简单\n * 支持多种缓存策略：lru、lfu、fifo 淘汰算法\n * 缓存数据有两级：内存和磁盘，因此无需担心容量问题\n * 缓存数据会在虚拟机重启的过程中写入磁盘\n * 可以通过 rmi、可插入 api 等方式进行分布式缓存\n * 具有缓存和缓存管理器的侦听接口\n * 支持多缓存管理器实例，以及一个实例的多个缓存区域\n * 提供 hibernate 的缓存实现\n\n缺点\n\n * 使用磁盘 cache 的时候非常占用磁盘空间\n * 不保证数据的安全\n * 虽然支持分布式缓存，但效率不高（通过组播方式，在不同节点之间同步数据）。\n\n\n# 3.6. 进程内缓存对比\n\n常用进程内缓存技术对比：\n\n比较项      concurrenthashmap   lrumap                ehcache                 guava cache             caffeine\n读写性能     很好，分段锁              一般，全局加锁               好                       好，需要做淘汰操作               很好\n淘汰算法     无                   lru，一般                支持多种淘汰算法,lru,lfu,fifo   lru，一般                  w-tinylfu, 很好\n功能丰富程度   功能比较简单              功能比较单一                功能很丰富                   功能很丰富，支持刷新和虚引用等         功能和 guava cache 类似\n工具大小     jdk 自带类，很小          基于 linkedhashmap，较小   很大，最新版本 1.4mb           是 guava 工具类中的一个小部分，较小   一般，最新版本 644kb\n是否持久化    否                   否                     是                       否                       否\n是否支持集群   否                   否                     是                       否                       否\n\n * concurrenthashmap - 比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是 jdk 自带的类，在各种框架中依然有大量的使用，比如我们可以用来缓存我们反射的 method，field 等等；也可以缓存一些链接，防止其重复建立。在 caffeine 中也是使用的 concurrenthashmap 来存储元素。\n * lrumap - 如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。\n * ehcache - 由于其 jar 包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择 ehcache。需要注意的是，虽然 ehcache 也支持分布式缓存，但是由于其节点间通信方式为 rmi，表现不如 redis，所以一般不建议用它来作为分布式缓存。\n * guava cache - guava 这个 jar 包在很多 java 应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解 caffeine 的情况下可以选择 guava cache。\n * caffeine - 其在命中率，读写性能上都比 guava cache 好很多，并且其 api 和 guava cache 基本一致，甚至会多一点。在真实环境中使用 caffeine，取得过不错的效果。\n\n总结一下：如果不需要淘汰算法则选择 concurrenthashmap，如果需要淘汰算法和一些丰富的 api，推荐选择 caffeine。\n\n\n# 4. 分布式缓存\n\n> 分布式缓存解决了进程内缓存最大的问题：如果应用是分布式系统，节点之间无法共享彼此的进程内缓存。\n> \n> 分布式缓存的应用场景：\n> \n>  * 缓存经过复杂计算得到的数据\n>  * 缓存系统中频繁访问的热点数据，减轻数据库压力\n\n不同分布式缓存的实现原理往往有比较大的差异。本文主要针对 memcached 和 redis 进行说明。\n\n\n# 4.1. memcached\n\n> memcached 是一个高性能，分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的 hash 表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。\n> \n> 简单的说就是：将数据缓存到内存中，然后从内存中读取，从而大大提高读取速度。\n\n# 4.1.1. memcached 特性\n\n * 使用物理内存作为缓存区，可独立运行在服务器上。每个进程最大 2g，如果想缓存更多的数据，可以开辟更多的 memcached 进程（不同端口）或者使用分布式 memcached 进行缓存，将数据缓存到不同的物理机或者虚拟机上。\n * 使用 key-value 的方式来存储数据。这是一种单索引的结构化数据组织形式，可使数据项查询时间复杂度为 o(1)。\n * 协议简单，基于文本行的协议。直接通过 telnet 在 memcached 服务器上可进行存取数据操作，简单，方便多种缓存参考此协议；\n * 基于 libevent 高性能通信。libevent 是一套利用 c 开发的程序库，它将 bsd 系统的 kqueue,linux 系统的 epoll 等事件处理功能封装成一个接口，与传统的 select 相比，提高了性能。\n * 分布式能力取决于 memcached 客户端，服务器之间互不通信。各个 memcached 服务器之间互不通信，各自独立存取数据，不共享任何信息。服务器并不具有分布式功能，分布式部署取决于 memcached 客户端。\n * 采用 lru 缓存淘汰策略。在 memcached 内存储数据项时，可以指定它在缓存的失效时间，默认为永久。当 memcached 服务器用完分配的内时，失效的数据被首先替换，然后也是最近未使用的数据。在 lru 中，memcached 使用的是一种 lazy expiration 策略，自己不会监控存入的 key/vlue 对是否过期，而是在获取 key 值时查看记录的时间戳，检查 key/value 对空间是否过期，这样可减轻服务器的负载。\n * 内置了一套高效的内存管理算法。这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。当内存满后，通过 lru 算法自动删除不使用的缓存。\n * 不支持持久化。memcached 没有考虑数据的容灾问题，重启服务，所有数据会丢失。\n\n# 4.1.2. memcached 工作原理\n\n（1）内存管理\n\nmemcached 利用 slab allocation 机制来分配和管理内存，它按照预先规定的大小，将分配的内存分割成特定长度的内存块，再把尺寸相同的内存块分成组，数据在存放时，根据键值 大小去匹配 slab 大小，找就近的 slab 存放，所以存在空间浪费现象。\n\n这套内存管理效率很高，而且不会造成内存碎片，但是它最大的缺点就是会导致空间浪费。\n\n（2）缓存淘汰策略\n\nmemcached 的缓存淘汰策略是 lru + 到期失效策略。\n\n当你在 memcached 内存储数据项时，你有可能会指定它在缓存的失效时间，默认为永久。当 memcached 服务器用完分配的内时，失效的数据被首先替换，然后是最近未使用的数据。\n\n在 lru 中，memcached 使用的是一种 lazy expiration 策略：memcached 不会监控存入的 key/vlue 对是否过期，而是在获取 key 值时查看记录的时间戳，检查 key/value 对空间是否过期，这样可减轻服务器的负载。\n\n（3）分区\n\nmemcached 服务器之间彼此不通信，它的分布式能力是依赖客户端来实现。\n\n具体来说，就是在客户端实现一种算法，根据 key 来计算出数据应该向哪个服务器节点读/写。\n\n而这种选取集群节点的算法常见的有三种：\n\n * 哈希取余算法 - 使用公式：hash（key）% n 计算出 哈希值 来决定数据映射到哪一个节点。\n * 一致性哈希算法 - 可以很好的解决 稳定性问题，可以将所有的 存储节点 排列在 首尾相接 的 hash 环上，每个 key 在计算 hash 后会 顺时针 找到 临接 的 存储节点 存放。而当有节点 加入 或 退出 时，仅影响该节点在 hash 环上 顺时针相邻 的 后续节点。\n * 虚拟 hash 槽算法 - 使用 分散度良好 的 哈希函数 把所有数据 映射 到一个 固定范围 的 整数集合 中，整数定义为 槽（slot），这个范围一般 远远大于 节点数。槽 是集群内 数据管理 和 迁移 的 基本单位。采用 大范围槽 的主要目的是为了方便 数据拆分 和 集群扩展。每个节点会负责 一定数量的槽。\n\n\n# 4.2. redis\n\n> redis 是一个开源（bsd 许可）的，基于内存的，多数据结构存储系统。可以用作数据库、缓存和消息中间件。\n> \n> redis 还可以使用客户端分片来扩展写性能。内置了 复制（replication），lua 脚本（lua scripting），lru 驱动事件（lru eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 redis 哨兵（sentinel）和自动分区（cluster）提供高可用性（high availability）。\n\n# 4.2.1. redis 特性\n\n * 支持多种数据类型 - string、hash、list、set、sorted set。\n\n * 支持多种数据淘汰策略\n   \n   * volatile-lru - 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰\n   * volatile-ttl - 从已设置过期时间的数据集中挑选将要过期的数据淘汰\n   * volatile-random - 从已设置过期时间的数据集中任意选择数据淘汰\n   * allkeys-lru - 从所有数据集中挑选最近最少使用的数据淘汰\n   * allkeys-random - 从所有数据集中任意选择数据进行淘汰\n   * noeviction - 禁止驱逐数据\n\n * 提供两种持久化方式 - rdb 和 aof\n\n * 通过 redis cluster 提供集群模式。\n\n# 4.2.2. redis 原理\n\n * 缓存淘汰\n   * redis 有两种数据淘汰实现\n     * 消极方式 - 访问 redis key 时，如果发现它已经失效，则删除它\n     * 积极方式 - 周期性从设置了失效时间的 key 中，根据淘汰策略，选择一部分失效的 key 进行删除。\n * 分区\n   * redis cluster 集群包含 16384 个虚拟 hash 槽，它通过一个高效的算法来计算 key 属于哪个 hash 槽。\n   * redis cluster 支持请求分发 - 节点在接到一个命令请求时，会先检测这个命令请求要处理的键所在的槽是否由自己负责，如果不是的话，节点将向客户端返回一个 moved 错误，moved 错误携带的信息可以指引客户端将请求重定向至正在负责相关槽的节点。\n * 主从复制\n   * redis 2.8 后支持异步复制。它有两种模式：\n     * 完整重同步（full resychronization） - 用于初次复制。执行步骤与 sync 命令基本一致。\n     * 部分重同步（partial resychronization） - 用于断线后重复制。如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只需接收并执行这些写命令，即可将主从服务器的数据库状态保持一致。\n   * 集群中每个节点都会定期向集群中的其他节点发送 ping 消息，以此来检测对方是否在线。\n   * 如果一个主节点被认为下线，则在其从节点中，根据 raft 算法，选举出一个节点，升级为主节点。\n * 数据一致性\n   * redis 不保证强一致性，因为这会使得集群性能大大降低。\n   * redis 是通过异步复制来实现最终一致性。\n\n\n# 4.3. 分布式缓存对比\n\n不同的分布式缓存功能特性和实现原理方面有很大的差异，因此他们所适应的场景也有所不同。\n\n\n\n这里选取三个比较出名的分布式缓存（memcache，redis，tair）来作为比较：\n\n比较项    memcache              redis                                tair\n数据结构   只支持简单的 key-value 结构   string,hash, list, set, sorted set   string,hashmap, list，set\n持久化    不支持                   支持                                   支持\n容量大小   数据纯内存，数据存储不宜过多        数据全内存，资源成本考量不宜超过 100gb               可以配置全内存或内存+磁盘引擎，数据容量可无限扩充\n读写性能   很高                    很高(rt0.5ms 左右)                       string 类型比较高(rt1ms 左右)，复杂类型比较慢(rt5ms 左右)\n过期策略   过期后，不删除缓存             有六种策略来处理过期数据                         支持\n\n * memcache - 只适合基于内存的缓存框架；且不支持数据持久化和容灾。\n * redis - 支持丰富的数据结构，读写性能很高，但是数据全内存，必须要考虑资源成本，支持持久化。\n * tair - 支持丰富的数据结构，读写性能较高，部分类型比较慢，理论上容量可以无限扩充。\n\n总结：如果服务对延迟比较敏感，map/set 数据也比较多的话，比较适合 redis。如果服务需要放入缓存量的数据很大，对延迟又不是特别敏感的话，那就可以选择 memcached。\n\n\n# 5. 多级缓存\n\n\n# 5.1. 整体缓存框架\n\n通常，一个大型软件系统的缓存采用多级缓存方案：\n\n\n\n请求过程：\n\n 1. 浏览器向客户端发起请求，如果 cdn 有缓存则直接返回；\n 2. 如果 cdn 无缓存，则访问反向代理服务器；\n 3. 如果反向代理服务器有缓存则直接返回；\n 4. 如果反向代理服务器无缓存或动态请求，则访问应用服务器；\n 5. 应用服务器访问进程内缓存；如果有缓存，则返回代理服务器，并缓存数据；（动态请求不缓存）\n 6. 如果进程内缓存无数据，则读取分布式缓存；并返回应用服务器；应用服务器将数据缓存到本地缓存（部分）；\n 7. 如果分布式缓存无数据，则应用程序读取数据库数据，并放入分布式缓存；\n\n\n# 5.2. 使用进程内缓存\n\n如果应用服务是单点应用，那么进程内缓存当然是缓存的首选方案。\n\n对于进程内缓存，其本来受限于内存的大小的限制，以及进程缓存更新后其他缓存无法得知，所以一般来说进程缓存适用于:\n\n * 数据量不是很大且更新频率较低的数据。\n * 如果更新频繁的数据，也想使用进程内缓存，那么可以将其过期时间设置为较短的时间，或者设置较短的自动刷新时间。\n\n这种方案存在以下问题：\n\n * 如果应用服务是分布式系统，应用节点之间无法共享缓存，存在数据不一致问题。\n * 由于进程内缓存受限于内存大小的限制，所以缓存不能无限扩展。\n\n\n# 5.3. 使用分布式缓存\n\n如果应用服务是分布式系统，那么最简单的缓存方案就是直接使用分布式缓存。\n\n其应用场景如图所示：\n\n\n\nredis 用来存储热点数据，如果缓存不命中，则去查询数据库，并更新缓存。\n\n这种方案存在以下问题：\n\n 1. 缓存服务如果挂了，这时应用只能访问数据库，容易造成缓存雪崩。\n 2. 访问分布式缓存服务会有一定的 i/o 以及序列化反序列化的开销，虽然性能很高，但是其终究没有在内存中查询快。\n\n\n# 5.4. 使用多级缓存\n\n单纯使用进程内缓存和分布式缓存都存在各自的不足。如果需要更高的性能以及更好的可用性，我们可以将缓存设计为多级结构。将最热的数据使用进程内缓存存储在内存中，进一步提升访问速度。\n\n这个设计思路在计算机系统中也存在，比如 cpu 使用 l1、l2、l3 多级缓存，用来减少对内存的直接访问，从而加快访问速度。\n\n一般来说，多级缓存架构使用二级缓存已可以满足大部分业务需求，过多的分级会增加系统的复杂度以及维护的成本。因此，多级缓存不是分级越多越好，需要根据实际情况进行权衡。\n\n一个典型的二级缓存架构，可以使用进程内缓存（如： caffeine/google guava/ehcache/hashmap）作为一级缓存；使用分布式缓存（如：redis/memcached）作为二级缓存。\n\n# 5.4.1. 多级缓存查询\n\n\n\n多级缓存查询流程如下：\n\n 1. 首先，查询 l1 缓存，如果缓存命中，直接返回结果；如果没有命中，执行下一步。\n 2. 接下来，查询 l2 缓存，如果缓存命中，直接返回结果并回填 l1 缓存；如果没有命中，执行下一步。\n 3. 最后，查询数据库，返回结果并依次回填 l2 缓存、l1 缓存。\n\n# 5.4.2. 多级缓存更新\n\n对于 l1 缓存，如果有数据更新，只能删除并更新所在机器上的缓存，其他机器只能通过超时机制来刷新缓存。超时设定可以有两种策略:\n\n * 设置成写入后多少时间后过期\n * 设置成写入后多少时间刷新\n\n对于 l2 缓存，如果有数据更新，其他机器立马可见。但是，也必须要设置超时时间，其时间应该比 l1 缓存的有效时间长。\n\n为了解决进程内缓存不一致的问题，设计可以进一步优化:\n\n\n\n通过消息队列的发布、订阅机制，可以通知其他应用节点对进程内缓存进行更新。使用这种方案，即使消息队列服务挂了或不可靠，由于先执行了数据库更新，但进程内缓存过期，刷新缓存时，也能保证数据的最终一致性。\n\n\n# 6. 缓存问题\n\n\n# 6.1. 缓存雪崩\n\n缓存雪崩是指缓存不可用或者大量缓存由于超时时间相同在同一时间段失效，大量请求直接访问数据库，数据库压力过大导致系统雪崩。\n\n举例来说，对于系统 a，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，dba 很着急，重启数据库，但是数据库立马又被新的流量给打死了。\n\n解决缓存雪崩的主要手段如下：\n\n * 增加缓存系统可用性（事前）。例如：部署 redis cluster（主从+哨兵），以实现 redis 的高可用，避免全盘崩溃。\n * 采用多级缓存方案（事中）。例如：本地缓存（ehcache/caffine/guava cache） + 分布式缓存（redis/ memcached）。\n * 限流、降级、熔断方案（事中），避免被流量打死。如：使用 hystrix 进行熔断、降级。\n * 缓存如果支持持久化，可以在恢复工作后恢复数据（事后）。如：redis 支持持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。\n\n上面的解决方案简单来说，就是多级缓存方案。系统收到一个查询请求，先查本地缓存，再查分布式缓存，最后查数据库，只要命中，立即返回。\n\n解决缓存雪崩的辅助手段如下：\n\n * 监控缓存，弹性扩容。\n * 缓存的过期时间可以取个随机值。这么做是为避免缓存同时失效，使得数据库 io 骤升。比如：以前是设置 10 分钟的超时时间，那每个 key 都可以随机 8-13 分钟过期，尽量让不同 key 的过期时间不同。\n\n\n# 6.2. 缓存穿透\n\n> 缓存穿透是指：查询的数据在数据库中不存在，那么缓存中自然也不存在。所以，应用在缓存中查不到，则会去查询数据库。当这样的请求多了后，数据库的压力就会增大。\n\n解决缓存穿透，一般有两种方法：\n\n（一）缓存空值\n\n对于返回为 null 的依然缓存，对于抛出异常的返回不进行缓存。\n\n\n\n采用这种手段的会增加我们缓存的维护成本，需要在插入缓存的时候删除这个空缓存，当然我们可以通过设置较短的超时时间来解决这个问题。\n\n（二）过滤不可能存在的数据\n\n\n\n制定一些规则过滤一些不可能存在的数据。可以使用布隆过滤器（针对二进制操作的数据结构，所以性能高），比如你的订单 id 明显是在一个范围 1-1000，如果不是 1-1000 之内的数据那其实可以直接给过滤掉。\n\n> 针对于一些恶意攻击，攻击带过来的大量 key 是不存在的，那么我们采用第一种方案就会缓存大量不存在 key 的数据。\n> \n> 此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些 key。\n> \n> 针对这种 key 异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。\n> \n> 而对于空数据的 key 有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。\n\n\n# 6.3. 缓存击穿\n\n缓存击穿是指，热点数据失效瞬间，大量请求直接访问数据库。例如，某些 key 是热点数据，访问非常频繁。如果某个 key 失效的瞬间，大量的请求过来，缓存未命中，然后去数据库访问，此时数据库访问量会急剧增加。\n\n为了避免这个问题，我们可以采取下面的两个手段:\n\n * 分布式锁 - 锁住热点数据的 key，避免大量线程同时访问同一个 key。\n * 定时异步刷新 - 可以对部分数据采取失效前自动刷新的策略，而不是到期自动淘汰。淘汰其实也是为了数据的时效性，所以采用自动刷新也可以。\n\n\n# 6.4. 小结\n\n上面逐一介绍了缓存使用中常见的问题。这里，从发生时间段的角度整体归纳一下缓存问题解决方案。\n\n * 事前：redis 高可用方案（redis cluster + 主从 + 哨兵），避免缓存全面崩溃。\n * 事中：（一）采用多级缓存方案，本地缓存（ehcache/caffine/guava cache） + 分布式缓存（redis/ memcached）。（二）限流 + 熔断 + 降级（hystrix），避免极端情况下，数据库被打死。\n * 事后：redis 持久化（rdb+aof），一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。\n\n> 分布式缓存 memcached ，由于数据类型不如 redis 丰富，并且不支持持久化、容灾。所以，一般会选择 redis 做分布式缓存。\n\n\n# 7. 缓存策略\n\n\n# 7.1. 缓存预热\n\n缓存预热是指系统启动后，直接查询热点数据并缓存。这样就可以避免用户请求的时候，先查询数据库，然后再更新缓存的问题。\n\n解决方案：\n\n * 手动刷新缓存：直接写个缓存刷新页面，上线时手工操作下。\n * 应用启动时刷新缓存：数据量不大，可以在项目启动的时候自动进行加载。\n * 定时异步刷新缓存\n\n\n# 7.2. 如何缓存\n\n# 7.2.1. 不过期缓存\n\n缓存更新模式：\n\n 1. 开启事务\n 2. 写 sql\n 3. 提交事务\n 4. 写缓存\n\n不要把写缓存操作放在事务中，尤其是写分布式缓存。因为网络抖动可能导致写缓存响应时间很慢，引起数据库事务阻塞。如果对缓存数据一致性要求不是那么高，数据量也不是很大，可以考虑定期全量同步缓存。\n\n这种模式存在这样的情况：存在事务成功，但缓存写失败的可能。但这种情况相对于上面的问题，影响较小。\n\n# 7.2.2. 过期缓存\n\n采用懒加载。对于热点数据，可以设置较短的缓存时间，并定期异步加载。\n\n\n# 7.3. 缓存更新\n\n一般来说，系统如果不是严格要求缓存和数据库保持一致性的话，尽量不要将读请求和写请求串行化。串行化可以保证一定不会出现数据不一致的情况，但是它会导致系统的吞吐量大幅度下降。\n\n缓存更新的策略有几种模式：\n\n * cache aside\n * read/write through\n\n需要注意的是：以上几种缓存更新策略，都无法保证数据强一致。如果一定要保证强一致性，可以通过两阶段提交（2pc）或 paxos 协议来实现。但是 2pc 太慢，而 paxos 太复杂，所以如果不是非常重要的数据，不建议使用强一致性方案。\n\n# 7.3.1. cache aside\n\ncache aside 应该是最常见的缓存更新策略了。\n\ncache aside 的思路是：先更新数据库，再删除缓存。具体来说：\n\n * 失效：尝试读缓存，如果不命中，则读数据库，然后更新缓存。\n\n * 命中：尝试读缓存，命中则直接返回数据。\n\n * 更新：先更新数据库，再删除缓存。\n\n\n\n# 7.3.1.1. 为什么不能先更新数据库，再更新缓存？\n\n多个并发的写操作可能导致脏数据：当有多个并发的写请求时，无法保证更新数据库的顺序和更新缓存的顺序一致，从而导致数据库和缓存数据不一致的问题。\n\n\n\n> 说明：如上图的场景中，两个写线程由于执行顺序，导致数据库中 val = 2，而缓存中 val = 1，数据不一致。\n\n# 7.3.1.2. 为什么不能先删缓存，再更新数据库？\n\n存在并发读请求和写请求时，可能导致脏数据。\n\n\n\n> 说明：如上图的场景中，读线程和写线程并行执行，导致数据库中 val = 2，而缓存中 val = 1，数据不一致。\n\n# 7.3.1.3. 先更新数据库，再删除缓存就没问题了吗\n\n存在并发读请求和写请求时，可能导致脏数据。\n\n\n\n> 上图中问题发生的概率非常低：因为通常数据库更新操作比内存操作耗时多出几个数量级，最后一步回写缓存速度非常快，通常会在更新数据库之前完成。所以 cache aside 模式选择先更新数据库，再删除缓存，而不是先删缓存，再更新数据库。\n> \n> 不过，如果真的出现了这种场景，为了避免缓存中一直保留着脏数据，可以为缓存设置过期时间，过期后缓存自动失效。通常，业务系统中允许少量数据短时间出现不一致的情况。\n\n# 7.3.2. read/write through\n\n\n\nread through 的思路是：查询时更新缓存。当缓存失效时，缓存服务自己进行加载。\n\nwrite through 的思路是：当数据更新时，缓存服务负责更新缓存。\n\nthrough vs. cache aside\n\nread through vs. cache aside\n\n * cache aside 模式中，应用需要维护两个数据源头：一个是缓存，一个是数据库。\n * read-through 模式中，应用无需管理缓存和数据库，只需要将数据库的同步委托给缓存服务即可。\n\n# 7.3.3. write behind\n\nwrite behind 又叫 write back。write behind 的思路是：应用更新数据时，只更新缓存， 缓存服务每隔一段时间将缓存数据批量更新到数据库中，即延迟写入。这个设计的好处就是让提高 i/o 效率，因为异步，write behind 还可以合并对同一个数据的多次操作，所以性能的提高是相当可观的。\n\n> 更详细的分析可以参考：分布式之数据库和缓存双写一致性方案解析\n\n\n# 8. 总结\n\n最后，通过一张思维导图来总结一下本文所述的知识点，帮助大家对缓存有一个系统性的认识。\n\n\n\n\n# 9. 参考资料\n\n * 《大型网站技术架构：核心原理与案例分析》\n * 你应该知道的缓存进化史\n * 如何优雅的设计和使用缓存？\n * 理解分布式系统中的缓存架构(上)\n * 缓存那些事\n * 分布式之数据库和缓存双写一致性方案解析\n * cache 的基本原理\n * 5 分钟看懂系列：http 缓存机制详解\n * 浏览器缓存看这一篇就够了",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"读写分离基本原理",frontmatter:{title:"读写分离基本原理",categories:["分布式","分布式关键技术","数据调度"],tags:["分布式","数据调度","读写分离"],abbrlink:"4898ead7",date:"2022-04-14T11:36:23.000Z",permalink:"/pages/7da6ca/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/02.%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%A6/02.%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB.html",relativePath:"02.分布式/03.分布式关键技术/02.数据调度/02.读写分离.md",key:"v-1af69402",path:"/pages/7da6ca/",headers:[{level:2,title:"1. 为何要读写分离",slug:"_1-为何要读写分离",normalizedTitle:"1. 为何要读写分离",charIndex:67},{level:2,title:"2. 读写分离的原理",slug:"_2-读写分离的原理",normalizedTitle:"2. 读写分离的原理",charIndex:307},{level:2,title:"3. 读写分离的问题",slug:"_3-读写分离的问题",normalizedTitle:"3. 读写分离的问题",charIndex:585},{level:3,title:"3.1. 数据一致性",slug:"_3-1-数据一致性",normalizedTitle:"3.1. 数据一致性",charIndex:624},{level:3,title:"3.2. 分发机制",slug:"_3-2-分发机制",normalizedTitle:"3.2. 分发机制",charIndex:667},{level:2,title:"4. 参考资料",slug:"_4-参考资料",normalizedTitle:"4. 参考资料",charIndex:996}],headersStr:"1. 为何要读写分离 2. 读写分离的原理 3. 读写分离的问题 3.1. 数据一致性 3.2. 分发机制 4. 参考资料",content:"# 读写分离基本原理\n\n读写分离的基本原理是：主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作。\n\n\n# 1. 为何要读写分离\n\n * 有效减少锁竞争 - 主服务器只负责写，从服务器只负责读，能够有效的避免由数据更新导致的行锁竞争，使得整个系统的查询性能得到极大的改善。\n * 提高查询吞吐量 - 通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。\n * 提升数据库可用性 - 使用多主多从的方式，不但能够提升系统的吞吐量，还能够提升数据库的可用性，可以达到在任何一个数据库宕机，甚至磁盘物理损坏的情况下仍然不影响系统的正常运行。\n\n\n# 2. 读写分离的原理\n\n读写分离的实现是根据 SQL 语义分析，将读操作和写操作分别路由至主库与从库。\n\n\n\n读写分离的基本实现是：\n\n\n\n * 数据库服务器搭建主从集群，一主一从、一主多从都可以。\n * 数据库主机负责读写操作，从机只负责读操作。\n * 数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了全量数据。\n * 业务服务器将写操作发给数据库主机，将读操作发给数据库从机。\n * 主机会记录请求的二进制日志，然后推送给从库，从库解析并执行日志中的请求，完成主从复制。这意味着：复制过程存在时延，这段时间内，主从数据可能不一致。\n\n\n# 3. 读写分离的问题\n\n读写分离存在两个问题：数据一致性和分发机制。\n\n\n# 3.1. 数据一致性\n\n读写分离产生了主库与从库之间的数据一致性的问题。\n\n\n\n\n# 3.2. 分发机制\n\n数据库读写分离后，一个 SQL 请求具体分发到哪个数据库节点？一般有两种分发方式：客户端分发和中间件代理分发。\n\n客户端分发，是基于程序代码，自行控制数据分发到哪个数据库节点。更细一点来说，一般程序中建立多个数据库的连接，根据一定的算法，选择合适的连接去发起 SQL 请求。这种方式也被称为客户端中间件，代表有：jdbc-sharding。\n\n中间件代理分发，指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 SQL 兼容的协议，业务服务器无须自己进行读写分离。对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。代表有：Mycat。\n\n\n# 4. 参考资料\n\n * 后端存储实战课\n * ShardingSphere 官方文档",normalizedContent:"# 读写分离基本原理\n\n读写分离的基本原理是：主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作。\n\n\n# 1. 为何要读写分离\n\n * 有效减少锁竞争 - 主服务器只负责写，从服务器只负责读，能够有效的避免由数据更新导致的行锁竞争，使得整个系统的查询性能得到极大的改善。\n * 提高查询吞吐量 - 通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。\n * 提升数据库可用性 - 使用多主多从的方式，不但能够提升系统的吞吐量，还能够提升数据库的可用性，可以达到在任何一个数据库宕机，甚至磁盘物理损坏的情况下仍然不影响系统的正常运行。\n\n\n# 2. 读写分离的原理\n\n读写分离的实现是根据 sql 语义分析，将读操作和写操作分别路由至主库与从库。\n\n\n\n读写分离的基本实现是：\n\n\n\n * 数据库服务器搭建主从集群，一主一从、一主多从都可以。\n * 数据库主机负责读写操作，从机只负责读操作。\n * 数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了全量数据。\n * 业务服务器将写操作发给数据库主机，将读操作发给数据库从机。\n * 主机会记录请求的二进制日志，然后推送给从库，从库解析并执行日志中的请求，完成主从复制。这意味着：复制过程存在时延，这段时间内，主从数据可能不一致。\n\n\n# 3. 读写分离的问题\n\n读写分离存在两个问题：数据一致性和分发机制。\n\n\n# 3.1. 数据一致性\n\n读写分离产生了主库与从库之间的数据一致性的问题。\n\n\n\n\n# 3.2. 分发机制\n\n数据库读写分离后，一个 sql 请求具体分发到哪个数据库节点？一般有两种分发方式：客户端分发和中间件代理分发。\n\n客户端分发，是基于程序代码，自行控制数据分发到哪个数据库节点。更细一点来说，一般程序中建立多个数据库的连接，根据一定的算法，选择合适的连接去发起 sql 请求。这种方式也被称为客户端中间件，代表有：jdbc-sharding。\n\n中间件代理分发，指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 sql 兼容的协议，业务服务器无须自己进行读写分离。对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。代表有：mycat。\n\n\n# 4. 参考资料\n\n * 后端存储实战课\n * shardingsphere 官方文档",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"分库分表基本原理",frontmatter:{title:"分库分表基本原理",categories:["分布式","分布式关键技术","数据调度"],tags:["分布式","数据调度","分库分表"],abbrlink:"b9d9ce9d",date:"2019-10-16T20:54:00.000Z",permalink:"/pages/103382/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/02.%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%A6/03.%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html",relativePath:"02.分布式/03.分布式关键技术/02.数据调度/03.分库分表.md",key:"v-f52afa76",path:"/pages/103382/",headers:[{level:2,title:"1. 为何要分库分表",slug:"_1-为何要分库分表",normalizedTitle:"1. 为何要分库分表",charIndex:15},{level:2,title:"2. 分库分表原理",slug:"_2-分库分表原理",normalizedTitle:"2. 分库分表原理",charIndex:397},{level:3,title:"2.1. 垂直分片",slug:"_2-1-垂直分片",normalizedTitle:"2.1. 垂直分片",charIndex:755},{level:3,title:"2.2. 水平分片",slug:"_2-2-水平分片",normalizedTitle:"2.2. 水平分片",charIndex:1430},{level:3,title:"2.3. 分库分表策略",slug:"_2-3-分库分表策略",normalizedTitle:"2.3. 分库分表策略",charIndex:1902},{level:4,title:"2.3.1. 数值范围路由",slug:"_2-3-1-数值范围路由",normalizedTitle:"2.3.1. 数值范围路由",charIndex:1960},{level:4,title:"2.3.2. Hash 路由",slug:"_2-3-2-hash-路由",normalizedTitle:"2.3.2. hash 路由",charIndex:2134},{level:4,title:"2.3.3. 路由表",slug:"_2-3-3-路由表",normalizedTitle:"2.3.3. 路由表",charIndex:2518},{level:2,title:"3. 迁移和扩容",slug:"_3-迁移和扩容",normalizedTitle:"3. 迁移和扩容",charIndex:2680},{level:3,title:"3.1. 停机迁移/扩容（不推荐）",slug:"_3-1-停机迁移-扩容-不推荐",normalizedTitle:"3.1. 停机迁移/扩容（不推荐）",charIndex:2693},{level:4,title:"3.1.1. 停机迁移/扩容流程",slug:"_3-1-1-停机迁移-扩容流程",normalizedTitle:"3.1.1. 停机迁移/扩容流程",charIndex:2742},{level:4,title:"3.1.2. 停机迁移/扩容方案分析",slug:"_3-1-2-停机迁移-扩容方案分析",normalizedTitle:"3.1.2. 停机迁移/扩容方案分析",charIndex:2885},{level:3,title:"3.2. 双写迁移",slug:"_3-2-双写迁移",normalizedTitle:"3.2. 双写迁移",charIndex:3043},{level:4,title:"3.2.1. 双写迁移流程",slug:"_3-2-1-双写迁移流程",normalizedTitle:"3.2.1. 双写迁移流程",charIndex:3892},{level:3,title:"3.3. 主从升级",slug:"_3-3-主从升级",normalizedTitle:"3.3. 主从升级",charIndex:4178},{level:4,title:"3.3.1. 升级从库的流程",slug:"_3-3-1-升级从库的流程",normalizedTitle:"3.3.1. 升级从库的流程",charIndex:4292},{level:4,title:"3.3.2. 升级从库方案分析",slug:"_3-3-2-升级从库方案分析",normalizedTitle:"3.3.2. 升级从库方案分析",charIndex:4501},{level:2,title:"4. 分库分表的问题",slug:"_4-分库分表的问题",normalizedTitle:"4. 分库分表的问题",charIndex:4539},{level:3,title:"4.1. 分布式 ID 问题",slug:"_4-1-分布式-id-问题",normalizedTitle:"4.1. 分布式 id 问题",charIndex:4554},{level:3,title:"4.2. 分布式事务问题",slug:"_4-2-分布式事务问题",normalizedTitle:"4.2. 分布式事务问题",charIndex:4707},{level:3,title:"4.3. 跨节点 Join 和聚合",slug:"_4-3-跨节点-join-和聚合",normalizedTitle:"4.3. 跨节点 join 和聚合",charIndex:4931},{level:3,title:"4.4. 跨分片的排序分页",slug:"_4-4-跨分片的排序分页",normalizedTitle:"4.4. 跨分片的排序分页",charIndex:5063},{level:2,title:"5. 中间件",slug:"_5-中间件",normalizedTitle:"5. 中间件",charIndex:5714},{level:2,title:"6. 参考资料",slug:"_6-参考资料",normalizedTitle:"6. 参考资料",charIndex:7013}],headersStr:"1. 为何要分库分表 2. 分库分表原理 2.1. 垂直分片 2.2. 水平分片 2.3. 分库分表策略 2.3.1. 数值范围路由 2.3.2. Hash 路由 2.3.3. 路由表 3. 迁移和扩容 3.1. 停机迁移/扩容（不推荐） 3.1.1. 停机迁移/扩容流程 3.1.2. 停机迁移/扩容方案分析 3.2. 双写迁移 3.2.1. 双写迁移流程 3.3. 主从升级 3.3.1. 升级从库的流程 3.3.2. 升级从库方案分析 4. 分库分表的问题 4.1. 分布式 ID 问题 4.2. 分布式事务问题 4.3. 跨节点 Join 和聚合 4.4. 跨分片的排序分页 5. 中间件 6. 参考资料",content:'# 分库分表基本原理\n\n\n# 1. 为何要分库分表\n\n分库分表主要基于以下理由：\n\n * 并发连接 - 单库超过每秒 2000 个并发时，而一个健康的单库最好保持在每秒 1000 个并发左右，不要太大。\n * 磁盘容量 - 磁盘容量占满，会导致服务器不可用。\n * SQL 性能 - 单表数据量过大，会导致 SQL 执行效率低下。一般，单表超过 1000 万条数据，就可以考虑分表了。\n\n#          分库分表前               分库分表后\n并发支撑情况     MySQL 单机部署，扛不住高并发   MySQL 从单机到多机，能承受的并发增加了多倍\n磁盘使用情况     MySQL 单机磁盘容量几乎撑满    拆分为多个库，数据库服务器磁盘使用率大大降低\nSQL 执行性能   单表数据量太大，SQL 越跑越慢    单表数据量减少，SQL 执行效率明显提升\n\n\n# 2. 分库分表原理\n\n数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。 数据分片的有效手段是对关系型数据库进行分库和分表。分库和分表均可以有效的避免由数据量超过可承受阈值而产生的查询瓶颈。 除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库压力，但却能够提供尽量将分布式事务转化为本地事务的可能，一旦涉及到跨库的更新操作，分布式事务往往会使问题变得复杂。 使用多主多从的分片方式，可以有效的避免数据单点，从而提升数据架构的可用性。\n\n通过分库和分表进行数据的拆分来使得各个表的数据量保持在阈值以下，以及对流量进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段。 数据分片的拆分方式又分为垂直分片和水平分片。\n\n\n# 2.1. 垂直分片\n\n垂直分片有两种拆分考量：业务拆分和访问频率拆分\n\n（1）业务拆分\n\n> 业务拆分的核心理念是专库专用。\n\n在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是按照业务将表进行归类，分布到不同的数据库中，从而将压力分散至不同的数据库。下图展示了根据业务需要，将用户表和订单表垂直分片到不同的数据库的方案。\n\n垂直分片往往需要对架构和设计进行调整。通常来讲，是来不及应对互联网业务需求快速变化的；而且，它也并无法真正的解决单点瓶颈。垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理。\n\n（2）访问频率拆分\n\n> 访问频率拆分，是 把一个有很多字段的表给拆分成多个表，或者是多个库上去。一般来说，会 将较少的、访问频率较高的字段放到一个表中，然后 将较多的、访问频率较低的字段放到另外一个表中。因为数据库是有缓存的，访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。\n\n\n\n一般来说，满足下面的条件就可以考虑扩容了：\n\n * Mysql 单库超过 5000 万条记录，Oracle 单库超过 1 亿条记录，DB 压力就很大。\n * 单库超过每秒 2000 个并发时，而一个健康的单库最好保持在每秒 1000 个并发左右，不要太大。\n\n在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。\n\n\n# 2.2. 水平分片\n\n> 水平拆分 又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。当 单表数据量太大 时，会极大影响 SQL 执行的性能 。分表是将原来一张表的数据分布到数据库集群的不同节点上，从而缓解单点的压力。\n\n相对于垂直分片，水平分片不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分。 例如：根据主键分片，偶数主键的记录放入 0 库（或表），奇数主键的记录放入 1 库（或表）。\n\n水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是分库分表的标准解决方案。\n\n\n\n一般来说，单表有 200 万条数据 的时候，性能就会相对差一些了，需要考虑分表了。但是，这也要视具体情况而定，可能是 100 万条，也可能是 500 万条，SQL 越复杂，就最好让单表行数越少。\n\n读写分离的数据节点中的数据内容是一致的，而水平分片的每个数据节点的数据内容却并不相同。将水平分片和读写分离联合使用，能够更加有效的提升系统性能。\n\n\n# 2.3. 分库分表策略\n\n\n\n分库分表策略主要有两种：\n\n * 根据数值范围划分\n * 根据 Hash 划分\n\n# 2.3.1. 数值范围路由\n\n数值范围路由，就是根据 ID、时间范围 这类具有排序性的字段来进行划分。例如：用户 Id 为 1-9999 的记录分到第一个库，10000-20000 的分到第二个库，以此类推。\n\n按这种策略划分出来的数据，具有数据连续性。\n\n优点：数据迁移很简单。\n\n缺点：容易产生热点问题，大量的流量都打在最新的数据上了。\n\n# 2.3.2. Hash 路由\n\n典型的 Hash 路由，如根据数值取模，当需要扩容时，一般以 2 的幂次方进行扩容（这样，扩容时迁移的数据量会小一些）。例如：用户 Id mod n，余数为 0 的记录放到第一个库，余数为 1 的放到第二个库，以此类推。\n\n一般采用 预分区 的方式，提前根据 数据量 规划好 分区数，比如划分为 512 或 1024 张表，保证可支撑未来一段时间的 数据容量，再根据 负载情况 将 表 迁移到其他 数据库 中。扩容时通常采用 翻倍扩容，避免 数据映射 全部被 打乱，导致 全量迁移 的情况。\n\n优点：数据离散分布，不存在热点问题。\n\n缺点：数据迁移、扩容麻烦（之前的数据需要重新计算 hash 值重新分配到不同的库或表）。当 节点数量 变化时，如 扩容 或 收缩 节点，数据节点 映射关系 需要重新计算，会导致数据的 重新迁移。\n\n# 2.3.3. 路由表\n\n这种策略，就是用一张独立的表记录路由信息。\n\n优点：简单、灵活，尤其是在扩容、迁移时，只需要迁移指定的数据，然后修改路由表即可。\n\n缺点：每次查询，必须先查路由表，增加了 IO 开销。并且，如果路由表本身太大，也会面临性能瓶颈，如果想对路由表再做分库分表，将出现死循环式的路由算法选择问题。\n\n\n# 3. 迁移和扩容\n\n\n# 3.1. 停机迁移/扩容（不推荐）\n\n停机迁移/扩容是最暴力、最简单的迁移、扩容方案。\n\n\n\n# 3.1.1. 停机迁移/扩容流程\n\n（0）预估停服时间，发布停服公告。\n\n（1）停服，不允许数据访问。\n\n（2）编写临时的数据导入程序，从老数据库中读取数据。\n\n（3）将数据写入中间件。\n\n（4）中间件根据分片规则，将数据分发到分库（分表）中。\n\n（5）应用程序修改配置，重启。\n\n# 3.1.2. 停机迁移/扩容方案分析\n\n优点：简单、没有数据一致性问题。\n\n缺点：如果老的数据库数据量很大，则停机处理时间可能很久。比如老的数据库是已经分库分表的数据库群，数据量可能达到亿级，导入数据可能就要花费几小时。如果中间过程中出现问题，就容易引发重大事故。\n\n点评：综上，这种方案代价太高，不可取。\n\n\n# 3.2. 双写迁移\n\n双写迁移的改造方案如下：\n\n * 支持双写新旧两个库，并且预留热切换开关，能通过开关控制三种写状态：只写旧库、只写新库和同步双写。\n * 支持读新旧两个库，同样预留热切换开关，控制读旧库还是新库。\n\n然后上线新版服务，这个时候服务仍然是只读写旧库，不读写新库。新版服务需要稳定运行至少一到二周的时间，期间除了验证新版服务的稳定性以外，还要验证新旧两个库中的数据是否是一致的。这个过程中，如果新版服务有问题，可以立即下线新版服务，回滚到旧版本的服务。\n\n稳定一段时间之后，就可以开启服务的双写开关了。开启双写开关的同时，需要停掉同步程序。这里面有一个问题需要注意一下，就是这个双写的业务逻辑，一定是先写旧库，再写新库，并且以写旧库的结果为准。\n\n旧库写成功，新库写失败，返回写成功，但这个时候要记录日志，后续我们会用到这个日志来验证新库是否还有问题。旧库写失败，直接返回失败，就不写新库了。这么做的原因是，不能让新库影响到现有业务的可用性和数据准确性。上面这个过程如果出现问题，可以关闭双写，回滚到只读写旧库的状态。\n\n切换到双写之后，新库与旧库的数据可能会存在不一致的情况，原因有两个：一、停止同步程序和开启双写，这两个过程很难做到无缝衔接，二、双写的策略也不保证新旧库强一致，这时候我们需要上线一个对比和补偿的程序，这个程序对比旧库最近的数据变更，然后检查新库中的数据是否一致，如果不一致，还要进行补偿。\n\n开启双写后，还需要至少稳定运行至少几周的时间，并且期间我们要不断地检查，确保不能有旧库写成功，新库写失败的情况出现。对比程序也没有发现新旧两个库的数据有不一致的情况，这个时候，我们就可以认为，新旧两个库的数据是一直保持同步的。接下来就可以用类似灰度发布的方式，把读请求一点儿一点儿地切到新库上。同样，期间如果出问题的话，可以再切回旧库。全部读请求都切换到新库上之后，这个时候其实读写请求就已经都切换到新库上了，实际的切换已经完成了，但还有后续的收尾步骤。\n\n\n\n# 3.2.1. 双写迁移流程\n\n 1. 修改应用程序配置，将数据同时写入老数据库和中间件。这就是所谓的双写，同时写俩库，老库和新库。\n\n 2. 编写临时程序，读取老数据库。\n\n 3. 将数据写入中间件。如果数据不存在，直接写入；如果数据存在，比较时间戳，只允许新数据覆盖老数据。\n\n 4. 导入数据后，有可能数据还是存在不一致，那么就对数据进行校验，比对新老库的每条数据。如果存在差异，针对差异数据，执行（3）。循环（3）、（4）步骤，直至数据完全一致。\n\n 5. 修改应用程序配置，将数据只写入中间件。\n\n 6. 中间件根据分片规则，将数据分发到分库（分表）中。\n\n\n# 3.3. 主从升级\n\n生产环境的数据库，为了保证高可用，一般会采用主备架构。主库支持读写操作，从库支持读操作。\n\n\n\n由于主备节点数据一致，所以将从库升级为主节点，并修改分片配置，将从节点作为分库之一，就实现了扩容。\n\n\n\n# 3.3.1. 升级从库的流程\n\n（1）解除主从关系，从库升级为主库。\n\n（2）应用程序，修改配置，读写通过中间件。\n\n（3）分库分表中间，修改分片配置。将数据按照新的规则分发。\n\n（4）编写临时程序，清理冗余数据。比如：原来是一个单库，数据量为 400 万。从节点升级为分库之一后，每个分库都有 400 万数据，其中 200 万是冗余数据。清理完后，进行数据校验。\n\n（5）为每个分库添加新的从库，保证高可用。\n\n# 3.3.2. 升级从库方案分析\n\n优点：不需要停机，无需数据迁移。\n\n\n# 4. 分库分表的问题\n\n\n# 4.1. 分布式 ID 问题\n\n一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的 ID 无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得 ID，以便进行 SQL 路由。\n\n> 分布式 ID 的解决方案详见：分布式 ID\n\n\n# 4.2. 分布式事务问题\n\n跨库事务也是分布式的数据库集群要面对的棘手事情。 合理采用分表，可以在降低单表数据量的情况下，尽量使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦。在不能避免跨库事务的场景，有些业务仍然需要保持事务的一致性。 而基于 XA 的分布式事务由于在并发度高的场景中性能无法满足需要，并未被互联网巨头大规模使用，他们大多采用最终一致性的柔性事务代替强一致事务。\n\n> 分布式事务的解决方案详见：分布式事务\n\n\n# 4.3. 跨节点 Join 和聚合\n\n分库分表后，无法直接跨节点 join 、count、order by、group by 以及聚合。\n\n针对这类问题，普遍做法是二次查询。\n\n在第一次查询时，获取各个节点上的结果。\n\n在程序中将这些结果进行合并、筛选。\n\n\n# 4.4. 跨分片的排序分页\n\n一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：\n\n\n\n上面图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第 10 页数据，情况又将变得复杂很多，如下图所示：\n\n\n\n有些读者可能并不太理解，为什么不能像获取第一页数据那样简单处理（排序取出前 10 条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前 N 页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差。\n\n那如何解决分库情况下的分页问题呢？有以下几种办法：\n\n如果是在前台应用提供分页，则限定用户只能看前面 n 页，这个限制在业务上也是合理的，一般看后面的分页意义不大（如果一定要看，可以要求用户缩小范围重新查询）。\n\n如果是后台批处理任务要求分批获取数据，则可以加大 page size，比如每次获取 5000 条记录，有效减少分页数（当然离线访问一般走备库，避免冲击主库）。\n\n分库设计时，一般还有配套大数据平台汇总所有分库的记录，有些分页查询可以考虑走大数据平台。\n\n\n# 5. 中间件\n\n国内常见分库分表中间件：\n\n * Cobar - 阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。应用程序通过 JDBC 驱动访问 cobar 集群，cobar 根据 SQL 和分库规则对 SQL 做分解，然后分发到 MySQL 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。\n * TDDL - 淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。\n * Atlas - 360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。\n * sharding-jdbc - 当当开源的，属于 client 层方案。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且目前推出到了 2.0 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也可以选择的方案。\n * Mycat - 基于 cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 sharding jdbc 来说，年轻一些，经历的锤炼少一些。\n\n技术选型建议：\n\n建议使用的是 sharding-jdbc 和 mycat。\n\n * sharding-jdbc 这种 client 层方案的优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要耦合 sharding-jdbc 的依赖。其本质上通过配置多数据源，然后根据设定的分库分表策略，计算路由，将请求发送到计算得到的节点上。\n * Mycat 这种 proxy 层方案的缺点在于需要部署，自己运维一套中间件，运维成本高，但是好处在于对于各个项目是透明的，如果遇到升级之类的都是自己中间件那里搞就行了。\n\n通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用 sharding-jdbc，client 层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多；但是中大型公司最好还是选用 mycat 这类 proxy 层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护 mycat，然后大量项目直接透明使用即可。\n\n\n# 6. 参考资料\n\n * 后端存储实战课\n * ShardingSphere 官方文档\n * “分库分表" ？选型和流程要慎重，否则会失控\n * 分库分表需要考虑的问题及方案\n * 一次难得的分库分表实践\n * 分库分表平滑扩容',normalizedContent:'# 分库分表基本原理\n\n\n# 1. 为何要分库分表\n\n分库分表主要基于以下理由：\n\n * 并发连接 - 单库超过每秒 2000 个并发时，而一个健康的单库最好保持在每秒 1000 个并发左右，不要太大。\n * 磁盘容量 - 磁盘容量占满，会导致服务器不可用。\n * sql 性能 - 单表数据量过大，会导致 sql 执行效率低下。一般，单表超过 1000 万条数据，就可以考虑分表了。\n\n#          分库分表前               分库分表后\n并发支撑情况     mysql 单机部署，扛不住高并发   mysql 从单机到多机，能承受的并发增加了多倍\n磁盘使用情况     mysql 单机磁盘容量几乎撑满    拆分为多个库，数据库服务器磁盘使用率大大降低\nsql 执行性能   单表数据量太大，sql 越跑越慢    单表数据量减少，sql 执行效率明显提升\n\n\n# 2. 分库分表原理\n\n数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果。 数据分片的有效手段是对关系型数据库进行分库和分表。分库和分表均可以有效的避免由数据量超过可承受阈值而产生的查询瓶颈。 除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库压力，但却能够提供尽量将分布式事务转化为本地事务的可能，一旦涉及到跨库的更新操作，分布式事务往往会使问题变得复杂。 使用多主多从的分片方式，可以有效的避免数据单点，从而提升数据架构的可用性。\n\n通过分库和分表进行数据的拆分来使得各个表的数据量保持在阈值以下，以及对流量进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段。 数据分片的拆分方式又分为垂直分片和水平分片。\n\n\n# 2.1. 垂直分片\n\n垂直分片有两种拆分考量：业务拆分和访问频率拆分\n\n（1）业务拆分\n\n> 业务拆分的核心理念是专库专用。\n\n在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是按照业务将表进行归类，分布到不同的数据库中，从而将压力分散至不同的数据库。下图展示了根据业务需要，将用户表和订单表垂直分片到不同的数据库的方案。\n\n垂直分片往往需要对架构和设计进行调整。通常来讲，是来不及应对互联网业务需求快速变化的；而且，它也并无法真正的解决单点瓶颈。垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理。\n\n（2）访问频率拆分\n\n> 访问频率拆分，是 把一个有很多字段的表给拆分成多个表，或者是多个库上去。一般来说，会 将较少的、访问频率较高的字段放到一个表中，然后 将较多的、访问频率较低的字段放到另外一个表中。因为数据库是有缓存的，访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。\n\n\n\n一般来说，满足下面的条件就可以考虑扩容了：\n\n * mysql 单库超过 5000 万条记录，oracle 单库超过 1 亿条记录，db 压力就很大。\n * 单库超过每秒 2000 个并发时，而一个健康的单库最好保持在每秒 1000 个并发左右，不要太大。\n\n在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。\n\n\n# 2.2. 水平分片\n\n> 水平拆分 又称为 sharding，它是将同一个表中的记录拆分到多个结构相同的表中。当 单表数据量太大 时，会极大影响 sql 执行的性能 。分表是将原来一张表的数据分布到数据库集群的不同节点上，从而缓解单点的压力。\n\n相对于垂直分片，水平分片不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分。 例如：根据主键分片，偶数主键的记录放入 0 库（或表），奇数主键的记录放入 1 库（或表）。\n\n水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是分库分表的标准解决方案。\n\n\n\n一般来说，单表有 200 万条数据 的时候，性能就会相对差一些了，需要考虑分表了。但是，这也要视具体情况而定，可能是 100 万条，也可能是 500 万条，sql 越复杂，就最好让单表行数越少。\n\n读写分离的数据节点中的数据内容是一致的，而水平分片的每个数据节点的数据内容却并不相同。将水平分片和读写分离联合使用，能够更加有效的提升系统性能。\n\n\n# 2.3. 分库分表策略\n\n\n\n分库分表策略主要有两种：\n\n * 根据数值范围划分\n * 根据 hash 划分\n\n# 2.3.1. 数值范围路由\n\n数值范围路由，就是根据 id、时间范围 这类具有排序性的字段来进行划分。例如：用户 id 为 1-9999 的记录分到第一个库，10000-20000 的分到第二个库，以此类推。\n\n按这种策略划分出来的数据，具有数据连续性。\n\n优点：数据迁移很简单。\n\n缺点：容易产生热点问题，大量的流量都打在最新的数据上了。\n\n# 2.3.2. hash 路由\n\n典型的 hash 路由，如根据数值取模，当需要扩容时，一般以 2 的幂次方进行扩容（这样，扩容时迁移的数据量会小一些）。例如：用户 id mod n，余数为 0 的记录放到第一个库，余数为 1 的放到第二个库，以此类推。\n\n一般采用 预分区 的方式，提前根据 数据量 规划好 分区数，比如划分为 512 或 1024 张表，保证可支撑未来一段时间的 数据容量，再根据 负载情况 将 表 迁移到其他 数据库 中。扩容时通常采用 翻倍扩容，避免 数据映射 全部被 打乱，导致 全量迁移 的情况。\n\n优点：数据离散分布，不存在热点问题。\n\n缺点：数据迁移、扩容麻烦（之前的数据需要重新计算 hash 值重新分配到不同的库或表）。当 节点数量 变化时，如 扩容 或 收缩 节点，数据节点 映射关系 需要重新计算，会导致数据的 重新迁移。\n\n# 2.3.3. 路由表\n\n这种策略，就是用一张独立的表记录路由信息。\n\n优点：简单、灵活，尤其是在扩容、迁移时，只需要迁移指定的数据，然后修改路由表即可。\n\n缺点：每次查询，必须先查路由表，增加了 io 开销。并且，如果路由表本身太大，也会面临性能瓶颈，如果想对路由表再做分库分表，将出现死循环式的路由算法选择问题。\n\n\n# 3. 迁移和扩容\n\n\n# 3.1. 停机迁移/扩容（不推荐）\n\n停机迁移/扩容是最暴力、最简单的迁移、扩容方案。\n\n\n\n# 3.1.1. 停机迁移/扩容流程\n\n（0）预估停服时间，发布停服公告。\n\n（1）停服，不允许数据访问。\n\n（2）编写临时的数据导入程序，从老数据库中读取数据。\n\n（3）将数据写入中间件。\n\n（4）中间件根据分片规则，将数据分发到分库（分表）中。\n\n（5）应用程序修改配置，重启。\n\n# 3.1.2. 停机迁移/扩容方案分析\n\n优点：简单、没有数据一致性问题。\n\n缺点：如果老的数据库数据量很大，则停机处理时间可能很久。比如老的数据库是已经分库分表的数据库群，数据量可能达到亿级，导入数据可能就要花费几小时。如果中间过程中出现问题，就容易引发重大事故。\n\n点评：综上，这种方案代价太高，不可取。\n\n\n# 3.2. 双写迁移\n\n双写迁移的改造方案如下：\n\n * 支持双写新旧两个库，并且预留热切换开关，能通过开关控制三种写状态：只写旧库、只写新库和同步双写。\n * 支持读新旧两个库，同样预留热切换开关，控制读旧库还是新库。\n\n然后上线新版服务，这个时候服务仍然是只读写旧库，不读写新库。新版服务需要稳定运行至少一到二周的时间，期间除了验证新版服务的稳定性以外，还要验证新旧两个库中的数据是否是一致的。这个过程中，如果新版服务有问题，可以立即下线新版服务，回滚到旧版本的服务。\n\n稳定一段时间之后，就可以开启服务的双写开关了。开启双写开关的同时，需要停掉同步程序。这里面有一个问题需要注意一下，就是这个双写的业务逻辑，一定是先写旧库，再写新库，并且以写旧库的结果为准。\n\n旧库写成功，新库写失败，返回写成功，但这个时候要记录日志，后续我们会用到这个日志来验证新库是否还有问题。旧库写失败，直接返回失败，就不写新库了。这么做的原因是，不能让新库影响到现有业务的可用性和数据准确性。上面这个过程如果出现问题，可以关闭双写，回滚到只读写旧库的状态。\n\n切换到双写之后，新库与旧库的数据可能会存在不一致的情况，原因有两个：一、停止同步程序和开启双写，这两个过程很难做到无缝衔接，二、双写的策略也不保证新旧库强一致，这时候我们需要上线一个对比和补偿的程序，这个程序对比旧库最近的数据变更，然后检查新库中的数据是否一致，如果不一致，还要进行补偿。\n\n开启双写后，还需要至少稳定运行至少几周的时间，并且期间我们要不断地检查，确保不能有旧库写成功，新库写失败的情况出现。对比程序也没有发现新旧两个库的数据有不一致的情况，这个时候，我们就可以认为，新旧两个库的数据是一直保持同步的。接下来就可以用类似灰度发布的方式，把读请求一点儿一点儿地切到新库上。同样，期间如果出问题的话，可以再切回旧库。全部读请求都切换到新库上之后，这个时候其实读写请求就已经都切换到新库上了，实际的切换已经完成了，但还有后续的收尾步骤。\n\n\n\n# 3.2.1. 双写迁移流程\n\n 1. 修改应用程序配置，将数据同时写入老数据库和中间件。这就是所谓的双写，同时写俩库，老库和新库。\n\n 2. 编写临时程序，读取老数据库。\n\n 3. 将数据写入中间件。如果数据不存在，直接写入；如果数据存在，比较时间戳，只允许新数据覆盖老数据。\n\n 4. 导入数据后，有可能数据还是存在不一致，那么就对数据进行校验，比对新老库的每条数据。如果存在差异，针对差异数据，执行（3）。循环（3）、（4）步骤，直至数据完全一致。\n\n 5. 修改应用程序配置，将数据只写入中间件。\n\n 6. 中间件根据分片规则，将数据分发到分库（分表）中。\n\n\n# 3.3. 主从升级\n\n生产环境的数据库，为了保证高可用，一般会采用主备架构。主库支持读写操作，从库支持读操作。\n\n\n\n由于主备节点数据一致，所以将从库升级为主节点，并修改分片配置，将从节点作为分库之一，就实现了扩容。\n\n\n\n# 3.3.1. 升级从库的流程\n\n（1）解除主从关系，从库升级为主库。\n\n（2）应用程序，修改配置，读写通过中间件。\n\n（3）分库分表中间，修改分片配置。将数据按照新的规则分发。\n\n（4）编写临时程序，清理冗余数据。比如：原来是一个单库，数据量为 400 万。从节点升级为分库之一后，每个分库都有 400 万数据，其中 200 万是冗余数据。清理完后，进行数据校验。\n\n（5）为每个分库添加新的从库，保证高可用。\n\n# 3.3.2. 升级从库方案分析\n\n优点：不需要停机，无需数据迁移。\n\n\n# 4. 分库分表的问题\n\n\n# 4.1. 分布式 id 问题\n\n一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的 id 无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得 id，以便进行 sql 路由。\n\n> 分布式 id 的解决方案详见：分布式 id\n\n\n# 4.2. 分布式事务问题\n\n跨库事务也是分布式的数据库集群要面对的棘手事情。 合理采用分表，可以在降低单表数据量的情况下，尽量使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦。在不能避免跨库事务的场景，有些业务仍然需要保持事务的一致性。 而基于 xa 的分布式事务由于在并发度高的场景中性能无法满足需要，并未被互联网巨头大规模使用，他们大多采用最终一致性的柔性事务代替强一致事务。\n\n> 分布式事务的解决方案详见：分布式事务\n\n\n# 4.3. 跨节点 join 和聚合\n\n分库分表后，无法直接跨节点 join 、count、order by、group by 以及聚合。\n\n针对这类问题，普遍做法是二次查询。\n\n在第一次查询时，获取各个节点上的结果。\n\n在程序中将这些结果进行合并、筛选。\n\n\n# 4.4. 跨分片的排序分页\n\n一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：\n\n\n\n上面图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第 10 页数据，情况又将变得复杂很多，如下图所示：\n\n\n\n有些读者可能并不太理解，为什么不能像获取第一页数据那样简单处理（排序取出前 10 条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前 n 页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差。\n\n那如何解决分库情况下的分页问题呢？有以下几种办法：\n\n如果是在前台应用提供分页，则限定用户只能看前面 n 页，这个限制在业务上也是合理的，一般看后面的分页意义不大（如果一定要看，可以要求用户缩小范围重新查询）。\n\n如果是后台批处理任务要求分批获取数据，则可以加大 page size，比如每次获取 5000 条记录，有效减少分页数（当然离线访问一般走备库，避免冲击主库）。\n\n分库设计时，一般还有配套大数据平台汇总所有分库的记录，有些分页查询可以考虑走大数据平台。\n\n\n# 5. 中间件\n\n国内常见分库分表中间件：\n\n * cobar - 阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。应用程序通过 jdbc 驱动访问 cobar 集群，cobar 根据 sql 和分库规则对 sql 做分解，然后分发到 mysql 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。\n * tddl - 淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。\n * atlas - 360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。\n * sharding-jdbc - 当当开源的，属于 client 层方案。确实之前用的还比较多一些，因为 sql 语法支持也比较多，没有太多限制，而且目前推出到了 2.0 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、tcc 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也可以选择的方案。\n * mycat - 基于 cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 sharding jdbc 来说，年轻一些，经历的锤炼少一些。\n\n技术选型建议：\n\n建议使用的是 sharding-jdbc 和 mycat。\n\n * sharding-jdbc 这种 client 层方案的优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要耦合 sharding-jdbc 的依赖。其本质上通过配置多数据源，然后根据设定的分库分表策略，计算路由，将请求发送到计算得到的节点上。\n * mycat 这种 proxy 层方案的缺点在于需要部署，自己运维一套中间件，运维成本高，但是好处在于对于各个项目是透明的，如果遇到升级之类的都是自己中间件那里搞就行了。\n\n通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用 sharding-jdbc，client 层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多；但是中大型公司最好还是选用 mycat 这类 proxy 层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护 mycat，然后大量项目直接透明使用即可。\n\n\n# 6. 参考资料\n\n * 后端存储实战课\n * shardingsphere 官方文档\n * “分库分表" ？选型和流程要慎重，否则会失控\n * 分库分表需要考虑的问题及方案\n * 一次难得的分库分表实践\n * 分库分表平滑扩容',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"分布式 ID 基本原理",frontmatter:{title:"分布式 ID 基本原理",categories:["分布式","分布式关键技术","数据调度"],tags:["分布式","数据调度","分布式ID"],abbrlink:"d547ed53",date:"2019-07-24T11:55:00.000Z",permalink:"/pages/0b2e59/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/02.%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%A6/04.%E5%88%86%E5%B8%83%E5%BC%8FID.html",relativePath:"02.分布式/03.分布式关键技术/02.数据调度/04.分布式ID.md",key:"v-255354da",path:"/pages/0b2e59/",headers:[{level:2,title:"1. 分布式 ID 简介",slug:"_1-分布式-id-简介",normalizedTitle:"1. 分布式 id 简介",charIndex:268},{level:2,title:"2. UUID",slug:"_2-uuid",normalizedTitle:"2. uuid",charIndex:620},{level:3,title:"2.1. UUID 的优点",slug:"_2-1-uuid-的优点",normalizedTitle:"2.1. uuid 的优点",charIndex:1641},{level:3,title:"2.2. UUID 的缺点",slug:"_2-2-uuid-的缺点",normalizedTitle:"2.2. uuid 的缺点",charIndex:1687},{level:3,title:"2.3. 适用场景",slug:"_2-3-适用场景",normalizedTitle:"2.3. 适用场景",charIndex:1999},{level:2,title:"3. 利用第三方存储生成键",slug:"_3-利用第三方存储生成键",normalizedTitle:"3. 利用第三方存储生成键",charIndex:2107},{level:3,title:"3.1. 优点",slug:"_3-1-优点",normalizedTitle:"3.1. 优点",charIndex:2245},{level:3,title:"3.2. 缺点",slug:"_3-2-缺点",normalizedTitle:"3.2. 缺点",charIndex:2299},{level:2,title:"4. 雪花算法（Snowflake）",slug:"_4-雪花算法-snowflake",normalizedTitle:"4. 雪花算法（snowflake）",charIndex:2412},{level:3,title:"4.1. 基本原理",slug:"_4-1-基本原理",normalizedTitle:"4.1. 基本原理",charIndex:2638},{level:4,title:"4.1.1. 键的组成",slug:"_4-1-1-键的组成",normalizedTitle:"4.1.1. 键的组成",charIndex:2651},{level:4,title:"4.1.2. 时钟回拨",slug:"_4-1-2-时钟回拨",normalizedTitle:"4.1.2. 时钟回拨",charIndex:3199},{level:4,title:"4.1.3. 灵活定制",slug:"_4-1-3-灵活定制",normalizedTitle:"4.1.3. 灵活定制",charIndex:3368},{level:3,title:"4.2. 优点",slug:"_4-2-优点",normalizedTitle:"4.2. 优点",charIndex:3790},{level:3,title:"4.3. 缺点",slug:"_4-3-缺点",normalizedTitle:"4.3. 缺点",charIndex:3898},{level:3,title:"4.4. 适用场景",slug:"_4-4-适用场景",normalizedTitle:"4.4. 适用场景",charIndex:3953},{level:3,title:"4.5. 防止时钟回拨",slug:"_4-5-防止时钟回拨",normalizedTitle:"4.5. 防止时钟回拨",charIndex:4055},{level:2,title:"5. Leaf",slug:"_5-leaf",normalizedTitle:"5. leaf",charIndex:4487},{level:3,title:"5.1. 基本原理",slug:"_5-1-基本原理",normalizedTitle:"5.1. 基本原理",charIndex:4582},{level:3,title:"5.2. 优点",slug:"_5-2-优点",normalizedTitle:"5.2. 优点",charIndex:6210},{level:3,title:"5.3. 缺点",slug:"_5-3-缺点",normalizedTitle:"5.3. 缺点",charIndex:6291},{level:3,title:"5.4. 适用场景",slug:"_5-4-适用场景",normalizedTitle:"5.4. 适用场景",charIndex:6357},{level:2,title:"6. 参考资料",slug:"_6-参考资料",normalizedTitle:"6. 参考资料",charIndex:6518}],headersStr:"1. 分布式 ID 简介 2. UUID 2.1. UUID 的优点 2.2. UUID 的缺点 2.3. 适用场景 3. 利用第三方存储生成键 3.1. 优点 3.2. 缺点 4. 雪花算法（Snowflake） 4.1. 基本原理 4.1.1. 键的组成 4.1.2. 时钟回拨 4.1.3. 灵活定制 4.2. 优点 4.3. 缺点 4.4. 适用场景 4.5. 防止时钟回拨 5. Leaf 5.1. 基本原理 5.2. 优点 5.3. 缺点 5.4. 适用场景 6. 参考资料",content:"# 分布式 ID 基本原理\n\n> 传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等。\n> \n> 数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。 虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。\n> \n> 为此，需要使用分布式 ID 来解决此问题。本文总结业界常用的分布式 ID 解决方案。\n\n\n# 1. 分布式 ID 简介\n\n首先，分布式 ID 应该具备哪些特性呢？\n\n 1. 全局唯一性 - 不能出现重复的 ID 号，既然是唯一标识，这是最基本的要求。\n 2. 趋势递增 - 在 MySQL InnoDB 引擎中使用的是聚集索引，由于多数 RDBMS 使用 B-tree 的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。\n 3. 单调递增 - 保证下一个 ID 一定大于上一个 ID，例如事务版本号、IM 增量消息、排序等特殊需求。\n 4. 信息安全 - 如果 ID 是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定 URL 即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要 ID 无规则、不规则。\n\n\n# 2. UUID\n\nUUID 是最简单的分布式 ID 方案。\n\nUUID 是通用唯一识别码（Universally Unique Identifier)的缩写，开放软件基金会(OSF)规范定义了包括网卡 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素。利用这些元素来生成 UUID。\n\nUUID 是由 128 位二进制组成，一般转换成十六进制，然后用 String 表示。在 java 中有个 UUID 类,在他的注释中我们看见这里有 4 种不同的 UUID 的生成策略:\n\n * random - 基于随机数生成 UUID，由于 Java 中的随机数是伪随机数，其重复的概率是可以被计算出来的。这个一般我们用下面的代码获取基于随机数的 UUID:\n\nString id = UUID.randomUUID().toString();\n\n\n * time-based - 基于时间的 UUID,这个一般是通过当前时间，随机数，和本地 Mac 地址来计算出来，自带的 JDK 包并没有这个算法的我们在一些 UUIDUtil 中，比如我们的 log4j.core.util，会重新定义 UUID 的高位和低位。\n\n public static UUID getTimeBasedUuid() {\n     long time = System.currentTimeMillis() * 10000L + 122192928000000000L + (long)(COUNT.incrementAndGet() % 10000);\n     long timeLow = (time & 4294967295L) << 32;\n     long timeMid = (time & 281470681743360L) >> 16;\n     long timeHi = (time & 1152640029630136320L) >> 48;\n     long most = timeLow | timeMid | 4096L | timeHi;\n     return new UUID(most, LEAST);\n }\n\n\n * DCE security - DCE 安全的 UUID。\n\n * name-based - 基于名字的 UUID，通过计算名字和名字空间的 MD5 来计算 UUID。\n\n\n# 2.1. UUID 的优点\n\n * 通过本地生成，没有经过网络 I/O，性能较快。\n\n\n# 2.2. UUID 的缺点\n\n * 长度过长 - UUID 太长，16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用。例如：Mysql 官方明确建议主键越短越好，36 个字符长度的 UUID 不符合要求。\n * 信息不安全 - 基于 MAC 地址生成 UUID 的算法可能会造成 MAC 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。\n * 无序性 - 不能生成递增有序的数字。这对于一些特定场景不利。例如：MySQL InnoDB 存储引擎使用 B+ 树存储索引数据，而主键也是一种索引。索引数据在 B+ 树中是有序排列的。UUID 的无序性可能会引起数据位置频繁变动，严重影响性能。\n\n\n# 2.3. 适用场景\n\nUUID 的适用场景可以为不需要担心过多的空间占用，以及不需要生成有递增趋势的数字。在 Log4j 里 UuidPatternConverter 中加入了 UUID 来标识每一条日志。\n\n\n# 3. 利用第三方存储生成键\n\n提到自增键，最先想到的肯定是直接使用数据库自增键。各数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等。\n\n当然，也可以考虑是用 Redis 这样的 Nosql，甚至 ZooKeeper 去生成键\n\n\n# 3.1. 优点\n\n * 非常简单，利用现有的功能实现，成本小\n * 有序递增\n * 方便排序和分页\n\n\n# 3.2. 缺点\n\n * 强依赖第三方存储，如果第三方存储非高可用系统，若出现丢失数据的情况，就可能出现重复生成 ID 的问题。\n * 生成 ID 性能瓶颈依赖于第三方存储的性能。\n * 增加了对第三方存储运维的成本。\n\n\n# 4. 雪花算法（Snowflake）\n\n雪花算法（Snowflake）是由 Twitter 公布的分布式主键生成算法，它会生成一个 64 bit 的整数，可以保证不同进程主键的不重复性，以及相同进程主键的有序性。\n\n在同一个进程中，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。 同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。\n\n\n# 4.1. 基本原理\n\n# 4.1.1. 键的组成\n\n使用雪花算法生成的主键，二进制表示形式包含 4 部分，从高位到低位分表为：1bit 符号位、41bit 时间戳位、10bit 工作进程位以及 12bit 序列号位。\n\n * 符号位(1bit)\n\n预留的符号位，恒为零。\n\n * 时间戳位(41bit)\n\n41 位的时间戳可以容纳的毫秒数是 2 的 41 次幂，一年所使用的毫秒数是：365 * 24 * 60 * 60 * 1000。通过计算可知：\n\nMath.pow(2, 41) / (365 * 24 * 60 * 60 * 1000L);\n\n\n结果约等于 69.73 年。ShardingSphere 的雪花算法的时间纪元从 2016 年 11 月 1 日零点开始，可以使用到 2086 年，相信能满足绝大部分系统的要求。\n\n * 工作进程位(10bit)\n\n该标志在 Java 进程内是唯一的，如果是分布式应用部署应保证每个工作进程的 id 是不同的。该值默认为 0，可通过属性设置。\n\n * 序列号位(12bit)\n\n该序列是用来在同一个毫秒内生成不同的 ID。如果在这个毫秒内生成的数量超过 4096(2 的 12 次幂)，那么生成器会等待到下个毫秒继续生成。\n\n雪花算法主键的详细结构见下图：\n\n\n\n# 4.1.2. 时钟回拨\n\n服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。 如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。 最大容忍的时钟回拨毫秒数的默认值为 0，可通过属性设置。\n\n# 4.1.3. 灵活定制\n\n上面只是一个将 64bit 划分的标准，当然也不一定这么做，可以根据不同业务的具体场景来划分，比如下面给出一个业务场景：\n\n * 服务目前 QPS10 万，预计几年之内会发展到百万。\n * 当前机器三地部署，上海，北京，深圳都有。\n * 当前机器 10 台左右，预计未来会增加至百台。\n\n这个时候我们根据上面的场景可以再次合理的划分 62bit，QPS 几年之内会发展到百万，那么每毫秒就是千级的请求，目前 10 台机器那么每台机器承担百级的请求，为了保证扩展，后面的循环位可以限制到 1024，也就是 2^10，那么循环位 10 位就足够了。\n\n机器三地部署我们可以用 3bit 总共 8 来表示机房位置，当前的机器 10 台，为了保证扩展到百台那么可以用 7bit 128 来表示，时间位依然是 41bit，那么还剩下 64-10-3-7-41-1 = 2bit，还剩下 2bit 可以用来进行扩展。\n\n\n\n\n# 4.2. 优点\n\n * 生成的 ID 都是趋势递增的。\n * 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成 ID 的性能也是非常高的。\n * 可以根据自身业务特性分配 bit 位，非常灵活。\n\n\n# 4.3. 缺点\n\n * 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。\n\n\n# 4.4. 适用场景\n\n当我们需要无序不能被猜测的 ID，并且需要一定高性能，且需要 long 型，那么就可以使用我们雪花算法。比如常见的订单 ID，用雪花算法别人就无法猜测你每天的订单量是多少。\n\n\n# 4.5. 防止时钟回拨\n\n雪花算法是强依赖于时间的，而如果机器时间发生回拨，有可能会生成重复的 ID。\n\n我们可以针对算法做一些优化，来防止时钟回拨生成重复 ID。\n\n用当前时间和上一次的时间进行判断，如果当前时间小于上一次的时间那么肯定是发生了回拨。普通的算法会直接抛出异常，这里我们可以对其进行优化，一般分为两个情况:\n\n * 如果时间回拨时间较短，比如配置 5ms 以内，那么可以直接等待一定的时间，让机器的时间追上来。\n * 如果时间的回拨时间较长，我们不能接受这么长的阻塞等待，那么又有两个策略:\n   * 直接拒绝，抛出异常。打日志，通知 RD 时钟回滚。\n   * 利用扩展位。上面我们讨论过，不同业务场景位数可能用不到那么多比特位，那么我们可以把扩展位数利用起来。比如：当这个时间回拨比较长的时候，我们可以不需要等待，直接在扩展位加 1。两位的扩展位允许我们有三次大的时钟回拨，一般来说就够了，如果其超过三次我们还是选择抛出异常，打日志。\n\n\n# 5. Leaf\n\n> 美团提供了一种分布式 ID 解决方案 Leaf，其本质可以视为数据库分段+服务缓存 ID。\n> \n> 详情可以参考 Leaf——美团点评分布式 ID 生成系统\n\n\n# 5.1. 基本原理\n\n使用数据库生成 ID，但是做了如下改进：\n\n原方案每次获取 ID 都得读写一次数据库，造成数据库压力大。改为利用 proxy server 批量获取，每次获取一个 segment(step 决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。 - 各个业务不同的发号需求用 biz_tag 字段来区分，每个 biz-tag 的 ID 获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对 biz_tag 分库分表就行。\n\n数据库表设计如下：\n\n+-------------+--------------+------+-----+-------------------+-----------------------------+\n| Field       | Type         | Null | Key | Default           | Extra                       |\n+-------------+--------------+------+-----+-------------------+-----------------------------+\n| biz_tag     | varchar(128) | NO   | PRI |                   |                             |\n| max_id      | bigint(20)   | NO   |     | 1                 |                             |\n| step        | int(11)      | NO   |     | NULL              |                             |\n| desc        | varchar(256) | YES  |     | NULL              |                             |\n| update_time | timestamp    | NO   |     | CURRENT_TIMESTAMP | on update CURRENT_TIMESTAMP |\n+-------------+--------------+------+-----+-------------------+-----------------------------+\n\n\n重要字段说明：\n\n * biz_tag 用来区分业务\n * max_id 表示该 biz_tag 目前所被分配的 ID 号段的最大值\n * step 表示每次分配的号段长度。原来获取 ID 每次都需要写数据库，现在只需要把 step 设置得足够大，比如 1000。那么只有当 1000 个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从 1 减小到了 1/step。\n\n大致架构如下图所示：\n\n\n\ntest_tag 在第一台 Leaf 机器上是 1~1000 的号段，当这个号段用完时，会去加载另一个长度为 step=1000 的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是 3001~4000。同时数据库对应的 biz_tag 这条数据的 max_id 会从 3000 被更新成 4000，更新号段的 SQL 语句如下：\n\nBegin\nUPDATE table SET max_id=max_id+step WHERE biz_tag=xxx\nSELECT tag, max_id, step FROM table WHERE biz_tag=xxx\nCommit\n\n\n\n# 5.2. 优点\n\n * 比数据库自增键性能高\n * 能保证键趋势递增。\n * 如果数据库宕机，由于 proxServer 有缓存，依然可以坚持一段时间。\n\n\n# 5.3. 缺点\n\n * 和主键递增一样，容易被人猜测。\n * 数据库宕机后，虽然能支撑一段时间，但是仍然会造成系统不可用。\n\n\n# 5.4. 适用场景\n\n需要趋势递增，并且 ID 大小可控制的，可以使用这套方案。\n\n当然这个方案也可以通过一些手段避免被人猜测，把 ID 变成是无序的，比如把我们生成的数据是一个递增的 long 型，把这个 Long 分成几个部分，比如可以分成几组三位数，几组四位数，然后在建立一个映射表，将我们的数据变成无序。\n\n\n# 6. 参考资料\n\n * 百度分布式 ID\n * 如果再有人问你分布式 ID，这篇文章丢给他\n * 理解分布式 id 生成算法 SnowFlake\n * Leaf——美团点评分布式 ID 生成系统\n * UUID 规范\n * ShardingSphere 分布式主键",normalizedContent:"# 分布式 id 基本原理\n\n> 传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如 mysql 的自增键，oracle 的自增序列等。\n> \n> 数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。 虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。\n> \n> 为此，需要使用分布式 id 来解决此问题。本文总结业界常用的分布式 id 解决方案。\n\n\n# 1. 分布式 id 简介\n\n首先，分布式 id 应该具备哪些特性呢？\n\n 1. 全局唯一性 - 不能出现重复的 id 号，既然是唯一标识，这是最基本的要求。\n 2. 趋势递增 - 在 mysql innodb 引擎中使用的是聚集索引，由于多数 rdbms 使用 b-tree 的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。\n 3. 单调递增 - 保证下一个 id 一定大于上一个 id，例如事务版本号、im 增量消息、排序等特殊需求。\n 4. 信息安全 - 如果 id 是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定 url 即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要 id 无规则、不规则。\n\n\n# 2. uuid\n\nuuid 是最简单的分布式 id 方案。\n\nuuid 是通用唯一识别码（universally unique identifier)的缩写，开放软件基金会(osf)规范定义了包括网卡 mac 地址、时间戳、名字空间（namespace）、随机或伪随机数、时序等元素。利用这些元素来生成 uuid。\n\nuuid 是由 128 位二进制组成，一般转换成十六进制，然后用 string 表示。在 java 中有个 uuid 类,在他的注释中我们看见这里有 4 种不同的 uuid 的生成策略:\n\n * random - 基于随机数生成 uuid，由于 java 中的随机数是伪随机数，其重复的概率是可以被计算出来的。这个一般我们用下面的代码获取基于随机数的 uuid:\n\nstring id = uuid.randomuuid().tostring();\n\n\n * time-based - 基于时间的 uuid,这个一般是通过当前时间，随机数，和本地 mac 地址来计算出来，自带的 jdk 包并没有这个算法的我们在一些 uuidutil 中，比如我们的 log4j.core.util，会重新定义 uuid 的高位和低位。\n\n public static uuid gettimebaseduuid() {\n     long time = system.currenttimemillis() * 10000l + 122192928000000000l + (long)(count.incrementandget() % 10000);\n     long timelow = (time & 4294967295l) << 32;\n     long timemid = (time & 281470681743360l) >> 16;\n     long timehi = (time & 1152640029630136320l) >> 48;\n     long most = timelow | timemid | 4096l | timehi;\n     return new uuid(most, least);\n }\n\n\n * dce security - dce 安全的 uuid。\n\n * name-based - 基于名字的 uuid，通过计算名字和名字空间的 md5 来计算 uuid。\n\n\n# 2.1. uuid 的优点\n\n * 通过本地生成，没有经过网络 i/o，性能较快。\n\n\n# 2.2. uuid 的缺点\n\n * 长度过长 - uuid 太长，16 字节 128 位，通常以 36 长度的字符串表示，很多场景不适用。例如：mysql 官方明确建议主键越短越好，36 个字符长度的 uuid 不符合要求。\n * 信息不安全 - 基于 mac 地址生成 uuid 的算法可能会造成 mac 地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。\n * 无序性 - 不能生成递增有序的数字。这对于一些特定场景不利。例如：mysql innodb 存储引擎使用 b+ 树存储索引数据，而主键也是一种索引。索引数据在 b+ 树中是有序排列的。uuid 的无序性可能会引起数据位置频繁变动，严重影响性能。\n\n\n# 2.3. 适用场景\n\nuuid 的适用场景可以为不需要担心过多的空间占用，以及不需要生成有递增趋势的数字。在 log4j 里 uuidpatternconverter 中加入了 uuid 来标识每一条日志。\n\n\n# 3. 利用第三方存储生成键\n\n提到自增键，最先想到的肯定是直接使用数据库自增键。各数据库对于该需求也提供了相应的支持，比如 mysql 的自增键，oracle 的自增序列等。\n\n当然，也可以考虑是用 redis 这样的 nosql，甚至 zookeeper 去生成键\n\n\n# 3.1. 优点\n\n * 非常简单，利用现有的功能实现，成本小\n * 有序递增\n * 方便排序和分页\n\n\n# 3.2. 缺点\n\n * 强依赖第三方存储，如果第三方存储非高可用系统，若出现丢失数据的情况，就可能出现重复生成 id 的问题。\n * 生成 id 性能瓶颈依赖于第三方存储的性能。\n * 增加了对第三方存储运维的成本。\n\n\n# 4. 雪花算法（snowflake）\n\n雪花算法（snowflake）是由 twitter 公布的分布式主键生成算法，它会生成一个 64 bit 的整数，可以保证不同进程主键的不重复性，以及相同进程主键的有序性。\n\n在同一个进程中，它首先是通过时间位保证不重复，如果时间相同则是通过序列位保证。 同时由于时间位是单调递增的，且各个服务器如果大体做了时间同步，那么生成的主键在分布式环境可以认为是总体有序的，这就保证了对索引字段的插入的高效性。\n\n\n# 4.1. 基本原理\n\n# 4.1.1. 键的组成\n\n使用雪花算法生成的主键，二进制表示形式包含 4 部分，从高位到低位分表为：1bit 符号位、41bit 时间戳位、10bit 工作进程位以及 12bit 序列号位。\n\n * 符号位(1bit)\n\n预留的符号位，恒为零。\n\n * 时间戳位(41bit)\n\n41 位的时间戳可以容纳的毫秒数是 2 的 41 次幂，一年所使用的毫秒数是：365 * 24 * 60 * 60 * 1000。通过计算可知：\n\nmath.pow(2, 41) / (365 * 24 * 60 * 60 * 1000l);\n\n\n结果约等于 69.73 年。shardingsphere 的雪花算法的时间纪元从 2016 年 11 月 1 日零点开始，可以使用到 2086 年，相信能满足绝大部分系统的要求。\n\n * 工作进程位(10bit)\n\n该标志在 java 进程内是唯一的，如果是分布式应用部署应保证每个工作进程的 id 是不同的。该值默认为 0，可通过属性设置。\n\n * 序列号位(12bit)\n\n该序列是用来在同一个毫秒内生成不同的 id。如果在这个毫秒内生成的数量超过 4096(2 的 12 次幂)，那么生成器会等待到下个毫秒继续生成。\n\n雪花算法主键的详细结构见下图：\n\n\n\n# 4.1.2. 时钟回拨\n\n服务器时钟回拨会导致产生重复序列，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。 如果时钟回拨的时间超过最大容忍的毫秒数阈值，则程序报错；如果在可容忍的范围内，默认分布式主键生成器会等待时钟同步到最后一次主键生成的时间后再继续工作。 最大容忍的时钟回拨毫秒数的默认值为 0，可通过属性设置。\n\n# 4.1.3. 灵活定制\n\n上面只是一个将 64bit 划分的标准，当然也不一定这么做，可以根据不同业务的具体场景来划分，比如下面给出一个业务场景：\n\n * 服务目前 qps10 万，预计几年之内会发展到百万。\n * 当前机器三地部署，上海，北京，深圳都有。\n * 当前机器 10 台左右，预计未来会增加至百台。\n\n这个时候我们根据上面的场景可以再次合理的划分 62bit，qps 几年之内会发展到百万，那么每毫秒就是千级的请求，目前 10 台机器那么每台机器承担百级的请求，为了保证扩展，后面的循环位可以限制到 1024，也就是 2^10，那么循环位 10 位就足够了。\n\n机器三地部署我们可以用 3bit 总共 8 来表示机房位置，当前的机器 10 台，为了保证扩展到百台那么可以用 7bit 128 来表示，时间位依然是 41bit，那么还剩下 64-10-3-7-41-1 = 2bit，还剩下 2bit 可以用来进行扩展。\n\n\n\n\n# 4.2. 优点\n\n * 生成的 id 都是趋势递增的。\n * 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成 id 的性能也是非常高的。\n * 可以根据自身业务特性分配 bit 位，非常灵活。\n\n\n# 4.3. 缺点\n\n * 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。\n\n\n# 4.4. 适用场景\n\n当我们需要无序不能被猜测的 id，并且需要一定高性能，且需要 long 型，那么就可以使用我们雪花算法。比如常见的订单 id，用雪花算法别人就无法猜测你每天的订单量是多少。\n\n\n# 4.5. 防止时钟回拨\n\n雪花算法是强依赖于时间的，而如果机器时间发生回拨，有可能会生成重复的 id。\n\n我们可以针对算法做一些优化，来防止时钟回拨生成重复 id。\n\n用当前时间和上一次的时间进行判断，如果当前时间小于上一次的时间那么肯定是发生了回拨。普通的算法会直接抛出异常，这里我们可以对其进行优化，一般分为两个情况:\n\n * 如果时间回拨时间较短，比如配置 5ms 以内，那么可以直接等待一定的时间，让机器的时间追上来。\n * 如果时间的回拨时间较长，我们不能接受这么长的阻塞等待，那么又有两个策略:\n   * 直接拒绝，抛出异常。打日志，通知 rd 时钟回滚。\n   * 利用扩展位。上面我们讨论过，不同业务场景位数可能用不到那么多比特位，那么我们可以把扩展位数利用起来。比如：当这个时间回拨比较长的时候，我们可以不需要等待，直接在扩展位加 1。两位的扩展位允许我们有三次大的时钟回拨，一般来说就够了，如果其超过三次我们还是选择抛出异常，打日志。\n\n\n# 5. leaf\n\n> 美团提供了一种分布式 id 解决方案 leaf，其本质可以视为数据库分段+服务缓存 id。\n> \n> 详情可以参考 leaf——美团点评分布式 id 生成系统\n\n\n# 5.1. 基本原理\n\n使用数据库生成 id，但是做了如下改进：\n\n原方案每次获取 id 都得读写一次数据库，造成数据库压力大。改为利用 proxy server 批量获取，每次获取一个 segment(step 决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。 - 各个业务不同的发号需求用 biz_tag 字段来区分，每个 biz-tag 的 id 获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对 biz_tag 分库分表就行。\n\n数据库表设计如下：\n\n+-------------+--------------+------+-----+-------------------+-----------------------------+\n| field       | type         | null | key | default           | extra                       |\n+-------------+--------------+------+-----+-------------------+-----------------------------+\n| biz_tag     | varchar(128) | no   | pri |                   |                             |\n| max_id      | bigint(20)   | no   |     | 1                 |                             |\n| step        | int(11)      | no   |     | null              |                             |\n| desc        | varchar(256) | yes  |     | null              |                             |\n| update_time | timestamp    | no   |     | current_timestamp | on update current_timestamp |\n+-------------+--------------+------+-----+-------------------+-----------------------------+\n\n\n重要字段说明：\n\n * biz_tag 用来区分业务\n * max_id 表示该 biz_tag 目前所被分配的 id 号段的最大值\n * step 表示每次分配的号段长度。原来获取 id 每次都需要写数据库，现在只需要把 step 设置得足够大，比如 1000。那么只有当 1000 个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从 1 减小到了 1/step。\n\n大致架构如下图所示：\n\n\n\ntest_tag 在第一台 leaf 机器上是 1~1000 的号段，当这个号段用完时，会去加载另一个长度为 step=1000 的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是 3001~4000。同时数据库对应的 biz_tag 这条数据的 max_id 会从 3000 被更新成 4000，更新号段的 sql 语句如下：\n\nbegin\nupdate table set max_id=max_id+step where biz_tag=xxx\nselect tag, max_id, step from table where biz_tag=xxx\ncommit\n\n\n\n# 5.2. 优点\n\n * 比数据库自增键性能高\n * 能保证键趋势递增。\n * 如果数据库宕机，由于 proxserver 有缓存，依然可以坚持一段时间。\n\n\n# 5.3. 缺点\n\n * 和主键递增一样，容易被人猜测。\n * 数据库宕机后，虽然能支撑一段时间，但是仍然会造成系统不可用。\n\n\n# 5.4. 适用场景\n\n需要趋势递增，并且 id 大小可控制的，可以使用这套方案。\n\n当然这个方案也可以通过一些手段避免被人猜测，把 id 变成是无序的，比如把我们生成的数据是一个递增的 long 型，把这个 long 分成几个部分，比如可以分成几组三位数，几组四位数，然后在建立一个映射表，将我们的数据变成无序。\n\n\n# 6. 参考资料\n\n * 百度分布式 id\n * 如果再有人问你分布式 id，这篇文章丢给他\n * 理解分布式 id 生成算法 snowflake\n * leaf——美团点评分布式 id 生成系统\n * uuid 规范\n * shardingsphere 分布式主键",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"分布式事务基本原理",frontmatter:{title:"分布式事务基本原理",categories:["分布式","分布式关键技术","数据调度"],tags:["分布式","数据调度","事务"],abbrlink:"83690cf5",date:"2019-06-21T11:30:00.000Z",permalink:"/pages/910bad/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/02.%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%A6/05.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html",relativePath:"02.分布式/03.分布式关键技术/02.数据调度/05.分布式事务.md",key:"v-0349074a",path:"/pages/910bad/",headers:[{level:2,title:"1. 分布式事务简介",slug:"_1-分布式事务简介",normalizedTitle:"1. 分布式事务简介",charIndex:57},{level:3,title:"1.1. 本地事务",slug:"_1-1-本地事务",normalizedTitle:"1.1. 本地事务",charIndex:72},{level:3,title:"1.2. 分布式事务",slug:"_1-2-分布式事务",normalizedTitle:"1.2. 分布式事务",charIndex:311},{level:3,title:"1.3. 分布式事务的难点",slug:"_1-3-分布式事务的难点",normalizedTitle:"1.3. 分布式事务的难点",charIndex:780},{level:3,title:"1.4. CAP 和 BASE",slug:"_1-4-cap-和-base",normalizedTitle:"1.4. cap 和 base",charIndex:1091},{level:3,title:"1.5. 柔性事务",slug:"_1-5-柔性事务",normalizedTitle:"1.5. 柔性事务",charIndex:1427},{level:4,title:"1.5.1. 柔性事务的概念",slug:"_1-5-1-柔性事务的概念",normalizedTitle:"1.5.1. 柔性事务的概念",charIndex:1440},{level:4,title:"1.5.2. 柔性事务的特性",slug:"_1-5-2-柔性事务的特性",normalizedTitle:"1.5.2. 柔性事务的特性",charIndex:1716},{level:2,title:"2. 两阶段提交（2PC）",slug:"_2-两阶段提交-2pc",normalizedTitle:"2. 两阶段提交（2pc）",charIndex:2244},{level:3,title:"2.1. 方案简介",slug:"_2-1-方案简介",normalizedTitle:"2.1. 方案简介",charIndex:2262},{level:3,title:"2.2. 处理流程",slug:"_2-2-处理流程",normalizedTitle:"2.2. 处理流程",charIndex:2650},{level:4,title:"2.2.1. 阶段 1：准备阶段",slug:"_2-2-1-阶段-1-准备阶段",normalizedTitle:"2.2.1. 阶段 1：准备阶段",charIndex:2719},{level:4,title:"2.2.2. 阶段 2：提交阶段",slug:"_2-2-2-阶段-2-提交阶段",normalizedTitle:"2.2.2. 阶段 2：提交阶段",charIndex:2884},{level:3,title:"2.3. 方案总结",slug:"_2-3-方案总结",normalizedTitle:"2.3. 方案总结",charIndex:3411},{level:2,title:"3. 三阶段提交（3PC）",slug:"_3-三阶段提交-3pc",normalizedTitle:"3. 三阶段提交（3pc）",charIndex:3641},{level:3,title:"3.1. 方案简介",slug:"_3-1-方案简介",normalizedTitle:"3.1. 方案简介",charIndex:3659},{level:3,title:"3.2. 处理流程",slug:"_3-2-处理流程",normalizedTitle:"3.2. 处理流程",charIndex:3885},{level:4,title:"3.2.1. 阶段 1：canCommit",slug:"_3-2-1-阶段-1-cancommit",normalizedTitle:"3.2.1. 阶段 1：cancommit",charIndex:3898},{level:4,title:"3.2.2. 阶段 2：preCommit",slug:"_3-2-2-阶段-2-precommit",normalizedTitle:"3.2.2. 阶段 2：precommit",charIndex:4110},{level:4,title:"3.2.3. 阶段 3：doCommit",slug:"_3-2-3-阶段-3-docommit",normalizedTitle:"3.2.3. 阶段 3：docommit",charIndex:4529},{level:3,title:"3.3. 方案总结",slug:"_3-3-方案总结",normalizedTitle:"3.3. 方案总结",charIndex:5092},{level:2,title:"4. 补偿事务（TCC）",slug:"_4-补偿事务-tcc",normalizedTitle:"4. 补偿事务（tcc）",charIndex:5302},{level:3,title:"4.1. 方案简介",slug:"_4-1-方案简介",normalizedTitle:"4.1. 方案简介",charIndex:5319},{level:3,title:"4.2. 处理流程",slug:"_4-2-处理流程",normalizedTitle:"4.2. 处理流程",charIndex:5665},{level:4,title:"4.2.1. Try 阶段",slug:"_4-2-1-try-阶段",normalizedTitle:"4.2.1. try 阶段",charIndex:5752},{level:4,title:"4.2.2. Confirm / Cancel 阶段",slug:"_4-2-2-confirm-cancel-阶段",normalizedTitle:"4.2.2. confirm / cancel 阶段",charIndex:6102},{level:3,title:"4.3. 方案总结",slug:"_4-3-方案总结",normalizedTitle:"4.3. 方案总结",charIndex:6539},{level:2,title:"5. 本地消息表",slug:"_5-本地消息表",normalizedTitle:"5. 本地消息表",charIndex:6845},{level:3,title:"5.1. 方案简介",slug:"_5-1-方案简介",normalizedTitle:"5.1. 方案简介",charIndex:6858},{level:3,title:"5.2. 处理流程",slug:"_5-2-处理流程",normalizedTitle:"5.2. 处理流程",charIndex:7083},{level:3,title:"5.3. 方案总结",slug:"_5-3-方案总结",normalizedTitle:"5.3. 方案总结",charIndex:7924},{level:2,title:"6. MQ 事务",slug:"_6-mq-事务",normalizedTitle:"6. mq 事务",charIndex:8127},{level:3,title:"6.1. 方案简介",slug:"_6-1-方案简介",normalizedTitle:"6.1. 方案简介",charIndex:8140},{level:3,title:"6.2. 处理流程",slug:"_6-2-处理流程",normalizedTitle:"6.2. 处理流程",charIndex:8216},{level:3,title:"6.3. 方案总结",slug:"_6-3-方案总结",normalizedTitle:"6.3. 方案总结",charIndex:8901},{level:2,title:"7. SAGA",slug:"_7-saga",normalizedTitle:"7. saga",charIndex:9066},{level:3,title:"7.1. 方案简介",slug:"_7-1-方案简介",normalizedTitle:"7.1. 方案简介",charIndex:9078},{level:3,title:"7.2. 处理流程",slug:"_7-2-处理流程",normalizedTitle:"7.2. 处理流程",charIndex:9253},{level:4,title:"7.2.1. 恢复策略",slug:"_7-2-1-恢复策略",normalizedTitle:"7.2.1. 恢复策略",charIndex:9661},{level:4,title:"7.2.2. 命令协调",slug:"_7-2-2-命令协调",normalizedTitle:"7.2.2. 命令协调",charIndex:10002},{level:4,title:"7.2.3. 事件编排",slug:"_7-2-3-事件编排",normalizedTitle:"7.2.3. 事件编排",charIndex:10454},{level:3,title:"7.3. 方案总结",slug:"_7-3-方案总结",normalizedTitle:"7.3. 方案总结",charIndex:10936},{level:2,title:"8. 总结",slug:"_8-总结",normalizedTitle:"8. 总结",charIndex:11420},{level:3,title:"8.1. 各方案使用场景",slug:"_8-1-各方案使用场景",normalizedTitle:"8.1. 各方案使用场景",charIndex:11430},{level:3,title:"8.2. 分布式事务方案设计",slug:"_8-2-分布式事务方案设计",normalizedTitle:"8.2. 分布式事务方案设计",charIndex:11910},{level:2,title:"9. 参考资料",slug:"_9-参考资料",normalizedTitle:"9. 参考资料",charIndex:12396}],headersStr:"1. 分布式事务简介 1.1. 本地事务 1.2. 分布式事务 1.3. 分布式事务的难点 1.4. CAP 和 BASE 1.5. 柔性事务 1.5.1. 柔性事务的概念 1.5.2. 柔性事务的特性 2. 两阶段提交（2PC） 2.1. 方案简介 2.2. 处理流程 2.2.1. 阶段 1：准备阶段 2.2.2. 阶段 2：提交阶段 2.3. 方案总结 3. 三阶段提交（3PC） 3.1. 方案简介 3.2. 处理流程 3.2.1. 阶段 1：canCommit 3.2.2. 阶段 2：preCommit 3.2.3. 阶段 3：doCommit 3.3. 方案总结 4. 补偿事务（TCC） 4.1. 方案简介 4.2. 处理流程 4.2.1. Try 阶段 4.2.2. Confirm / Cancel 阶段 4.3. 方案总结 5. 本地消息表 5.1. 方案简介 5.2. 处理流程 5.3. 方案总结 6. MQ 事务 6.1. 方案简介 6.2. 处理流程 6.3. 方案总结 7. SAGA 7.1. 方案简介 7.2. 处理流程 7.2.1. 恢复策略 7.2.2. 命令协调 7.2.3. 事件编排 7.3. 方案总结 8. 总结 8.1. 各方案使用场景 8.2. 分布式事务方案设计 9. 参考资料",content:'# 分布式事务基本原理\n\n> 分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。\n\n\n# 1. 分布式事务简介\n\n\n# 1.1. 本地事务\n\n学习分布式之前，先了解一下本地事务的概念。\n\n事务简单来说：一个会话中所进行所有的操作，要么同时成功，要么同时失败。\n\n\n\n具体来说，事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。\n\n * 原子性（Atomicity）\n * 一致性（Consistency）\n * 隔离性（Isolation）\n * 持久性（Durability）\n\n> 💡 更详细的内容可以参考：事务\n\n\n# 1.2. 分布式事务\n\n分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 ACID 特性。\n\n随着互联网快速发展，微服务，SOA 等服务架构模式正在被大规模的使用，现在分布式系统一般由多个独立的子系统组成，多个子系统通过网络通信互相协作配合完成各个功能。\n\n有很多用例会跨多个子系统才能完成，比较典型的是电子商务网站的下单支付流程，至少会涉及交易系统和支付系统，而且这个过程中会涉及到事务的概念，即保证交易系统和支付系统的数据一致性，此处我们称这种跨系统的事务为分布式事务，具体一点而言，分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。\n\n举个互联网常用的交易业务为例：\n\n\n\n上图中包含了库存和订单两个独立的微服务，每个微服务维护了自己的数据库。在交易系统的业务逻辑中，一个商品在下单之前需要先调用库存服务，进行扣除库存，再调用订单服务，创建订单记录。\n\n\n\n可以看到，如果多个数据库之间的数据更新没有保证事务，将会导致出现子系统数据不一致，业务出现问题。\n\n\n# 1.3. 分布式事务的难点\n\n * 事务的原子性 事务操作跨不同节点，当多个节点某一节点操作失败时，需要保证多节点操作的**都做或都不做（All or Nothing）**的原子性。\n * 事务的一致性 当发生网络传输故障或者节点故障，节点间数据复制通道中断，在进行事务操作时需要保证数据一致性，保证事务的任何操作都不会使得数据违反数据库定义的约束、触发器等规则。\n * 事务的隔离性 事务隔离性的本质就是如何正确多个并发事务的处理的读写冲突和写写冲突，因为在分布式事务控制中，可能会出现提交不同步的现象，这个时候就有可能出现“部分已经提交”的事务。此时并发应用访问数据如果没有加以控制，有可能出现“脏读”问题。\n\n\n# 1.4. CAP 和 BASE\n\nCAP 定理又称为 CAP 原则，指的是：在一个分布式系统中， 一致性（C：Consistency）、可用性（A：Availability） 和 分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。\n\nBASE 是 基本可用（Basically Available）、软状态（Soft State） 和 最终一致性（Eventually Consistent） 三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n> 💡 更详细的内容可以参考：分布式理论\n\n\n# 1.5. 柔性事务\n\n# 1.5.1. 柔性事务的概念\n\n在电商等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于 CAP 理论以及 BASE 理论，有人就提出了柔性事务的概念。\n\n基于 BASE 理论的设计思想，柔性事务下，在不影响系统整体可用性的情况下(Basically Available 基本可用)，允许系统存在数据不一致的中间状态(Soft State 软状态)，在经过数据同步的延时之后，最终数据能够达到一致。并不是完全放弃了 ACID，而是通过放宽一致性要求，借助本地事务来实现最终分布式事务一致性的同时也保证系统的吞吐。\n\n# 1.5.2. 柔性事务的特性\n\n下面介绍的是实现柔性事务的一些常见特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样。\n\n可见性(对外可查询) 在分布式事务执行过程中，如果某一个步骤执行出错，就需要明确的知道其他几个操作的处理情况，这就需要其他的服务都能够提供查询接口，保证可以通过查询来判断操作的处理情况。\n\n为了保证操作的可查询，需要对于每一个服务的每一次调用都有一个全局唯一的标识，可以是业务单据号（如订单号）、也可以是系统分配的操作流水号（如支付记录流水号）。除此之外，操作的时间信息也要有完整的记录。\n\n操作幂等性 幂等性，其实是一个数学概念。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。也就是说，同一个方法，使用同样的参数，调用多次产生的业务结果与调用一次产生的业务结果相同。\n\n之所以需要操作幂等性，是因为为了保证数据的最终一致性，很多事务协议都会有很多重试的操作，如果一个方法不保证幂等，那么将无法被重试。幂等操作的实现方式有多种，如在系统中缓存所有的请求与处理结果、检测到重复操作后，直接返回上一次的处理结果等。\n\n\n# 2. 两阶段提交（2PC）\n\n\n# 2.1. 方案简介\n\n二阶段提交协议（Two-phase Commit，即 2PC）是常用的分布式事务解决方案，即将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段。事务的发起者称协调者，事务的执行者称参与者。\n\n在分布式系统里，每个节点都可以知晓自己操作的成功或者失败，却无法知道其他节点操作的成功或失败。当一个事务跨多个节点时，为了保持事务的原子性与一致性，而引入一个协调者来统一掌控所有参与者的操作结果，并指示它们是否要把操作结果进行真正的提交或者回滚（rollback）。\n\n二阶段提交的思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。\n\n核心思想就是对每一个事务都采用先尝试后提交的处理方式，处理后所有的读操作都要能获得最新的数据，因此也可以将二阶段提交看作是一个强一致性算法。\n\n\n# 2.2. 处理流程\n\n简单一点理解，可以把协调者节点比喻为带头大哥，参与者理解比喻为跟班小弟，带头大哥统一协调跟班小弟的任务执行。\n\n# 2.2.1. 阶段 1：准备阶段\n\n 1. 协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。\n 2. 各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。\n 3. 如参与者执行成功，给协调者反馈 yes，即可以提交；如执行失败，给协调者反馈 no，即不可提交。\n\n# 2.2.2. 阶段 2：提交阶段\n\n如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息；否则，发送提交(commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源) 接下来分两种情况分别讨论提交阶段的过程。\n\n情况 1，当所有参与者均反馈 yes，提交事务。\n\n\n\n>  1. 协调者向所有参与者发出正式提交事务的请求（即 commit 请求）。\n>  2. 参与者执行 commit 请求，并释放整个事务期间占用的资源。\n>  3. 各参与者向协调者反馈 ack(应答)完成的消息。\n>  4. 协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。\n\n情况 2，当任何阶段 1 一个参与者反馈 no，中断事务。\n\n\n\n>  1. 协调者向所有参与者发出回滚请求（即 rollback 请求）。\n>  2. 参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。\n>  3. 各参与者向协调者反馈 ack 完成的消息。\n>  4. 协调者收到所有参与者反馈的 ack 消息后，即完成事务中断。\n\n\n# 2.3. 方案总结\n\n2PC 方案实现起来简单，实际项目中使用比较少，主要因为以下问题：\n\n * 性能问题 - 所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。\n * 可靠性问题 - 如果协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。\n * 数据一致性问题 - 在阶段 2 中，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。\n\n\n# 3. 三阶段提交（3PC）\n\n\n# 3.1. 方案简介\n\n三阶段提交协议（Three-phase Commit，3PC），是二阶段提交协议的改进版本，与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。\n\n三阶段提交将二阶段的准备阶段拆分为 2 个阶段，插入了一个 preCommit 阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。\n\n\n# 3.2. 处理流程\n\n# 3.2.1. 阶段 1：canCommit\n\n协调者向参与者发送 commit 请求，参与者如果可以提交就返回 yes 响应(参与者不执行事务操作)，否则返回 no 响应：\n\n 1. 协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。\n 2. 参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。\n\n# 3.2.2. 阶段 2：preCommit\n\n协调者根据阶段 1 canCommit 参与者的反应情况来决定是否可以基于事务的 preCommit 操作。根据响应情况，有以下两种可能。\n\n情况 1：阶段 1 所有参与者均反馈 yes，参与者预执行事务。\n\n\n\n>  1. 协调者向所有参与者发出 preCommit 请求，进入准备阶段。\n>  2. 参与者收到 preCommit 请求后，执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。\n>  3. 各参与者向协调者反馈 ack 响应或 no 响应，并等待最终指令。\n\n情况 2：阶段 1 任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务。\n\n\n\n>  1. 协调者向所有参与者发出 abort 请求。\n>  2. 无论收到协调者发出的 abort 请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。\n\n# 3.2.3. 阶段 3：doCommit\n\n该阶段进行真正的事务提交，也可以分为以下两种情况：\n\n情况 1：阶段 2 所有参与者均反馈 ack 响应，执行真正的事务提交。\n\n\n\n>  1. 如果协调者处于工作状态，则向所有参与者发出 do Commit 请求。\n>  2. 参与者收到 do Commit 请求后，会正式执行事务提交，并释放整个事务期间占用的资源。\n>  3. 各参与者向协调者反馈 ack 完成的消息。\n>  4. 协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。\n\n情况 2：任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务。\n\n\n\n>  1. 如果协调者处于工作状态，向所有参与者发出 abort 请求。\n>  2. 参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。\n>  3. 各参与者向协调者反馈 ack 完成的消息。\n>  4. 协调者收到所有参与者反馈的 ack 消息后，即完成事务中断。\n\n注意：进入阶段 3 后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的 do Commit 请求或 abort 请求。此时，参与者都会在等待超时之后，继续执行事务提交。\n\n\n# 3.3. 方案总结\n\n优点：\n\n * 相比二阶段提交，三阶段降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段 3 中协调者出现问题时，参与者会继续提交事务。\n\n缺点：\n\n * 数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 do commite 指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。\n\n\n# 4. 补偿事务（TCC）\n\n\n# 4.1. 方案简介\n\nTCC（Try-Confirm-Cancel）的概念，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。\n\nTCC 是服务化的二阶段编程模型，其 Try、Confirm、Cancel 3 个方法均由业务编码实现；\n\n * Try - 操作作为一阶段，负责资源的检查和预留。\n * Confirm - 操作作为二阶段提交操作，执行真正的业务。\n * Cancel - 是预留资源的取消。\n\nTCC 事务的 Try、Confirm、Cancel 可以理解为 SQL 事务中的 Lock、Commit、Rollback。\n\n\n# 4.2. 处理流程\n\n为了方便理解，下面以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上。\n\n# 4.2.1. Try 阶段\n\n从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，却不一样。TCC 机制中的 Try 仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：\n\n * 完成所有业务检查( 一致性 )\n * 预留必须业务资源( 准隔离性 )\n * Try 尝试执行业务 TCC 事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try 阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其执行结果撤销。\n\n假设商品库存为 100，购买数量为 2，这里检查和更新库存的同时，冻结用户购买数量的库存，同时创建订单，订单状态为待确认。\n\n# 4.2.2. Confirm / Cancel 阶段\n\n根据 Try 阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。 Confirm 和 Cancel 操作满足幂等性，如果 Confirm 或 Cancel 操作执行失败，将会不断重试直到执行完成。\n\nConfirm：当 Try 阶段服务全部正常执行， 执行确认业务逻辑操作\n\n\n\n这里使用的资源一定是 Try 阶段预留的业务资源。在 TCC 事务机制中认为，如果在 Try 阶段能正常的预留资源，那 Confirm 一定能完整正确的提交。Confirm 阶段也可以看成是对 Try 阶段的一个补充，Try+Confirm 一起组成了一个完整的业务逻辑。\n\nCancel：当 Try 阶段存在服务执行失败， 进入 Cancel 阶段\n\n\n\nCancel 取消执行，释放 Try 阶段预留的业务资源，上面的例子中，Cancel 操作会把冻结的库存释放，并更新订单状态为取消。\n\n\n# 4.3. 方案总结\n\nTCC 事务机制相对于传统事务机制（X/Open XA），TCC 事务机制相比于上面介绍的 XA 事务机制，有以下优点:\n\n * 性能提升 - 具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。\n * 数据最终一致性 - 基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。\n * 可靠性 - 解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。\n\n缺点： TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。\n\n\n# 5. 本地消息表\n\n\n# 5.1. 方案简介\n\n本地消息表的方案最初是由 ebay 提出，核心思路是将分布式事务拆分成本地事务进行处理。\n\n方案通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。\n\n这样设计可以避免”业务处理成功 + 事务消息发送失败"，或"业务处理失败 + 事务消息发送成功"的棘手情况出现，保证 2 个系统事务的数据一致性。\n\n\n# 5.2. 处理流程\n\n下面把分布式事务最先开始处理的事务方成为事务主动方，在事务主动方之后处理的业务内的其他事务成为事务被动方。\n\n为了方便理解，下面继续以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上，其中库存服务是事务主动方，订单服务是事务被动方。\n\n事务的主动方需要额外新建事务消息表，用于记录分布式事务的消息的发生、处理状态。\n\n整个业务处理流程如下：\n\n\n\n>  1. 步骤 1 事务主动方处理本地事务。 事务主动发在本地事务中处理业务更新操作和写消息表操作。 上面例子中库存服务阶段再本地事务中完成扣减库存和写消息表(图中 1、2)。\n>  2. 步骤 2 事务主动方通过 MQ 通知事务被动方处理事务。 消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方法主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。 上面例子中，库存服务把事务待处理消息写到消息中间件，订单服务消费消息中间件的消息，完成新增订单（图中 3 - 5）。\n>  3. 步骤 3 事务被动方通过 MQ 反会处理结果。 上面例子中，订单服务把事务已处理消息写到消息中间件，库存服务消费中间件的消息，并将事务消息的状态更新为已完成(图中 6 - 8)\n\n为了数据的一致性，当处理错误需要重试，事务发送方和事务接收方相关业务处理需要支持幂等。具体保存一致性的容错处理如下：\n\n>  * 当步骤 1 处理出错，事务回滚，相当于什么都没发生。\n>  * 当步骤 2、步骤 3 处理出错，由于未处理的事务消息还是保存在事务发送方，事务发送方可以定时轮询为超时消息数据，再次发送的消息中间件进行处理。事务被动方消费事务消息重试处理。\n>  * 如果是业务上的失败，事务被动方可以发消息给事务主动方进行回滚。\n>  * 如果多个事务被动方已经消费消息，事务主动方需要回滚事务时需要通知事务被动方回滚。\n\n\n# 5.3. 方案总结\n\n方案的优点如下：\n\n * 从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。\n * 方案轻量，容易实现。\n\n缺点如下：\n\n * 与具体的业务场景绑定，耦合性强，不可复用。\n * 消息数据与业务数据同库，占用业务系统资源。\n * 业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。\n\n\n# 6. MQ 事务\n\n\n# 6.1. 方案简介\n\n基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。\n\n\n# 6.2. 处理流程\n\n下面主要基于 RocketMQ4.3 之后的版本介绍 MQ 的分布式事务方案。\n\n在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ 的事务消息相对于普通 MQ，相对于提供了 2PC 的提交接口，方案如下：\n\n正常情况——事务主动方发消息 这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：\n\n\n\n>  1. 发送方向 MQ 服务端(MQ Server)发送 half 消息。\n>  2. MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功。\n>  3. 发送方开始执行本地事务逻辑。\n>  4. 发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。\n>  5. MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。\n\n异常情况——事务主动方消息恢复 在断网或者应用重启等异常情况下，图中 4 提交的二次确认超时未到达 MQ Server，此时处理逻辑如下：\n\n\n\n>  5. MQ Server 对该消息发起消息回查。\n>  6. 发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。\n>  7. 发送方根据检查得到的本地事务的最终状态再次提交二次确认\n>  8. MQ Server 基于 commit / rollback 对消息进行投递或者删除\n\n\n# 6.3. 方案总结\n\n相比本地消息表方案，MQ 事务方案优点是：\n\n * 消息数据独立存储 ，降低业务系统与消息系统之间的耦合。\n * 吞吐量优于使用本地消息表方案。\n\n缺点是：\n\n * 一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息)\n * 业务处理服务需要实现消息状态回查接口\n\n\n# 7. SAGA\n\n\n# 7.1. 方案简介\n\nSaga 事务源于 1987 年普林斯顿大学的 Hecto 和 Kenneth 发表的如何处理 long lived transaction（长活事务）论文，Saga 事务核心思想是将长事务拆分为多个本地短事务，由 Saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。\n\n\n# 7.2. 处理流程\n\nSaga 事务基本协议如下：\n\n * 每个 Saga 事务由一系列幂等的有序子事务(sub-transaction) Ti 组成。\n * 每个 Ti 都有对应的幂等补偿动作 Ci，补偿动作用于撤销 Ti 造成的结果。\n\n可以看到，和 TCC 相比，Saga 没有“预留”动作，它的 Ti 就是直接提交到库。\n\n下面以下单流程为例，整个操作包括：创建订单、扣减库存、支付、增加积分 Saga 的执行顺序有两种：\n\n\n\n * 事务正常执行完成 T1, T2, T3, ..., Tn，例如：扣减库存(T1)，创建订单(T2)，支付(T3)，依次有序完成整个事务。\n * 事务回滚 T1, T2, ..., Tj, Cj,..., C2, C1，其中 0 < j < n，例如：扣减库存(T1)，创建订单(T2)，支付(T3，支付失败)，支付回滚(C3)，订单回滚(C2)，恢复库存(C1)。\n\n# 7.2.1. 恢复策略\n\nSaga 定义了两种恢复策略：\n\n * 向前恢复(forward recovery)\n\n\n\n对应于上面第一种执行顺序，适用于必须要成功的场景，发生失败进行重试，执行顺序是类似于这样的：T1, T2, ..., Tj(失败), Tj(重试),..., Tn，其中 j 是发生错误的子事务(sub-transaction)。该情况下不需要 Ci。\n\n * 向后恢复(backward recovery)\n\n\n\n对应于上面提到的第二种执行顺序，其中 j 是发生错误的子事务(sub-transaction)，这种做法的效果是撤销掉之前所有成功的子事务，使得整个 Saga 的执行结果撤销。\n\nSaga 事务常见的有两种不同的实现方式：命令协调和事件编排。\n\n# 7.2.2. 命令协调\n\n * 命令协调(Order Orchestrator)：中央协调器负责集中处理事件的决策和业务逻辑排序。\n\n中央协调器（Orchestrator，简称 OSO）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。\n\n\n\n以电商订单的例子为例：\n\n>  1. 事务发起方的主业务逻辑请求 OSO 服务开启订单事务。\n>  2. OSO 向库存服务请求扣减库存，库存服务回复处理结果。\n>  3. OSO 向订单服务请求创建订单，订单服务回复创建结果。\n>  4. OSO 向支付服务请求支付，支付服务回复处理结果。\n>  5. 主业务逻辑接收并处理 OSO 事务处理结果回复。\n\n中央协调器必须事先知道执行整个订单事务所需的流程(例如通过读取配置)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。\n\n# 7.2.3. 事件编排\n\n * 事件编排 (Event Choreography0：没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动。\n\n在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。\n\n当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 Saga 参与者听到都意味着事务结束。\n\n以电商订单的例子为例：\n\n\n\n>  1. 事务发起方的主业务逻辑发布开始订单事件\n>  2. 库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件\n>  3. 订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件\n>  4. 支付服务监听订单已创建事件，进行支付，并发布订单已支付事件\n>  5. 主业务逻辑监听订单已支付事件并处理。\n\n事件/编排是实现 Saga 模式的自然方式，它很简单，容易理解，不需要太多的代码来构建。如果事务涉及 2 至 4 个步骤，则可能是非常合适的。\n\n\n# 7.3. 方案总结\n\n命令协调设计的优点和缺点：\n\n优点如下：\n\n * 服务之间关系简单，避免服务之间的循环依赖关系，因为 Saga 协调器会调用 Saga 参与者，但参与者不会调用协调器\n * 程序开发简单，只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。\n * 易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试\n\n缺点如下：\n\n * 中央协调器容易处理逻辑容易过于复杂，导致难以维护。\n * 存在协调器单点故障风险。\n\n事件/编排设计的优点和缺点\n\n优点如下：\n\n * 避免中央协调器单点故障风险。\n * 当涉及的步骤较少服务开发简单，容易实现。\n\n缺点如下：\n\n * 服务之间存在循环依赖的风险。\n * 当涉及的步骤较多，服务间关系混乱，难以追踪调测。\n\n值得补充的是，由于 Saga 模型中没有 Prepare 阶段，因此事务间不能保证隔离性，当多个 Saga 事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。\n\n\n# 8. 总结\n\n\n# 8.1. 各方案使用场景\n\n介绍完分布式事务相关理论和常见解决方案后，最终的目的在实际项目中运用，因此，总结一下各个方案的常见的使用场景。\n\n\n\n * 2PC/3PC 依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。\n * TCC 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。\n * 本地消息表/MQ 事务 都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。\n * Saga 事务 由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。 Saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga 事务较适用于补偿动作容易处理的场景。\n\n\n# 8.2. 分布式事务方案设计\n\n本文介绍的偏向于原理，业界已经有不少开源的或者收费的解决方案，篇幅所限，就不再展开介绍。\n\n实际运用理论时进行架构设计时，许多人容易犯“手里有了锤子，看什么都觉得像钉子”的错误，设计方案时考虑的问题场景过多，各种重试，各种补偿机制引入系统，导致设计出来的系统过于复杂，落地遥遥无期。\n\n> 世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！—— 阿里中间件技术专家沈询\n\n有些问题，看起来很重要，但实际上我们可以通过合理的设计或者将问题分解来规避。设计分布式事务系统也不是需要考虑所有异常情况，不必过度设计各种回滚，补偿机制。如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。\n\n如果系统要实现回滚流程的话，有可能系统复杂度将大大提升，且很容易出现 Bug，估计出现 Bug 的概率会比需要事务回滚的概率大很多。在设计系统时，我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，可以考虑当出现这个概率很小的问题，能否采用人工解决的方式，这也是大家在解决疑难问题时需要多多思考的地方。\n\n\n# 9. 参考资料\n\n * 聊聊分布式事务，再说说解决方案\n * 理解分布式事务',normalizedContent:'# 分布式事务基本原理\n\n> 分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 acid 特性。\n\n\n# 1. 分布式事务简介\n\n\n# 1.1. 本地事务\n\n学习分布式之前，先了解一下本地事务的概念。\n\n事务简单来说：一个会话中所进行所有的操作，要么同时成功，要么同时失败。\n\n\n\n具体来说，事务指的是满足 acid 特性的一组操作，可以通过 commit 提交一个事务，也可以使用 rollback 进行回滚。\n\n * 原子性（atomicity）\n * 一致性（consistency）\n * 隔离性（isolation）\n * 持久性（durability）\n\n> 💡 更详细的内容可以参考：事务\n\n\n# 1.2. 分布式事务\n\n分布式事务指的是事务操作跨越多个节点，并且要求满足事务的 acid 特性。\n\n随着互联网快速发展，微服务，soa 等服务架构模式正在被大规模的使用，现在分布式系统一般由多个独立的子系统组成，多个子系统通过网络通信互相协作配合完成各个功能。\n\n有很多用例会跨多个子系统才能完成，比较典型的是电子商务网站的下单支付流程，至少会涉及交易系统和支付系统，而且这个过程中会涉及到事务的概念，即保证交易系统和支付系统的数据一致性，此处我们称这种跨系统的事务为分布式事务，具体一点而言，分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。\n\n举个互联网常用的交易业务为例：\n\n\n\n上图中包含了库存和订单两个独立的微服务，每个微服务维护了自己的数据库。在交易系统的业务逻辑中，一个商品在下单之前需要先调用库存服务，进行扣除库存，再调用订单服务，创建订单记录。\n\n\n\n可以看到，如果多个数据库之间的数据更新没有保证事务，将会导致出现子系统数据不一致，业务出现问题。\n\n\n# 1.3. 分布式事务的难点\n\n * 事务的原子性 事务操作跨不同节点，当多个节点某一节点操作失败时，需要保证多节点操作的**都做或都不做（all or nothing）**的原子性。\n * 事务的一致性 当发生网络传输故障或者节点故障，节点间数据复制通道中断，在进行事务操作时需要保证数据一致性，保证事务的任何操作都不会使得数据违反数据库定义的约束、触发器等规则。\n * 事务的隔离性 事务隔离性的本质就是如何正确多个并发事务的处理的读写冲突和写写冲突，因为在分布式事务控制中，可能会出现提交不同步的现象，这个时候就有可能出现“部分已经提交”的事务。此时并发应用访问数据如果没有加以控制，有可能出现“脏读”问题。\n\n\n# 1.4. cap 和 base\n\ncap 定理又称为 cap 原则，指的是：在一个分布式系统中， 一致性（c：consistency）、可用性（a：availability） 和 分区容忍性（p：partition tolerance），最多只能同时满足其中两项。\n\nbase 是 基本可用（basically available）、软状态（soft state） 和 最终一致性（eventually consistent） 三个短语的缩写。base 理论是对 cap 中一致性和可用性权衡的结果，它的理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n> 💡 更详细的内容可以参考：分布式理论\n\n\n# 1.5. 柔性事务\n\n# 1.5.1. 柔性事务的概念\n\n在电商等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于 cap 理论以及 base 理论，有人就提出了柔性事务的概念。\n\n基于 base 理论的设计思想，柔性事务下，在不影响系统整体可用性的情况下(basically available 基本可用)，允许系统存在数据不一致的中间状态(soft state 软状态)，在经过数据同步的延时之后，最终数据能够达到一致。并不是完全放弃了 acid，而是通过放宽一致性要求，借助本地事务来实现最终分布式事务一致性的同时也保证系统的吞吐。\n\n# 1.5.2. 柔性事务的特性\n\n下面介绍的是实现柔性事务的一些常见特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样。\n\n可见性(对外可查询) 在分布式事务执行过程中，如果某一个步骤执行出错，就需要明确的知道其他几个操作的处理情况，这就需要其他的服务都能够提供查询接口，保证可以通过查询来判断操作的处理情况。\n\n为了保证操作的可查询，需要对于每一个服务的每一次调用都有一个全局唯一的标识，可以是业务单据号（如订单号）、也可以是系统分配的操作流水号（如支付记录流水号）。除此之外，操作的时间信息也要有完整的记录。\n\n操作幂等性 幂等性，其实是一个数学概念。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。也就是说，同一个方法，使用同样的参数，调用多次产生的业务结果与调用一次产生的业务结果相同。\n\n之所以需要操作幂等性，是因为为了保证数据的最终一致性，很多事务协议都会有很多重试的操作，如果一个方法不保证幂等，那么将无法被重试。幂等操作的实现方式有多种，如在系统中缓存所有的请求与处理结果、检测到重复操作后，直接返回上一次的处理结果等。\n\n\n# 2. 两阶段提交（2pc）\n\n\n# 2.1. 方案简介\n\n二阶段提交协议（two-phase commit，即 2pc）是常用的分布式事务解决方案，即将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段。事务的发起者称协调者，事务的执行者称参与者。\n\n在分布式系统里，每个节点都可以知晓自己操作的成功或者失败，却无法知道其他节点操作的成功或失败。当一个事务跨多个节点时，为了保持事务的原子性与一致性，而引入一个协调者来统一掌控所有参与者的操作结果，并指示它们是否要把操作结果进行真正的提交或者回滚（rollback）。\n\n二阶段提交的思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。\n\n核心思想就是对每一个事务都采用先尝试后提交的处理方式，处理后所有的读操作都要能获得最新的数据，因此也可以将二阶段提交看作是一个强一致性算法。\n\n\n# 2.2. 处理流程\n\n简单一点理解，可以把协调者节点比喻为带头大哥，参与者理解比喻为跟班小弟，带头大哥统一协调跟班小弟的任务执行。\n\n# 2.2.1. 阶段 1：准备阶段\n\n 1. 协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。\n 2. 各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。\n 3. 如参与者执行成功，给协调者反馈 yes，即可以提交；如执行失败，给协调者反馈 no，即不可提交。\n\n# 2.2.2. 阶段 2：提交阶段\n\n如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息；否则，发送提交(commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源) 接下来分两种情况分别讨论提交阶段的过程。\n\n情况 1，当所有参与者均反馈 yes，提交事务。\n\n\n\n>  1. 协调者向所有参与者发出正式提交事务的请求（即 commit 请求）。\n>  2. 参与者执行 commit 请求，并释放整个事务期间占用的资源。\n>  3. 各参与者向协调者反馈 ack(应答)完成的消息。\n>  4. 协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。\n\n情况 2，当任何阶段 1 一个参与者反馈 no，中断事务。\n\n\n\n>  1. 协调者向所有参与者发出回滚请求（即 rollback 请求）。\n>  2. 参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。\n>  3. 各参与者向协调者反馈 ack 完成的消息。\n>  4. 协调者收到所有参与者反馈的 ack 消息后，即完成事务中断。\n\n\n# 2.3. 方案总结\n\n2pc 方案实现起来简单，实际项目中使用比较少，主要因为以下问题：\n\n * 性能问题 - 所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。\n * 可靠性问题 - 如果协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。\n * 数据一致性问题 - 在阶段 2 中，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。\n\n\n# 3. 三阶段提交（3pc）\n\n\n# 3.1. 方案简介\n\n三阶段提交协议（three-phase commit，3pc），是二阶段提交协议的改进版本，与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。\n\n三阶段提交将二阶段的准备阶段拆分为 2 个阶段，插入了一个 precommit 阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。\n\n\n# 3.2. 处理流程\n\n# 3.2.1. 阶段 1：cancommit\n\n协调者向参与者发送 commit 请求，参与者如果可以提交就返回 yes 响应(参与者不执行事务操作)，否则返回 no 响应：\n\n 1. 协调者向所有参与者发出包含事务内容的 cancommit 请求，询问是否可以提交事务，并等待所有参与者答复。\n 2. 参与者收到 cancommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。\n\n# 3.2.2. 阶段 2：precommit\n\n协调者根据阶段 1 cancommit 参与者的反应情况来决定是否可以基于事务的 precommit 操作。根据响应情况，有以下两种可能。\n\n情况 1：阶段 1 所有参与者均反馈 yes，参与者预执行事务。\n\n\n\n>  1. 协调者向所有参与者发出 precommit 请求，进入准备阶段。\n>  2. 参与者收到 precommit 请求后，执行事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）。\n>  3. 各参与者向协调者反馈 ack 响应或 no 响应，并等待最终指令。\n\n情况 2：阶段 1 任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务。\n\n\n\n>  1. 协调者向所有参与者发出 abort 请求。\n>  2. 无论收到协调者发出的 abort 请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。\n\n# 3.2.3. 阶段 3：docommit\n\n该阶段进行真正的事务提交，也可以分为以下两种情况：\n\n情况 1：阶段 2 所有参与者均反馈 ack 响应，执行真正的事务提交。\n\n\n\n>  1. 如果协调者处于工作状态，则向所有参与者发出 do commit 请求。\n>  2. 参与者收到 do commit 请求后，会正式执行事务提交，并释放整个事务期间占用的资源。\n>  3. 各参与者向协调者反馈 ack 完成的消息。\n>  4. 协调者收到所有参与者反馈的 ack 消息后，即完成事务提交。\n\n情况 2：任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务。\n\n\n\n>  1. 如果协调者处于工作状态，向所有参与者发出 abort 请求。\n>  2. 参与者使用阶段 1 中的 undo 信息执行回滚操作，并释放整个事务期间占用的资源。\n>  3. 各参与者向协调者反馈 ack 完成的消息。\n>  4. 协调者收到所有参与者反馈的 ack 消息后，即完成事务中断。\n\n注意：进入阶段 3 后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的 do commit 请求或 abort 请求。此时，参与者都会在等待超时之后，继续执行事务提交。\n\n\n# 3.3. 方案总结\n\n优点：\n\n * 相比二阶段提交，三阶段降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段 3 中协调者出现问题时，参与者会继续提交事务。\n\n缺点：\n\n * 数据不一致问题依然存在，当在参与者收到 precommit 请求后等待 do commite 指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。\n\n\n# 4. 补偿事务（tcc）\n\n\n# 4.1. 方案简介\n\ntcc（try-confirm-cancel）的概念，最早是由 pat helland 于 2007 年发表的一篇名为《life beyond distributed transactions:an apostate’s opinion》的论文提出。\n\ntcc 是服务化的二阶段编程模型，其 try、confirm、cancel 3 个方法均由业务编码实现；\n\n * try - 操作作为一阶段，负责资源的检查和预留。\n * confirm - 操作作为二阶段提交操作，执行真正的业务。\n * cancel - 是预留资源的取消。\n\ntcc 事务的 try、confirm、cancel 可以理解为 sql 事务中的 lock、commit、rollback。\n\n\n# 4.2. 处理流程\n\n为了方便理解，下面以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上。\n\n# 4.2.1. try 阶段\n\n从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，却不一样。tcc 机制中的 try 仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：\n\n * 完成所有业务检查( 一致性 )\n * 预留必须业务资源( 准隔离性 )\n * try 尝试执行业务 tcc 事务机制以初步操作（try）为中心的，确认操作（confirm）和取消操作（cancel）都是围绕初步操作（try）而展开。因此，try 阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（cancel）可以将其执行结果撤销。\n\n假设商品库存为 100，购买数量为 2，这里检查和更新库存的同时，冻结用户购买数量的库存，同时创建订单，订单状态为待确认。\n\n# 4.2.2. confirm / cancel 阶段\n\n根据 try 阶段服务是否全部正常执行，继续执行确认操作（confirm）或取消操作（cancel）。 confirm 和 cancel 操作满足幂等性，如果 confirm 或 cancel 操作执行失败，将会不断重试直到执行完成。\n\nconfirm：当 try 阶段服务全部正常执行， 执行确认业务逻辑操作\n\n\n\n这里使用的资源一定是 try 阶段预留的业务资源。在 tcc 事务机制中认为，如果在 try 阶段能正常的预留资源，那 confirm 一定能完整正确的提交。confirm 阶段也可以看成是对 try 阶段的一个补充，try+confirm 一起组成了一个完整的业务逻辑。\n\ncancel：当 try 阶段存在服务执行失败， 进入 cancel 阶段\n\n\n\ncancel 取消执行，释放 try 阶段预留的业务资源，上面的例子中，cancel 操作会把冻结的库存释放，并更新订单状态为取消。\n\n\n# 4.3. 方案总结\n\ntcc 事务机制相对于传统事务机制（x/open xa），tcc 事务机制相比于上面介绍的 xa 事务机制，有以下优点:\n\n * 性能提升 - 具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。\n * 数据最终一致性 - 基于 confirm 和 cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。\n * 可靠性 - 解决了 xa 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。\n\n缺点： tcc 的 try、confirm 和 cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。\n\n\n# 5. 本地消息表\n\n\n# 5.1. 方案简介\n\n本地消息表的方案最初是由 ebay 提出，核心思路是将分布式事务拆分成本地事务进行处理。\n\n方案通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。\n\n这样设计可以避免”业务处理成功 + 事务消息发送失败"，或"业务处理失败 + 事务消息发送成功"的棘手情况出现，保证 2 个系统事务的数据一致性。\n\n\n# 5.2. 处理流程\n\n下面把分布式事务最先开始处理的事务方成为事务主动方，在事务主动方之后处理的业务内的其他事务成为事务被动方。\n\n为了方便理解，下面继续以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上，其中库存服务是事务主动方，订单服务是事务被动方。\n\n事务的主动方需要额外新建事务消息表，用于记录分布式事务的消息的发生、处理状态。\n\n整个业务处理流程如下：\n\n\n\n>  1. 步骤 1 事务主动方处理本地事务。 事务主动发在本地事务中处理业务更新操作和写消息表操作。 上面例子中库存服务阶段再本地事务中完成扣减库存和写消息表(图中 1、2)。\n>  2. 步骤 2 事务主动方通过 mq 通知事务被动方处理事务。 消息中间件可以基于 kafka、rocketmq 消息队列，事务主动方法主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。 上面例子中，库存服务把事务待处理消息写到消息中间件，订单服务消费消息中间件的消息，完成新增订单（图中 3 - 5）。\n>  3. 步骤 3 事务被动方通过 mq 反会处理结果。 上面例子中，订单服务把事务已处理消息写到消息中间件，库存服务消费中间件的消息，并将事务消息的状态更新为已完成(图中 6 - 8)\n\n为了数据的一致性，当处理错误需要重试，事务发送方和事务接收方相关业务处理需要支持幂等。具体保存一致性的容错处理如下：\n\n>  * 当步骤 1 处理出错，事务回滚，相当于什么都没发生。\n>  * 当步骤 2、步骤 3 处理出错，由于未处理的事务消息还是保存在事务发送方，事务发送方可以定时轮询为超时消息数据，再次发送的消息中间件进行处理。事务被动方消费事务消息重试处理。\n>  * 如果是业务上的失败，事务被动方可以发消息给事务主动方进行回滚。\n>  * 如果多个事务被动方已经消费消息，事务主动方需要回滚事务时需要通知事务被动方回滚。\n\n\n# 5.3. 方案总结\n\n方案的优点如下：\n\n * 从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 mq 中间件特性的依赖。\n * 方案轻量，容易实现。\n\n缺点如下：\n\n * 与具体的业务场景绑定，耦合性强，不可复用。\n * 消息数据与业务数据同库，占用业务系统资源。\n * 业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。\n\n\n# 6. mq 事务\n\n\n# 6.1. 方案简介\n\n基于 mq 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 mq 内部，其他方面的协议基本与本地消息表一致。\n\n\n# 6.2. 处理流程\n\n下面主要基于 rocketmq4.3 之后的版本介绍 mq 的分布式事务方案。\n\n在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，rocketmq 的事务消息相对于普通 mq，相对于提供了 2pc 的提交接口，方案如下：\n\n正常情况——事务主动方发消息 这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：\n\n\n\n>  1. 发送方向 mq 服务端(mq server)发送 half 消息。\n>  2. mq server 将消息持久化成功之后，向发送方 ack 确认消息已经发送成功。\n>  3. 发送方开始执行本地事务逻辑。\n>  4. 发送方根据本地事务执行结果向 mq server 提交二次确认（commit 或是 rollback）。\n>  5. mq server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；mq server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。\n\n异常情况——事务主动方消息恢复 在断网或者应用重启等异常情况下，图中 4 提交的二次确认超时未到达 mq server，此时处理逻辑如下：\n\n\n\n>  5. mq server 对该消息发起消息回查。\n>  6. 发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。\n>  7. 发送方根据检查得到的本地事务的最终状态再次提交二次确认\n>  8. mq server 基于 commit / rollback 对消息进行投递或者删除\n\n\n# 6.3. 方案总结\n\n相比本地消息表方案，mq 事务方案优点是：\n\n * 消息数据独立存储 ，降低业务系统与消息系统之间的耦合。\n * 吞吐量优于使用本地消息表方案。\n\n缺点是：\n\n * 一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息)\n * 业务处理服务需要实现消息状态回查接口\n\n\n# 7. saga\n\n\n# 7.1. 方案简介\n\nsaga 事务源于 1987 年普林斯顿大学的 hecto 和 kenneth 发表的如何处理 long lived transaction（长活事务）论文，saga 事务核心思想是将长事务拆分为多个本地短事务，由 saga 事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。\n\n\n# 7.2. 处理流程\n\nsaga 事务基本协议如下：\n\n * 每个 saga 事务由一系列幂等的有序子事务(sub-transaction) ti 组成。\n * 每个 ti 都有对应的幂等补偿动作 ci，补偿动作用于撤销 ti 造成的结果。\n\n可以看到，和 tcc 相比，saga 没有“预留”动作，它的 ti 就是直接提交到库。\n\n下面以下单流程为例，整个操作包括：创建订单、扣减库存、支付、增加积分 saga 的执行顺序有两种：\n\n\n\n * 事务正常执行完成 t1, t2, t3, ..., tn，例如：扣减库存(t1)，创建订单(t2)，支付(t3)，依次有序完成整个事务。\n * 事务回滚 t1, t2, ..., tj, cj,..., c2, c1，其中 0 < j < n，例如：扣减库存(t1)，创建订单(t2)，支付(t3，支付失败)，支付回滚(c3)，订单回滚(c2)，恢复库存(c1)。\n\n# 7.2.1. 恢复策略\n\nsaga 定义了两种恢复策略：\n\n * 向前恢复(forward recovery)\n\n\n\n对应于上面第一种执行顺序，适用于必须要成功的场景，发生失败进行重试，执行顺序是类似于这样的：t1, t2, ..., tj(失败), tj(重试),..., tn，其中 j 是发生错误的子事务(sub-transaction)。该情况下不需要 ci。\n\n * 向后恢复(backward recovery)\n\n\n\n对应于上面提到的第二种执行顺序，其中 j 是发生错误的子事务(sub-transaction)，这种做法的效果是撤销掉之前所有成功的子事务，使得整个 saga 的执行结果撤销。\n\nsaga 事务常见的有两种不同的实现方式：命令协调和事件编排。\n\n# 7.2.2. 命令协调\n\n * 命令协调(order orchestrator)：中央协调器负责集中处理事件的决策和业务逻辑排序。\n\n中央协调器（orchestrator，简称 oso）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。\n\n\n\n以电商订单的例子为例：\n\n>  1. 事务发起方的主业务逻辑请求 oso 服务开启订单事务。\n>  2. oso 向库存服务请求扣减库存，库存服务回复处理结果。\n>  3. oso 向订单服务请求创建订单，订单服务回复创建结果。\n>  4. oso 向支付服务请求支付，支付服务回复处理结果。\n>  5. 主业务逻辑接收并处理 oso 事务处理结果回复。\n\n中央协调器必须事先知道执行整个订单事务所需的流程(例如通过读取配置)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。\n\n# 7.2.3. 事件编排\n\n * 事件编排 (event choreography0：没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动。\n\n在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。\n\n当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 saga 参与者听到都意味着事务结束。\n\n以电商订单的例子为例：\n\n\n\n>  1. 事务发起方的主业务逻辑发布开始订单事件\n>  2. 库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件\n>  3. 订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件\n>  4. 支付服务监听订单已创建事件，进行支付，并发布订单已支付事件\n>  5. 主业务逻辑监听订单已支付事件并处理。\n\n事件/编排是实现 saga 模式的自然方式，它很简单，容易理解，不需要太多的代码来构建。如果事务涉及 2 至 4 个步骤，则可能是非常合适的。\n\n\n# 7.3. 方案总结\n\n命令协调设计的优点和缺点：\n\n优点如下：\n\n * 服务之间关系简单，避免服务之间的循环依赖关系，因为 saga 协调器会调用 saga 参与者，但参与者不会调用协调器\n * 程序开发简单，只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。\n * 易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试\n\n缺点如下：\n\n * 中央协调器容易处理逻辑容易过于复杂，导致难以维护。\n * 存在协调器单点故障风险。\n\n事件/编排设计的优点和缺点\n\n优点如下：\n\n * 避免中央协调器单点故障风险。\n * 当涉及的步骤较少服务开发简单，容易实现。\n\n缺点如下：\n\n * 服务之间存在循环依赖的风险。\n * 当涉及的步骤较多，服务间关系混乱，难以追踪调测。\n\n值得补充的是，由于 saga 模型中没有 prepare 阶段，因此事务间不能保证隔离性，当多个 saga 事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。\n\n\n# 8. 总结\n\n\n# 8.1. 各方案使用场景\n\n介绍完分布式事务相关理论和常见解决方案后，最终的目的在实际项目中运用，因此，总结一下各个方案的常见的使用场景。\n\n\n\n * 2pc/3pc 依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。\n * tcc 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。\n * 本地消息表/mq 事务 都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。\n * saga 事务 由于 saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。 saga 相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。saga 事务较适用于补偿动作容易处理的场景。\n\n\n# 8.2. 分布式事务方案设计\n\n本文介绍的偏向于原理，业界已经有不少开源的或者收费的解决方案，篇幅所限，就不再展开介绍。\n\n实际运用理论时进行架构设计时，许多人容易犯“手里有了锤子，看什么都觉得像钉子”的错误，设计方案时考虑的问题场景过多，各种重试，各种补偿机制引入系统，导致设计出来的系统过于复杂，落地遥遥无期。\n\n> 世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！—— 阿里中间件技术专家沈询\n\n有些问题，看起来很重要，但实际上我们可以通过合理的设计或者将问题分解来规避。设计分布式事务系统也不是需要考虑所有异常情况，不必过度设计各种回滚，补偿机制。如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。\n\n如果系统要实现回滚流程的话，有可能系统复杂度将大大提升，且很容易出现 bug，估计出现 bug 的概率会比需要事务回滚的概率大很多。在设计系统时，我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，可以考虑当出现这个概率很小的问题，能否采用人工解决的方式，这也是大家在解决疑难问题时需要多多思考的地方。\n\n\n# 9. 参考资料\n\n * 聊聊分布式事务，再说说解决方案\n * 理解分布式事务',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"分布式锁基本原理",frontmatter:{title:"分布式锁基本原理",categories:["分布式","分布式关键技术","数据调度"],tags:["分布式","数据调度","锁"],abbrlink:"55b1b1a1",date:"2019-06-04T23:42:00.000Z",permalink:"/pages/69360c/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/02.%E6%95%B0%E6%8D%AE%E8%B0%83%E5%BA%A6/06.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html",relativePath:"02.分布式/03.分布式关键技术/02.数据调度/06.分布式锁.md",key:"v-65b0509c",path:"/pages/69360c/",headers:[{level:2,title:"1. 分布式锁思路",slug:"_1-分布式锁思路",normalizedTitle:"1. 分布式锁思路",charIndex:264},{level:2,title:"2. 数据库分布式锁",slug:"_2-数据库分布式锁",normalizedTitle:"2. 数据库分布式锁",charIndex:951},{level:3,title:"2.1. 数据库分布式锁原理",slug:"_2-1-数据库分布式锁原理",normalizedTitle:"2.1. 数据库分布式锁原理",charIndex:966},{level:3,title:"2.2. 数据库分布式锁问题",slug:"_2-2-数据库分布式锁问题",normalizedTitle:"2.2. 数据库分布式锁问题",charIndex:1752},{level:3,title:"2.3. 数据库分布式锁小结",slug:"_2-3-数据库分布式锁小结",normalizedTitle:"2.3. 数据库分布式锁小结",charIndex:2201},{level:2,title:"3. Redis 分布式锁",slug:"_3-redis-分布式锁",normalizedTitle:"3. redis 分布式锁",charIndex:2305},{level:3,title:"3.1. Redis 分布式锁原理",slug:"_3-1-redis-分布式锁原理",normalizedTitle:"3.1. redis 分布式锁原理",charIndex:2410},{level:3,title:"3.2. Redis 分布式锁实现",slug:"_3-2-redis-分布式锁实现",normalizedTitle:"3.2. redis 分布式锁实现",charIndex:2842},{level:3,title:"3.3. 数据库分布式锁小结",slug:"_3-3-数据库分布式锁小结",normalizedTitle:"3.3. 数据库分布式锁小结",charIndex:3266},{level:3,title:"3.4. RedLock 算法",slug:"_3-4-redlock-算法",normalizedTitle:"3.4. redlock 算法",charIndex:3561},{level:2,title:"4. ZooKeeper 分布式锁",slug:"_4-zookeeper-分布式锁",normalizedTitle:"4. zookeeper 分布式锁",charIndex:3943},{level:3,title:"4.1. ZooKeeper 分布式锁原理",slug:"_4-1-zookeeper-分布式锁原理",normalizedTitle:"4.1. zookeeper 分布式锁原理",charIndex:3965},{level:3,title:"4.2. ZooKeeper 分布式锁实现",slug:"_4-2-zookeeper-分布式锁实现",normalizedTitle:"4.2. zookeeper 分布式锁实现",charIndex:4514},{level:3,title:"4.3. ZooKeeper 分布式锁小结",slug:"_4-3-zookeeper-分布式锁小结",normalizedTitle:"4.3. zookeeper 分布式锁小结",charIndex:11820},{level:2,title:"5. 分布式锁方案对比",slug:"_5-分布式锁方案对比",normalizedTitle:"5. 分布式锁方案对比",charIndex:12321},{level:2,title:"6. 参考资料",slug:"_6-参考资料",normalizedTitle:"6. 参考资料",charIndex:12613}],headersStr:"1. 分布式锁思路 2. 数据库分布式锁 2.1. 数据库分布式锁原理 2.2. 数据库分布式锁问题 2.3. 数据库分布式锁小结 3. Redis 分布式锁 3.1. Redis 分布式锁原理 3.2. Redis 分布式锁实现 3.3. 数据库分布式锁小结 3.4. RedLock 算法 4. ZooKeeper 分布式锁 4.1. ZooKeeper 分布式锁原理 4.2. ZooKeeper 分布式锁实现 4.3. ZooKeeper 分布式锁小结 5. 分布式锁方案对比 6. 参考资料",content:'# 分布式锁基本原理\n\n> 在并发场景下，为了保证并发安全，我们常常要通过互斥（加锁）手段来保证数据同步安全。\n> \n> JDK 虽然提供了大量锁工具，但是只能作用于单一 Java 进程，无法应用于分布式系统。为了解决这个问题，需要使用分布式锁。\n> \n> 分布式锁的解决方案大致有以下几种：\n> \n>  * 基于数据库实现\n>  * 基于缓存（redis，memcached 等）实现\n>  * 基于 Zookeeper 实现 ✅\n> \n> 注：推荐基于 ZooKeeper 实现分布式锁，具体原因看完本文即可明了。\n\n\n# 1. 分布式锁思路\n\n分布式锁的总体思路大同小异，仅在实现细节上有所不同。\n\n分布式锁的主要思路如下：\n\n * 互斥、可重入 - 创建锁必须是唯一的，表现形式为向数据存储服务器或容器插入一个唯一的 key，一旦有一个线程插入这个 key，其他线程就不能再插入了。\n   * 保证 key 唯一性的最简单的方式是使用 UUID。\n   * 存储锁的重入次数，以及分布式环境下唯一的线程标识。举例来说，可以使用 json 存储结构化数据，为了保证唯一，可以考虑将 mac 地址（IP 地址、机器 ID）、Jvm 进程 ID（应用 ID、服务 ID）、线程 ID 拼接起来作为唯一标识。\n     \n     {"count":1,"expireAt":147506817232,"jvmPid":22224,"mac":"28-D2-44-0E-0D-9A","threadId":14}\n     \n\n * 避免死锁 - 数据库分布式锁和缓存分布式锁（Redis）的思路都是引入超时机制，即成功申请锁后，超过一定时间，锁失效（删除 key），原因在于它们无法感知申请锁的客户端节点状态。而 ZooKeeper 由于其 znode 以目录、文件形式组织，天然就存在物理空间隔离，只要 znode 存在，即表示客户端节点还在工作，所以不存在这种问题。\n * 容错 - 只要大部分 Redis 节点可用，客户端就能正常加锁。\n * 自旋重试 - 获取不到锁时，不要直接返回失败，而是支持一定的周期自旋重试，设置一个总的超时时间，当过了超时时间以后还没有获取到锁则返回失败。\n\n\n# 2. 数据库分布式锁\n\n\n# 2.1. 数据库分布式锁原理\n\n（1）创建表\n\nCREATE TABLE `methodLock` (\n  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT \'主键\',\n  `method_name` varchar(64) NOT NULL DEFAULT \'\' COMMENT \'锁定的方法名\',\n  `desc` varchar(1024) NOT NULL DEFAULT \'备注信息\',\n  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT \'保存数据时间，自动生成\',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uidx_method_name` (`method_name `) USING BTREE\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=\'锁定中的方法\';\n\n\n（2）获取锁\n\n想要锁住某个方法时，执行以下 SQL：\n\ninsert into methodLock(method_name,desc) values (‘method_name’,‘desc’)\n\n\n因为我们对 method_name 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。\n\n成功插入则获取锁。\n\n（3）释放锁\n\n当方法执行完毕之后，想要释放锁的话，需要执行以下 Sql:\n\ndelete from methodLock where method_name =\'method_name\'\n\n\n\n# 2.2. 数据库分布式锁问题\n\n * 这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。\n * 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。\n * 这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。\n * 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。\n\n解决办法：\n\n * 单点问题可以用多数据库实例，同时塞 N 个表，N/2+1 个成功就任务锁定成功\n * 写一个定时任务，隔一段时间清除一次过期的数据。\n * 写一个 while 循环，不断的重试插入，直到成功。\n * 在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。\n\n\n# 2.3. 数据库分布式锁小结\n\n * 优点: 直接借助数据库，容易理解。\n * 缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。\n\n\n# 3. Redis 分布式锁\n\n相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好。目前有很多成熟的分布式产品，包括 Redis、memcache、Tair 等。这里以 Redis 举例。\n\n\n# 3.1. Redis 分布式锁原理\n\n这个分布式锁有 3 个重要的考量点：\n\n 1. 互斥（只能有一个客户端获取锁）\n 2. 不能死锁\n 3. 容错（只要大部分 redis 节点创建了这把锁就可以）\n\n对应的 Redis 指令如下：\n\n * setnx - setnx key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。\n * expire - expire key timeout：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。\n * delete - delete key：删除 key\n\n> 注意：\n> \n> 不要将 setnx 和 expire 作为两个命令组合实现加锁，这样就无法保证原子性。如果客户端在 setnx 之后崩溃，那么将导致锁无法释放。正确的做法应是在 setnx 命令中指定 expire 时间。\n\n\n# 3.2. Redis 分布式锁实现\n\n（1）申请锁\n\nSET resource_name my_random_value NX PX 30000\n\n\n执行这个命令就 ok。\n\n * NX：表示只有 key 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 nil）\n * PX 30000：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。\n\n（2）释放锁\n\n释放锁就是删除 key ，但是一般可以用 lua 脚本删除，判断 value 一样才删除：\n\n-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。\nif redis.call("get",KEYS[1]) == ARGV[1] then\n    return redis.call("del",KEYS[1])\nelse\n    return 0\nend\n\n\n\n# 3.3. 数据库分布式锁小结\n\n为啥要用 random_value 随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，比如说超过了 30s，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除 key 的话会有问题，所以得用随机值加上面的 lua 脚本来释放锁。\n\n但是这样是肯定不行的。因为如果是普通的 redis 单实例，那就是单点故障。或者是 redis 普通主从，那 redis 主从异步复制，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。\n\n\n# 3.4. RedLock 算法\n\n这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：\n\n 1. 获取当前时间戳，单位是毫秒；\n 2. 跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；\n 3. 尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点 n / 2 + 1；\n 4. 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；\n 5. 要是锁建立失败了，那么就依次之前建立过的锁删除；\n 6. 只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。\n\nRedis 官方给出了以上两种基于 Redis 实现分布式锁的方法，详细说明可以查看：https://redis.io/topics/distlock 。\n\n\n# 4. ZooKeeper 分布式锁\n\n\n# 4.1. ZooKeeper 分布式锁原理\n\nZooKeeper 实现分布式锁基于 ZooKeeper 的两个特性：\n\n * 顺序临时节点：ZooKeeper 的存储类似于 DNS 那样的具有层级的命名空间。ZooKeeper 节点类型可以分为持久节点（PERSISTENT ）、临时节点（EPHEMERAL），每个节点还能被标记为有序性（SEQUENTIAL），一旦节点被标记为有序性，那么整个节点就具有顺序自增的特点。\n * Watch 机制：ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在特定事件触发的时候，ZooKeeper 服务端会将事件通知给用户。\n\n这也是 ZooKeeper 客户端 curator 的分布式锁实现。\n\n 1. 创建一个目录 mylock；\n 2. 线程 A 想获取锁就在 mylock 目录下创建临时顺序节点；\n 3. 获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；\n 4. 线程 B 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；\n 5. 线程 A 处理完，删除自己的节点，线程 B 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。\n\n\n# 4.2. ZooKeeper 分布式锁实现\n\n/**\n * ZooKeeperSession\n *\n * @author bingo\n * @since 2018/11/29\n *\n */\npublic class ZooKeeperSession {\n\n    private static CountDownLatch connectedSemaphore = new CountDownLatch(1);\n\n    private ZooKeeper zookeeper;\n    private CountDownLatch latch;\n\n    public ZooKeeperSession() {\n        try {\n            this.zookeeper = new ZooKeeper("192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181", 50000, new ZooKeeperWatcher());\n            try {\n                connectedSemaphore.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n\n            System.out.println("ZooKeeper session established......");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 获取分布式锁\n     *\n     * @param productId\n     */\n    public Boolean acquireDistributedLock(Long productId) {\n        String path = "/product-lock-" + productId;\n\n        try {\n            zookeeper.create(path, "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n            return true;\n        } catch (Exception e) {\n            while (true) {\n                try {\n                    // 相当于是给node注册一个监听器，去看看这个监听器是否存在\n                    Stat stat = zk.exists(path, true);\n\n                    if (stat != null) {\n                        this.latch = new CountDownLatch(1);\n                        this.latch.await(waitTime, TimeUnit.MILLISECONDS);\n                        this.latch = null;\n                    }\n                    zookeeper.create(path, "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);\n                    return true;\n                } catch (Exception ee) {\n                    continue;\n                }\n            }\n\n        }\n        return true;\n    }\n\n    /**\n     * 释放掉一个分布式锁\n     *\n     * @param productId\n     */\n    public void releaseDistributedLock(Long productId) {\n        String path = "/product-lock-" + productId;\n        try {\n            zookeeper.delete(path, -1);\n            System.out.println("release the lock for product[id=" + productId + "]......");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    /**\n     * 建立zk session的watcher\n     *\n     * @author bingo\n     * @since 2018/11/29\n     *\n     */\n    private class ZooKeeperWatcher implements Watcher {\n\n        public void process(WatchedEvent event) {\n            System.out.println("Receive watched event: " + event.getState());\n\n            if (KeeperState.SyncConnected == event.getState()) {\n                connectedSemaphore.countDown();\n            }\n\n            if (this.latch != null) {\n                this.latch.countDown();\n            }\n        }\n\n    }\n\n    /**\n     * 封装单例的静态内部类\n     *\n     * @author bingo\n     * @since 2018/11/29\n     *\n     */\n    private static class Singleton {\n\n        private static ZooKeeperSession instance;\n\n        static {\n            instance = new ZooKeeperSession();\n        }\n\n        public static ZooKeeperSession getInstance() {\n            return instance;\n        }\n\n    }\n\n    /**\n     * 获取单例\n     *\n     * @return\n     */\n    public static ZooKeeperSession getInstance() {\n        return Singleton.getInstance();\n    }\n\n    /**\n     * 初始化单例的便捷方法\n     */\n    public static void init() {\n        getInstance();\n    }\n\n}\n\n\n也可以采用另一种方式，创建临时顺序节点：\n\n如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；后面的每个人都会去监听排在自己前面的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 zookeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。\n\npublic class ZooKeeperDistributedLock implements Watcher {\n\n    private ZooKeeper zk;\n    private String locksRoot = "/locks";\n    private String productId;\n    private String waitNode;\n    private String lockNode;\n    private CountDownLatch latch;\n    private CountDownLatch connectedLatch = new CountDownLatch(1);\n    private int sessionTimeout = 30000;\n\n    public ZooKeeperDistributedLock(String productId) {\n        this.productId = productId;\n        try {\n            String address = "192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181";\n            zk = new ZooKeeper(address, sessionTimeout, this);\n            connectedLatch.await();\n        } catch (IOException e) {\n            throw new LockException(e);\n        } catch (KeeperException e) {\n            throw new LockException(e);\n        } catch (InterruptedException e) {\n            throw new LockException(e);\n        }\n    }\n\n    public void process(WatchedEvent event) {\n        if (event.getState() == KeeperState.SyncConnected) {\n            connectedLatch.countDown();\n            return;\n        }\n\n        if (this.latch != null) {\n            this.latch.countDown();\n        }\n    }\n\n    public void acquireDistributedLock() {\n        try {\n            if (this.tryLock()) {\n                return;\n            } else {\n                waitForLock(waitNode, sessionTimeout);\n            }\n        } catch (KeeperException e) {\n            throw new LockException(e);\n        } catch (InterruptedException e) {\n            throw new LockException(e);\n        }\n    }\n\n    public boolean tryLock() {\n        try {\n \t\t    // 传入进去的locksRoot + “/” + productId\n\t\t    // 假设productId代表了一个商品id，比如说1\n\t\t    // locksRoot = locks\n\t\t    // /locks/10000000000，/locks/10000000001，/locks/10000000002\n            lockNode = zk.create(locksRoot + "/" + productId, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);\n\n            // 看看刚创建的节点是不是最小的节点\n\t \t    // locks：10000000000，10000000001，10000000002\n            List<String> locks = zk.getChildren(locksRoot, false);\n            Collections.sort(locks);\n\n            if(lockNode.equals(locksRoot+"/"+ locks.get(0))){\n                //如果是最小的节点,则表示取得锁\n                return true;\n            }\n\n            //如果不是最小的节点，找到比自己小1的节点\n\t  int previousLockIndex = -1;\n            for(int i = 0; i < locks.size(); i++) {\n\t\tif(lockNode.equals(locksRoot + “/” + locks.get(i))) {\n\t         \t    previousLockIndex = i - 1;\n\t\t    break;\n\t\t}\n\t   }\n\n\t   this.waitNode = locks.get(previousLockIndex);\n        } catch (KeeperException e) {\n            throw new LockException(e);\n        } catch (InterruptedException e) {\n            throw new LockException(e);\n        }\n        return false;\n    }\n\n    private boolean waitForLock(String waitNode, long waitTime) throws InterruptedException, KeeperException {\n        Stat stat = zk.exists(locksRoot + "/" + waitNode, true);\n        if (stat != null) {\n            this.latch = new CountDownLatch(1);\n            this.latch.await(waitTime, TimeUnit.MILLISECONDS);\n            this.latch = null;\n        }\n        return true;\n    }\n\n    public void unlock() {\n        try {\n            // 删除/locks/10000000000节点\n            // 删除/locks/10000000001节点\n            System.out.println("unlock " + lockNode);\n            zk.delete(lockNode, -1);\n            lockNode = null;\n            zk.close();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (KeeperException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public class LockException extends RuntimeException {\n        private static final long serialVersionUID = 1L;\n\n        public LockException(String e) {\n            super(e);\n        }\n\n        public LockException(Exception e) {\n            super(e);\n        }\n    }\n}\n\n\n\n# 4.3. ZooKeeper 分布式锁小结\n\nZooKeeper 版本的分布式锁问题相对比较来说少。\n\n * 锁的占用时间限制：redis 就有占用时间限制，而 ZooKeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 ZooKeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 ZooKeeper 一样添加一些与客户端绑定的临时键，也是一大好事。\n * 是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 ZooKeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。\n\n总体上来说 ZooKeeper 实现分布式锁更加的简单，可靠性更高。但 ZooKeeper 因为需要频繁的创建和删除节点，性能上不如 Redis 方式。\n\n\n# 5. 分布式锁方案对比\n\n数据库分布式锁，问题比较多，解决起来比较麻烦，不推荐。\n\n性能：\n\n * Redis 分布式锁，其实需要自己不断自旋去尝试获取锁，比较消耗性能。\n * ZooKeeper 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。\n\n可靠性：\n\n * 如果是 redis 获取锁的那个客户端出现 bug 挂了，那么只能等待超时时间之后才能释放锁；\n * 而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。\n\n综上分析，ZooKeeper 实现分布式锁更加的简单，可靠性更高。✅\n\n\n# 6. 参考资料\n\n * 分布式锁实现汇总\n * Redis 实现分布式锁，以及可重入锁思路',normalizedContent:'# 分布式锁基本原理\n\n> 在并发场景下，为了保证并发安全，我们常常要通过互斥（加锁）手段来保证数据同步安全。\n> \n> jdk 虽然提供了大量锁工具，但是只能作用于单一 java 进程，无法应用于分布式系统。为了解决这个问题，需要使用分布式锁。\n> \n> 分布式锁的解决方案大致有以下几种：\n> \n>  * 基于数据库实现\n>  * 基于缓存（redis，memcached 等）实现\n>  * 基于 zookeeper 实现 ✅\n> \n> 注：推荐基于 zookeeper 实现分布式锁，具体原因看完本文即可明了。\n\n\n# 1. 分布式锁思路\n\n分布式锁的总体思路大同小异，仅在实现细节上有所不同。\n\n分布式锁的主要思路如下：\n\n * 互斥、可重入 - 创建锁必须是唯一的，表现形式为向数据存储服务器或容器插入一个唯一的 key，一旦有一个线程插入这个 key，其他线程就不能再插入了。\n   * 保证 key 唯一性的最简单的方式是使用 uuid。\n   * 存储锁的重入次数，以及分布式环境下唯一的线程标识。举例来说，可以使用 json 存储结构化数据，为了保证唯一，可以考虑将 mac 地址（ip 地址、机器 id）、jvm 进程 id（应用 id、服务 id）、线程 id 拼接起来作为唯一标识。\n     \n     {"count":1,"expireat":147506817232,"jvmpid":22224,"mac":"28-d2-44-0e-0d-9a","threadid":14}\n     \n\n * 避免死锁 - 数据库分布式锁和缓存分布式锁（redis）的思路都是引入超时机制，即成功申请锁后，超过一定时间，锁失效（删除 key），原因在于它们无法感知申请锁的客户端节点状态。而 zookeeper 由于其 znode 以目录、文件形式组织，天然就存在物理空间隔离，只要 znode 存在，即表示客户端节点还在工作，所以不存在这种问题。\n * 容错 - 只要大部分 redis 节点可用，客户端就能正常加锁。\n * 自旋重试 - 获取不到锁时，不要直接返回失败，而是支持一定的周期自旋重试，设置一个总的超时时间，当过了超时时间以后还没有获取到锁则返回失败。\n\n\n# 2. 数据库分布式锁\n\n\n# 2.1. 数据库分布式锁原理\n\n（1）创建表\n\ncreate table `methodlock` (\n  `id` int(11) not null auto_increment comment \'主键\',\n  `method_name` varchar(64) not null default \'\' comment \'锁定的方法名\',\n  `desc` varchar(1024) not null default \'备注信息\',\n  `update_time` timestamp not null default current_timestamp on update current_timestamp comment \'保存数据时间，自动生成\',\n  primary key (`id`),\n  unique key `uidx_method_name` (`method_name `) using btree\n) engine=innodb default charset=utf8 comment=\'锁定中的方法\';\n\n\n（2）获取锁\n\n想要锁住某个方法时，执行以下 sql：\n\ninsert into methodlock(method_name,desc) values (‘method_name’,‘desc’)\n\n\n因为我们对 method_name 做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。\n\n成功插入则获取锁。\n\n（3）释放锁\n\n当方法执行完毕之后，想要释放锁的话，需要执行以下 sql:\n\ndelete from methodlock where method_name =\'method_name\'\n\n\n\n# 2.2. 数据库分布式锁问题\n\n * 这把锁强依赖数据库的可用性。如果数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。\n * 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。\n * 这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。\n * 这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。\n\n解决办法：\n\n * 单点问题可以用多数据库实例，同时塞 n 个表，n/2+1 个成功就任务锁定成功\n * 写一个定时任务，隔一段时间清除一次过期的数据。\n * 写一个 while 循环，不断的重试插入，直到成功。\n * 在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。\n\n\n# 2.3. 数据库分布式锁小结\n\n * 优点: 直接借助数据库，容易理解。\n * 缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。操作数据库需要一定的开销，性能问题需要考虑。\n\n\n# 3. redis 分布式锁\n\n相比于用数据库来实现分布式锁，基于缓存实现的分布式锁的性能会更好。目前有很多成熟的分布式产品，包括 redis、memcache、tair 等。这里以 redis 举例。\n\n\n# 3.1. redis 分布式锁原理\n\n这个分布式锁有 3 个重要的考量点：\n\n 1. 互斥（只能有一个客户端获取锁）\n 2. 不能死锁\n 3. 容错（只要大部分 redis 节点创建了这把锁就可以）\n\n对应的 redis 指令如下：\n\n * setnx - setnx key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0。\n * expire - expire key timeout：为 key 设置一个超时时间，单位为 second，超过这个时间锁会自动释放，避免死锁。\n * delete - delete key：删除 key\n\n> 注意：\n> \n> 不要将 setnx 和 expire 作为两个命令组合实现加锁，这样就无法保证原子性。如果客户端在 setnx 之后崩溃，那么将导致锁无法释放。正确的做法应是在 setnx 命令中指定 expire 时间。\n\n\n# 3.2. redis 分布式锁实现\n\n（1）申请锁\n\nset resource_name my_random_value nx px 30000\n\n\n执行这个命令就 ok。\n\n * nx：表示只有 key 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 nil）\n * px 30000：意思是 30s 后锁自动释放。别人创建的时候如果发现已经有了就不能加锁了。\n\n（2）释放锁\n\n释放锁就是删除 key ，但是一般可以用 lua 脚本删除，判断 value 一样才删除：\n\n-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。\nif redis.call("get",keys[1]) == argv[1] then\n    return redis.call("del",keys[1])\nelse\n    return 0\nend\n\n\n\n# 3.3. 数据库分布式锁小结\n\n为啥要用 random_value 随机值呢？因为如果某个客户端获取到了锁，但是阻塞了很长时间才执行完，比如说超过了 30s，此时可能已经自动释放锁了，此时可能别的客户端已经获取到了这个锁，要是你这个时候直接删除 key 的话会有问题，所以得用随机值加上面的 lua 脚本来释放锁。\n\n但是这样是肯定不行的。因为如果是普通的 redis 单实例，那就是单点故障。或者是 redis 普通主从，那 redis 主从异步复制，如果主节点挂了（key 就没有了），key 还没同步到从节点，此时从节点切换为主节点，别人就可以 set key，从而拿到锁。\n\n\n# 3.4. redlock 算法\n\n这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：\n\n 1. 获取当前时间戳，单位是毫秒；\n 2. 跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；\n 3. 尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点 n / 2 + 1；\n 4. 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；\n 5. 要是锁建立失败了，那么就依次之前建立过的锁删除；\n 6. 只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。\n\nredis 官方给出了以上两种基于 redis 实现分布式锁的方法，详细说明可以查看：https://redis.io/topics/distlock 。\n\n\n# 4. zookeeper 分布式锁\n\n\n# 4.1. zookeeper 分布式锁原理\n\nzookeeper 实现分布式锁基于 zookeeper 的两个特性：\n\n * 顺序临时节点：zookeeper 的存储类似于 dns 那样的具有层级的命名空间。zookeeper 节点类型可以分为持久节点（persistent ）、临时节点（ephemeral），每个节点还能被标记为有序性（sequential），一旦节点被标记为有序性，那么整个节点就具有顺序自增的特点。\n * watch 机制：zookeeper 允许用户在指定节点上注册一些 watcher，并且在特定事件触发的时候，zookeeper 服务端会将事件通知给用户。\n\n这也是 zookeeper 客户端 curator 的分布式锁实现。\n\n 1. 创建一个目录 mylock；\n 2. 线程 a 想获取锁就在 mylock 目录下创建临时顺序节点；\n 3. 获取 mylock 目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；\n 4. 线程 b 获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；\n 5. 线程 a 处理完，删除自己的节点，线程 b 监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。\n\n\n# 4.2. zookeeper 分布式锁实现\n\n/**\n * zookeepersession\n *\n * @author bingo\n * @since 2018/11/29\n *\n */\npublic class zookeepersession {\n\n    private static countdownlatch connectedsemaphore = new countdownlatch(1);\n\n    private zookeeper zookeeper;\n    private countdownlatch latch;\n\n    public zookeepersession() {\n        try {\n            this.zookeeper = new zookeeper("192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181", 50000, new zookeeperwatcher());\n            try {\n                connectedsemaphore.await();\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n\n            system.out.println("zookeeper session established......");\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    }\n\n    /**\n     * 获取分布式锁\n     *\n     * @param productid\n     */\n    public boolean acquiredistributedlock(long productid) {\n        string path = "/product-lock-" + productid;\n\n        try {\n            zookeeper.create(path, "".getbytes(), ids.open_acl_unsafe, createmode.ephemeral);\n            return true;\n        } catch (exception e) {\n            while (true) {\n                try {\n                    // 相当于是给node注册一个监听器，去看看这个监听器是否存在\n                    stat stat = zk.exists(path, true);\n\n                    if (stat != null) {\n                        this.latch = new countdownlatch(1);\n                        this.latch.await(waittime, timeunit.milliseconds);\n                        this.latch = null;\n                    }\n                    zookeeper.create(path, "".getbytes(), ids.open_acl_unsafe, createmode.ephemeral);\n                    return true;\n                } catch (exception ee) {\n                    continue;\n                }\n            }\n\n        }\n        return true;\n    }\n\n    /**\n     * 释放掉一个分布式锁\n     *\n     * @param productid\n     */\n    public void releasedistributedlock(long productid) {\n        string path = "/product-lock-" + productid;\n        try {\n            zookeeper.delete(path, -1);\n            system.out.println("release the lock for product[id=" + productid + "]......");\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    }\n\n    /**\n     * 建立zk session的watcher\n     *\n     * @author bingo\n     * @since 2018/11/29\n     *\n     */\n    private class zookeeperwatcher implements watcher {\n\n        public void process(watchedevent event) {\n            system.out.println("receive watched event: " + event.getstate());\n\n            if (keeperstate.syncconnected == event.getstate()) {\n                connectedsemaphore.countdown();\n            }\n\n            if (this.latch != null) {\n                this.latch.countdown();\n            }\n        }\n\n    }\n\n    /**\n     * 封装单例的静态内部类\n     *\n     * @author bingo\n     * @since 2018/11/29\n     *\n     */\n    private static class singleton {\n\n        private static zookeepersession instance;\n\n        static {\n            instance = new zookeepersession();\n        }\n\n        public static zookeepersession getinstance() {\n            return instance;\n        }\n\n    }\n\n    /**\n     * 获取单例\n     *\n     * @return\n     */\n    public static zookeepersession getinstance() {\n        return singleton.getinstance();\n    }\n\n    /**\n     * 初始化单例的便捷方法\n     */\n    public static void init() {\n        getinstance();\n    }\n\n}\n\n\n也可以采用另一种方式，创建临时顺序节点：\n\n如果有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；后面的每个人都会去监听排在自己前面的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 zookeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁，就可以执行代码了。\n\npublic class zookeeperdistributedlock implements watcher {\n\n    private zookeeper zk;\n    private string locksroot = "/locks";\n    private string productid;\n    private string waitnode;\n    private string locknode;\n    private countdownlatch latch;\n    private countdownlatch connectedlatch = new countdownlatch(1);\n    private int sessiontimeout = 30000;\n\n    public zookeeperdistributedlock(string productid) {\n        this.productid = productid;\n        try {\n            string address = "192.168.31.187:2181,192.168.31.19:2181,192.168.31.227:2181";\n            zk = new zookeeper(address, sessiontimeout, this);\n            connectedlatch.await();\n        } catch (ioexception e) {\n            throw new lockexception(e);\n        } catch (keeperexception e) {\n            throw new lockexception(e);\n        } catch (interruptedexception e) {\n            throw new lockexception(e);\n        }\n    }\n\n    public void process(watchedevent event) {\n        if (event.getstate() == keeperstate.syncconnected) {\n            connectedlatch.countdown();\n            return;\n        }\n\n        if (this.latch != null) {\n            this.latch.countdown();\n        }\n    }\n\n    public void acquiredistributedlock() {\n        try {\n            if (this.trylock()) {\n                return;\n            } else {\n                waitforlock(waitnode, sessiontimeout);\n            }\n        } catch (keeperexception e) {\n            throw new lockexception(e);\n        } catch (interruptedexception e) {\n            throw new lockexception(e);\n        }\n    }\n\n    public boolean trylock() {\n        try {\n \t\t    // 传入进去的locksroot + “/” + productid\n\t\t    // 假设productid代表了一个商品id，比如说1\n\t\t    // locksroot = locks\n\t\t    // /locks/10000000000，/locks/10000000001，/locks/10000000002\n            locknode = zk.create(locksroot + "/" + productid, new byte[0], zoodefs.ids.open_acl_unsafe, createmode.ephemeral_sequential);\n\n            // 看看刚创建的节点是不是最小的节点\n\t \t    // locks：10000000000，10000000001，10000000002\n            list<string> locks = zk.getchildren(locksroot, false);\n            collections.sort(locks);\n\n            if(locknode.equals(locksroot+"/"+ locks.get(0))){\n                //如果是最小的节点,则表示取得锁\n                return true;\n            }\n\n            //如果不是最小的节点，找到比自己小1的节点\n\t  int previouslockindex = -1;\n            for(int i = 0; i < locks.size(); i++) {\n\t\tif(locknode.equals(locksroot + “/” + locks.get(i))) {\n\t         \t    previouslockindex = i - 1;\n\t\t    break;\n\t\t}\n\t   }\n\n\t   this.waitnode = locks.get(previouslockindex);\n        } catch (keeperexception e) {\n            throw new lockexception(e);\n        } catch (interruptedexception e) {\n            throw new lockexception(e);\n        }\n        return false;\n    }\n\n    private boolean waitforlock(string waitnode, long waittime) throws interruptedexception, keeperexception {\n        stat stat = zk.exists(locksroot + "/" + waitnode, true);\n        if (stat != null) {\n            this.latch = new countdownlatch(1);\n            this.latch.await(waittime, timeunit.milliseconds);\n            this.latch = null;\n        }\n        return true;\n    }\n\n    public void unlock() {\n        try {\n            // 删除/locks/10000000000节点\n            // 删除/locks/10000000001节点\n            system.out.println("unlock " + locknode);\n            zk.delete(locknode, -1);\n            locknode = null;\n            zk.close();\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        } catch (keeperexception e) {\n            e.printstacktrace();\n        }\n    }\n\n    public class lockexception extends runtimeexception {\n        private static final long serialversionuid = 1l;\n\n        public lockexception(string e) {\n            super(e);\n        }\n\n        public lockexception(exception e) {\n            super(e);\n        }\n    }\n}\n\n\n\n# 4.3. zookeeper 分布式锁小结\n\nzookeeper 版本的分布式锁问题相对比较来说少。\n\n * 锁的占用时间限制：redis 就有占用时间限制，而 zookeeper 则没有，最主要的原因是 redis 目前没有办法知道已经获取锁的客户端的状态，是已经挂了呢还是正在执行耗时较长的业务逻辑。而 zookeeper 通过临时节点就能清晰知道，如果临时节点存在说明还在执行业务逻辑，如果临时节点不存在说明已经执行完毕释放锁或者是挂了。由此看来 redis 如果能像 zookeeper 一样添加一些与客户端绑定的临时键，也是一大好事。\n * 是否单点故障：redis 本身有很多中玩法，如客户端一致性 hash，服务器端 sentinel 方案或者 cluster 方案，很难做到一种分布式锁方式能应对所有这些方案。而 zookeeper 只有一种玩法，多台机器的节点数据是一致的，没有 redis 的那么多的麻烦因素要考虑。\n\n总体上来说 zookeeper 实现分布式锁更加的简单，可靠性更高。但 zookeeper 因为需要频繁的创建和删除节点，性能上不如 redis 方式。\n\n\n# 5. 分布式锁方案对比\n\n数据库分布式锁，问题比较多，解决起来比较麻烦，不推荐。\n\n性能：\n\n * redis 分布式锁，其实需要自己不断自旋去尝试获取锁，比较消耗性能。\n * zookeeper 分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小。\n\n可靠性：\n\n * 如果是 redis 获取锁的那个客户端出现 bug 挂了，那么只能等待超时时间之后才能释放锁；\n * 而 zk 的话，因为创建的是临时 znode，只要客户端挂了，znode 就没了，此时就自动释放锁。\n\n综上分析，zookeeper 实现分布式锁更加的简单，可靠性更高。✅\n\n\n# 6. 参考资料\n\n * 分布式锁实现汇总\n * redis 实现分布式锁，以及可重入锁思路',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"消息队列基本原理",frontmatter:{title:"消息队列基本原理",categories:["分布式","分布式关键技术","通信"],tags:["分布式","通信","消息队列"],abbrlink:"2d0902c8",date:"2019-07-05T15:11:00.000Z",permalink:"/pages/4bba35/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/04.%E9%80%9A%E4%BF%A1/01.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html",relativePath:"02.分布式/03.分布式关键技术/04.通信/01.消息队列.md",key:"v-30f4df2d",path:"/pages/4bba35/",headers:[{level:2,title:"1. MQ 的简介",slug:"_1-mq-的简介",normalizedTitle:"1. mq 的简介",charIndex:281},{level:3,title:"1.1. 什么是 MQ",slug:"_1-1-什么是-mq",normalizedTitle:"1.1. 什么是 mq",charIndex:295},{level:3,title:"1.2. MQ 通信模型",slug:"_1-2-mq-通信模型",normalizedTitle:"1.2. mq 通信模型",charIndex:748},{level:2,title:"2. MQ 的应用",slug:"_2-mq-的应用",normalizedTitle:"2. mq 的应用",charIndex:1517},{level:3,title:"2.1. 异步处理",slug:"_2-1-异步处理",normalizedTitle:"2.1. 异步处理",charIndex:1531},{level:3,title:"2.2. 系统解耦",slug:"_2-2-系统解耦",normalizedTitle:"2.2. 系统解耦",charIndex:1967},{level:3,title:"2.3. 流量削峰",slug:"_2-3-流量削峰",normalizedTitle:"2.3. 流量削峰",charIndex:2298},{level:3,title:"2.4. 传输缓冲",slug:"_2-4-传输缓冲",normalizedTitle:"2.4. 传输缓冲",charIndex:2855},{level:3,title:"2.5. 最终一致性",slug:"_2-5-最终一致性",normalizedTitle:"2.5. 最终一致性",charIndex:3181},{level:3,title:"2.6. 系统间通信",slug:"_2-6-系统间通信",normalizedTitle:"2.6. 系统间通信",charIndex:3444},{level:2,title:"3. MQ 的问题",slug:"_3-mq-的问题",normalizedTitle:"3. mq 的问题",charIndex:3586},{level:3,title:"3.1. 重复消费",slug:"_3-1-重复消费",normalizedTitle:"3.1. 重复消费",charIndex:3951},{level:4,title:"重复消费问题原因",slug:"重复消费问题原因",normalizedTitle:"重复消费问题原因",charIndex:4025},{level:4,title:"重复消费解决方案",slug:"重复消费解决方案",normalizedTitle:"重复消费解决方案",charIndex:4375},{level:3,title:"3.2. 消息丢失",slug:"_3-2-消息丢失",normalizedTitle:"3.2. 消息丢失",charIndex:4714},{level:4,title:"消费方丢失数据",slug:"消费方丢失数据",normalizedTitle:"消费方丢失数据",charIndex:4787},{level:4,title:"Kafka Server 丢失数据",slug:"kafka-server-丢失数据",normalizedTitle:"kafka server 丢失数据",charIndex:5022},{level:4,title:"生产方丢失数据",slug:"生产方丢失数据",normalizedTitle:"生产方丢失数据",charIndex:4798},{level:3,title:"3.3. 消息的顺序性",slug:"_3-3-消息的顺序性",normalizedTitle:"3.3. 消息的顺序性",charIndex:5649},{level:3,title:"3.4. 消息积压",slug:"_3-4-消息积压",normalizedTitle:"3.4. 消息积压",charIndex:6066},{level:2,title:"4. MQ 的高可用",slug:"_4-mq-的高可用",normalizedTitle:"4. mq 的高可用",charIndex:6624},{level:3,title:"4.1. Kafka 的高可用",slug:"_4-1-kafka-的高可用",normalizedTitle:"4.1. kafka 的高可用",charIndex:6692},{level:4,title:"Kafka 的核心概念",slug:"kafka-的核心概念",normalizedTitle:"kafka 的核心概念",charIndex:6711},{level:4,title:"Kafka 的副本机制",slug:"kafka-的副本机制",normalizedTitle:"kafka 的副本机制",charIndex:7188},{level:4,title:"Kafka 选举 Leader",slug:"kafka-选举-leader",normalizedTitle:"kafka 选举 leader",charIndex:7849},{level:2,title:"5. 主流 MQ",slug:"_5-主流-mq",normalizedTitle:"5. 主流 mq",charIndex:7979},{level:3,title:"5.1. ActiveMQ",slug:"_5-1-activemq",normalizedTitle:"5.1. activemq",charIndex:7992},{level:4,title:"(a) 主要特性",slug:"a-主要特性",normalizedTitle:"(a) 主要特性",charIndex:8142},{level:4,title:"(b) 部署环境",slug:"b-部署环境",normalizedTitle:"(b) 部署环境",charIndex:8785},{level:4,title:"(c) 优点",slug:"c-优点",normalizedTitle:"(c) 优点",charIndex:8874},{level:4,title:"(d) 缺点",slug:"d-缺点",normalizedTitle:"(d) 缺点",charIndex:9264},{level:3,title:"5.2. RabbitMQ",slug:"_5-2-rabbitmq",normalizedTitle:"5.2. rabbitmq",charIndex:9401},{level:4,title:"(a) 主要特性",slug:"a-主要特性-2",normalizedTitle:"(a) 主要特性",charIndex:8142},{level:4,title:"(b) 部署环境",slug:"b-部署环境-2",normalizedTitle:"(b) 部署环境",charIndex:8785},{level:4,title:"(c) 优点",slug:"c-优点-2",normalizedTitle:"(c) 优点",charIndex:8874},{level:4,title:"(d) 缺点",slug:"d-缺点-2",normalizedTitle:"(d) 缺点",charIndex:9264},{level:3,title:"5.3. RocketMQ",slug:"_5-3-rocketmq",normalizedTitle:"5.3. rocketmq",charIndex:10527},{level:4,title:"(a) 主要特性",slug:"a-主要特性-3",normalizedTitle:"(a) 主要特性",charIndex:8142},{level:4,title:"(b) 部署环境",slug:"b-部署环境-3",normalizedTitle:"(b) 部署环境",charIndex:8785},{level:4,title:"(c) 优点",slug:"c-优点-3",normalizedTitle:"(c) 优点",charIndex:8874},{level:4,title:"(d) 缺点",slug:"d-缺点-3",normalizedTitle:"(d) 缺点",charIndex:9264},{level:3,title:"5.4. Kafka",slug:"_5-4-kafka",normalizedTitle:"5.4. kafka",charIndex:11585},{level:4,title:"(a) 主要特性",slug:"a-主要特性-4",normalizedTitle:"(a) 主要特性",charIndex:8142},{level:4,title:"(b) 部署环境",slug:"b-部署环境-4",normalizedTitle:"(b) 部署环境",charIndex:8785},{level:4,title:"(c) 优点",slug:"c-优点-4",normalizedTitle:"(c) 优点",charIndex:8874},{level:4,title:"(d) 缺点",slug:"d-缺点-4",normalizedTitle:"(d) 缺点",charIndex:9264},{level:3,title:"5.5. MQ 的技术选型",slug:"_5-5-mq-的技术选型",normalizedTitle:"5.5. mq 的技术选型",charIndex:12631},{level:2,title:"6. JMS",slug:"_6-jms",normalizedTitle:"6. jms",charIndex:14441},{level:3,title:"6.1. 消息模型",slug:"_6-1-消息模型",normalizedTitle:"6.1. 消息模型",charIndex:14664},{level:4,title:"P2P 模式",slug:"p2p-模式",normalizedTitle:"p2p 模式",charIndex:14751},{level:4,title:"Pub/sub 模式",slug:"pub-sub-模式",normalizedTitle:"pub/sub 模式",charIndex:15041},{level:3,title:"6.2. 消息消费",slug:"_6-2-消息消费",normalizedTitle:"6.2. 消息消费",charIndex:15394},{level:3,title:"6.3. JMS 编程模型",slug:"_6-3-jms-编程模型",normalizedTitle:"6.3. jms 编程模型",charIndex:15727},{level:4,title:"ConnectionFactory",slug:"connectionfactory",normalizedTitle:"connectionfactory",charIndex:15744},{level:4,title:"Destination",slug:"destination",normalizedTitle:"destination",charIndex:914},{level:4,title:"Connection",slug:"connection",normalizedTitle:"connection",charIndex:15744},{level:4,title:"Session",slug:"session",normalizedTitle:"session",charIndex:16200},{level:4,title:"消息的生产者",slug:"消息的生产者",normalizedTitle:"消息的生产者",charIndex:16440},{level:4,title:"消息消费者",slug:"消息消费者",normalizedTitle:"消息消费者",charIndex:15938},{level:4,title:"MessageListener",slug:"messagelistener",normalizedTitle:"messagelistener",charIndex:16781},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:16902}],headersStr:"1. MQ 的简介 1.1. 什么是 MQ 1.2. MQ 通信模型 2. MQ 的应用 2.1. 异步处理 2.2. 系统解耦 2.3. 流量削峰 2.4. 传输缓冲 2.5. 最终一致性 2.6. 系统间通信 3. MQ 的问题 3.1. 重复消费 重复消费问题原因 重复消费解决方案 3.2. 消息丢失 消费方丢失数据 Kafka Server 丢失数据 生产方丢失数据 3.3. 消息的顺序性 3.4. 消息积压 4. MQ 的高可用 4.1. Kafka 的高可用 Kafka 的核心概念 Kafka 的副本机制 Kafka 选举 Leader 5. 主流 MQ 5.1. ActiveMQ (a) 主要特性 (b) 部署环境 (c) 优点 (d) 缺点 5.2. RabbitMQ (a) 主要特性 (b) 部署环境 (c) 优点 (d) 缺点 5.3. RocketMQ (a) 主要特性 (b) 部署环境 (c) 优点 (d) 缺点 5.4. Kafka (a) 主要特性 (b) 部署环境 (c) 优点 (d) 缺点 5.5. MQ 的技术选型 6. JMS 6.1. 消息模型 P2P 模式 Pub/sub 模式 6.2. 消息消费 6.3. JMS 编程模型 ConnectionFactory Destination Connection Session 消息的生产者 消息消费者 MessageListener 7. 参考资料",content:'# 消息队列基本原理\n\n> 📦 本文已归档到：「blog」\n> \n> 消息队列（Message Queue，简称 MQ）技术是应用间交换信息的一种技术。\n> \n> 消息队列主要解决异步处理、应用间耦合，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。\n> \n> 目前主流的 MQ 有：Kafka、RabbitMQ、RocketMQ、ActiveMQ，而部分数据库如 Redis、MySQL 以及 phxsql 也可实现消息队列的功能。\n> \n> 注意：为了简便，下文中除了文章标题，一律使用 MQ 简称。\n\n\n# 1. MQ 的简介\n\n\n# 1.1. 什么是 MQ\n\n消息队列（Message Queue，简称 MQ）技术是应用间交换信息的一种技术。\n\n消息队列主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。\n\nMQ 是消费-生产者模型的一个典型的代表，一端往消息队列中不断写入消息，而另一端则可以读取队列中的消息。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。\n\nMQ 的数据可驻留在内存或磁盘上，直到它们被应用程序读取。通过 MQ，应用程序可独立地执行，它们不需要知道彼此的位置，不需要等待接收程序接收此消息。在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。\n\n目前主流的 MQ 有：Kafka、RabbitMQ、RocketMQ、ActiveMQ。\n\n\n# 1.2. MQ 通信模型\n\nMQ 通信模型大致有以下类型：\n\n * 点对点 - 点对点方式是最为传统和常见的通讯方式，它支持一对一、一对多、多对多、多对一等多种配置方式，支持树状、网状等多种拓扑结构。\n * 多点广播 - MQ 适用于不同类型的应用。其中重要的，也是正在发展中的是"多点广播"应用，即能够将消息发送到多个目标站点 (Destination List)。可以使用一条 MQ 指令将单一消息发送到多个目标站点，并确保为每一站点可靠地提供信息。MQ 不仅提供了多点广播的功能，而且还拥有智能消息分发功能，在将一条消息发送到同一系统上的多个用户时，MQ 将消息的一个复制版本和该系统上接收者的名单发送到目标 MQ 系统。目标 MQ 系统在本地复制这些消息，并将它们发送到名单上的队列，从而尽可能减少网络的传输量。\n * 发布/订阅 (Publish/Subscribe) - 发布/订阅模式使消息的分发可以突破目的队列地理位置的限制，使消息按照特定的主题甚至内容进行分发，用户或应用程序可以根据主题或内容接收到所需要的消息。发布/订阅模式使得发送者和接收者之间的耦合关系变得更为松散，发送者不必关心接收者的目的地址，而接收者也不必关心消息的发送地址，而只是根据消息的主题进行消息的收发。\n * 集群 (Cluster) - 为了简化点对点通讯模式中的系统配置，MQ 提供 Cluster(集群) 的解决方案。集群类似于一个域 (Domain)，集群内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用集群 (Cluster) 通道与其它成员通讯，从而大大简化了系统配置。此外，集群中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性。\n\n\n# 2. MQ 的应用\n\n\n# 2.1. 异步处理\n\n> MQ 可以将系统间的处理流程异步化，减少等待响应的时间，从而提高整体并发吞吐量。\n> \n> 一般，MQ 异步处理应用于非核心流程，例如：短信/邮件通知、数据推送、上报数据到监控中心/日志中心等。\n\n假设这样一个场景，用户向系统 A 发起请求，系统 A 处理计算只需要 10 ms，然后通知系统 BCD 写库，系统 BCD 写库耗时分别为：100ms、200ms、300ms。最终总耗时为： 10+100ms+200ms+300ms=610ms。此外，加上请求和响应的网络传输时间，从用户角度看，可能要等待将近 1s 才能得到结果。\n\n\n\n如果使用 MQ，系统 A 接到请求后，耗时 10ms 处理计算，然后向系统 BCD 连续发送消息，假设耗时 5ms。那么 这一过程的总耗时为 3ms + 5ms = 8ms，这相比于 610 ms，大大缩短了响应时间。至于系统 BCD 的写库操作，只要自行消费 MQ 后处理即可，用户无需关注。\n\n\n\n\n# 2.2. 系统解耦\n\n> 通过 MQ，可以消除系统间的强耦合。它的好处在于：\n> \n>  * 消息的消费者系统可以随意增加，无需修改生产者系统的代码。\n>  * 生产者系统、消费者系统彼此不会影响对方的流程。\n>    * 如果生产者系统宕机，消费者系统收不到消息，就不会有下一步的动作。\n>    * 如果消费者系统宕机，生产者系统让然可以正常发送消息，不影响流程。\n\n不同系统如果要建立通信，传统的做法是：调用接口。\n\n如果需要和新的系统建立通信或删除已建立的通信，都需要修改代码，这种方案显然耦合度很高。\n\n\n\n如果使用 MQ，系统间的通信只需要通过发布/订阅（Pub/Sub）模型即可，彼此没有直接联系，也就不需要相互感知，从而达到 解耦。\n\n\n\n\n# 2.3. 流量削峰\n\n> 当 上下游系统 处理能力存在差距的时候，利用 MQ 做一个 “漏斗” 模型，进行 流控。把 MQ 当成可靠的 消息暂存地，进行一定程度的 消息堆积；在下游有能力处理的时候，再发送消息。\n> \n> MQ 的流量削峰常用于高并发场景（例如：秒杀、团抢等业务场景），它是缓解瞬时暴增流量的核心手段之一。\n> \n> 如果没有 MQ，两个系统之间通过 协商、滑动窗口、限流/降级/熔断 等复杂的方案也能实现 流控。但 系统复杂性 指数级增长，势必在上游或者下游做存储，并且要处理 定时、拥塞 等一系列问题。而且每当有 处理能力有差距 的时候，都需要 单独 开发一套逻辑来维护这套逻辑。\n\n假设某个系统读写数据库的稳定性能为每秒处理 1000 条数据。平常情况下，远远达不到这么大的处理量。假设，因为因为做活动，系统的瞬时请求量剧增，达到每秒 10000 个并发请求，数据库根本承受不了，可能直接就把数据库给整崩溃了，这样系统服务就不可用了。\n\n\n\n如果使用 MQ，每秒写入 10000 条请求，但是系统 A 每秒只从 MQ 中消费 1000 条请求，然后写入数据库。这样，就不会超过数据库的承受能力，而是把请求积压在 MQ 中。只要高峰期一过，系统 A 就会很快把积压的消息给处理掉。\n\n\n\n\n# 2.4. 传输缓冲\n\n（1）MQ 常被用于做海量数据的传输缓冲。\n\n例如，Kafka 常被用于做为各种日志数据、采集数据的数据中转。然后，Kafka 将数据转发给 Logstash、Elasticsearch 中，然后基于 Elasticsearch 来做日志中心，提供检索、聚合、分析日志的能力。开发者可以通过 Kibana 集成 Elasticsearch 数据进行可视化展示，或自行进行定制化开发。\n\n\n\n（2）MQ 也可以被用于流式处理。\n\n例如，Kafka 几乎已经是流计算的数据采集端的标准组件。而流计算通过实时数据处理能力，提供了更为快捷的聚合计算能力，被大量应用于链路监控、实时监控、实时数仓、实时大屏、风控、推荐等应用领域。\n\n\n# 2.5. 最终一致性\n\n最终一致性 不是 消息队列 的必备特性，但确实可以依靠 消息队列 来做 最终一致性 的事情。\n\n * 先写消息再操作，确保操作完成后再修改消息状态。定时任务补偿机制 实现消息 可靠发送接收、业务操作的可靠执行，要注意 消息重复 与 幂等设计。\n * 所有不保证 100% 不丢消息 的消息队列，理论上无法实现 最终一致性。\n\n> 像 Kafka 一类的设计，在设计层面上就有 丢消息 的可能（比如 定时刷盘，如果掉电就会丢消息）。哪怕只丢千分之一的消息，业务也必须用其他的手段来保证结果正确。\n\n\n# 2.6. 系统间通信\n\n消息队列一般都内置了 高效的通信机制，因此也可以用于单纯的 消息通讯，比如实现 点对点消息队列 或者 聊天室 等。\n\n生产者/消费者 模式，只需要关心消息是否 送达队列，至于谁希望订阅和需要消费，是 下游 的事情，无疑极大地减少了开发和联调的工作量。\n\n\n# 3. MQ 的问题\n\n任何技术都会有利有弊，MQ 给整体系统架构带来很多好处，但也会付出一定的代价。\n\nMQ 主要引入了以下问题：\n\n * 系统可用性降低：引入了 MQ 后，通信需要基于 MQ 完成，如果 MQ 宕机，则服务不可用。因此，MQ 要保证是高可用的，详情参考：MQ 的高可用\n * 系统复杂度提高：使用 MQ，需要关注一些新的问题：\n   * 如何保证消息没有 重复消费？\n   * 如何处理 消息丢失 的问题？\n   * 如何保证传递 消息的顺序性？\n   * 如何处理大量 消息积压 的问题？\n * 一致性问题：假设系统 A 处理完直接返回成功的结果给用户，用户认为请求成功。但如果此时，系统 BCD 中只要有任意一个写库失败，那么数据就不一致了。这种情况如何处理？\n\n下面，我们针对以上问题来一一分析。\n\n\n# 3.1. 重复消费\n\n如何保证消息不被重复消费 和 如何保证消息消费的幂等性 是同一个问题。\n\n必须先明确产生重复消费的原因，才能对症下药。\n\n# 重复消费问题原因\n\n重复消费问题通常不是 MQ 来处理，而是由开发来处理的。\n\n以 Kafka 举例，Kafka 每个 Partition 都是一个有序的、不可变的记录序列，不断追加到结构化的提交日志中。Partition 中为每条记录分配一个连续的 id 号，称为偏移量（Offset），用于唯一标识 Partition 内的记录。\n\nKafka 的客户端和 Broker 都会保存 Offset。客户端消费消息后，每隔一段时间，就把已消费的 Offset 提交给 Kafka Broker，表示已消费。\n\n\n\n在这个过程中，如果客户端应用消费消息后，因为宕机、重启等情况而没有提交已消费的 Offset 。当系统恢复后，会继续消费消息，由于 Offset 未提交，就会出现重复消费的问题。\n\n# 重复消费解决方案\n\n应对重复消费问题，需要在业务层面，通过 幂等性设计 来解决。\n\nMQ 重复消费不可怕，可怕的是没有应对机制，可以借鉴的思路有：\n\n * 如果是写关系型数据库，可以先根据主键查询，判断数据是否已存在，存在则更新，不存在则插入；\n * 如果是写 Redis，由于 set 操作天然具有幂等性，所以什么都不用做；\n * 如果是根据消息做较复杂的逻辑处理，可以在消息中加入全局唯一 ID，例如：订单 ID 等。在客户端存储中（Mysql、Redis 等）保存已消费消息的 ID。一旦接受到新消息，先判断消息中的 ID 是否在已消费消息 ID 表中存在，存在则不再处理，不存在则处理。\n\n在实际开发中，可以参考上面的例子，结合现实场景，设计合理的幂等性方案。\n\n\n# 3.2. 消息丢失\n\n如何处理消息丢失的问题 和 如何保证消息不被重复消费 是同一个问题。关注点有：\n\n * MQ Server 丢失数据\n * 消费方丢失数据\n * 生产方丢失数据\n\n# 消费方丢失数据\n\n唯一可能导致消费方丢失数据的情况是：消费方设置了自动提交 Offset。一旦设置了自动提交 Offset，接受到消息后就会自动提交 Offset 给 Kafka ，Kafka 就认为消息已被消费。如果此时，消费方尚未来得及处理消息就挂了，那么消息就丢了。\n\n解决方法就是：消费方关闭自动提交 Offset，处理完消息后手动提交 Offset。但这种情况下可能会出现重复消费的情形，需要自行保证幂等性。\n\n# Kafka Server 丢失数据\n\n当 Kafka 某个 Broker 宕机，需要重新选举 Partition 的 Leader。若此时其他的 Follower 尚未同步 Leader 的数据，那么新选某个 Follower 为 Leader 后，就丢失了部分数据。\n\n为此，一般要求至少设置 4 个参数：\n\n * 给 Topic 设置 replication.factor 参数 - 这个值必须大于 1，要求每个 Partition 必须有至少 2 个副本。\n * 在 Kafka 服务端设置 min.insync.replicas 参数 - 这个值必须大于 1，这是要求一个 Leader 需要和至少一个 Follower 保持通信，这样才能确保 Leader 挂了还有替补。\n * 在 Producer 端设置 acks=all - 这意味着：要求每条数据，必须是写入所有 replica 之后，才能认为写入成功了。\n * 在 Producer 端设置 retries=MAX（很大很大很大的一个值，无限次重试的意思） - 这意味着要求一旦写入失败，就无限重试，卡在这里了。\n\n# 生产方丢失数据\n\n如果按照上述的思路设置了 acks=all，生产方一定不会丢数据。\n\n要求是，你的 Leader 接收到消息，所有的 Follower 都同步到了消息之后，才认为本生产消息成功了。如果未满足这个条件，生产者会自动不断的重试，重试无限次。\n\n\n# 3.3. 消息的顺序性\n\n要保证 MQ 的顺序性，势必要付出一定的代价，所以实施方案前，要先明确业务场景是不是有必要保证消息的顺序性。只有那些明确对消息处理顺序有要求的业务场景才值得去保证消息顺序性。\n\n方案一\n\n一个 Topic，一个 Partition，一个 Consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。\n\n方案二\n\n * 写入数据到 Partition 时指定一个全局唯一的 ID，例如订单 ID。发送方保证相同 ID 的消息有序的发送到同一个 Partition。\n * 基于上一点，消费方从 Kafka Partition 中消费消息时，此刻一定是顺序的。但如果消费方式以并发方式消费消息，顺序就可能会被打乱。为此，还有做到以下几点：\n   * 消费方维护 N 个缓存队列，具有相同 ID 的数据都写入同一个队列中；\n   * 创建 N 个线程，每个线程只负责从指定的一个队列中取数据。\n\n\n\n\n# 3.4. 消息积压\n\n假设一个 MQ 消费者可以一秒处理 1000 条消息，三个 MQ 消费者可以一秒处理 3000 条消息，那么一分钟的处理量是 18 万条。如果 MQ 中积压了几百万到上千万的数据，即使消费者恢复了，也需要大概很长的时间才能恢复过来。\n\n对于产线环境来说，漫长的等待是不可接受的，所以面临这种窘境时，只能临时紧急扩容以应对了，具体操作步骤和思路如下：\n\n * 先修复 Consumer 的问题，确保其恢复消费速度，然后将现有 Consumer 都停掉。\n * 新建一个 Topic，Partition 是原来的 10 倍，临时建立好原先 10 倍的 Queue 数量。\n * 然后写一个临时的分发数据的 Consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 Queue。\n * 接着临时征用 10 倍的机器来部署 Consumer ，每一批 Consumer 消费一个临时 Queue 的数据。这种做法相当于是临时将 Queue 资源和 Consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。\n * 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。\n\n\n# 4. MQ 的高可用\n\n不同 MQ 实现高可用的原理各不相同。因为 Kafka 比较具有代表性，所以这里以 Kafka 为例。\n\n\n# 4.1. Kafka 的高可用\n\n# Kafka 的核心概念\n\n了解 Kafka，必须先了解 Kafka 的核心概念：\n\n * Broker - Kafka 集群包含一个或多个节点，这种节点被称为 Broker。\n\n * Topic - 每条发布到 Kafka 集群的消息都有一个类别，这个类别被称为 Topic。（不同 Topic 的消息是物理隔离的；同一个 Topic 的消息保存在一个或多个 Broker 上，但用户只需指定消息的 Topic 即可生产或消费数据而不必关心数据存于何处）。对于每一个 Topic， Kafka 集群都会维持一个分区日志。\n\n * Partition - 了提高 Kafka 的吞吐率，每个 Topic 包含一个或多个 Partition，每个 Partition 在物理上对应一个文件夹，该文件夹下存储这个 Partition 的所有消息和索引文件。\n   \n   * Kafka 日志的分区（Partition）分布在 Kafka 集群的节点上。每个节点在处理数据和请求时，共享这些分区。每一个分区都会在已配置的节点上进行备份，确保容错性。\n\n\n\n# Kafka 的副本机制\n\nKafka 是如何实现高可用的呢？\n\nKafka 在 0.8 以前的版本中，如果一个 Broker 宕机了，其上面的 Partition 都不能用了，这自然不是高可用的。\n\n为了实现高可用，Kafka 引入了复制功能。\n\n简单来说，就是副本机制（ Replicate ）。\n\n每个 Partition 都有一个 Leader，零个或多个 Follower。Leader 和 Follower 都是 Broker，每个 Broker 都会成为某些分区的 Leader 和某些分区的 Follower，因此集群的负载是平衡的。\n\n * Leader 处理一切对 Partition （分区）的读写请求；\n * 而 Follower 只需被动的同步 Leader 上的数据。\n\n同一个 Topic 的不同 Partition 会分布在多个 Broker 上，而且一个 Partition 还会在其他的 Broker 上面进行备份，Producer 在发布消息到某个 Partition 时，先找到该 Partition 的 Leader，然后向这个 Leader 推送消息；每个 Follower 都从 Leader 拉取消息，拉取消息成功之后，向 Leader 发送一个 ACK 确认。\n\n\n\n> FAQ\n> \n> 问：为什么让 Leader 处理一切对对 Partition （分区）的读写请求？\n> \n> 答：因为如果允许所有 Broker 都可以处理读写请求，就可能产生数据一致性问题。\n\n# Kafka 选举 Leader\n\n由上文可知，Partition 在多个 Broker 上存在副本。\n\n如果某个 Follower 宕机，啥事儿没有，正常工作。\n\n如果 Leader 宕机了，会从 Follower 中重新选举一个新的 Leader。\n\n\n# 5. 主流 MQ\n\n\n# 5.1. ActiveMQ\n\nActiveMQ 是由 Apache 出品，ActiveMQ 是一个完全支持JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现。它非常快速，支持 多种语言的客户端 和 协议，而且可以非常容易的嵌入到企业的应用环境中，并有许多高级功能。\n\n\n\n# (a) 主要特性\n\n 1. 服从 JMS 规范：JMS 规范提供了良好的标准和保证，包括：同步 或 异步 的消息分发，一次和仅一次的消息分发，消息接收 和 订阅 等等。遵从 JMS 规范的好处在于，不论使用什么 JMS 实现提供者，这些基础特性都是可用的；\n 2. 连接灵活性：ActiveMQ 提供了广泛的 连接协议，支持的协议有：HTTP/S，IP 多播，SSL，TCP，UDP 等等。对众多协议的支持让 ActiveMQ 拥有了很好的灵活性；\n 3. 支持的协议种类多：OpenWire、STOMP、REST、XMPP、AMQP；\n 4. 持久化插件和安全插件：ActiveMQ 提供了 多种持久化 选择。而且，ActiveMQ 的安全性也可以完全依据用户需求进行 自定义鉴权 和 授权；\n 5. 支持的客户端语言种类多：除了 Java 之外，还有：C/C++，.NET，Perl，PHP，Python，Ruby；\n 6. 代理集群：多个 ActiveMQ 代理 可以组成一个 集群 来提供服务；\n 7. 异常简单的管理：ActiveMQ 是以开发者思维被设计的。所以，它并不需要专门的管理员，因为它提供了简单又使用的管理特性。有很多中方法可以 监控 ActiveMQ 不同层面的数据，包括使用在 JConsole 或者在 ActiveMQ 的 Web Console 中使用 JMX。通过处理 JMX 的告警消息，通过使用 命令行脚本，甚至可以通过监控各种类型的 日志。\n\n# (b) 部署环境\n\nActiveMQ 可以运行在 Java 语言所支持的平台之上。使用 ActiveMQ 需要：\n\n * Java JDK\n * ActiveMQ 安装包\n\n# (c) 优点\n\n 1. 跨平台 (JAVA 编写与平台无关，ActiveMQ 几乎可以运行在任何的 JVM 上)；\n 2. 可以用 JDBC：可以将 数据持久化 到数据库。虽然使用 JDBC 会降低 ActiveMQ 的性能，但是数据库一直都是开发人员最熟悉的存储介质；\n 3. 支持 JMS 规范：支持 JMS 规范提供的 统一接口;\n 4. 支持 自动重连 和 错误重试机制；\n 5. 有安全机制：支持基于 shiro，jaas 等多种 安全配置机制，可以对 Queue/Topic 进行 认证和授权；\n 6. 监控完善：拥有完善的 监控，包括 Web Console，JMX，Shell 命令行，Jolokia 的 RESTful API；\n 7. 界面友善：提供的 Web Console 可以满足大部分情况，还有很多 第三方的组件 可以使用，比如 hawtio；\n\n# (d) 缺点\n\n 1. 社区活跃度不及 RabbitMQ 高；\n 2. 根据其他用户反馈，会出莫名其妙的问题，会 丢失消息；\n 3. 目前重心放到 activemq 6.0 产品 Apollo，对 5.x 的维护较少；\n 4. 不适合用于 上千个队列 的应用场景；\n\n\n# 5.2. RabbitMQ\n\nRabbitMQ 于 2007 年发布，是一个在 AMQP (高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。\n\n\n\n# (a) 主要特性\n\n 1. 可靠性：提供了多种技术可以让你在 性能 和 可靠性 之间进行 权衡。这些技术包括 持久性机制、投递确认、发布者证实 和 高可用性机制；\n 2. 灵活的路由：消息在到达队列前是通过 交换机 进行 路由 的。RabbitMQ 为典型的路由逻辑提供了 多种内置交换机 类型。如果你有更复杂的路由需求，可以将这些交换机组合起来使用，你甚至可以实现自己的交换机类型，并且当做 RabbitMQ 的 插件 来使用；\n 3. 消息集群：在相同局域网中的多个 RabbitMQ 服务器可以 聚合 在一起，作为一个独立的逻辑代理来使用；\n 4. 队列高可用：队列可以在集群中的机器上 进行镜像，以确保在硬件问题下还保证 消息安全；\n 5. 支持多种协议：支持 多种消息队列协议；\n 6. 支持多种语言：用 Erlang 语言编写，支持只要是你能想到的 所有编程语言；\n 7. 管理界面： RabbitMQ 有一个易用的 用户界面，使得用户可以 监控 和 管理 消息 Broker 的许多方面；\n 8. 跟踪机制：如果 消息异常，RabbitMQ 提供消息跟踪机制，使用者可以找出发生了什么；\n 9. 插件机制：提供了许多 插件，来从多方面进行扩展，也可以编写自己的插件。\n\n# (b) 部署环境\n\nRabbitMQ 可以运行在 Erlang 语言所支持的平台之上，包括 Solaris，BSD，Linux，MacOSX，TRU64，Windows 等。使用 RabbitMQ 需要：\n\n * ErLang 语言包\n * RabbitMQ 安装包\n\n# (c) 优点\n\n 1. 由于 Erlang 语言的特性，消息队列性能较好，支持 高并发；\n 2. 健壮、稳定、易用、跨平台、支持 多种语言、文档齐全；\n 3. 有消息 确认机制 和 持久化机制，可靠性高；\n 4. 高度可定制的 路由；\n 5. 管理界面 较丰富，在互联网公司也有较大规模的应用，社区活跃度高。\n\n# (d) 缺点\n\n 1. 尽管结合 Erlang 语言本身的并发优势，性能较好，但是不利于做 二次开发和维护；\n 2. 实现了 代理架构，意味着消息在发送到客户端之前可以在 中央节点 上排队。此特性使得 RabbitMQ 易于使用和部署，但是使得其 运行速度较慢，因为中央节点 增加了延迟，消息封装后 也比较大；\n 3. 需要学习 比较复杂 的 接口和协议，学习和维护成本较高。\n\n\n# 5.3. RocketMQ\n\nRocketMQ 出自 阿里 的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进，消息可靠性上 比 Kafka 更好。RocketMQ 在阿里内部 \b 被广泛应用在 订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发 等场景。\n\n# (a) 主要特性\n\n![img](data:image/svg+xml;utf8,)\n\n 1. 基于 队列模型：具有 高性能、高可靠、高实时、分布式 等特点；\n 2. Producer、Consumer、队列 都支持 分布式；\n 3. Producer 向一些队列轮流发送消息，队列集合 称为 Topic。Consumer 如果做 广播消费，则一个 Consumer 实例消费这个 Topic 对应的 所有队列；如果做 集群消费，则 多个 Consumer 实例 平均消费 这个 Topic 对应的队列集合；\n 4. 能够保证 严格的消息顺序；\n 5. 提供丰富的 消息拉取模式；\n 6. 高效的订阅者 水平扩展能力；\n 7. 实时 的 消息订阅机制；\n 8. 亿级 消息堆积 能力；\n 9. 较少的外部依赖。\n\n# (b) 部署环境\n\nRocketMQ 可以运行在 Java 语言所支持的平台之上。使用 RocketMQ 需要：\n\n * Java JDK\n * 安装 git、Maven\n * RocketMQ 安装包\n\n# (c) 优点\n\n 1. 单机 支持 1 万以上 持久化队列；\n 2. RocketMQ 的所有消息都是 持久化的，先写入系统 PAGECACHE，然后 刷盘，可以保证 内存 与 磁盘 都有一份数据，而 访问 时，直接 从内存读取。\n 3. 模型简单，接口易用（JMS 的接口很多场合并不太实用）；\n 4. 性能非常好，可以允许 大量堆积消息 在 Broker 中；\n 5. 支持 多种消费模式，包括 集群消费、广播消费等；\n 6. 各个环节 分布式扩展设计，支持 主从 和 高可用；\n 7. 开发度较活跃，版本更新很快。\n\n# (d) 缺点\n\n 1. 支持的 客户端语言 不多，目前是 Java 及 C++，其中 C++ 还不成熟；\n 2. RocketMQ 社区关注度及成熟度也不及前两者；\n 3. 没有 Web 管理界面，提供了一个 CLI (命令行界面) 管理工具带来 查询、管理 和 诊断各种问题；\n 4. 没有在 MQ 核心里实现 JMS 等接口；\n\n\n# 5.4. Kafka\n\nApache Kafka 是一个 分布式消息发布订阅 系统。它最初由 LinkedIn 公司基于独特的设计实现为一个 分布式的日志提交系统 (a distributed commit log)，之后成为 Apache 项目的一部分。Kafka 性能高效、可扩展良好 并且 可持久化。它的 分区特性，可复制 和 可容错 都是其不错的特性。\n\n# (a) 主要特性\n\n 1. 快速持久化：可以在 O(1) 的系统开销下进行 消息持久化；\n 2. 高吞吐：在一台普通的服务器上既可以达到 10W/s 的 吞吐速率；\n 3. 完全的分布式系统：Broker、Producer 和 Consumer 都原生自动支持 分布式，自动实现 负载均衡；\n 4. 支持 同步 和 异步 复制两种 高可用机制；\n 5. 支持 数据批量发送 和 拉取；\n 6. 零拷贝技术(zero-copy)：减少 IO 操作步骤，提高 系统吞吐量；\n 7. 数据迁移、扩容 对用户透明；\n 8. 无需停机 即可扩展机器；\n 9. 其他特性：丰富的 消息拉取模型、高效 订阅者水平扩展、实时的 消息订阅、亿级的 消息堆积能力、定期删除机制；\n\n# (b) 部署环境\n\n使用 Kafka 需要：\n\n * Java JDK\n * Kafka 安装包\n\n# (c) 优点\n\n 1. 客户端语言丰富：支持 Java、.Net、PHP、Ruby、Python、Go 等多种语言；\n 2. 高性能：单机写入 TPS 约在 100 万条/秒，消息大小 10 个字节；\n 3. 提供 完全分布式架构，并有 replica 机制，拥有较高的 可用性 和 可靠性，理论上支持 消息无限堆积；\n 4. 支持批量操作；\n 5. 消费者 采用 Pull 方式获取消息。消息有序，通过控制 能够保证所有消息被消费且仅被消费 一次；\n 6. 有优秀的第三方 Kafka Web 管理界面 Kafka-Manager；\n 7. 在 日志领域 比较成熟，被多家公司和多个开源项目使用。\n\n# (d) 缺点\n\n 1. Kafka 单机超过 64 个 队列/分区 时，Load 时会发生明显的飙高现象。队列 越多，负载 越高，发送消息 响应时间变长；\n 2. 使用 短轮询方式，实时性 取决于 轮询间隔时间；\n 3. 消费失败 不支持重试；\n 4. 支持 消息顺序，但是 一台代理宕机 后，就会产生 消息乱序；\n 5. 社区更新较慢。\n\n\n# 5.5. MQ 的技术选型\n\nMQ 的技术选型一般要考虑以下几点：\n\n * 是否开源：这决定了能否商用，所以最为重要。\n * 社区活跃度越高越好：高社区活跃度，一般保证了低 Bug 率，因为大部分 Bug，已经有人遇到并解决了。\n * 技术生态适配性：客户端对各种编程语言的支持。比如：如果使用 MQ 的都是 Java 应用，那么 ActiveMQ、RabbitMQ、RocketMQ、Kafka 都可以。如果需要支持其他语言，那么 RMQ 比较合适，因为它支持的编程语言比较丰富。如果 MQ 是应用于大数据或流式计算，那么 Kafka 几乎是标配。如果是应用于在线业务系统，那么 Kafka 就不合适了，可以考虑 RabbitMQ、 RocketMQ 很合适。\n * 高可用性：应用于线上的准入标准。\n * 性能：具备足够好的性能，能满足绝大多数场景的性能要求。\n\n特性                ACTIVEMQ                     RABBITMQ                        ROCKETMQ                                      KAFKA\n单机吞吐量             万级，比 RocketMQ、Kafka 低一个数量级   同 ActiveMQ                      10 万级，支撑高吞吐                                   10 万级，高吞吐，一般配合大数据类的系统来进行流式计算、日志采集等场景\ntopic 数量对吞吐量的影响                                                                topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ   topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic\n                                                                               的一大优势，在同等机器下，可以支撑大量的 topic                    数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源\n时效性               ms 级                         微秒级，这是 RabbitMQ 的一大特点，延迟最低      ms 级                                          延迟在 ms 级以内\n可用性               高，基于主从架构实现高可用                同 ActiveMQ                      非常高，分布式架构                                     非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用\n消息可靠性             有较低的概率丢失数据                   基本不丢                            经过参数优化配置，可以做到 0 丢失                            同 RocketMQ\n功能支持              MQ 领域的功能极其完备                 基于 erlang 开发，并发能力很强，性能极好，延时很低   MQ 功能较为完善，还是分布式的，扩展性好                         功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用\n\n综上，各种对比之后，有如下建议：\n\n * 业务系统场景，建议使用 RocketMQ、RabbitMQ。如果所有应用都是 Java，优选 RocketMQ，因为 RocketMQ 本身就是 Java 开发的，所以最适配。如果业务中有多种编程语言的应用，建议选择 RabbitMQ。\n * 大数据和流式计算领域，或是作为日志缓冲，强烈建议选择 Kafka，业界标准，久经考验。\n\n\n# 6. JMS\n\n提到 MQ，就顺便提一下 JMS 。\n\nJMS（JAVA Message Service，java 消息服务）API 是一个消息服务的标准/规范，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。\n\n在 EJB 架构中，有消息 bean 可以无缝的与 JMS 消息服务集成。在 J2EE 架构模式中，有消息服务者模式，用于实现消息与应用直接的解耦。\n\n\n# 6.1. 消息模型\n\n在 JMS 标准中，有两种消息模型：\n\n * P2P(Point to Point)\n * Pub/Sub(Publish/Subscribe)\n\n# P2P 模式\n\n\nP2P 模式包含三个角色：MQ（Queue），发送者(Sender)，接收者(Receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。\n\nP2P 的特点\n\n * 每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在 MQ 中)\n * 发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列\n * 接收者在成功接收消息之后需向队列应答成功\n\n如果希望发送的每个消息都会被成功处理的话，那么需要 P2P 模式。\n\n# Pub/sub 模式\n\n\n包含三个角色主题（Topic），发布者（Publisher），订阅者（Subscriber） 。多个发布者将消息发送到 Topic,系统将这些消息传递给多个订阅者。\n\nPub/Sub 的特点\n\n * 每个消息可以有多个消费者\n * 发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。\n * 为了消费消息，订阅者必须保持运行的状态。\n\n为了缓和这样严格的时间相关性，JMS 允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。\n\n如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用 Pub/Sub 模型。\n\n\n# 6.2. 消息消费\n\n在 JMS 中，消息的产生和消费都是异步的。对于消费来说，JMS 的消息者可以通过两种方式来消费消息。\n\n * 同步 - 订阅者或接收者通过 receive 方法来接收消息，receive 方法在接收到消息之前（或超时之前）将一直阻塞；\n * 异步 - 订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的 onMessage 方法。\n\nJNDI - Java 命名和目录接口,是一种标准的 Java 命名系统接口。可以在网络上查找和访问服务。通过指定一个资源名称，该名称对应于数据库或命名服务中的一个记录，同时返回资源连接建立所必须的信息。\n\nJNDI 在 JMS 中起到查找和访问发送目标或消息来源的作用。\n\n\n# 6.3. JMS 编程模型\n\n# ConnectionFactory\n\n创建 Connection 对象的工厂，针对两种不同的 jms 消息模型，分别有 QueueConnectionFactory 和 TopicConnectionFactory 两种。可以通过 JNDI 来查找 ConnectionFactory 对象。\n\n# Destination\n\nDestination 的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的 Destination 是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的 Destination 也是某个队列或主题（即消息来源）。\n\n所以，Destination 实际上就是两种类型的对象：Queue、Topic。可以通过 JNDI 来查找 Destination。\n\n# Connection\n\nConnection 表示在客户端和 JMS 系统之间建立的链接（对 TCP/IP socket 的包装）。Connection 可以产生一个或多个 Session。跟 ConnectionFactory 一样，Connection 也有两种类型：QueueConnection 和 TopicConnection。\n\n# Session\n\nSession 是操作消息的接口。可以通过 session 创建生产者、消费者、消息等。Session 提供了事务的功能。当需要使用 session 发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分 QueueSession 和 TopicSession。\n\n# 消息的生产者\n\n消息生产者由 Session 创建，并用于将消息发送到 Destination。同样，消息生产者分两种类型：QueueSender 和 TopicPublisher。可以调用消息生产者的方法（send 或 publish 方法）发送消息。\n\n# 消息消费者\n\n消息消费者由 Session 创建，用于接收被发送到 Destination 的消息。两种类型：QueueReceiver 和 TopicSubscriber。可分别通过 session 的 createReceiver(Queue)或 createSubscriber(Topic)来创建。当然，也可以 session 的 creatDurableSubscriber 方法来创建持久化的订阅者。\n\n# MessageListener\n\n消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的 onMessage 方法。EJB 中的 MDB（Message-Driven Bean）就是一种 MessageListener。\n\n\n# 7. 参考资料\n\n * 大型网站架构系列：分布式 MQ（一）\n * 大型网站架构系列：MQ（二）\n * 分布式开放 MQ(RocketMQ)的原理与实践\n * 阿里 RocketMQ 优势对比\n * advanced-java 之 MQ\n * 浅谈消息队列及常见的消息中间件',normalizedContent:'# 消息队列基本原理\n\n> 📦 本文已归档到：「blog」\n> \n> 消息队列（message queue，简称 mq）技术是应用间交换信息的一种技术。\n> \n> 消息队列主要解决异步处理、应用间耦合，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。\n> \n> 目前主流的 mq 有：kafka、rabbitmq、rocketmq、activemq，而部分数据库如 redis、mysql 以及 phxsql 也可实现消息队列的功能。\n> \n> 注意：为了简便，下文中除了文章标题，一律使用 mq 简称。\n\n\n# 1. mq 的简介\n\n\n# 1.1. 什么是 mq\n\n消息队列（message queue，简称 mq）技术是应用间交换信息的一种技术。\n\n消息队列主要解决应用耦合，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。是大型分布式系统不可缺少的中间件。\n\nmq 是消费-生产者模型的一个典型的代表，一端往消息队列中不断写入消息，而另一端则可以读取队列中的消息。消息发布者只管把消息发布到 mq 中而不用管谁来取，消息使用者只管从 mq 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。\n\nmq 的数据可驻留在内存或磁盘上，直到它们被应用程序读取。通过 mq，应用程序可独立地执行，它们不需要知道彼此的位置，不需要等待接收程序接收此消息。在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。\n\n目前主流的 mq 有：kafka、rabbitmq、rocketmq、activemq。\n\n\n# 1.2. mq 通信模型\n\nmq 通信模型大致有以下类型：\n\n * 点对点 - 点对点方式是最为传统和常见的通讯方式，它支持一对一、一对多、多对多、多对一等多种配置方式，支持树状、网状等多种拓扑结构。\n * 多点广播 - mq 适用于不同类型的应用。其中重要的，也是正在发展中的是"多点广播"应用，即能够将消息发送到多个目标站点 (destination list)。可以使用一条 mq 指令将单一消息发送到多个目标站点，并确保为每一站点可靠地提供信息。mq 不仅提供了多点广播的功能，而且还拥有智能消息分发功能，在将一条消息发送到同一系统上的多个用户时，mq 将消息的一个复制版本和该系统上接收者的名单发送到目标 mq 系统。目标 mq 系统在本地复制这些消息，并将它们发送到名单上的队列，从而尽可能减少网络的传输量。\n * 发布/订阅 (publish/subscribe) - 发布/订阅模式使消息的分发可以突破目的队列地理位置的限制，使消息按照特定的主题甚至内容进行分发，用户或应用程序可以根据主题或内容接收到所需要的消息。发布/订阅模式使得发送者和接收者之间的耦合关系变得更为松散，发送者不必关心接收者的目的地址，而接收者也不必关心消息的发送地址，而只是根据消息的主题进行消息的收发。\n * 集群 (cluster) - 为了简化点对点通讯模式中的系统配置，mq 提供 cluster(集群) 的解决方案。集群类似于一个域 (domain)，集群内部的队列管理器之间通讯时，不需要两两之间建立消息通道，而是采用集群 (cluster) 通道与其它成员通讯，从而大大简化了系统配置。此外，集群中的队列管理器之间能够自动进行负载均衡，当某一队列管理器出现故障时，其它队列管理器可以接管它的工作，从而大大提高系统的高可靠性。\n\n\n# 2. mq 的应用\n\n\n# 2.1. 异步处理\n\n> mq 可以将系统间的处理流程异步化，减少等待响应的时间，从而提高整体并发吞吐量。\n> \n> 一般，mq 异步处理应用于非核心流程，例如：短信/邮件通知、数据推送、上报数据到监控中心/日志中心等。\n\n假设这样一个场景，用户向系统 a 发起请求，系统 a 处理计算只需要 10 ms，然后通知系统 bcd 写库，系统 bcd 写库耗时分别为：100ms、200ms、300ms。最终总耗时为： 10+100ms+200ms+300ms=610ms。此外，加上请求和响应的网络传输时间，从用户角度看，可能要等待将近 1s 才能得到结果。\n\n\n\n如果使用 mq，系统 a 接到请求后，耗时 10ms 处理计算，然后向系统 bcd 连续发送消息，假设耗时 5ms。那么 这一过程的总耗时为 3ms + 5ms = 8ms，这相比于 610 ms，大大缩短了响应时间。至于系统 bcd 的写库操作，只要自行消费 mq 后处理即可，用户无需关注。\n\n\n\n\n# 2.2. 系统解耦\n\n> 通过 mq，可以消除系统间的强耦合。它的好处在于：\n> \n>  * 消息的消费者系统可以随意增加，无需修改生产者系统的代码。\n>  * 生产者系统、消费者系统彼此不会影响对方的流程。\n>    * 如果生产者系统宕机，消费者系统收不到消息，就不会有下一步的动作。\n>    * 如果消费者系统宕机，生产者系统让然可以正常发送消息，不影响流程。\n\n不同系统如果要建立通信，传统的做法是：调用接口。\n\n如果需要和新的系统建立通信或删除已建立的通信，都需要修改代码，这种方案显然耦合度很高。\n\n\n\n如果使用 mq，系统间的通信只需要通过发布/订阅（pub/sub）模型即可，彼此没有直接联系，也就不需要相互感知，从而达到 解耦。\n\n\n\n\n# 2.3. 流量削峰\n\n> 当 上下游系统 处理能力存在差距的时候，利用 mq 做一个 “漏斗” 模型，进行 流控。把 mq 当成可靠的 消息暂存地，进行一定程度的 消息堆积；在下游有能力处理的时候，再发送消息。\n> \n> mq 的流量削峰常用于高并发场景（例如：秒杀、团抢等业务场景），它是缓解瞬时暴增流量的核心手段之一。\n> \n> 如果没有 mq，两个系统之间通过 协商、滑动窗口、限流/降级/熔断 等复杂的方案也能实现 流控。但 系统复杂性 指数级增长，势必在上游或者下游做存储，并且要处理 定时、拥塞 等一系列问题。而且每当有 处理能力有差距 的时候，都需要 单独 开发一套逻辑来维护这套逻辑。\n\n假设某个系统读写数据库的稳定性能为每秒处理 1000 条数据。平常情况下，远远达不到这么大的处理量。假设，因为因为做活动，系统的瞬时请求量剧增，达到每秒 10000 个并发请求，数据库根本承受不了，可能直接就把数据库给整崩溃了，这样系统服务就不可用了。\n\n\n\n如果使用 mq，每秒写入 10000 条请求，但是系统 a 每秒只从 mq 中消费 1000 条请求，然后写入数据库。这样，就不会超过数据库的承受能力，而是把请求积压在 mq 中。只要高峰期一过，系统 a 就会很快把积压的消息给处理掉。\n\n\n\n\n# 2.4. 传输缓冲\n\n（1）mq 常被用于做海量数据的传输缓冲。\n\n例如，kafka 常被用于做为各种日志数据、采集数据的数据中转。然后，kafka 将数据转发给 logstash、elasticsearch 中，然后基于 elasticsearch 来做日志中心，提供检索、聚合、分析日志的能力。开发者可以通过 kibana 集成 elasticsearch 数据进行可视化展示，或自行进行定制化开发。\n\n\n\n（2）mq 也可以被用于流式处理。\n\n例如，kafka 几乎已经是流计算的数据采集端的标准组件。而流计算通过实时数据处理能力，提供了更为快捷的聚合计算能力，被大量应用于链路监控、实时监控、实时数仓、实时大屏、风控、推荐等应用领域。\n\n\n# 2.5. 最终一致性\n\n最终一致性 不是 消息队列 的必备特性，但确实可以依靠 消息队列 来做 最终一致性 的事情。\n\n * 先写消息再操作，确保操作完成后再修改消息状态。定时任务补偿机制 实现消息 可靠发送接收、业务操作的可靠执行，要注意 消息重复 与 幂等设计。\n * 所有不保证 100% 不丢消息 的消息队列，理论上无法实现 最终一致性。\n\n> 像 kafka 一类的设计，在设计层面上就有 丢消息 的可能（比如 定时刷盘，如果掉电就会丢消息）。哪怕只丢千分之一的消息，业务也必须用其他的手段来保证结果正确。\n\n\n# 2.6. 系统间通信\n\n消息队列一般都内置了 高效的通信机制，因此也可以用于单纯的 消息通讯，比如实现 点对点消息队列 或者 聊天室 等。\n\n生产者/消费者 模式，只需要关心消息是否 送达队列，至于谁希望订阅和需要消费，是 下游 的事情，无疑极大地减少了开发和联调的工作量。\n\n\n# 3. mq 的问题\n\n任何技术都会有利有弊，mq 给整体系统架构带来很多好处，但也会付出一定的代价。\n\nmq 主要引入了以下问题：\n\n * 系统可用性降低：引入了 mq 后，通信需要基于 mq 完成，如果 mq 宕机，则服务不可用。因此，mq 要保证是高可用的，详情参考：mq 的高可用\n * 系统复杂度提高：使用 mq，需要关注一些新的问题：\n   * 如何保证消息没有 重复消费？\n   * 如何处理 消息丢失 的问题？\n   * 如何保证传递 消息的顺序性？\n   * 如何处理大量 消息积压 的问题？\n * 一致性问题：假设系统 a 处理完直接返回成功的结果给用户，用户认为请求成功。但如果此时，系统 bcd 中只要有任意一个写库失败，那么数据就不一致了。这种情况如何处理？\n\n下面，我们针对以上问题来一一分析。\n\n\n# 3.1. 重复消费\n\n如何保证消息不被重复消费 和 如何保证消息消费的幂等性 是同一个问题。\n\n必须先明确产生重复消费的原因，才能对症下药。\n\n# 重复消费问题原因\n\n重复消费问题通常不是 mq 来处理，而是由开发来处理的。\n\n以 kafka 举例，kafka 每个 partition 都是一个有序的、不可变的记录序列，不断追加到结构化的提交日志中。partition 中为每条记录分配一个连续的 id 号，称为偏移量（offset），用于唯一标识 partition 内的记录。\n\nkafka 的客户端和 broker 都会保存 offset。客户端消费消息后，每隔一段时间，就把已消费的 offset 提交给 kafka broker，表示已消费。\n\n\n\n在这个过程中，如果客户端应用消费消息后，因为宕机、重启等情况而没有提交已消费的 offset 。当系统恢复后，会继续消费消息，由于 offset 未提交，就会出现重复消费的问题。\n\n# 重复消费解决方案\n\n应对重复消费问题，需要在业务层面，通过 幂等性设计 来解决。\n\nmq 重复消费不可怕，可怕的是没有应对机制，可以借鉴的思路有：\n\n * 如果是写关系型数据库，可以先根据主键查询，判断数据是否已存在，存在则更新，不存在则插入；\n * 如果是写 redis，由于 set 操作天然具有幂等性，所以什么都不用做；\n * 如果是根据消息做较复杂的逻辑处理，可以在消息中加入全局唯一 id，例如：订单 id 等。在客户端存储中（mysql、redis 等）保存已消费消息的 id。一旦接受到新消息，先判断消息中的 id 是否在已消费消息 id 表中存在，存在则不再处理，不存在则处理。\n\n在实际开发中，可以参考上面的例子，结合现实场景，设计合理的幂等性方案。\n\n\n# 3.2. 消息丢失\n\n如何处理消息丢失的问题 和 如何保证消息不被重复消费 是同一个问题。关注点有：\n\n * mq server 丢失数据\n * 消费方丢失数据\n * 生产方丢失数据\n\n# 消费方丢失数据\n\n唯一可能导致消费方丢失数据的情况是：消费方设置了自动提交 offset。一旦设置了自动提交 offset，接受到消息后就会自动提交 offset 给 kafka ，kafka 就认为消息已被消费。如果此时，消费方尚未来得及处理消息就挂了，那么消息就丢了。\n\n解决方法就是：消费方关闭自动提交 offset，处理完消息后手动提交 offset。但这种情况下可能会出现重复消费的情形，需要自行保证幂等性。\n\n# kafka server 丢失数据\n\n当 kafka 某个 broker 宕机，需要重新选举 partition 的 leader。若此时其他的 follower 尚未同步 leader 的数据，那么新选某个 follower 为 leader 后，就丢失了部分数据。\n\n为此，一般要求至少设置 4 个参数：\n\n * 给 topic 设置 replication.factor 参数 - 这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。\n * 在 kafka 服务端设置 min.insync.replicas 参数 - 这个值必须大于 1，这是要求一个 leader 需要和至少一个 follower 保持通信，这样才能确保 leader 挂了还有替补。\n * 在 producer 端设置 acks=all - 这意味着：要求每条数据，必须是写入所有 replica 之后，才能认为写入成功了。\n * 在 producer 端设置 retries=max（很大很大很大的一个值，无限次重试的意思） - 这意味着要求一旦写入失败，就无限重试，卡在这里了。\n\n# 生产方丢失数据\n\n如果按照上述的思路设置了 acks=all，生产方一定不会丢数据。\n\n要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本生产消息成功了。如果未满足这个条件，生产者会自动不断的重试，重试无限次。\n\n\n# 3.3. 消息的顺序性\n\n要保证 mq 的顺序性，势必要付出一定的代价，所以实施方案前，要先明确业务场景是不是有必要保证消息的顺序性。只有那些明确对消息处理顺序有要求的业务场景才值得去保证消息顺序性。\n\n方案一\n\n一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。\n\n方案二\n\n * 写入数据到 partition 时指定一个全局唯一的 id，例如订单 id。发送方保证相同 id 的消息有序的发送到同一个 partition。\n * 基于上一点，消费方从 kafka partition 中消费消息时，此刻一定是顺序的。但如果消费方式以并发方式消费消息，顺序就可能会被打乱。为此，还有做到以下几点：\n   * 消费方维护 n 个缓存队列，具有相同 id 的数据都写入同一个队列中；\n   * 创建 n 个线程，每个线程只负责从指定的一个队列中取数据。\n\n\n\n\n# 3.4. 消息积压\n\n假设一个 mq 消费者可以一秒处理 1000 条消息，三个 mq 消费者可以一秒处理 3000 条消息，那么一分钟的处理量是 18 万条。如果 mq 中积压了几百万到上千万的数据，即使消费者恢复了，也需要大概很长的时间才能恢复过来。\n\n对于产线环境来说，漫长的等待是不可接受的，所以面临这种窘境时，只能临时紧急扩容以应对了，具体操作步骤和思路如下：\n\n * 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。\n * 新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。\n * 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。\n * 接着临时征用 10 倍的机器来部署 consumer ，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。\n * 等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。\n\n\n# 4. mq 的高可用\n\n不同 mq 实现高可用的原理各不相同。因为 kafka 比较具有代表性，所以这里以 kafka 为例。\n\n\n# 4.1. kafka 的高可用\n\n# kafka 的核心概念\n\n了解 kafka，必须先了解 kafka 的核心概念：\n\n * broker - kafka 集群包含一个或多个节点，这种节点被称为 broker。\n\n * topic - 每条发布到 kafka 集群的消息都有一个类别，这个类别被称为 topic。（不同 topic 的消息是物理隔离的；同一个 topic 的消息保存在一个或多个 broker 上，但用户只需指定消息的 topic 即可生产或消费数据而不必关心数据存于何处）。对于每一个 topic， kafka 集群都会维持一个分区日志。\n\n * partition - 了提高 kafka 的吞吐率，每个 topic 包含一个或多个 partition，每个 partition 在物理上对应一个文件夹，该文件夹下存储这个 partition 的所有消息和索引文件。\n   \n   * kafka 日志的分区（partition）分布在 kafka 集群的节点上。每个节点在处理数据和请求时，共享这些分区。每一个分区都会在已配置的节点上进行备份，确保容错性。\n\n\n\n# kafka 的副本机制\n\nkafka 是如何实现高可用的呢？\n\nkafka 在 0.8 以前的版本中，如果一个 broker 宕机了，其上面的 partition 都不能用了，这自然不是高可用的。\n\n为了实现高可用，kafka 引入了复制功能。\n\n简单来说，就是副本机制（ replicate ）。\n\n每个 partition 都有一个 leader，零个或多个 follower。leader 和 follower 都是 broker，每个 broker 都会成为某些分区的 leader 和某些分区的 follower，因此集群的负载是平衡的。\n\n * leader 处理一切对 partition （分区）的读写请求；\n * 而 follower 只需被动的同步 leader 上的数据。\n\n同一个 topic 的不同 partition 会分布在多个 broker 上，而且一个 partition 还会在其他的 broker 上面进行备份，producer 在发布消息到某个 partition 时，先找到该 partition 的 leader，然后向这个 leader 推送消息；每个 follower 都从 leader 拉取消息，拉取消息成功之后，向 leader 发送一个 ack 确认。\n\n\n\n> faq\n> \n> 问：为什么让 leader 处理一切对对 partition （分区）的读写请求？\n> \n> 答：因为如果允许所有 broker 都可以处理读写请求，就可能产生数据一致性问题。\n\n# kafka 选举 leader\n\n由上文可知，partition 在多个 broker 上存在副本。\n\n如果某个 follower 宕机，啥事儿没有，正常工作。\n\n如果 leader 宕机了，会从 follower 中重新选举一个新的 leader。\n\n\n# 5. 主流 mq\n\n\n# 5.1. activemq\n\nactivemq 是由 apache 出品，activemq 是一个完全支持jms1.1 和 j2ee 1.4 规范的 jms provider 实现。它非常快速，支持 多种语言的客户端 和 协议，而且可以非常容易的嵌入到企业的应用环境中，并有许多高级功能。\n\n\n\n# (a) 主要特性\n\n 1. 服从 jms 规范：jms 规范提供了良好的标准和保证，包括：同步 或 异步 的消息分发，一次和仅一次的消息分发，消息接收 和 订阅 等等。遵从 jms 规范的好处在于，不论使用什么 jms 实现提供者，这些基础特性都是可用的；\n 2. 连接灵活性：activemq 提供了广泛的 连接协议，支持的协议有：http/s，ip 多播，ssl，tcp，udp 等等。对众多协议的支持让 activemq 拥有了很好的灵活性；\n 3. 支持的协议种类多：openwire、stomp、rest、xmpp、amqp；\n 4. 持久化插件和安全插件：activemq 提供了 多种持久化 选择。而且，activemq 的安全性也可以完全依据用户需求进行 自定义鉴权 和 授权；\n 5. 支持的客户端语言种类多：除了 java 之外，还有：c/c++，.net，perl，php，python，ruby；\n 6. 代理集群：多个 activemq 代理 可以组成一个 集群 来提供服务；\n 7. 异常简单的管理：activemq 是以开发者思维被设计的。所以，它并不需要专门的管理员，因为它提供了简单又使用的管理特性。有很多中方法可以 监控 activemq 不同层面的数据，包括使用在 jconsole 或者在 activemq 的 web console 中使用 jmx。通过处理 jmx 的告警消息，通过使用 命令行脚本，甚至可以通过监控各种类型的 日志。\n\n# (b) 部署环境\n\nactivemq 可以运行在 java 语言所支持的平台之上。使用 activemq 需要：\n\n * java jdk\n * activemq 安装包\n\n# (c) 优点\n\n 1. 跨平台 (java 编写与平台无关，activemq 几乎可以运行在任何的 jvm 上)；\n 2. 可以用 jdbc：可以将 数据持久化 到数据库。虽然使用 jdbc 会降低 activemq 的性能，但是数据库一直都是开发人员最熟悉的存储介质；\n 3. 支持 jms 规范：支持 jms 规范提供的 统一接口;\n 4. 支持 自动重连 和 错误重试机制；\n 5. 有安全机制：支持基于 shiro，jaas 等多种 安全配置机制，可以对 queue/topic 进行 认证和授权；\n 6. 监控完善：拥有完善的 监控，包括 web console，jmx，shell 命令行，jolokia 的 restful api；\n 7. 界面友善：提供的 web console 可以满足大部分情况，还有很多 第三方的组件 可以使用，比如 hawtio；\n\n# (d) 缺点\n\n 1. 社区活跃度不及 rabbitmq 高；\n 2. 根据其他用户反馈，会出莫名其妙的问题，会 丢失消息；\n 3. 目前重心放到 activemq 6.0 产品 apollo，对 5.x 的维护较少；\n 4. 不适合用于 上千个队列 的应用场景；\n\n\n# 5.2. rabbitmq\n\nrabbitmq 于 2007 年发布，是一个在 amqp (高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。\n\n\n\n# (a) 主要特性\n\n 1. 可靠性：提供了多种技术可以让你在 性能 和 可靠性 之间进行 权衡。这些技术包括 持久性机制、投递确认、发布者证实 和 高可用性机制；\n 2. 灵活的路由：消息在到达队列前是通过 交换机 进行 路由 的。rabbitmq 为典型的路由逻辑提供了 多种内置交换机 类型。如果你有更复杂的路由需求，可以将这些交换机组合起来使用，你甚至可以实现自己的交换机类型，并且当做 rabbitmq 的 插件 来使用；\n 3. 消息集群：在相同局域网中的多个 rabbitmq 服务器可以 聚合 在一起，作为一个独立的逻辑代理来使用；\n 4. 队列高可用：队列可以在集群中的机器上 进行镜像，以确保在硬件问题下还保证 消息安全；\n 5. 支持多种协议：支持 多种消息队列协议；\n 6. 支持多种语言：用 erlang 语言编写，支持只要是你能想到的 所有编程语言；\n 7. 管理界面： rabbitmq 有一个易用的 用户界面，使得用户可以 监控 和 管理 消息 broker 的许多方面；\n 8. 跟踪机制：如果 消息异常，rabbitmq 提供消息跟踪机制，使用者可以找出发生了什么；\n 9. 插件机制：提供了许多 插件，来从多方面进行扩展，也可以编写自己的插件。\n\n# (b) 部署环境\n\nrabbitmq 可以运行在 erlang 语言所支持的平台之上，包括 solaris，bsd，linux，macosx，tru64，windows 等。使用 rabbitmq 需要：\n\n * erlang 语言包\n * rabbitmq 安装包\n\n# (c) 优点\n\n 1. 由于 erlang 语言的特性，消息队列性能较好，支持 高并发；\n 2. 健壮、稳定、易用、跨平台、支持 多种语言、文档齐全；\n 3. 有消息 确认机制 和 持久化机制，可靠性高；\n 4. 高度可定制的 路由；\n 5. 管理界面 较丰富，在互联网公司也有较大规模的应用，社区活跃度高。\n\n# (d) 缺点\n\n 1. 尽管结合 erlang 语言本身的并发优势，性能较好，但是不利于做 二次开发和维护；\n 2. 实现了 代理架构，意味着消息在发送到客户端之前可以在 中央节点 上排队。此特性使得 rabbitmq 易于使用和部署，但是使得其 运行速度较慢，因为中央节点 增加了延迟，消息封装后 也比较大；\n 3. 需要学习 比较复杂 的 接口和协议，学习和维护成本较高。\n\n\n# 5.3. rocketmq\n\nrocketmq 出自 阿里 的开源产品，用 java 语言实现，在设计时参考了 kafka，并做出了自己的一些改进，消息可靠性上 比 kafka 更好。rocketmq 在阿里内部 \b 被广泛应用在 订单，交易，充值，流计算，消息推送，日志流式处理，binglog 分发 等场景。\n\n# (a) 主要特性\n\n![img](data:image/svg+xml;utf8,)\n\n 1. 基于 队列模型：具有 高性能、高可靠、高实时、分布式 等特点；\n 2. producer、consumer、队列 都支持 分布式；\n 3. producer 向一些队列轮流发送消息，队列集合 称为 topic。consumer 如果做 广播消费，则一个 consumer 实例消费这个 topic 对应的 所有队列；如果做 集群消费，则 多个 consumer 实例 平均消费 这个 topic 对应的队列集合；\n 4. 能够保证 严格的消息顺序；\n 5. 提供丰富的 消息拉取模式；\n 6. 高效的订阅者 水平扩展能力；\n 7. 实时 的 消息订阅机制；\n 8. 亿级 消息堆积 能力；\n 9. 较少的外部依赖。\n\n# (b) 部署环境\n\nrocketmq 可以运行在 java 语言所支持的平台之上。使用 rocketmq 需要：\n\n * java jdk\n * 安装 git、maven\n * rocketmq 安装包\n\n# (c) 优点\n\n 1. 单机 支持 1 万以上 持久化队列；\n 2. rocketmq 的所有消息都是 持久化的，先写入系统 pagecache，然后 刷盘，可以保证 内存 与 磁盘 都有一份数据，而 访问 时，直接 从内存读取。\n 3. 模型简单，接口易用（jms 的接口很多场合并不太实用）；\n 4. 性能非常好，可以允许 大量堆积消息 在 broker 中；\n 5. 支持 多种消费模式，包括 集群消费、广播消费等；\n 6. 各个环节 分布式扩展设计，支持 主从 和 高可用；\n 7. 开发度较活跃，版本更新很快。\n\n# (d) 缺点\n\n 1. 支持的 客户端语言 不多，目前是 java 及 c++，其中 c++ 还不成熟；\n 2. rocketmq 社区关注度及成熟度也不及前两者；\n 3. 没有 web 管理界面，提供了一个 cli (命令行界面) 管理工具带来 查询、管理 和 诊断各种问题；\n 4. 没有在 mq 核心里实现 jms 等接口；\n\n\n# 5.4. kafka\n\napache kafka 是一个 分布式消息发布订阅 系统。它最初由 linkedin 公司基于独特的设计实现为一个 分布式的日志提交系统 (a distributed commit log)，之后成为 apache 项目的一部分。kafka 性能高效、可扩展良好 并且 可持久化。它的 分区特性，可复制 和 可容错 都是其不错的特性。\n\n# (a) 主要特性\n\n 1. 快速持久化：可以在 o(1) 的系统开销下进行 消息持久化；\n 2. 高吞吐：在一台普通的服务器上既可以达到 10w/s 的 吞吐速率；\n 3. 完全的分布式系统：broker、producer 和 consumer 都原生自动支持 分布式，自动实现 负载均衡；\n 4. 支持 同步 和 异步 复制两种 高可用机制；\n 5. 支持 数据批量发送 和 拉取；\n 6. 零拷贝技术(zero-copy)：减少 io 操作步骤，提高 系统吞吐量；\n 7. 数据迁移、扩容 对用户透明；\n 8. 无需停机 即可扩展机器；\n 9. 其他特性：丰富的 消息拉取模型、高效 订阅者水平扩展、实时的 消息订阅、亿级的 消息堆积能力、定期删除机制；\n\n# (b) 部署环境\n\n使用 kafka 需要：\n\n * java jdk\n * kafka 安装包\n\n# (c) 优点\n\n 1. 客户端语言丰富：支持 java、.net、php、ruby、python、go 等多种语言；\n 2. 高性能：单机写入 tps 约在 100 万条/秒，消息大小 10 个字节；\n 3. 提供 完全分布式架构，并有 replica 机制，拥有较高的 可用性 和 可靠性，理论上支持 消息无限堆积；\n 4. 支持批量操作；\n 5. 消费者 采用 pull 方式获取消息。消息有序，通过控制 能够保证所有消息被消费且仅被消费 一次；\n 6. 有优秀的第三方 kafka web 管理界面 kafka-manager；\n 7. 在 日志领域 比较成熟，被多家公司和多个开源项目使用。\n\n# (d) 缺点\n\n 1. kafka 单机超过 64 个 队列/分区 时，load 时会发生明显的飙高现象。队列 越多，负载 越高，发送消息 响应时间变长；\n 2. 使用 短轮询方式，实时性 取决于 轮询间隔时间；\n 3. 消费失败 不支持重试；\n 4. 支持 消息顺序，但是 一台代理宕机 后，就会产生 消息乱序；\n 5. 社区更新较慢。\n\n\n# 5.5. mq 的技术选型\n\nmq 的技术选型一般要考虑以下几点：\n\n * 是否开源：这决定了能否商用，所以最为重要。\n * 社区活跃度越高越好：高社区活跃度，一般保证了低 bug 率，因为大部分 bug，已经有人遇到并解决了。\n * 技术生态适配性：客户端对各种编程语言的支持。比如：如果使用 mq 的都是 java 应用，那么 activemq、rabbitmq、rocketmq、kafka 都可以。如果需要支持其他语言，那么 rmq 比较合适，因为它支持的编程语言比较丰富。如果 mq 是应用于大数据或流式计算，那么 kafka 几乎是标配。如果是应用于在线业务系统，那么 kafka 就不合适了，可以考虑 rabbitmq、 rocketmq 很合适。\n * 高可用性：应用于线上的准入标准。\n * 性能：具备足够好的性能，能满足绝大多数场景的性能要求。\n\n特性                activemq                     rabbitmq                        rocketmq                                      kafka\n单机吞吐量             万级，比 rocketmq、kafka 低一个数量级   同 activemq                      10 万级，支撑高吞吐                                   10 万级，高吞吐，一般配合大数据类的系统来进行流式计算、日志采集等场景\ntopic 数量对吞吐量的影响                                                                topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 rocketmq   topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，kafka 尽量保证 topic\n                                                                               的一大优势，在同等机器下，可以支撑大量的 topic                    数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源\n时效性               ms 级                         微秒级，这是 rabbitmq 的一大特点，延迟最低      ms 级                                          延迟在 ms 级以内\n可用性               高，基于主从架构实现高可用                同 activemq                      非常高，分布式架构                                     非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用\n消息可靠性             有较低的概率丢失数据                   基本不丢                            经过参数优化配置，可以做到 0 丢失                            同 rocketmq\n功能支持              mq 领域的功能极其完备                 基于 erlang 开发，并发能力很强，性能极好，延时很低   mq 功能较为完善，还是分布式的，扩展性好                         功能较为简单，主要支持简单的 mq 功能，在大数据领域的实时计算以及日志采集被大规模使用\n\n综上，各种对比之后，有如下建议：\n\n * 业务系统场景，建议使用 rocketmq、rabbitmq。如果所有应用都是 java，优选 rocketmq，因为 rocketmq 本身就是 java 开发的，所以最适配。如果业务中有多种编程语言的应用，建议选择 rabbitmq。\n * 大数据和流式计算领域，或是作为日志缓冲，强烈建议选择 kafka，业界标准，久经考验。\n\n\n# 6. jms\n\n提到 mq，就顺便提一下 jms 。\n\njms（java message service，java 消息服务）api 是一个消息服务的标准/规范，允许应用程序组件基于 javaee 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。\n\n在 ejb 架构中，有消息 bean 可以无缝的与 jms 消息服务集成。在 j2ee 架构模式中，有消息服务者模式，用于实现消息与应用直接的解耦。\n\n\n# 6.1. 消息模型\n\n在 jms 标准中，有两种消息模型：\n\n * p2p(point to point)\n * pub/sub(publish/subscribe)\n\n# p2p 模式\n\n\np2p 模式包含三个角色：mq（queue），发送者(sender)，接收者(receiver)。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。\n\np2p 的特点\n\n * 每个消息只有一个消费者（consumer）(即一旦被消费，消息就不再在 mq 中)\n * 发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列\n * 接收者在成功接收消息之后需向队列应答成功\n\n如果希望发送的每个消息都会被成功处理的话，那么需要 p2p 模式。\n\n# pub/sub 模式\n\n\n包含三个角色主题（topic），发布者（publisher），订阅者（subscriber） 。多个发布者将消息发送到 topic,系统将这些消息传递给多个订阅者。\n\npub/sub 的特点\n\n * 每个消息可以有多个消费者\n * 发布者和订阅者之间有时间上的依赖性。针对某个主题（topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。\n * 为了消费消息，订阅者必须保持运行的状态。\n\n为了缓和这样严格的时间相关性，jms 允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。\n\n如果希望发送的消息可以不被做任何处理、或者只被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用 pub/sub 模型。\n\n\n# 6.2. 消息消费\n\n在 jms 中，消息的产生和消费都是异步的。对于消费来说，jms 的消息者可以通过两种方式来消费消息。\n\n * 同步 - 订阅者或接收者通过 receive 方法来接收消息，receive 方法在接收到消息之前（或超时之前）将一直阻塞；\n * 异步 - 订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的 onmessage 方法。\n\njndi - java 命名和目录接口,是一种标准的 java 命名系统接口。可以在网络上查找和访问服务。通过指定一个资源名称，该名称对应于数据库或命名服务中的一个记录，同时返回资源连接建立所必须的信息。\n\njndi 在 jms 中起到查找和访问发送目标或消息来源的作用。\n\n\n# 6.3. jms 编程模型\n\n# connectionfactory\n\n创建 connection 对象的工厂，针对两种不同的 jms 消息模型，分别有 queueconnectionfactory 和 topicconnectionfactory 两种。可以通过 jndi 来查找 connectionfactory 对象。\n\n# destination\n\ndestination 的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的 destination 是某个队列（queue）或某个主题（topic）;对于消息消费者来说，它的 destination 也是某个队列或主题（即消息来源）。\n\n所以，destination 实际上就是两种类型的对象：queue、topic。可以通过 jndi 来查找 destination。\n\n# connection\n\nconnection 表示在客户端和 jms 系统之间建立的链接（对 tcp/ip socket 的包装）。connection 可以产生一个或多个 session。跟 connectionfactory 一样，connection 也有两种类型：queueconnection 和 topicconnection。\n\n# session\n\nsession 是操作消息的接口。可以通过 session 创建生产者、消费者、消息等。session 提供了事务的功能。当需要使用 session 发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分 queuesession 和 topicsession。\n\n# 消息的生产者\n\n消息生产者由 session 创建，并用于将消息发送到 destination。同样，消息生产者分两种类型：queuesender 和 topicpublisher。可以调用消息生产者的方法（send 或 publish 方法）发送消息。\n\n# 消息消费者\n\n消息消费者由 session 创建，用于接收被发送到 destination 的消息。两种类型：queuereceiver 和 topicsubscriber。可分别通过 session 的 createreceiver(queue)或 createsubscriber(topic)来创建。当然，也可以 session 的 creatdurablesubscriber 方法来创建持久化的订阅者。\n\n# messagelistener\n\n消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的 onmessage 方法。ejb 中的 mdb（message-driven bean）就是一种 messagelistener。\n\n\n# 7. 参考资料\n\n * 大型网站架构系列：分布式 mq（一）\n * 大型网站架构系列：mq（二）\n * 分布式开放 mq(rocketmq)的原理与实践\n * 阿里 rocketmq 优势对比\n * advanced-java 之 mq\n * 浅谈消息队列及常见的消息中间件',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"服务注册和发现",frontmatter:{title:"服务注册和发现",categories:["分布式","分布式关键技术","服务治理"],tags:["分布式","服务治理","服务注册","服务发现","CAP"],abbrlink:"fd02eff6",date:"2022-04-18T19:34:47.000Z",permalink:"/pages/516f3b/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/05.%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/01.%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0.html",relativePath:"02.分布式/03.分布式关键技术/05.服务治理/01.服务注册和发现.md",key:"v-686da33c",path:"/pages/516f3b/",headers:[{level:2,title:"1. 服务元数据",slug:"_1-服务元数据",normalizedTitle:"1. 服务元数据",charIndex:14},{level:3,title:"1.1. REST API",slug:"_1-1-rest-api",normalizedTitle:"1.1. rest api",charIndex:280},{level:3,title:"1.2. XML 文件",slug:"_1-2-xml-文件",normalizedTitle:"1.2. xml 文件",charIndex:1466},{level:3,title:"1.3. IDL 文件",slug:"_1-3-idl-文件",normalizedTitle:"1.3. idl 文件",charIndex:3325},{level:2,title:"2. 服务注册和发现基本原理",slug:"_2-服务注册和发现基本原理",normalizedTitle:"2. 服务注册和发现基本原理",charIndex:5730},{level:3,title:"2.1. 应用内注册与发现",slug:"_2-1-应用内注册与发现",normalizedTitle:"2.1. 应用内注册与发现",charIndex:6169},{level:3,title:"2.2. 应用外注册与发现",slug:"_2-2-应用外注册与发现",normalizedTitle:"2.2. 应用外注册与发现",charIndex:6513},{level:2,title:"3. 注册中心基本功能",slug:"_3-注册中心基本功能",normalizedTitle:"3. 注册中心基本功能",charIndex:6880},{level:3,title:"3.1. 注册中心 API",slug:"_3-1-注册中心-api",normalizedTitle:"3.1. 注册中心 api",charIndex:7229},{level:3,title:"3.2. 集群部署",slug:"_3-2-集群部署",normalizedTitle:"3.2. 集群部署",charIndex:7578},{level:3,title:"3.3. 元数据存储",slug:"_3-3-元数据存储",normalizedTitle:"3.3. 元数据存储",charIndex:8e3},{level:3,title:"3.4. 白名单机制",slug:"_3-4-白名单机制",normalizedTitle:"3.4. 白名单机制",charIndex:8191},{level:2,title:"4. 服务健康检测",slug:"_4-服务健康检测",normalizedTitle:"4. 服务健康检测",charIndex:8564},{level:3,title:"4.1. 服务状态变更通知",slug:"_4-1-服务状态变更通知",normalizedTitle:"4.1. 服务状态变更通知",charIndex:9e3},{level:3,title:"4.2. 心跳开关保护机制",slug:"_4-2-心跳开关保护机制",normalizedTitle:"4.2. 心跳开关保护机制",charIndex:9280},{level:3,title:"4.3. 服务节点摘除保护机制",slug:"_4-3-服务节点摘除保护机制",normalizedTitle:"4.3. 服务节点摘除保护机制",charIndex:9812},{level:3,title:"4.4. 静态注册中心",slug:"_4-4-静态注册中心",normalizedTitle:"4.4. 静态注册中心",charIndex:10405},{level:2,title:"5. 注册中心选型",slug:"_5-注册中心选型",normalizedTitle:"5. 注册中心选型",charIndex:10622},{level:3,title:"5.1. 高可用性",slug:"_5-1-高可用性",normalizedTitle:"5.1. 高可用性",charIndex:10666},{level:3,title:"5.2. 数据一致性",slug:"_5-2-数据一致性",normalizedTitle:"5.2. 数据一致性",charIndex:10919},{level:2,title:"6. 服务发现的问题",slug:"_6-服务发现的问题",normalizedTitle:"6. 服务发现的问题",charIndex:10934},{level:3,title:"6.1. 多注册中心",slug:"_6-1-多注册中心",normalizedTitle:"6.1. 多注册中心",charIndex:10949},{level:3,title:"6.2. 并行订阅服务",slug:"_6-2-并行订阅服务",normalizedTitle:"6.2. 并行订阅服务",charIndex:11256},{level:3,title:"6.3. 批量注销服务",slug:"_6-3-批量注销服务",normalizedTitle:"6.3. 批量注销服务",charIndex:11594},{level:3,title:"6.4. 服务变更信息的增量更新",slug:"_6-4-服务变更信息的增量更新",normalizedTitle:"6.4. 服务变更信息的增量更新",charIndex:11883},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:12280}],headersStr:"1. 服务元数据 1.1. REST API 1.2. XML 文件 1.3. IDL 文件 2. 服务注册和发现基本原理 2.1. 应用内注册与发现 2.2. 应用外注册与发现 3. 注册中心基本功能 3.1. 注册中心 API 3.2. 集群部署 3.3. 元数据存储 3.4. 白名单机制 4. 服务健康检测 4.1. 服务状态变更通知 4.2. 心跳开关保护机制 4.3. 服务节点摘除保护机制 4.4. 静态注册中心 5. 注册中心选型 5.1. 高可用性 5.2. 数据一致性 6. 服务发现的问题 6.1. 多注册中心 6.2. 并行订阅服务 6.3. 批量注销服务 6.4. 服务变更信息的增量更新 7. 参考资料",content:'# 服务注册和发现\n\n\n# 1. 服务元数据\n\n构建微服务的首要问题是：服务提供者和服务消费者通信时，如何达成共识。具体来说，就是这个服务的接口名是什么？调用这个服务需要传递哪些参数？接口的返回值是什么类型？以及一些其他接口描述信息。\n\n服务的元数据信息通常有以下信息：\n\n * 服务节点信息，如 IP、端口等。\n * 接口定义，如接口名、请求参数、响应参数等。\n * 请求失败的重试次数\n * 序列化方式\n * 压缩方式\n * 通信协议\n * 等等\n\n常见的发布服务元数据的方式有：\n\n * REST API\n * XML 文件\n * IDL 文件\n\n\n# 1.1. REST API\n\n以 Eureka 为例\n\n服务提供者定义接口\n\n@RestController\npublic class ProviderController {\n\n    private final DiscoveryClient discoveryClient;\n\n    public ProviderController(DiscoveryClient discoveryClient) {\n        this.discoveryClient = discoveryClient;\n    }\n\n    @GetMapping("/send")\n    public String send() {\n        String services = "Services: " + discoveryClient.getServices();\n        System.out.println(services);\n        return services;\n    }\n\n}\n\n\n服务消费者消费接口\n\n@RestController\npublic class ConsumerController {\n\n    private final LoadBalancerClient loadBalancerClient;\n    private final RestTemplate restTemplate;\n\n    public ConsumerController(LoadBalancerClient loadBalancerClient,\n        RestTemplate restTemplate) {\n        this.loadBalancerClient = loadBalancerClient;\n        this.restTemplate = restTemplate;\n    }\n\n    @GetMapping("/recv")\n    public String recv() {\n        ServiceInstance serviceInstance = loadBalancerClient.choose("eureka-provider");\n        String url = "http://" + serviceInstance.getHost() + ":" + serviceInstance.getPort() + "/send";\n        System.out.println(url);\n        return restTemplate.getForObject(url, String.class);\n    }\n\n}\n\n\n\n# 1.2. XML 文件\n\nXML 文件这种方式的服务发布和引用主要分三个步骤：\n\n（1）服务提供者定义接口，并实现接口。\n\n// The demo service definition.\nservice DemoService {\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\n// The request message containing the user\'s name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n\n\n（2）服务提供者进程启动时，通过加载 xml 配置文件将接口暴露出去。\n\n<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"\n       xmlns="http://www.springframework.org/schema/beans"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd">\n    <dubbo:application name="demo-provider"/>\n    <dubbo:registry address="zookeeper://127.0.0.1:2181"/>\n    <dubbo:protocol name="dubbo" port="20890"/>\n    <bean id="demoService" class="org.apache.dubbo.samples.basic.impl.DemoServiceImpl"/>\n    <dubbo:service interface="org.apache.dubbo.samples.basic.api.DemoService" ref="demoService"/>\n</beans>\n\n\n（3）服务消费者进程启动时，通过加载 xml 配置文件来引入要调用的接口。\n\nconsumer.xml 示例\n\n<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"\n       xmlns="http://www.springframework.org/schema/beans"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd">\n    <dubbo:application name="demo-consumer"/>\n    <dubbo:registry group="aaa" address="zookeeper://127.0.0.1:2181"/>\n    <dubbo:reference id="demoService" check="false" interface="org.apache.dubbo.samples.basic.api.DemoService"/>\n</beans>\n\n\n\n# 1.3. IDL 文件\n\nIDL 就是接口描述语言（interface description language）的缩写，通过一种中立的方式来描述接口，使得在不同的平台上运行的对象和不同语言编写的程序可以相互通信交流。\n\n也就是说 IDL 主要是用作跨语言平台的服务之间的调用，有两种最常用的 IDL：一个是 Facebook 开源的Thrift 协议，另一个是 Google 开源的gRPC 协议。\n\n以 gRPC 协议为例，gRPC 协议使用 Protobuf 简称 proto 文件来定义接口名、调用参数以及返回值类型。\n\n比如文件 helloword.proto 定义了一个接口 SayHello 方法，它的请求参数是 HelloRequest，它的返回值是 HelloReply。\n\n// The greeter service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n  rpc SayHelloAgain (HelloRequest) returns (HelloReply) {}\n\n}\n\n// The request message containing the user\'s name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n\n\n假如服务提供者使用的是 Java 语言，那么利用 protoc 插件即可自动生成 Server 端的 Java 代码。\n\nprivate class GreeterImpl extends GreeterGrpc.GreeterImplBase {\n\n  @Override\n  public void sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n    HelloReply reply = HelloReply.newBuilder().setMessage("Hello " + req.getName()).build();\n    responseObserver.onNext(reply);\n    responseObserver.onCompleted();\n  }\n\n  @Override\n  public void sayHelloAgain(HelloRequest req, StreamObserver<HelloReply> responseObserver) {\n    HelloReply reply = HelloReply.newBuilder().setMessage("Hello again " + req.getName()).build();\n    responseObserver.onNext(reply);\n    responseObserver.onCompleted();\n  }\n}\n\n\n假如服务消费者使用的也是 Java 语言，那么利用 protoc 插件即可自动生成 Client 端的 Java 代码。\n\npublic void greet(String name) {\n  logger.info("Will try to greet " + name + " ...");\n  HelloRequest request = HelloRequest.newBuilder().setName(name).build();\n  HelloReply response;\n  try {\n    response = blockingStub.sayHello(request);\n  } catch (StatusRuntimeException e) {\n    logger.log(Level.WARNING, "RPC failed: {0}", e.getStatus());\n    return;\n  }\n  logger.info("Greeting: " + response.getMessage());\n  try {\n    response = blockingStub.sayHelloAgain(request);\n  } catch (StatusRuntimeException e) {\n    logger.log(Level.WARNING, "RPC failed: {0}", e.getStatus());\n    return;\n  }\n  logger.info("Greeting: " + response.getMessage());\n}\n\n\n假如服务消费者使用的是其他语言，也可以利用相应的插件生成代码。\n\n由此可见，gRPC 协议的服务描述是通过 proto 文件来定义接口的，然后再使用 protoc 来生成不同语言平台的客户端和服务端代码，从而具备跨语言服务调用能力。\n\n有一点特别需要注意的是，在描述接口定义时，IDL 文件需要对接口返回值进行详细定义。如果接口返回值的字段比较多，并且经常变化时，采用 IDL 文件方式的接口定义就不太合适了。一方面可能会造成 IDL 文件过大难以维护，另一方面只要 IDL 文件中定义的接口返回值有变更，都需要同步所有的服务消费者都更新，管理成本就太高了。\n\n\n# 2. 服务注册和发现基本原理\n\n服务发现通常依赖于注册中心来协调服务发现的过程，其步骤如下：\n\n 1. 服务提供者将接口信息以注册到注册中心。\n 2. 服务消费者从注册中心读取和订阅服务提供者的地址信息。\n 3. 如果有可用的服务，注册中心会主动通知服务消费者。\n 4. 服务消费者根据可用服务的地址列表，调用服务提供者的接口。\n\n这个过程很像是生活中的房屋租赁，房东将租房信息挂到中介公司，房客从中介公司查找租房信息。房客如果想要租房东的房子，通过中介公司牵线搭桥，联系上房东，双方谈妥签订协议，就可以正式建立起租赁关系。\n\n\n\n主流的服务注册与发现的解决方案，主要有两种：\n\n * 应用内注册与发现：注册中心提供服务端和客户端的 SDK，业务应用通过引入注册中心提供的 SDK，通过 SDK 与注册中心交互，来实现服务的注册和发现。\n * 应用外注册与发现：业务应用本身不需要通过 SDK 与注册中心打交道，而是通过其他方式与注册中心交互，间接完成服务注册与发现。\n\n\n# 2.1. 应用内注册与发现\n\n应用内注册与发现方案是：注册中心提供服务端和客户端的 SDK，业务应用通过引入注册中心提供的 SDK，通过 SDK 与注册中心交互，来实现服务的注册和发现。最典型的案例要属 Netflix 开源的 Eureka，官方架构图如下：\n\n\n\nEureka 的架构主要由三个重要的组件组成：\n\n * Eureka Server：注册中心的服务端，实现了服务信息注册、存储以及查询等功能。\n * 服务端的 Eureka Client：集成在服务端的注册中心 SDK，服务提供者通过调用 SDK，实现服务注册、反注册等功能。\n * 客户端的 Eureka Client：集成在客户端的注册中心 SDK，服务消费者通过调用 SDK，实现服务订阅、服务更新等功能。\n\n\n# 2.2. 应用外注册与发现\n\n应用外注册与发现方案是：业务应用本身不需要通过 SDK 与注册中心打交道，而是通过其他方式与注册中心交互，间接完成服务注册与发现。最典型的案例是开源注册中心 Consul。\n\n\n\nConsul 实现应用外服务注册和发现主要依靠三个重要的组件：\n\n * Consul：注册中心的服务端，实现服务注册信息的存储，并提供注册和发现服务。\n * Registrator：一个开源的第三方服务管理器项目，它通过监听服务部署的 Docker 实例是否存活，来负责服务提供者的注册和销毁。\n * Consul Template：定时从注册中心服务端获取最新的服务提供者节点列表并刷新 LB 配置（比如 Nginx 的 upstream），这样服务消费者就通过访问 Nginx 就可以获取最新的服务提供者信息。\n\n\n# 3. 注册中心基本功能\n\n从服务注册和发现的流程，可以看出，注册中心是服务发现的核心组件。常见的注册中心组件有：Nacos、Consul、Zookeeper 等。\n\n注册中心是用来存储服务的元数据信息。服务的元数据信息通常有以下信息：\n\n * 服务节点信息，如 IP、端口等。\n * 接口定义，如接口名、请求参数、响应参数等。\n * 请求失败的重试次数\n * 序列化方式\n * 压缩方式\n * 通信协议\n * 等等\n\n在具体存储时，一般会按照“服务 - 分组 - 节点信息”三层结构来存储。\n\n注册中心的实现主要涉及几个问题：注册中心需要提供哪些接口，该如何部署；如何存储服务信息；如何监控服务提供者节点的存活；如果服务提供者节点有变化如何通知服务消费者，以及如何控制注册中心的访问权限。\n\n\n# 3.1. 注册中心 API\n\n根据注册中心原理的描述，注册中心必须提供以下最基本的 API，例如：\n\n * 服务注册接口：服务提供者通过调用服务注册接口来完成服务注册。\n * 服务反注册接口：服务提供者通过调用服务反注册接口来完成服务注销。\n * 心跳汇报接口：服务提供者通过调用心跳汇报接口完成节点存活状态上报。\n * 服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。\n * 服务变更查询接口：服务消费者通过调用服务变更查询接口，获取最新的可用服务节点列表。\n\n除此之外，为了便于管理，注册中心还必须提供一些后台管理的 API，例如：\n\n * 服务查询接口：查询注册中心当前注册了哪些服务信息。\n * 服务修改接口：修改注册中心中某一服务的信息。\n\n\n# 3.2. 集群部署\n\n注册中心作为服务提供者和服务消费者之间沟通的桥梁，它的重要性不言而喻。所以注册中心一般都是采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。\n\n以开源注册中心 ZooKeeper 为例，ZooKeeper 集群中包含多个节点，服务提供者和服务消费者可以同任意一个节点通信，因为它们的数据一定是相同的，这是为什么呢？这就要从 ZooKeeper 的工作原理说起：\n\n * 每个 Server 在内存中存储了一份数据，Client 的读请求可以请求任意一个 Server。\n * ZooKeeper 启动时，将从实例中选举一个 leader（Paxos 协议）。\n * Leader 负责处理数据更新等操作（ZAB 协议）。\n * 一个更新操作成功，当且仅当大多数 Server 在内存中成功修改 。\n\n通过上面这种方式，ZooKeeper 保证了高可用性以及数据一致性。\n\n\n\n\n# 3.3. 元数据存储\n\n注册中心存储服务信息一般采用层次化的目录结构，以 ZooKeeper 为例：\n\n * 每个目录在 ZooKeeper 中叫作 znode，并且其有一个唯一的路径标识。\n * znode 可以包含数据和子 znode。\n * znode 中的数据可以有多个版本，比如某一个 znode 下存有多个数据版本，那么查询这个路径下的数据需带上版本信息。\n\n\n\n\n# 3.4. 白名单机制\n\n在实际的微服务测试和部署时，通常包含多套环境，比如生产环境一套、测试环境一套。开发在进行业务自测、测试在进行回归测试时，一般都是用测试环境，部署的 RPC Server 节点注册到测试的注册中心集群。但经常会出现开发或者测试在部署时，错误的把测试环境下的服务节点注册到了线上注册中心集群，这样的话线上流量就会调用到测试环境下的 RPC Server 节点，可能会造成意想不到的后果。\n\n为了防止这种情况发生，注册中心需要提供一个保护机制，你可以把注册中心想象成一个带有门禁的房间，只有拥有门禁卡的 RPC Server 才能进入。在实际应用中，注册中心可以提供一个白名单机制，只有添加到注册中心白名单内的 RPC Server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。\n\n\n# 4. 服务健康检测\n\n注册中心除了要支持最基本的服务注册和服务订阅功能以外，还必须具备对服务提供者节点的健康状态检测功能，这样才能保证注册中心里保存的服务节点都是可用的。\n\n还是以 ZooKeeper 为例，它是基于 ZooKeeper 客户端和服务端的长连接和会话超时控制机制，来实现服务健康状态检测的。\n\n在 ZooKeeper 中，客户端和服务端建立连接后，会话也随之建立，并生成一个全局唯一的 Session ID。服务端和客户端维持的是一个长连接，在 SESSION_TIMEOUT 周期内，服务端会检测与客户端的链路是否正常，具体方式是通过客户端定时向服务端发送心跳消息（ping 消息），服务器重置下次 SESSION_TIMEOUT 时间。如果超过 SESSION_TIMEOUT 后服务端都没有收到客户端的心跳消息，则服务端认为这个 Session 就已经结束了，ZooKeeper 就会认为这个服务节点已经不可用，将会从注册中心中删除其信息。\n\n\n# 4.1. 服务状态变更通知\n\n一旦注册中心探测到有服务提供者节点新加入或者被剔除，就必须立刻通知所有订阅该服务的服务消费者，刷新本地缓存的服务节点信息，确保服务调用不会请求不可用的服务提供者节点。\n\n继续以 ZooKeeper 为例，基于 ZooKeeper 的 Watcher 机制，来实现服务状态变更通知给服务消费者的。服务消费者在调用 ZooKeeper 的 getData 方法订阅服务时，还可以通过监听器 Watcher 的 process 方法获取服务的变更，然后调用 getData 方法来获取变更后的数据，刷新本地缓存的服务节点信息。\n\n\n# 4.2. 心跳开关保护机制\n\n在网络频繁抖动的情况下，注册中心中可用的节点会不断变化，这时候服务消费者会频繁收到服务提供者节点变更的信息，于是就不断地请求注册中心来拉取最新的可用服务节点信息。当有成百上千个服务消费者，同时请求注册中心获取最新的服务提供者的节点信息时，可能会把注册中心的带宽给占满，尤其是注册中心是百兆网卡的情况下。\n\n针对这种情况，需要一种保护机制，即使在网络频繁抖动的时候，服务消费者也不至于同时去请求注册中心获取最新的服务节点信息。\n\n一个可行的解决方案就是给注册中心设置一个开关，当开关打开时，即使网络频繁抖动，注册中心也不会通知所有的服务消费者有服务节点信息变更，比如只给 10% 的服务消费者返回变更，这样的话就能将注册中心的请求量减少到原来的 1/10。当然打开这个开关也是有一定代价的，它会导致服务消费者感知最新的服务节点信息延迟，原先可能在 10s 内就能感知到服务提供者节点信息的变更，现在可能会延迟到几分钟，所以在网络正常的情况下，开关并不适合打开；可以作为一个紧急措施，在网络频繁抖动的时候，才打开这个开关。\n\n心跳开关保护机制，是为了防止服务提供者节点频繁变更导致的服务消费者同时去注册中心获取最新服务节点信息。\n\n\n# 4.3. 服务节点摘除保护机制\n\n服务提供者在进程启动时，会注册服务到注册中心，并每隔一段时间，汇报心跳给注册中心，以标识自己的存活状态。如果隔了一段固定时间后，服务提供者仍然没有汇报心跳给注册中心，注册中心就会认为该节点已经处于“dead”状态，于是从服务的可用节点信息中移除出去。\n\n如果遇到网络问题，大批服务提供者节点汇报给注册中心的心跳信息都可能会传达失败，注册中心就会把它们都从可用节点列表中移除出去，造成剩下的可用节点难以承受所有的调用，引起“雪崩”。但是这种情况下，可能大部分服务提供者节点是可用的，仅仅因为网络原因无法汇报心跳给注册中心就被“无情”的摘除了。\n\n这个时候就需要根据实际业务的情况，设定一个阈值比例，即使遇到刚才说的这种情况，注册中心也不能摘除超过这个阈值比例的节点。\n\n这个阈值比例可以根据实际业务的冗余度来确定，我通常会把这个比例设定在 20%，就是说注册中心不能摘除超过 20% 的节点。因为大部分情况下，节点的变化不会这么频繁，只有在网络抖动或者业务明确要下线大批量节点的情况下才有可能发生。而业务明确要下线大批量节点的情况是可以预知的，这种情况下可以关闭阈值保护；而正常情况下，应该打开阈值保护，以防止网络抖动时，大批量可用的服务节点被摘除。\n\n服务节点摘除保护机制，是为了防止服务提供者节点被大量摘除引起服务消费者可以调用的节点不足。\n\n\n# 4.4. 静态注册中心\n\n因为服务提供者是向服务消费者提供服务的，是否可用服务消费者应该比注册中心更清楚，因此可以直接在服务消费者端根据调用服务提供者是否成功来判定服务提供者是否可用。如果服务消费者调用某一个服务提供者节点连续失败超过一定次数，可以在本地内存中将这个节点标记为不可用。并且每隔一段固定时间，服务消费者都要向标记为不可用的节点发起保活探测，如果探测成功了，就将标记为不可用的节点再恢复为可用状态，重新发起调用。\n\n\n# 5. 注册中心选型\n\n注册中心选型时最需要关注两个问题：高可用性和数据一致性。\n\n\n# 5.1. 高可用性\n\n注册中心作为服务提供者和服务消费者之间沟通的纽带，它的高可用性十分重要。如果注册中心不可用了，那么服务提供者就无法对外暴露自己的服务，而服务消费者也无法知道自己想要调用的服务的具体地址。\n\n实现高可用性的手段主要有两种\n\n * 集群部署，即使有部分机器宕机，将请求分发到正常的机器上就可以保证服务的正常访问。\n * 多机房部署，避免一个机房因为断电或者光缆被挖断等不可抗力因素不可用时，仍然可以通过把请求迁移到其他机房来保证服务的正常访问。\n\n这两种手段本质上都是服务冗余。\n\n\n# 5.2. 数据一致性\n\n\n# 6. 服务发现的问题\n\n\n# 6.1. 多注册中心\n\n理想情况下，如果始终只有一个注册中心，那么整个交互非常简单。但在实际工作中，往往需要对接多个注册中心，常见场景如下：\n\n * 服务消费者订阅多个注册中心：服务消费者可能订阅了多个服务，多个服务可能是由多个业务部门提供的，而且每个业务部门都有自己的注册中心，提供的服务只在自己的注册中心里有记录。这就要求服务消费者要具备在启动时，能够从多个注册中心订阅服务的能力。\n * 服务提供者注册多个注册中心：一个服务提供者提供了某个服务，可能作为静态服务对外提供，也可能作为动态服务对外提供，这两个服务部署在不同的注册中心，所以要求服务提供者在启动的时候，要能够同时向多个注册中心注册服务。\n\n\n# 6.2. 并行订阅服务\n\n通常一个服务消费者订阅了不止一个服务。如果采用串行订阅方式，即每订阅一个服务，服务消费者就调用一次注册中心的订阅接口，获取这个服务的节点列表并初始化连接，就可能要执行很多次这样的过程。在某些服务节点的初始化连接过程中，出现连接超时的情况，后续所有的服务节点的初始化连接都需要等待它完成，导致服务消费者启动变慢，最后耗费了将近五分钟时间来完成所有服务节点的初始化连接过程。\n\n由于以上问题，所以服务发现应该支持并行订阅，每订阅一个服务就单独用一个线程来处理，这样的话即使遇到个别服务节点连接超时，其他服务节点的初始化连接也不受影响，最慢也就是这个服务节点的初始化连接耗费的时间，最终所有服务节点的初始化连接耗时控制在一个可以接受的时间范围内。\n\n\n# 6.3. 批量注销服务\n\n通常一个服务提供者节点提供不止一个服务，所以注册和反注册都需要多次调用注册中心。在与注册中心的多次交互中，可能由于网络抖动、注册中心集群异常等原因，导致个别调用失败。对于注册中心来说，偶发的注册调用失败对服务调用基本没有影响，其结果顶多就是某一个服务少了一个可用的节点。但偶发的反注册调用失败会导致不可用的节点残留在注册中心中，变成“僵尸节点”，但服务消费者端还会把它当成“活节点”，继续发起调用，最终导致调用失败。\n\n可以通过调用注册中心提供的批量反注册接口，一次调用就可以把该节点上提供的所有服务同时注销掉，从而避免了“僵尸节点”的出现。\n\n\n# 6.4. 服务变更信息的增量更新\n\n服务消费者端启动时，除了会查询订阅服务的可用节点列表做初始化连接，还会订阅服务的变更，每隔一段时间从注册中心获取最新的服务节点信息标记 sign，并与本地保存的 sign 值作比对，如果不一样，就会调用注册中心获取最新的服务节点信息。\n\n一般情况下，按照这个过程是没问题的，但是在网络频繁抖动时，服务提供者上报给注册中心的心跳可能会一会儿失败一会儿成功，这时候注册中心就会频繁更新服务的可用节点信息，导致服务消费者频繁从注册中心拉取最新的服务可用节点信息，严重时可能产生网络风暴，导致注册中心带宽被打满。\n\n为了减少服务消费者从注册中心中拉取的服务可用节点信息的数据量，这个时候可以通过增量更新的方式，注册中心只返回变化的那部分节点信息，尤其在只有少数节点信息变更时，此举可以大大减少服务消费者从注册中心拉取的数据量，从而最大程度避免产生网络风暴。\n\n\n# 7. 参考资料\n\n * 从 0 开始学微服务\n * RPC 实战与核心原理\n * 微服务架构核心 20 讲',normalizedContent:'# 服务注册和发现\n\n\n# 1. 服务元数据\n\n构建微服务的首要问题是：服务提供者和服务消费者通信时，如何达成共识。具体来说，就是这个服务的接口名是什么？调用这个服务需要传递哪些参数？接口的返回值是什么类型？以及一些其他接口描述信息。\n\n服务的元数据信息通常有以下信息：\n\n * 服务节点信息，如 ip、端口等。\n * 接口定义，如接口名、请求参数、响应参数等。\n * 请求失败的重试次数\n * 序列化方式\n * 压缩方式\n * 通信协议\n * 等等\n\n常见的发布服务元数据的方式有：\n\n * rest api\n * xml 文件\n * idl 文件\n\n\n# 1.1. rest api\n\n以 eureka 为例\n\n服务提供者定义接口\n\n@restcontroller\npublic class providercontroller {\n\n    private final discoveryclient discoveryclient;\n\n    public providercontroller(discoveryclient discoveryclient) {\n        this.discoveryclient = discoveryclient;\n    }\n\n    @getmapping("/send")\n    public string send() {\n        string services = "services: " + discoveryclient.getservices();\n        system.out.println(services);\n        return services;\n    }\n\n}\n\n\n服务消费者消费接口\n\n@restcontroller\npublic class consumercontroller {\n\n    private final loadbalancerclient loadbalancerclient;\n    private final resttemplate resttemplate;\n\n    public consumercontroller(loadbalancerclient loadbalancerclient,\n        resttemplate resttemplate) {\n        this.loadbalancerclient = loadbalancerclient;\n        this.resttemplate = resttemplate;\n    }\n\n    @getmapping("/recv")\n    public string recv() {\n        serviceinstance serviceinstance = loadbalancerclient.choose("eureka-provider");\n        string url = "http://" + serviceinstance.gethost() + ":" + serviceinstance.getport() + "/send";\n        system.out.println(url);\n        return resttemplate.getforobject(url, string.class);\n    }\n\n}\n\n\n\n# 1.2. xml 文件\n\nxml 文件这种方式的服务发布和引用主要分三个步骤：\n\n（1）服务提供者定义接口，并实现接口。\n\n// the demo service definition.\nservice demoservice {\n  rpc sayhello (hellorequest) returns (helloreply) {}\n}\n\n// the request message containing the user\'s name.\nmessage hellorequest {\n  string name = 1;\n}\n\n// the response message containing the greetings\nmessage helloreply {\n  string message = 1;\n}\n\n\n（2）服务提供者进程启动时，通过加载 xml 配置文件将接口暴露出去。\n\n<beans xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"\n       xmlns="http://www.springframework.org/schema/beans"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd">\n    <dubbo:application name="demo-provider"/>\n    <dubbo:registry address="zookeeper://127.0.0.1:2181"/>\n    <dubbo:protocol name="dubbo" port="20890"/>\n    <bean id="demoservice" class="org.apache.dubbo.samples.basic.impl.demoserviceimpl"/>\n    <dubbo:service interface="org.apache.dubbo.samples.basic.api.demoservice" ref="demoservice"/>\n</beans>\n\n\n（3）服务消费者进程启动时，通过加载 xml 配置文件来引入要调用的接口。\n\nconsumer.xml 示例\n\n<beans xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:dubbo="http://dubbo.apache.org/schema/dubbo"\n       xmlns="http://www.springframework.org/schema/beans"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd">\n    <dubbo:application name="demo-consumer"/>\n    <dubbo:registry group="aaa" address="zookeeper://127.0.0.1:2181"/>\n    <dubbo:reference id="demoservice" check="false" interface="org.apache.dubbo.samples.basic.api.demoservice"/>\n</beans>\n\n\n\n# 1.3. idl 文件\n\nidl 就是接口描述语言（interface description language）的缩写，通过一种中立的方式来描述接口，使得在不同的平台上运行的对象和不同语言编写的程序可以相互通信交流。\n\n也就是说 idl 主要是用作跨语言平台的服务之间的调用，有两种最常用的 idl：一个是 facebook 开源的thrift 协议，另一个是 google 开源的grpc 协议。\n\n以 grpc 协议为例，grpc 协议使用 protobuf 简称 proto 文件来定义接口名、调用参数以及返回值类型。\n\n比如文件 helloword.proto 定义了一个接口 sayhello 方法，它的请求参数是 hellorequest，它的返回值是 helloreply。\n\n// the greeter service definition.\nservice greeter {\n  // sends a greeting\n  rpc sayhello (hellorequest) returns (helloreply) {}\n  rpc sayhelloagain (hellorequest) returns (helloreply) {}\n\n}\n\n// the request message containing the user\'s name.\nmessage hellorequest {\n  string name = 1;\n}\n\n// the response message containing the greetings\nmessage helloreply {\n  string message = 1;\n}\n\n\n假如服务提供者使用的是 java 语言，那么利用 protoc 插件即可自动生成 server 端的 java 代码。\n\nprivate class greeterimpl extends greetergrpc.greeterimplbase {\n\n  @override\n  public void sayhello(hellorequest req, streamobserver<helloreply> responseobserver) {\n    helloreply reply = helloreply.newbuilder().setmessage("hello " + req.getname()).build();\n    responseobserver.onnext(reply);\n    responseobserver.oncompleted();\n  }\n\n  @override\n  public void sayhelloagain(hellorequest req, streamobserver<helloreply> responseobserver) {\n    helloreply reply = helloreply.newbuilder().setmessage("hello again " + req.getname()).build();\n    responseobserver.onnext(reply);\n    responseobserver.oncompleted();\n  }\n}\n\n\n假如服务消费者使用的也是 java 语言，那么利用 protoc 插件即可自动生成 client 端的 java 代码。\n\npublic void greet(string name) {\n  logger.info("will try to greet " + name + " ...");\n  hellorequest request = hellorequest.newbuilder().setname(name).build();\n  helloreply response;\n  try {\n    response = blockingstub.sayhello(request);\n  } catch (statusruntimeexception e) {\n    logger.log(level.warning, "rpc failed: {0}", e.getstatus());\n    return;\n  }\n  logger.info("greeting: " + response.getmessage());\n  try {\n    response = blockingstub.sayhelloagain(request);\n  } catch (statusruntimeexception e) {\n    logger.log(level.warning, "rpc failed: {0}", e.getstatus());\n    return;\n  }\n  logger.info("greeting: " + response.getmessage());\n}\n\n\n假如服务消费者使用的是其他语言，也可以利用相应的插件生成代码。\n\n由此可见，grpc 协议的服务描述是通过 proto 文件来定义接口的，然后再使用 protoc 来生成不同语言平台的客户端和服务端代码，从而具备跨语言服务调用能力。\n\n有一点特别需要注意的是，在描述接口定义时，idl 文件需要对接口返回值进行详细定义。如果接口返回值的字段比较多，并且经常变化时，采用 idl 文件方式的接口定义就不太合适了。一方面可能会造成 idl 文件过大难以维护，另一方面只要 idl 文件中定义的接口返回值有变更，都需要同步所有的服务消费者都更新，管理成本就太高了。\n\n\n# 2. 服务注册和发现基本原理\n\n服务发现通常依赖于注册中心来协调服务发现的过程，其步骤如下：\n\n 1. 服务提供者将接口信息以注册到注册中心。\n 2. 服务消费者从注册中心读取和订阅服务提供者的地址信息。\n 3. 如果有可用的服务，注册中心会主动通知服务消费者。\n 4. 服务消费者根据可用服务的地址列表，调用服务提供者的接口。\n\n这个过程很像是生活中的房屋租赁，房东将租房信息挂到中介公司，房客从中介公司查找租房信息。房客如果想要租房东的房子，通过中介公司牵线搭桥，联系上房东，双方谈妥签订协议，就可以正式建立起租赁关系。\n\n\n\n主流的服务注册与发现的解决方案，主要有两种：\n\n * 应用内注册与发现：注册中心提供服务端和客户端的 sdk，业务应用通过引入注册中心提供的 sdk，通过 sdk 与注册中心交互，来实现服务的注册和发现。\n * 应用外注册与发现：业务应用本身不需要通过 sdk 与注册中心打交道，而是通过其他方式与注册中心交互，间接完成服务注册与发现。\n\n\n# 2.1. 应用内注册与发现\n\n应用内注册与发现方案是：注册中心提供服务端和客户端的 sdk，业务应用通过引入注册中心提供的 sdk，通过 sdk 与注册中心交互，来实现服务的注册和发现。最典型的案例要属 netflix 开源的 eureka，官方架构图如下：\n\n\n\neureka 的架构主要由三个重要的组件组成：\n\n * eureka server：注册中心的服务端，实现了服务信息注册、存储以及查询等功能。\n * 服务端的 eureka client：集成在服务端的注册中心 sdk，服务提供者通过调用 sdk，实现服务注册、反注册等功能。\n * 客户端的 eureka client：集成在客户端的注册中心 sdk，服务消费者通过调用 sdk，实现服务订阅、服务更新等功能。\n\n\n# 2.2. 应用外注册与发现\n\n应用外注册与发现方案是：业务应用本身不需要通过 sdk 与注册中心打交道，而是通过其他方式与注册中心交互，间接完成服务注册与发现。最典型的案例是开源注册中心 consul。\n\n\n\nconsul 实现应用外服务注册和发现主要依靠三个重要的组件：\n\n * consul：注册中心的服务端，实现服务注册信息的存储，并提供注册和发现服务。\n * registrator：一个开源的第三方服务管理器项目，它通过监听服务部署的 docker 实例是否存活，来负责服务提供者的注册和销毁。\n * consul template：定时从注册中心服务端获取最新的服务提供者节点列表并刷新 lb 配置（比如 nginx 的 upstream），这样服务消费者就通过访问 nginx 就可以获取最新的服务提供者信息。\n\n\n# 3. 注册中心基本功能\n\n从服务注册和发现的流程，可以看出，注册中心是服务发现的核心组件。常见的注册中心组件有：nacos、consul、zookeeper 等。\n\n注册中心是用来存储服务的元数据信息。服务的元数据信息通常有以下信息：\n\n * 服务节点信息，如 ip、端口等。\n * 接口定义，如接口名、请求参数、响应参数等。\n * 请求失败的重试次数\n * 序列化方式\n * 压缩方式\n * 通信协议\n * 等等\n\n在具体存储时，一般会按照“服务 - 分组 - 节点信息”三层结构来存储。\n\n注册中心的实现主要涉及几个问题：注册中心需要提供哪些接口，该如何部署；如何存储服务信息；如何监控服务提供者节点的存活；如果服务提供者节点有变化如何通知服务消费者，以及如何控制注册中心的访问权限。\n\n\n# 3.1. 注册中心 api\n\n根据注册中心原理的描述，注册中心必须提供以下最基本的 api，例如：\n\n * 服务注册接口：服务提供者通过调用服务注册接口来完成服务注册。\n * 服务反注册接口：服务提供者通过调用服务反注册接口来完成服务注销。\n * 心跳汇报接口：服务提供者通过调用心跳汇报接口完成节点存活状态上报。\n * 服务订阅接口：服务消费者通过调用服务订阅接口完成服务订阅，获取可用的服务提供者节点列表。\n * 服务变更查询接口：服务消费者通过调用服务变更查询接口，获取最新的可用服务节点列表。\n\n除此之外，为了便于管理，注册中心还必须提供一些后台管理的 api，例如：\n\n * 服务查询接口：查询注册中心当前注册了哪些服务信息。\n * 服务修改接口：修改注册中心中某一服务的信息。\n\n\n# 3.2. 集群部署\n\n注册中心作为服务提供者和服务消费者之间沟通的桥梁，它的重要性不言而喻。所以注册中心一般都是采用集群部署来保证高可用性，并通过分布式一致性协议来确保集群中不同节点之间的数据保持一致。\n\n以开源注册中心 zookeeper 为例，zookeeper 集群中包含多个节点，服务提供者和服务消费者可以同任意一个节点通信，因为它们的数据一定是相同的，这是为什么呢？这就要从 zookeeper 的工作原理说起：\n\n * 每个 server 在内存中存储了一份数据，client 的读请求可以请求任意一个 server。\n * zookeeper 启动时，将从实例中选举一个 leader（paxos 协议）。\n * leader 负责处理数据更新等操作（zab 协议）。\n * 一个更新操作成功，当且仅当大多数 server 在内存中成功修改 。\n\n通过上面这种方式，zookeeper 保证了高可用性以及数据一致性。\n\n\n\n\n# 3.3. 元数据存储\n\n注册中心存储服务信息一般采用层次化的目录结构，以 zookeeper 为例：\n\n * 每个目录在 zookeeper 中叫作 znode，并且其有一个唯一的路径标识。\n * znode 可以包含数据和子 znode。\n * znode 中的数据可以有多个版本，比如某一个 znode 下存有多个数据版本，那么查询这个路径下的数据需带上版本信息。\n\n\n\n\n# 3.4. 白名单机制\n\n在实际的微服务测试和部署时，通常包含多套环境，比如生产环境一套、测试环境一套。开发在进行业务自测、测试在进行回归测试时，一般都是用测试环境，部署的 rpc server 节点注册到测试的注册中心集群。但经常会出现开发或者测试在部署时，错误的把测试环境下的服务节点注册到了线上注册中心集群，这样的话线上流量就会调用到测试环境下的 rpc server 节点，可能会造成意想不到的后果。\n\n为了防止这种情况发生，注册中心需要提供一个保护机制，你可以把注册中心想象成一个带有门禁的房间，只有拥有门禁卡的 rpc server 才能进入。在实际应用中，注册中心可以提供一个白名单机制，只有添加到注册中心白名单内的 rpc server，才能够调用注册中心的注册接口，这样的话可以避免测试环境中的节点意外跑到线上环境中去。\n\n\n# 4. 服务健康检测\n\n注册中心除了要支持最基本的服务注册和服务订阅功能以外，还必须具备对服务提供者节点的健康状态检测功能，这样才能保证注册中心里保存的服务节点都是可用的。\n\n还是以 zookeeper 为例，它是基于 zookeeper 客户端和服务端的长连接和会话超时控制机制，来实现服务健康状态检测的。\n\n在 zookeeper 中，客户端和服务端建立连接后，会话也随之建立，并生成一个全局唯一的 session id。服务端和客户端维持的是一个长连接，在 session_timeout 周期内，服务端会检测与客户端的链路是否正常，具体方式是通过客户端定时向服务端发送心跳消息（ping 消息），服务器重置下次 session_timeout 时间。如果超过 session_timeout 后服务端都没有收到客户端的心跳消息，则服务端认为这个 session 就已经结束了，zookeeper 就会认为这个服务节点已经不可用，将会从注册中心中删除其信息。\n\n\n# 4.1. 服务状态变更通知\n\n一旦注册中心探测到有服务提供者节点新加入或者被剔除，就必须立刻通知所有订阅该服务的服务消费者，刷新本地缓存的服务节点信息，确保服务调用不会请求不可用的服务提供者节点。\n\n继续以 zookeeper 为例，基于 zookeeper 的 watcher 机制，来实现服务状态变更通知给服务消费者的。服务消费者在调用 zookeeper 的 getdata 方法订阅服务时，还可以通过监听器 watcher 的 process 方法获取服务的变更，然后调用 getdata 方法来获取变更后的数据，刷新本地缓存的服务节点信息。\n\n\n# 4.2. 心跳开关保护机制\n\n在网络频繁抖动的情况下，注册中心中可用的节点会不断变化，这时候服务消费者会频繁收到服务提供者节点变更的信息，于是就不断地请求注册中心来拉取最新的可用服务节点信息。当有成百上千个服务消费者，同时请求注册中心获取最新的服务提供者的节点信息时，可能会把注册中心的带宽给占满，尤其是注册中心是百兆网卡的情况下。\n\n针对这种情况，需要一种保护机制，即使在网络频繁抖动的时候，服务消费者也不至于同时去请求注册中心获取最新的服务节点信息。\n\n一个可行的解决方案就是给注册中心设置一个开关，当开关打开时，即使网络频繁抖动，注册中心也不会通知所有的服务消费者有服务节点信息变更，比如只给 10% 的服务消费者返回变更，这样的话就能将注册中心的请求量减少到原来的 1/10。当然打开这个开关也是有一定代价的，它会导致服务消费者感知最新的服务节点信息延迟，原先可能在 10s 内就能感知到服务提供者节点信息的变更，现在可能会延迟到几分钟，所以在网络正常的情况下，开关并不适合打开；可以作为一个紧急措施，在网络频繁抖动的时候，才打开这个开关。\n\n心跳开关保护机制，是为了防止服务提供者节点频繁变更导致的服务消费者同时去注册中心获取最新服务节点信息。\n\n\n# 4.3. 服务节点摘除保护机制\n\n服务提供者在进程启动时，会注册服务到注册中心，并每隔一段时间，汇报心跳给注册中心，以标识自己的存活状态。如果隔了一段固定时间后，服务提供者仍然没有汇报心跳给注册中心，注册中心就会认为该节点已经处于“dead”状态，于是从服务的可用节点信息中移除出去。\n\n如果遇到网络问题，大批服务提供者节点汇报给注册中心的心跳信息都可能会传达失败，注册中心就会把它们都从可用节点列表中移除出去，造成剩下的可用节点难以承受所有的调用，引起“雪崩”。但是这种情况下，可能大部分服务提供者节点是可用的，仅仅因为网络原因无法汇报心跳给注册中心就被“无情”的摘除了。\n\n这个时候就需要根据实际业务的情况，设定一个阈值比例，即使遇到刚才说的这种情况，注册中心也不能摘除超过这个阈值比例的节点。\n\n这个阈值比例可以根据实际业务的冗余度来确定，我通常会把这个比例设定在 20%，就是说注册中心不能摘除超过 20% 的节点。因为大部分情况下，节点的变化不会这么频繁，只有在网络抖动或者业务明确要下线大批量节点的情况下才有可能发生。而业务明确要下线大批量节点的情况是可以预知的，这种情况下可以关闭阈值保护；而正常情况下，应该打开阈值保护，以防止网络抖动时，大批量可用的服务节点被摘除。\n\n服务节点摘除保护机制，是为了防止服务提供者节点被大量摘除引起服务消费者可以调用的节点不足。\n\n\n# 4.4. 静态注册中心\n\n因为服务提供者是向服务消费者提供服务的，是否可用服务消费者应该比注册中心更清楚，因此可以直接在服务消费者端根据调用服务提供者是否成功来判定服务提供者是否可用。如果服务消费者调用某一个服务提供者节点连续失败超过一定次数，可以在本地内存中将这个节点标记为不可用。并且每隔一段固定时间，服务消费者都要向标记为不可用的节点发起保活探测，如果探测成功了，就将标记为不可用的节点再恢复为可用状态，重新发起调用。\n\n\n# 5. 注册中心选型\n\n注册中心选型时最需要关注两个问题：高可用性和数据一致性。\n\n\n# 5.1. 高可用性\n\n注册中心作为服务提供者和服务消费者之间沟通的纽带，它的高可用性十分重要。如果注册中心不可用了，那么服务提供者就无法对外暴露自己的服务，而服务消费者也无法知道自己想要调用的服务的具体地址。\n\n实现高可用性的手段主要有两种\n\n * 集群部署，即使有部分机器宕机，将请求分发到正常的机器上就可以保证服务的正常访问。\n * 多机房部署，避免一个机房因为断电或者光缆被挖断等不可抗力因素不可用时，仍然可以通过把请求迁移到其他机房来保证服务的正常访问。\n\n这两种手段本质上都是服务冗余。\n\n\n# 5.2. 数据一致性\n\n\n# 6. 服务发现的问题\n\n\n# 6.1. 多注册中心\n\n理想情况下，如果始终只有一个注册中心，那么整个交互非常简单。但在实际工作中，往往需要对接多个注册中心，常见场景如下：\n\n * 服务消费者订阅多个注册中心：服务消费者可能订阅了多个服务，多个服务可能是由多个业务部门提供的，而且每个业务部门都有自己的注册中心，提供的服务只在自己的注册中心里有记录。这就要求服务消费者要具备在启动时，能够从多个注册中心订阅服务的能力。\n * 服务提供者注册多个注册中心：一个服务提供者提供了某个服务，可能作为静态服务对外提供，也可能作为动态服务对外提供，这两个服务部署在不同的注册中心，所以要求服务提供者在启动的时候，要能够同时向多个注册中心注册服务。\n\n\n# 6.2. 并行订阅服务\n\n通常一个服务消费者订阅了不止一个服务。如果采用串行订阅方式，即每订阅一个服务，服务消费者就调用一次注册中心的订阅接口，获取这个服务的节点列表并初始化连接，就可能要执行很多次这样的过程。在某些服务节点的初始化连接过程中，出现连接超时的情况，后续所有的服务节点的初始化连接都需要等待它完成，导致服务消费者启动变慢，最后耗费了将近五分钟时间来完成所有服务节点的初始化连接过程。\n\n由于以上问题，所以服务发现应该支持并行订阅，每订阅一个服务就单独用一个线程来处理，这样的话即使遇到个别服务节点连接超时，其他服务节点的初始化连接也不受影响，最慢也就是这个服务节点的初始化连接耗费的时间，最终所有服务节点的初始化连接耗时控制在一个可以接受的时间范围内。\n\n\n# 6.3. 批量注销服务\n\n通常一个服务提供者节点提供不止一个服务，所以注册和反注册都需要多次调用注册中心。在与注册中心的多次交互中，可能由于网络抖动、注册中心集群异常等原因，导致个别调用失败。对于注册中心来说，偶发的注册调用失败对服务调用基本没有影响，其结果顶多就是某一个服务少了一个可用的节点。但偶发的反注册调用失败会导致不可用的节点残留在注册中心中，变成“僵尸节点”，但服务消费者端还会把它当成“活节点”，继续发起调用，最终导致调用失败。\n\n可以通过调用注册中心提供的批量反注册接口，一次调用就可以把该节点上提供的所有服务同时注销掉，从而避免了“僵尸节点”的出现。\n\n\n# 6.4. 服务变更信息的增量更新\n\n服务消费者端启动时，除了会查询订阅服务的可用节点列表做初始化连接，还会订阅服务的变更，每隔一段时间从注册中心获取最新的服务节点信息标记 sign，并与本地保存的 sign 值作比对，如果不一样，就会调用注册中心获取最新的服务节点信息。\n\n一般情况下，按照这个过程是没问题的，但是在网络频繁抖动时，服务提供者上报给注册中心的心跳可能会一会儿失败一会儿成功，这时候注册中心就会频繁更新服务的可用节点信息，导致服务消费者频繁从注册中心拉取最新的服务可用节点信息，严重时可能产生网络风暴，导致注册中心带宽被打满。\n\n为了减少服务消费者从注册中心中拉取的服务可用节点信息的数据量，这个时候可以通过增量更新的方式，注册中心只返回变化的那部分节点信息，尤其在只有少数节点信息变更时，此举可以大大减少服务消费者从注册中心拉取的数据量，从而最大程度避免产生网络风暴。\n\n\n# 7. 参考资料\n\n * 从 0 开始学微服务\n * rpc 实战与核心原理\n * 微服务架构核心 20 讲',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"服务监控",frontmatter:{title:"服务监控",categories:["分布式","分布式关键技术","服务治理"],tags:["分布式","服务治理","监控"],abbrlink:"a7bb904f",date:"2022-04-19T20:02:48.000Z",permalink:"/pages/4c0174/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/05.%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/02.%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7.html",relativePath:"02.分布式/03.分布式关键技术/05.服务治理/02.服务监控.md",key:"v-03ef00cc",path:"/pages/4c0174/",headers:[{level:2,title:"监控对象",slug:"监控对象",normalizedTitle:"监控对象",charIndex:133},{level:2,title:"监控维度",slug:"监控维度",normalizedTitle:"监控维度",charIndex:367},{level:2,title:"系统监控原理",slug:"系统监控原理",normalizedTitle:"系统监控原理",charIndex:889},{level:3,title:"数据采集",slug:"数据采集",normalizedTitle:"数据采集",charIndex:935},{level:3,title:"数据传输",slug:"数据传输",normalizedTitle:"数据传输",charIndex:940},{level:3,title:"数据处理",slug:"数据处理",normalizedTitle:"数据处理",charIndex:945},{level:3,title:"数据展示",slug:"数据展示",normalizedTitle:"数据展示",charIndex:950},{level:2,title:"监控技术",slug:"监控技术",normalizedTitle:"监控技术",charIndex:1797},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2117}],headersStr:"监控对象 监控维度 系统监控原理 数据采集 数据传输 数据处理 数据展示 监控技术 参考资料",content:"# 服务监控\n\n当服务消费者与服务提供者之间建立了通信，作为管理者需要通过监控手段来观察服务是否正常，调用是否成功。服务监控是很复杂的，在微服务架构下，一次用户调用会因为服务化拆分后，变成多个不同服务之间的相互调用，这也就需要对拆分后的每个服务都监控起来。\n\n\n# 监控对象\n\n服务监控一定是通过观察数据来量化分析，所以首先要明确需要监控什么。\n\n一般来说，服务监控数据有以下分类：\n\n * 业务监控：核心指标、登录、登出、下单、支付等。\n * 应用监控：接口监控、访问服务、SQL、内存使用率、响应时间、TPS、QPS 等。\n * 系统监控：CPU 利用率、内存使用量、网络带宽、IO 带宽、磁盘使用率等。\n * 基础监控：网络流量、丢包数、错包数、连接数等。\n * 客户端监控：性能、返回码、地域、运营商、版本、系统等。\n\n\n# 监控维度\n\n一般来说，要从多个维度来对业务进行监控，具体来讲可以包括下面几个维度：\n\n * 全局维度。从整体角度监控对象的的请求量、平均耗时以及错误率，全局维度的监控一般是为了让你对监控对象的调用情况有个整体了解。\n * 机房维度。一般为了业务的高可用性，服务通常部署在不止一个机房，因为不同机房地域的不同，同一个监控对象的各种指标可能会相差很大，所以需要深入到机房内部去了解。\n * 单机维度。即便是在同一个机房内部，可能由于采购年份和批次的不同，位于不同机器上的同一个监控对象的各种指标也会有很大差异。一般来说，新采购的机器通常由于成本更低，配置也更高，在同等请求量的情况下，可能表现出较大的性能差异，因此也需要从单机维度去监控同一个对象。\n * 时间维度。同一个监控对象，在每天的同一时刻各种指标通常也不会一样，这种差异要么是由业务变更导致，要么是运营活动导致。为了了解监控对象各种指标的变化，通常需要与一天前、一周前、一个月前，甚至三个月前做比较。\n * 核心维度。业务上一般会依据重要性程度对监控对象进行分级，最简单的是分成核心业务和非核心业务。核心业务和非核心业务在部署上必须隔离，分开监控，这样才能对核心业务做重点保障。\n\n\n# 系统监控原理\n\n一旦明确了要监控的对象，接下就是考虑如何监控。\n\n监控系统主要包括四个环节：数据采集、数据传输、数据处理和数据展示\n\n\n# 数据采集\n\n通常有两种数据收集方式：\n\n * 服务主动上报：这种处理方式通过在业务代码或者服务框架里加入数据收集代码逻辑，在每一次服务调用完成后，主动上报服务的调用信息。这种方式在链路跟踪中较为常见，主流的技术方案有：Zipkin。\n * 代理收集：这种处理方式通过服务调用后把调用的详细信息记录到本地日志文件中，然后再通过代理去解析本地日志文件，然后再上报服务的调用信息。主流的技术方案有：ELK、Flume。\n\n\n# 数据传输\n\n数据传输最常用的方式有两种：\n\n * UDP 传输：这种处理方式是数据处理单元提供服务器的请求地址，数据采集后通过 UDP 协议与服务器建立连接，然后把数据发送过去。\n * Kafka 传输：这种处理方式是数据采集后发送到指定的 Topic，然后数据处理单元再订阅对应的 Topic，就可以从 Kafka 消息队列中读取到对应的数据。由于 Kafka 有非常高的吞吐能力，所以很适合作为大数据量的缓冲池。\n\n\n# 数据处理\n\n数据处理是对收集来的原始数据进行聚合并存储。数据聚合通常有两个维度：\n\n * 接口维度聚合：这个维度是把实时收到的数据按照接口名维度实时聚合在一起，这样就可以得到每个接口的每秒请求量、平均耗时、成功率等信息。\n * 机器维度聚合：这个维度是把实时收到的数据按照调用的节点维度聚合在一起，这样就可以从单机维度去查看每个接口的实时请求量、平均耗时等信息。\n\n聚合后的数据需要持久化到数据库中存储，所选用的数据库一般分为两种：\n\n * 全文检索数据库：比如 Elasticsearch，以倒排索引的数据结构存储，需要查询的时候，根据索引来查询。\n * 时序数据库：比如 OpenTSDB，以时序序列数据的方式存储，查询的时候按照时序如 1min、5min 等维度来查询。\n\n\n# 数据展示\n\n数据展示是把处理后的数据以 Dashboard 的方式展示给用户。数据展示有多种方式，比如曲线图、饼状图、格子图展示等。\n\n\n# 监控技术\n\n * ELK 的技术栈比较成熟，应用范围也比较广，除了可用作监控系统外，还可以用作日志查询和分析。\n * Graphite 是基于时间序列数据库存储的监控系统，并且提供了功能强大的各种聚合函数比如 sum、average、top5 等可用于监控分析，而且对外提供了 API 也可以接入其他图形化监控系统如 Grafana。\n * TICK 的核心在于其时间序列数据库 InfluxDB 的存储功能强大，且支持类似 SQL 语言的复杂数据处理操作。\n * Prometheus 的独特之处在于它采用了拉数据的方式，对业务影响较小，同时也采用了时间序列数据库存储，而且支持独有的 PromQL 查询语言，功能强大而且简洁。\n\n\n# 参考资料\n\n * 从 0 开始学微服务\n * RPC 实战与核心原理\n * 微服务架构核心 20 讲",normalizedContent:"# 服务监控\n\n当服务消费者与服务提供者之间建立了通信，作为管理者需要通过监控手段来观察服务是否正常，调用是否成功。服务监控是很复杂的，在微服务架构下，一次用户调用会因为服务化拆分后，变成多个不同服务之间的相互调用，这也就需要对拆分后的每个服务都监控起来。\n\n\n# 监控对象\n\n服务监控一定是通过观察数据来量化分析，所以首先要明确需要监控什么。\n\n一般来说，服务监控数据有以下分类：\n\n * 业务监控：核心指标、登录、登出、下单、支付等。\n * 应用监控：接口监控、访问服务、sql、内存使用率、响应时间、tps、qps 等。\n * 系统监控：cpu 利用率、内存使用量、网络带宽、io 带宽、磁盘使用率等。\n * 基础监控：网络流量、丢包数、错包数、连接数等。\n * 客户端监控：性能、返回码、地域、运营商、版本、系统等。\n\n\n# 监控维度\n\n一般来说，要从多个维度来对业务进行监控，具体来讲可以包括下面几个维度：\n\n * 全局维度。从整体角度监控对象的的请求量、平均耗时以及错误率，全局维度的监控一般是为了让你对监控对象的调用情况有个整体了解。\n * 机房维度。一般为了业务的高可用性，服务通常部署在不止一个机房，因为不同机房地域的不同，同一个监控对象的各种指标可能会相差很大，所以需要深入到机房内部去了解。\n * 单机维度。即便是在同一个机房内部，可能由于采购年份和批次的不同，位于不同机器上的同一个监控对象的各种指标也会有很大差异。一般来说，新采购的机器通常由于成本更低，配置也更高，在同等请求量的情况下，可能表现出较大的性能差异，因此也需要从单机维度去监控同一个对象。\n * 时间维度。同一个监控对象，在每天的同一时刻各种指标通常也不会一样，这种差异要么是由业务变更导致，要么是运营活动导致。为了了解监控对象各种指标的变化，通常需要与一天前、一周前、一个月前，甚至三个月前做比较。\n * 核心维度。业务上一般会依据重要性程度对监控对象进行分级，最简单的是分成核心业务和非核心业务。核心业务和非核心业务在部署上必须隔离，分开监控，这样才能对核心业务做重点保障。\n\n\n# 系统监控原理\n\n一旦明确了要监控的对象，接下就是考虑如何监控。\n\n监控系统主要包括四个环节：数据采集、数据传输、数据处理和数据展示\n\n\n# 数据采集\n\n通常有两种数据收集方式：\n\n * 服务主动上报：这种处理方式通过在业务代码或者服务框架里加入数据收集代码逻辑，在每一次服务调用完成后，主动上报服务的调用信息。这种方式在链路跟踪中较为常见，主流的技术方案有：zipkin。\n * 代理收集：这种处理方式通过服务调用后把调用的详细信息记录到本地日志文件中，然后再通过代理去解析本地日志文件，然后再上报服务的调用信息。主流的技术方案有：elk、flume。\n\n\n# 数据传输\n\n数据传输最常用的方式有两种：\n\n * udp 传输：这种处理方式是数据处理单元提供服务器的请求地址，数据采集后通过 udp 协议与服务器建立连接，然后把数据发送过去。\n * kafka 传输：这种处理方式是数据采集后发送到指定的 topic，然后数据处理单元再订阅对应的 topic，就可以从 kafka 消息队列中读取到对应的数据。由于 kafka 有非常高的吞吐能力，所以很适合作为大数据量的缓冲池。\n\n\n# 数据处理\n\n数据处理是对收集来的原始数据进行聚合并存储。数据聚合通常有两个维度：\n\n * 接口维度聚合：这个维度是把实时收到的数据按照接口名维度实时聚合在一起，这样就可以得到每个接口的每秒请求量、平均耗时、成功率等信息。\n * 机器维度聚合：这个维度是把实时收到的数据按照调用的节点维度聚合在一起，这样就可以从单机维度去查看每个接口的实时请求量、平均耗时等信息。\n\n聚合后的数据需要持久化到数据库中存储，所选用的数据库一般分为两种：\n\n * 全文检索数据库：比如 elasticsearch，以倒排索引的数据结构存储，需要查询的时候，根据索引来查询。\n * 时序数据库：比如 opentsdb，以时序序列数据的方式存储，查询的时候按照时序如 1min、5min 等维度来查询。\n\n\n# 数据展示\n\n数据展示是把处理后的数据以 dashboard 的方式展示给用户。数据展示有多种方式，比如曲线图、饼状图、格子图展示等。\n\n\n# 监控技术\n\n * elk 的技术栈比较成熟，应用范围也比较广，除了可用作监控系统外，还可以用作日志查询和分析。\n * graphite 是基于时间序列数据库存储的监控系统，并且提供了功能强大的各种聚合函数比如 sum、average、top5 等可用于监控分析，而且对外提供了 api 也可以接入其他图形化监控系统如 grafana。\n * tick 的核心在于其时间序列数据库 influxdb 的存储功能强大，且支持类似 sql 语言的复杂数据处理操作。\n * prometheus 的独特之处在于它采用了拉数据的方式，对业务影响较小，同时也采用了时间序列数据库存储，而且支持独有的 promql 查询语言，功能强大而且简洁。\n\n\n# 参考资料\n\n * 从 0 开始学微服务\n * rpc 实战与核心原理\n * 微服务架构核心 20 讲",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"服务链路监控",frontmatter:{title:"服务链路监控",categories:["分布式","分布式关键技术","服务治理"],tags:["分布式","服务治理","监控","APM","链路追踪"],abbrlink:"ec339fb7",date:"2022-04-20T09:08:29.000Z",permalink:"/pages/f918df/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/05.%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/03.%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7.html",relativePath:"02.分布式/03.分布式关键技术/05.服务治理/03.服务链路监控.md",key:"v-7f83aac5",path:"/pages/f918df/",headers:[{level:2,title:"什么是服务追踪",slug:"什么是服务追踪",normalizedTitle:"什么是服务追踪",charIndex:11},{level:2,title:"为什么需要服务追踪",slug:"为什么需要服务追踪",normalizedTitle:"为什么需要服务追踪",charIndex:256},{level:2,title:"服务链路监控的原理",slug:"服务链路监控的原理",normalizedTitle:"服务链路监控的原理",charIndex:1035},{level:2,title:"服务追踪系统实现",slug:"服务追踪系统实现",normalizedTitle:"服务追踪系统实现",charIndex:1958},{level:3,title:"数据采集层",slug:"数据采集层",normalizedTitle:"数据采集层",charIndex:1988},{level:3,title:"数据处理层",slug:"数据处理层",normalizedTitle:"数据处理层",charIndex:2008},{level:3,title:"数据展示层",slug:"数据展示层",normalizedTitle:"数据展示层",charIndex:2029},{level:4,title:"调用链路图",slug:"调用链路图",normalizedTitle:"调用链路图",charIndex:3013},{level:4,title:"调用拓扑图",slug:"调用拓扑图",normalizedTitle:"调用拓扑图",charIndex:785},{level:2,title:"服务追踪技术选型",slug:"服务追踪技术选型",normalizedTitle:"服务追踪技术选型",charIndex:3384},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:3730}],headersStr:"什么是服务追踪 为什么需要服务追踪 服务链路监控的原理 服务追踪系统实现 数据采集层 数据处理层 数据展示层 调用链路图 调用拓扑图 服务追踪技术选型 参考资料",content:"# 服务追踪\n\n\n# 什么是服务追踪\n\n在微服务架构下，由于进行了服务拆分，一次请求往往需要涉及多个服务，每个服务可能是由不同的团队开发，使用了不同的编程语言，还有可能部署在不同的机器上，分布在不同的数据中心。如果请求失败了，要想查清楚到底是哪个应用导致，会是非常复杂的一件事情。\n\n如果有一个系统，可以跟踪记录一次用户请求都发起了哪些调用，经过哪些服务处理，并且记录每一次调用所涉及的服务的详细信息，这时候如果发生调用失败，你就可以通过这个日志快速定位是在哪个环节出了问题，这个系统就是服务链路监控。\n\n\n# 为什么需要服务追踪\n\n * 优化系统瓶颈：通过记录调用经过的每一条链路上的耗时，我们能快速定位整个系统的瓶颈点在哪里。比如你访问微博首页发现很慢，肯定是由于某种原因造成的，有可能是运营商网络延迟，有可能是网关系统异常，有可能是某个服务异常，还有可能是缓存或者数据库异常。通过服务追踪，可以从全局视角上去观察，找出整个系统的瓶颈点所在，然后做出针对性的优化。\n * 优化链路调用：通过服务追踪可以分析调用所经过的路径，然后评估是否合理。比如一个服务调用下游依赖了多个服务，通过调用链分析，可以评估是否每个依赖都是必要的，是否可以通过业务优化来减少服务依赖。还有就是，一般业务都会在多个数据中心都部署服务，以实现异地容灾，这个时候经常会出现一种状况就是服务 A 调用了另外一个数据中心的服务 B，而没有调用同处于一个数据中心的服务 B。根据我的经验，跨数据中心的调用视距离远近都会有一定的网络延迟，像北京和广州这种几千公里距离的网络延迟可能达到 30ms 以上，这对于有些业务几乎是不可接受的。通过对调用链路进行分析，可以找出跨数据中心的服务调用，从而进行优化，尽量规避这种情况出现。\n * 生成网络拓扑：通过服务追踪系统中记录的链路信息，可以生成一张系统的网络调用拓扑图，它可以反映系统都依赖了哪些服务，以及服务之间的调用关系是什么样的，可以一目了然。除此之外，在网络拓扑图上还可以把服务调用的详细信息也标出来，也能起到服务监控的作用。\n * 透明传输数据：除了服务追踪，业务上经常有一种需求，期望能把一些用户数据，从调用的开始一直往下传递，以便系统中的各个服务都能获取到这个信息。比如业务想做一些 A/B 测试，这时候就想通过服务追踪系统，把 A/B 测试的开关逻辑一直往下传递，经过的每一层服务都能获取到这个开关值，就能够统一进行 A/B 测试。\n\n\n# 服务链路监控的原理\n\nGoogle 发布的一篇的论文 Dapper, a Large-Scale Distributed Systems Tracing Infrastructure，里面详细讲解了服务追踪系统的实现原理。它的核心理念就是调用链：通过一个全局唯一的 ID 将分布在各个服务节点上的同一次请求串联起来，从而还原原有的调用关系，可以追踪系统问题、分析调用数据并统计各种系统指标。\n\n可以说后面的诞生各种服务追踪系统都是基于 Dapper 衍生出来的，比较有名的有 Twitter 的Zipkin、阿里的鹰眼、美团的MTrace等。\n\n要理解服务追踪的原理，首先必须搞懂一些基本概念：traceId、spanId、annonation 等。Dapper 这篇论文讲得比较清楚，但对初学者来说理解起来可能有点困难，美团的 MTrace 的原理介绍理解起来相对容易一些，下面我就以 MTrace 为例，给你详细讲述服务追踪系统的实现原理。虽然原理有些晦涩，但却是你必须掌握的，只有理解了服务追踪的基本概念，才能更好地将其实现出来。\n\n\n\n * Trace：用于表示某一次具体的请求。当用户的请求进入系统后，会在 RPC 调用网络的第一层生成一个全局唯一的 Trace ID，并且会随着每一层的 RPC 调用，不断往后传递，这样的话通过 Trace ID 就可以把一次用户请求在系统中调用的路径串联起来。\n * Span：工作的基本单位。Span 用于标识一次 RPC 调用在分布式请求中的位置。当用户的请求进入系统后，处在 RPC 调用网络的第一层 A 时 Span ID 初始值是 0，进入下一层 RPC 调用 B 的时候 Span ID 是 0.1，继续进入下一层 RPC 调用 C 时 Span ID 是 0.1.1，而与 B 处在同一层的 RPC 调用 E 的 Span ID 是 0.2，这样的话通过 Span ID 就可以定位某一次 RPC 请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。\n * Annotation：用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户 UID。\n\n\n# 服务追踪系统实现\n\n一个服务追踪系统可以分为三层：\n\n * 数据采集层，负责数据埋点并上报。\n * 数据处理层，负责数据的存储与计算。\n * 数据展示层，负责数据的图形化展示。\n\n\n# 数据采集层\n\n数据采集层的作用就是在系统的各个不同模块中进行埋点，采集数据并上报给数据处理层进行处理。\n\n那么该如何进行数据埋点呢？\n\n一次 RPC 请求可以分为四个阶段。\n\n * **CS（Client Send）**阶段 : 客户端发起请求，并生成调用的上下文。\n * **SR（Server Recieve）**阶段 : 服务端接收请求，并生成上下文。\n * **SS（Server Send）**阶段 : 服务端返回请求，这个阶段会将服务端上下文数据上报，下面这张图可以说明上报的数据有：traceId=123456，spanId=0.1，appKey=B，method=B.method，start=103，duration=38。\n * **CR（Client Recieve）**阶段 : 客户端接收返回结果，这个阶段会将客户端上下文数据上报，上报的数据有：traceid=123456，spanId=0.1，appKey=A，method=B.method，start=103，duration=38。\n\n\n# 数据处理层\n\n数据处理层的作用就是把数据采集层上报的数据按需计算，然后落地存储供查询使用。\n\n数据处理的需求一般分为两类，一类是实时计算需求，一类是离线计算需求。\n\n实时计算需求对计算效率要求比较高，一般要求对收集的链路数据能够在秒级别完成聚合计算，以供实时查询。而离线计算需求对计算效率要求就没那么高了，一般能在小时级别完成链路数据的聚合计算即可，一般用作数据汇总统计。针对这两类不同的数据处理需求，采用的计算方法和存储也不相同。\n\n * 实时数据处理：针对实时数据处理，一般采用 Flink、Storm、Spark Streaming 来对链路数据进行实时聚合加工，存储一般使用 OLTP 数据仓库，比如 HBase，使用 traceId 作为 RowKey，能天然地把一整条调用链聚合在一起，提高查询效率。\n\n * 离线数据处理：针对离线数据处理，一般通过运行 MapReduce 或者 Spark 批处理程序来对链路数据进行离线计算，存储一般使用 Hive。\n\n\n# 数据展示层\n\n数据展示层的作用就是将处理后的链路信息以图形化的方式展示给用户。\n\n实际项目中主要用到两种图形展示，一种是调用链路图，一种是调用拓扑图。\n\n# 调用链路图\n\n调用链路图一般展示服务总耗时、服务调用的网络深度、每一层经过的系统，以及多少次调用。调用链路图在实际项目中，主要是被用来做故障定位，比如某一次用户调用失败了，可以通过调用链路图查询这次用户调用经过了哪些环节，到底是哪一层的调用失败所导致。\n\n下面是 Zipkin 的调用链路图：\n\n\n\n# 调用拓扑图\n\n调用拓扑图一般展示系统内都包含哪些应用，它们之间是什么关系，以及依赖调用的 QPS、平均耗时情况。调用拓扑图是一种全局视野图，在实际项目中，主要用作全局监控，用于发现系统中异常的点，从而快速做出决策。比如，某一个服务突然出现异常，那么在调用链路拓扑图中可以看出对这个服务的调用耗时都变高了，可以用红色的图样标出来，用作监控报警。\n\n下面是 Pinpoint 的调用链路图：\n\n\n\n\n# 服务追踪技术选型\n\n服务追踪的主流开源产品比较丰富，主要有\n\n * Zipkin：Zipkin 是 Twitter 开源的调用链分析工具，目前基于 spring-cloud-sleuth 得到了广泛的使用，特点是轻量，使用、部署简单。\n * Pinpoint：是韩国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI 功能强大，接入端无代码侵入。\n * SkyWalking：是本土开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，UI 功能较强，接入端无代码侵入。目前已加入 Apache 孵化器。\n * CAT：CAT 是美团点评开源的基于编码和配置的调用链分析，应用监控分析，日志采集，监控报警等一系列的监控平台工具。\n\n\n# 参考资料\n\n * 从 0 开始学微服务\n * RPC 实战与核心原理\n * 微服务架构核心 20 讲",normalizedContent:"# 服务追踪\n\n\n# 什么是服务追踪\n\n在微服务架构下，由于进行了服务拆分，一次请求往往需要涉及多个服务，每个服务可能是由不同的团队开发，使用了不同的编程语言，还有可能部署在不同的机器上，分布在不同的数据中心。如果请求失败了，要想查清楚到底是哪个应用导致，会是非常复杂的一件事情。\n\n如果有一个系统，可以跟踪记录一次用户请求都发起了哪些调用，经过哪些服务处理，并且记录每一次调用所涉及的服务的详细信息，这时候如果发生调用失败，你就可以通过这个日志快速定位是在哪个环节出了问题，这个系统就是服务链路监控。\n\n\n# 为什么需要服务追踪\n\n * 优化系统瓶颈：通过记录调用经过的每一条链路上的耗时，我们能快速定位整个系统的瓶颈点在哪里。比如你访问微博首页发现很慢，肯定是由于某种原因造成的，有可能是运营商网络延迟，有可能是网关系统异常，有可能是某个服务异常，还有可能是缓存或者数据库异常。通过服务追踪，可以从全局视角上去观察，找出整个系统的瓶颈点所在，然后做出针对性的优化。\n * 优化链路调用：通过服务追踪可以分析调用所经过的路径，然后评估是否合理。比如一个服务调用下游依赖了多个服务，通过调用链分析，可以评估是否每个依赖都是必要的，是否可以通过业务优化来减少服务依赖。还有就是，一般业务都会在多个数据中心都部署服务，以实现异地容灾，这个时候经常会出现一种状况就是服务 a 调用了另外一个数据中心的服务 b，而没有调用同处于一个数据中心的服务 b。根据我的经验，跨数据中心的调用视距离远近都会有一定的网络延迟，像北京和广州这种几千公里距离的网络延迟可能达到 30ms 以上，这对于有些业务几乎是不可接受的。通过对调用链路进行分析，可以找出跨数据中心的服务调用，从而进行优化，尽量规避这种情况出现。\n * 生成网络拓扑：通过服务追踪系统中记录的链路信息，可以生成一张系统的网络调用拓扑图，它可以反映系统都依赖了哪些服务，以及服务之间的调用关系是什么样的，可以一目了然。除此之外，在网络拓扑图上还可以把服务调用的详细信息也标出来，也能起到服务监控的作用。\n * 透明传输数据：除了服务追踪，业务上经常有一种需求，期望能把一些用户数据，从调用的开始一直往下传递，以便系统中的各个服务都能获取到这个信息。比如业务想做一些 a/b 测试，这时候就想通过服务追踪系统，把 a/b 测试的开关逻辑一直往下传递，经过的每一层服务都能获取到这个开关值，就能够统一进行 a/b 测试。\n\n\n# 服务链路监控的原理\n\ngoogle 发布的一篇的论文 dapper, a large-scale distributed systems tracing infrastructure，里面详细讲解了服务追踪系统的实现原理。它的核心理念就是调用链：通过一个全局唯一的 id 将分布在各个服务节点上的同一次请求串联起来，从而还原原有的调用关系，可以追踪系统问题、分析调用数据并统计各种系统指标。\n\n可以说后面的诞生各种服务追踪系统都是基于 dapper 衍生出来的，比较有名的有 twitter 的zipkin、阿里的鹰眼、美团的mtrace等。\n\n要理解服务追踪的原理，首先必须搞懂一些基本概念：traceid、spanid、annonation 等。dapper 这篇论文讲得比较清楚，但对初学者来说理解起来可能有点困难，美团的 mtrace 的原理介绍理解起来相对容易一些，下面我就以 mtrace 为例，给你详细讲述服务追踪系统的实现原理。虽然原理有些晦涩，但却是你必须掌握的，只有理解了服务追踪的基本概念，才能更好地将其实现出来。\n\n\n\n * trace：用于表示某一次具体的请求。当用户的请求进入系统后，会在 rpc 调用网络的第一层生成一个全局唯一的 trace id，并且会随着每一层的 rpc 调用，不断往后传递，这样的话通过 trace id 就可以把一次用户请求在系统中调用的路径串联起来。\n * span：工作的基本单位。span 用于标识一次 rpc 调用在分布式请求中的位置。当用户的请求进入系统后，处在 rpc 调用网络的第一层 a 时 span id 初始值是 0，进入下一层 rpc 调用 b 的时候 span id 是 0.1，继续进入下一层 rpc 调用 c 时 span id 是 0.1.1，而与 b 处在同一层的 rpc 调用 e 的 span id 是 0.2，这样的话通过 span id 就可以定位某一次 rpc 请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。\n * annotation：用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户 uid。\n\n\n# 服务追踪系统实现\n\n一个服务追踪系统可以分为三层：\n\n * 数据采集层，负责数据埋点并上报。\n * 数据处理层，负责数据的存储与计算。\n * 数据展示层，负责数据的图形化展示。\n\n\n# 数据采集层\n\n数据采集层的作用就是在系统的各个不同模块中进行埋点，采集数据并上报给数据处理层进行处理。\n\n那么该如何进行数据埋点呢？\n\n一次 rpc 请求可以分为四个阶段。\n\n * **cs（client send）**阶段 : 客户端发起请求，并生成调用的上下文。\n * **sr（server recieve）**阶段 : 服务端接收请求，并生成上下文。\n * **ss（server send）**阶段 : 服务端返回请求，这个阶段会将服务端上下文数据上报，下面这张图可以说明上报的数据有：traceid=123456，spanid=0.1，appkey=b，method=b.method，start=103，duration=38。\n * **cr（client recieve）**阶段 : 客户端接收返回结果，这个阶段会将客户端上下文数据上报，上报的数据有：traceid=123456，spanid=0.1，appkey=a，method=b.method，start=103，duration=38。\n\n\n# 数据处理层\n\n数据处理层的作用就是把数据采集层上报的数据按需计算，然后落地存储供查询使用。\n\n数据处理的需求一般分为两类，一类是实时计算需求，一类是离线计算需求。\n\n实时计算需求对计算效率要求比较高，一般要求对收集的链路数据能够在秒级别完成聚合计算，以供实时查询。而离线计算需求对计算效率要求就没那么高了，一般能在小时级别完成链路数据的聚合计算即可，一般用作数据汇总统计。针对这两类不同的数据处理需求，采用的计算方法和存储也不相同。\n\n * 实时数据处理：针对实时数据处理，一般采用 flink、storm、spark streaming 来对链路数据进行实时聚合加工，存储一般使用 oltp 数据仓库，比如 hbase，使用 traceid 作为 rowkey，能天然地把一整条调用链聚合在一起，提高查询效率。\n\n * 离线数据处理：针对离线数据处理，一般通过运行 mapreduce 或者 spark 批处理程序来对链路数据进行离线计算，存储一般使用 hive。\n\n\n# 数据展示层\n\n数据展示层的作用就是将处理后的链路信息以图形化的方式展示给用户。\n\n实际项目中主要用到两种图形展示，一种是调用链路图，一种是调用拓扑图。\n\n# 调用链路图\n\n调用链路图一般展示服务总耗时、服务调用的网络深度、每一层经过的系统，以及多少次调用。调用链路图在实际项目中，主要是被用来做故障定位，比如某一次用户调用失败了，可以通过调用链路图查询这次用户调用经过了哪些环节，到底是哪一层的调用失败所导致。\n\n下面是 zipkin 的调用链路图：\n\n\n\n# 调用拓扑图\n\n调用拓扑图一般展示系统内都包含哪些应用，它们之间是什么关系，以及依赖调用的 qps、平均耗时情况。调用拓扑图是一种全局视野图，在实际项目中，主要用作全局监控，用于发现系统中异常的点，从而快速做出决策。比如，某一个服务突然出现异常，那么在调用链路拓扑图中可以看出对这个服务的调用耗时都变高了，可以用红色的图样标出来，用作监控报警。\n\n下面是 pinpoint 的调用链路图：\n\n\n\n\n# 服务追踪技术选型\n\n服务追踪的主流开源产品比较丰富，主要有\n\n * zipkin：zipkin 是 twitter 开源的调用链分析工具，目前基于 spring-cloud-sleuth 得到了广泛的使用，特点是轻量，使用、部署简单。\n * pinpoint：是韩国人开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，ui 功能强大，接入端无代码侵入。\n * skywalking：是本土开源的基于字节码注入的调用链分析，以及应用监控分析工具。特点是支持多种插件，ui 功能较强，接入端无代码侵入。目前已加入 apache 孵化器。\n * cat：cat 是美团点评开源的基于编码和配置的调用链分析，应用监控分析，日志采集，监控报警等一系列的监控平台工具。\n\n\n# 参考资料\n\n * 从 0 开始学微服务\n * rpc 实战与核心原理\n * 微服务架构核心 20 讲",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"服务容错",frontmatter:{title:"服务容错",categories:["分布式","分布式关键技术","服务治理"],tags:["分布式","服务治理","监控","APM","链路追踪"],abbrlink:"9c24212e",date:"2022-04-20T17:27:42.000Z",permalink:"/pages/28bda8/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/03.%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/05.%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/04.%E6%9C%8D%E5%8A%A1%E5%AE%B9%E9%94%99.html",relativePath:"02.分布式/03.分布式关键技术/05.服务治理/04.服务容错.md",key:"v-35aeaf87",path:"/pages/28bda8/",headers:[{level:2,title:"故障分类",slug:"故障分类",normalizedTitle:"故障分类",charIndex:11},{level:3,title:"集群故障应对处理",slug:"集群故障应对处理",normalizedTitle:"集群故障应对处理",charIndex:293},{level:3,title:"机房故障应对处理",slug:"机房故障应对处理",normalizedTitle:"机房故障应对处理",charIndex:465},{level:3,title:"单机故障应对处理",slug:"单机故障应对处理",normalizedTitle:"单机故障应对处理",charIndex:921},{level:2,title:"容错策略",slug:"容错策略",normalizedTitle:"容错策略",charIndex:1111},{level:2,title:"容错设计模式",slug:"容错设计模式",normalizedTitle:"容错设计模式",charIndex:1986},{level:3,title:"断路器模式",slug:"断路器模式",normalizedTitle:"断路器模式",charIndex:1997},{level:3,title:"舱壁隔离模式",slug:"舱壁隔离模式",normalizedTitle:"舱壁隔离模式",charIndex:2271},{level:3,title:"重试模式",slug:"重试模式",normalizedTitle:"重试模式",charIndex:2433},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2680}],headersStr:"故障分类 集群故障应对处理 机房故障应对处理 单机故障应对处理 容错策略 容错设计模式 断路器模式 舱壁隔离模式 重试模式 参考资料",content:"# 服务容错\n\n\n# 故障分类\n\n从故障影响范围维度来看，分布式系统的故障可以分为三类：\n\n * 集群故障：根据业务量大小而定，集群规模从几台到甚至上万台都有可能。一旦某些代码出现 bug，可能整个集群都会发生故障，不能提供对外提供服务。\n * 机房故障：现在大多数互联网公司为了保证业务的高可用性，往往业务部署在不止一个机房。然而现实中，某机房的光缆因为道路施工被挖断，导致整个机房脱网的事情，也是时有发生的。并且这种事情往往容易上热搜。\n * 单机故障：集群中的个别机器出现故障，这种情况往往对全局没有太大影响，但会导致调用到故障机器上的请求都失败，影响整个系统的成功率。\n\n\n# 集群故障应对处理\n\n一般而言，集群故障的产生原因不外乎有两种：\n\n * 一种是代码 bug 所导致，比如说某一段 Java 代码不断地分配大对象，但没有及时回收导致 JVM OOM 退出；\n * 另一种是流量突刺，短时间突然而至的大量请求超出了系统的承载能力。\n\n应付集群故障的思路，主要是采用流量控制，主要手段有：限流、降级、熔断。\n\n\n# 机房故障应对处理\n\n单机房脱网的事情，多半是因为一些不可抗因素，如：机房失火、光缆被挖断等等。有句老话叫：不要把鸡蛋都放在一个篮子里。同理，不要把业务都部署在一个机房中，一旦机房出事，那就彻底完蛋了。所以，很多互联网公司的业务都采用多机房部署。如果要追求更高的可靠性，可以采用同城多活部署，甚至异地多活部署。\n\n多机房部署的好处显而易见，即提高了系统的可用性，但是这种架构引入了其他的问题：如何保证不同机房数据的一致性，如何切换多机房的流量，等等。\n\n针对流量切换问题，一般有两种手段：\n\n * 基于 DNS 解析的流量切换，一般是通过把请求访问域名解析的 VIP 从一个 IDC 切换到另外一个 IDC。\n * 基于 RPC 分组的流量切换，对于一个服务来说，如果是部署在多个 IDC 的话，一般每个 IDC 就是一个分组。假如一个 IDC 出现故障，那么原先路由到这个分组的流量，就可以通过向配置中心下发命令，把原先路由到这个分组的流量全部切换到别的分组，这样的话就可以切换故障 IDC 的流量了。\n\n\n# 单机故障应对处理\n\n对于大规模集群来说，出现单机故障的概率是很高的。当出现单机故障时，需要有一定的自动化处理手段。\n\n处理单机故障一个有效的办法就是自动重启。具体来讲，你可以设置一个阈值，比如以某个接口的平均耗时为准，当监控单机上某个接口的平均耗时超过一定阈值时，就认为这台机器有问题，这个时候就需要把有问题的机器从线上集群中摘除掉，然后在重启服务后，重新加入到集群中。\n\n\n# 容错策略\n\n服务调用并不总是一定成功的，前面我讲过，可能因为服务提供者节点自身宕机、进程异常退出或者服务消费者与提供者之间的网络出现故障等原因。对于服务调用失败的情况，需要有手段自动恢复，来保证调用成功。\n\n常用的手段主要有以下几种：\n\n * 故障转移（FailOver）：当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。这种策略要求服务调用的操作必须是幂等的，也就是说无论调用多少次，只要是同一个调用，返回的结果都是相同的，一般适合服务调用是读请求的场景。\n * 快速失败（FailFast）：只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。实际在业务执行时，一般非核心业务的调用，会采用快速失败策略，调用失败后一般就记录下失败日志就返回了。\n * 安全失败（Failsafe）：出现异常时，直接忽略。通常用于写入审计日志等操作。\n * 静默失败（Failsilent）：如果大量的请求需要等到超时（或者长时间处理后）才宣告失败，很容易由于某个远程服务的请求堆积而消耗大量的线程、内存、网络等资源，进而影响到整个系统的稳定。面对这种情况，一种合理的失败策略是当请求失败后，就默认服务提供者一定时间内无法再对外提供服务，不再向它分配请求流量，将错误隔离开来，避免对系统其他部分产生影响，此即为沉默失败策略。\n * 故障恢复（FailBack）：就是服务消费者调用失败或者超时后，不再重试，而是根据失败的详细信息，来决定后续的执行策略。比如对于非幂等的调用场景，如果调用失败后，不能简单地重试，而是应该查询服务端的状态，看调用到底是否实际生效，如果已经生效了就不能再重试了；如果没有生效可以再发起一次调用。通常用于消息通知操作。\n * 并行调用（Forking）：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。\n * 广播调用（Broadcast）：广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n\n\n# 容错设计模式\n\n\n# 断路器模式\n\n断路器的基本思路是很简单的，就是通过代理（断路器对象）来一对一地（一个远程服务对应一个断路器对象）接管服务调用者的远程请求。断路器会持续监控并统计服务返回的成功、失败、超时、拒绝等各种结果，当出现故障（失败、超时、拒绝）的次数达到断路器的阈值时，它状态就自动变为“OPEN”，后续此断路器代理的远程访问都将直接返回调用失败，而不会发出真正的远程服务请求。通过断路器对远程服务的熔断，避免因持续的失败或拒绝而消耗资源，因持续的超时而堆积请求，最终的目的就是避免雪崩效应的出现。由此可见，断路器本质是一种快速失败策略的实现方式。\n\n\n# 舱壁隔离模式\n\n舱壁隔离模式是常用的实现服务隔离的设计模式，舱壁这个词是来自造船业的舶来品，它原本的意思是设计舰船时，要在每个区域设计独立的水密舱室，一旦某个舱室进水，也只是影响这个舱室中的货物，而不至于让整艘舰艇沉没。这种思想就很符合容错策略中失败静默策略。\n\nHystrix 就采用舱壁隔离模式来实现线程隔离。\n\n\n# 重试模式\n\n故障转移和故障恢复策略都需要对服务进行重复调用，差别是这些重复调用有可能是同步的，也可能是后台异步进行；有可能会重复调用同一个服务，也可能会调用到服务的其他副本。无论具体是通过怎样的方式调用、调用的服务实例是否相同，都可以归结为重试设计模式的应用范畴。重试模式适合解决系统中的瞬时故障，简单的说就是有可能自己恢复（Resilient，称为自愈，也叫做回弹性）的临时性失灵，网络抖动、服务的临时过载（典型的如返回了 503 Bad Gateway 错误）这些都属于瞬时故障。\n\n\n# 参考资料\n\n * 从 0 开始学微服务\n * 凤凰架构之服务容错",normalizedContent:"# 服务容错\n\n\n# 故障分类\n\n从故障影响范围维度来看，分布式系统的故障可以分为三类：\n\n * 集群故障：根据业务量大小而定，集群规模从几台到甚至上万台都有可能。一旦某些代码出现 bug，可能整个集群都会发生故障，不能提供对外提供服务。\n * 机房故障：现在大多数互联网公司为了保证业务的高可用性，往往业务部署在不止一个机房。然而现实中，某机房的光缆因为道路施工被挖断，导致整个机房脱网的事情，也是时有发生的。并且这种事情往往容易上热搜。\n * 单机故障：集群中的个别机器出现故障，这种情况往往对全局没有太大影响，但会导致调用到故障机器上的请求都失败，影响整个系统的成功率。\n\n\n# 集群故障应对处理\n\n一般而言，集群故障的产生原因不外乎有两种：\n\n * 一种是代码 bug 所导致，比如说某一段 java 代码不断地分配大对象，但没有及时回收导致 jvm oom 退出；\n * 另一种是流量突刺，短时间突然而至的大量请求超出了系统的承载能力。\n\n应付集群故障的思路，主要是采用流量控制，主要手段有：限流、降级、熔断。\n\n\n# 机房故障应对处理\n\n单机房脱网的事情，多半是因为一些不可抗因素，如：机房失火、光缆被挖断等等。有句老话叫：不要把鸡蛋都放在一个篮子里。同理，不要把业务都部署在一个机房中，一旦机房出事，那就彻底完蛋了。所以，很多互联网公司的业务都采用多机房部署。如果要追求更高的可靠性，可以采用同城多活部署，甚至异地多活部署。\n\n多机房部署的好处显而易见，即提高了系统的可用性，但是这种架构引入了其他的问题：如何保证不同机房数据的一致性，如何切换多机房的流量，等等。\n\n针对流量切换问题，一般有两种手段：\n\n * 基于 dns 解析的流量切换，一般是通过把请求访问域名解析的 vip 从一个 idc 切换到另外一个 idc。\n * 基于 rpc 分组的流量切换，对于一个服务来说，如果是部署在多个 idc 的话，一般每个 idc 就是一个分组。假如一个 idc 出现故障，那么原先路由到这个分组的流量，就可以通过向配置中心下发命令，把原先路由到这个分组的流量全部切换到别的分组，这样的话就可以切换故障 idc 的流量了。\n\n\n# 单机故障应对处理\n\n对于大规模集群来说，出现单机故障的概率是很高的。当出现单机故障时，需要有一定的自动化处理手段。\n\n处理单机故障一个有效的办法就是自动重启。具体来讲，你可以设置一个阈值，比如以某个接口的平均耗时为准，当监控单机上某个接口的平均耗时超过一定阈值时，就认为这台机器有问题，这个时候就需要把有问题的机器从线上集群中摘除掉，然后在重启服务后，重新加入到集群中。\n\n\n# 容错策略\n\n服务调用并不总是一定成功的，前面我讲过，可能因为服务提供者节点自身宕机、进程异常退出或者服务消费者与提供者之间的网络出现故障等原因。对于服务调用失败的情况，需要有手段自动恢复，来保证调用成功。\n\n常用的手段主要有以下几种：\n\n * 故障转移（failover）：当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。这种策略要求服务调用的操作必须是幂等的，也就是说无论调用多少次，只要是同一个调用，返回的结果都是相同的，一般适合服务调用是读请求的场景。\n * 快速失败（failfast）：只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。实际在业务执行时，一般非核心业务的调用，会采用快速失败策略，调用失败后一般就记录下失败日志就返回了。\n * 安全失败（failsafe）：出现异常时，直接忽略。通常用于写入审计日志等操作。\n * 静默失败（failsilent）：如果大量的请求需要等到超时（或者长时间处理后）才宣告失败，很容易由于某个远程服务的请求堆积而消耗大量的线程、内存、网络等资源，进而影响到整个系统的稳定。面对这种情况，一种合理的失败策略是当请求失败后，就默认服务提供者一定时间内无法再对外提供服务，不再向它分配请求流量，将错误隔离开来，避免对系统其他部分产生影响，此即为沉默失败策略。\n * 故障恢复（failback）：就是服务消费者调用失败或者超时后，不再重试，而是根据失败的详细信息，来决定后续的执行策略。比如对于非幂等的调用场景，如果调用失败后，不能简单地重试，而是应该查询服务端的状态，看调用到底是否实际生效，如果已经生效了就不能再重试了；如果没有生效可以再发起一次调用。通常用于消息通知操作。\n * 并行调用（forking）：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。\n * 广播调用（broadcast）：广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。\n\n\n# 容错设计模式\n\n\n# 断路器模式\n\n断路器的基本思路是很简单的，就是通过代理（断路器对象）来一对一地（一个远程服务对应一个断路器对象）接管服务调用者的远程请求。断路器会持续监控并统计服务返回的成功、失败、超时、拒绝等各种结果，当出现故障（失败、超时、拒绝）的次数达到断路器的阈值时，它状态就自动变为“open”，后续此断路器代理的远程访问都将直接返回调用失败，而不会发出真正的远程服务请求。通过断路器对远程服务的熔断，避免因持续的失败或拒绝而消耗资源，因持续的超时而堆积请求，最终的目的就是避免雪崩效应的出现。由此可见，断路器本质是一种快速失败策略的实现方式。\n\n\n# 舱壁隔离模式\n\n舱壁隔离模式是常用的实现服务隔离的设计模式，舱壁这个词是来自造船业的舶来品，它原本的意思是设计舰船时，要在每个区域设计独立的水密舱室，一旦某个舱室进水，也只是影响这个舱室中的货物，而不至于让整艘舰艇沉没。这种思想就很符合容错策略中失败静默策略。\n\nhystrix 就采用舱壁隔离模式来实现线程隔离。\n\n\n# 重试模式\n\n故障转移和故障恢复策略都需要对服务进行重复调用，差别是这些重复调用有可能是同步的，也可能是后台异步进行；有可能会重复调用同一个服务，也可能会调用到服务的其他副本。无论具体是通过怎样的方式调用、调用的服务实例是否相同，都可以归结为重试设计模式的应用范畴。重试模式适合解决系统中的瞬时故障，简单的说就是有可能自己恢复（resilient，称为自愈，也叫做回弹性）的临时性失灵，网络抖动、服务的临时过载（典型的如返回了 503 bad gateway 错误）这些都属于瞬时故障。\n\n\n# 参考资料\n\n * 从 0 开始学微服务\n * 凤凰架构之服务容错",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"微服务基本原理",frontmatter:{title:"微服务基本原理",categories:["分布式","分布式应用","微服务"],tags:["分布式","分布式应用","微服务"],abbrlink:"717ee426",date:"2020-07-21T15:35:00.000Z",permalink:"/pages/5b6d71/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/04.%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.html",relativePath:"02.分布式/04.分布式应用/01.微服务/01.微服务基本原理.md",key:"v-6c538cc0",path:"/pages/5b6d71/",headers:[{level:2,title:"1. 微服务简介",slug:"_1-微服务简介",normalizedTitle:"1. 微服务简介",charIndex:14},{level:3,title:"1.1. 什么是微服务架构",slug:"_1-1-什么是微服务架构",normalizedTitle:"1.1. 什么是微服务架构",charIndex:27},{level:3,title:"1.2. 如何权衡微服务的利弊",slug:"_1-2-如何权衡微服务的利弊",normalizedTitle:"1.2. 如何权衡微服务的利弊",charIndex:198},{level:3,title:"1.3. 康威定律",slug:"_1-3-康威定律",normalizedTitle:"1.3. 康威定律",charIndex:293},{level:3,title:"1.4. 如何拆分微服务",slug:"_1-4-如何拆分微服务",normalizedTitle:"1.4. 如何拆分微服务",charIndex:429},{level:2,title:"2. 微服务技术架构",slug:"_2-微服务技术架构",normalizedTitle:"2. 微服务技术架构",charIndex:705},{level:2,title:"3. 服务注册发现",slug:"_3-服务注册发现",normalizedTitle:"3. 服务注册发现",charIndex:834},{level:3,title:"3.1. 注册中心的工作流程",slug:"_3-1-注册中心的工作流程",normalizedTitle:"3.1. 注册中心的工作流程",charIndex:1234},{level:3,title:"3.2. 注册中心实现模式",slug:"_3-2-注册中心实现模式",normalizedTitle:"3.2. 注册中心实现模式",charIndex:1431},{level:4,title:"3.2.1. 应用内注册和发现",slug:"_3-2-1-应用内注册和发现",normalizedTitle:"3.2.1. 应用内注册和发现",charIndex:1448},{level:4,title:"3.2.2. 应用外注册和发现",slug:"_3-2-2-应用外注册和发现",normalizedTitle:"3.2.2. 应用外注册和发现",charIndex:1743},{level:4,title:"3.2.3. 注册中心选型",slug:"_3-2-3-注册中心选型",normalizedTitle:"3.2.3. 注册中心选型",charIndex:2039},{level:5,title:"3.2.3.1. 高可用性",slug:"_3-2-3-1-高可用性",normalizedTitle:"3.2.3.1. 高可用性",charIndex:2056},{level:5,title:"3.2.3.2. 数据一致性",slug:"_3-2-3-2-数据一致性",normalizedTitle:"3.2.3.2. 数据一致性",charIndex:2122},{level:3,title:"3.3. 服务注册发现的问题",slug:"_3-3-服务注册发现的问题",normalizedTitle:"3.3. 服务注册发现的问题",charIndex:2635},{level:4,title:"3.3.1. 多注册中心",slug:"_3-3-1-多注册中心",normalizedTitle:"3.3.1. 多注册中心",charIndex:2653},{level:4,title:"3.3.2. 并行订阅服务",slug:"_3-3-2-并行订阅服务",normalizedTitle:"3.3.2. 并行订阅服务",charIndex:2725},{level:4,title:"3.3.3. 批量注销服务",slug:"_3-3-3-批量注销服务",normalizedTitle:"3.3.3. 批量注销服务",charIndex:2853},{level:4,title:"3.3.4. 服务变更信息同步更新",slug:"_3-3-4-服务变更信息同步更新",normalizedTitle:"3.3.4. 服务变更信息同步更新",charIndex:2929},{level:3,title:"3.4. 识别服务节点是否存活",slug:"_3-4-识别服务节点是否存活",normalizedTitle:"3.4. 识别服务节点是否存活",charIndex:3073},{level:4,title:"3.4.1. 心跳开关保护机制",slug:"_3-4-1-心跳开关保护机制",normalizedTitle:"3.4.1. 心跳开关保护机制",charIndex:3092},{level:4,title:"3.4.2. 服务节点摘除保护机制",slug:"_3-4-2-服务节点摘除保护机制",normalizedTitle:"3.4.2. 服务节点摘除保护机制",charIndex:3588},{level:2,title:"4. 服务通信",slug:"_4-服务通信",normalizedTitle:"4. 服务通信",charIndex:4136},{level:3,title:"4.1. 序列化方式",slug:"_4-1-序列化方式",normalizedTitle:"4.1. 序列化方式",charIndex:4554},{level:3,title:"4.2. 通信协议",slug:"_4-2-通信协议",normalizedTitle:"4.2. 通信协议",charIndex:4639},{level:2,title:"5. 服务监控",slug:"_5-服务监控",normalizedTitle:"5. 服务监控",charIndex:5072},{level:3,title:"5.1. 监控对象",slug:"_5-1-监控对象",normalizedTitle:"5.1. 监控对象",charIndex:5206},{level:3,title:"5.2. 系统监控原理",slug:"_5-2-系统监控原理",normalizedTitle:"5.2. 系统监控原理",charIndex:5427},{level:4,title:"5.2.1. 数据采集",slug:"_5-2-1-数据采集",normalizedTitle:"5.2.1. 数据采集",charIndex:5501},{level:4,title:"5.2.2. 数据传输",slug:"_5-2-2-数据传输",normalizedTitle:"5.2.2. 数据传输",charIndex:5718},{level:4,title:"5.2.3. 数据处理",slug:"_5-2-3-数据处理",normalizedTitle:"5.2.3. 数据处理",charIndex:5937},{level:4,title:"5.2.4. 数据展示",slug:"_5-2-4-数据展示",normalizedTitle:"5.2.4. 数据展示",charIndex:6286},{level:3,title:"5.3. 监控技术",slug:"_5-3-监控技术",normalizedTitle:"5.3. 监控技术",charIndex:6364},{level:2,title:"6. 服务治理",slug:"_6-服务治理",normalizedTitle:"6. 服务治理",charIndex:6691},{level:2,title:"7. API 网关",slug:"_7-api-网关",normalizedTitle:"7. api 网关",charIndex:7143},{level:3,title:"7.1. Zuul",slug:"_7-1-zuul",normalizedTitle:"7.1. zuul",charIndex:7383},{level:2,title:"8. 负载均衡",slug:"_8-负载均衡",normalizedTitle:"8. 负载均衡",charIndex:7855},{level:2,title:"9. 服务路由",slug:"_9-服务路由",normalizedTitle:"9. 服务路由",charIndex:7882},{level:3,title:"9.1. 服务路由的应用场景",slug:"_9-1-服务路由的应用场景",normalizedTitle:"9.1. 服务路由的应用场景",charIndex:7945},{level:3,title:"9.2. 服务路由的规则",slug:"_9-2-服务路由的规则",normalizedTitle:"9.2. 服务路由的规则",charIndex:8439},{level:4,title:"9.2.1. 条件路由",slug:"_9-2-1-条件路由",normalizedTitle:"9.2.1. 条件路由",charIndex:8485},{level:4,title:"9.2.2. 脚本路由",slug:"_9-2-2-脚本路由",normalizedTitle:"9.2.2. 脚本路由",charIndex:10120},{level:3,title:"9.3. 服务路由的获取方式",slug:"_9-3-服务路由的获取方式",normalizedTitle:"9.3. 服务路由的获取方式",charIndex:10738},{level:3,title:"9.4. 内部服务调用",slug:"_9-4-内部服务调用",normalizedTitle:"9.4. 内部服务调用",charIndex:11033},{level:3,title:"9.5. 外部服务调用",slug:"_9-5-外部服务调用",normalizedTitle:"9.5. 外部服务调用",charIndex:11213},{level:2,title:"10. 配置中心",slug:"_10-配置中心",normalizedTitle:"10. 配置中心",charIndex:11621},{level:3,title:"10.1. Apollo",slug:"_10-1-apollo",normalizedTitle:"10.1. apollo",charIndex:11822},{level:3,title:"10.2. Spring Cloud Git",slug:"_10-2-spring-cloud-git",normalizedTitle:"10.2. spring cloud git",charIndex:11917},{level:2,title:"11. 链路追踪",slug:"_11-链路追踪",normalizedTitle:"11. 链路追踪",charIndex:12032},{level:3,title:"11.1. 链路追踪的作用",slug:"_11-1-链路追踪的作用",normalizedTitle:"11.1. 链路追踪的作用",charIndex:12045},{level:3,title:"11.2. 链路追踪的原理",slug:"_11-2-链路追踪的原理",normalizedTitle:"11.2. 链路追踪的原理",charIndex:12104},{level:3,title:"11.3. 链路追踪的实现",slug:"_11-3-链路追踪的实现",normalizedTitle:"11.3. 链路追踪的实现",charIndex:12577},{level:4,title:"11.3.1. 数据采集层",slug:"_11-3-1-数据采集层",normalizedTitle:"11.3.1. 数据采集层",charIndex:12676},{level:4,title:"11.3.2. 数据处理层",slug:"_11-3-2-数据处理层",normalizedTitle:"11.3.2. 数据处理层",charIndex:13070},{level:4,title:"11.3.3. 数据展示层",slug:"_11-3-3-数据展示层",normalizedTitle:"11.3.3. 数据展示层",charIndex:13343},{level:3,title:"11.4. 链路追踪方案对比",slug:"_11-4-链路追踪方案对比",normalizedTitle:"11.4. 链路追踪方案对比",charIndex:13431},{level:2,title:"12. 限流熔断",slug:"_12-限流熔断",normalizedTitle:"12. 限流熔断",charIndex:13452},{level:3,title:"12.1. 限流",slug:"_12-1-限流",normalizedTitle:"12.1. 限流",charIndex:13658},{level:3,title:"12.2. 降级",slug:"_12-2-降级",normalizedTitle:"12.2. 降级",charIndex:14228},{level:2,title:"13. DEVOPS",slug:"_13-devops",normalizedTitle:"13. devops",charIndex:14880},{level:3,title:"13.1. 容器和容器平台",slug:"_13-1-容器和容器平台",normalizedTitle:"13.1. 容器和容器平台",charIndex:14895},{level:2,title:"14. RPC 选型",slug:"_14-rpc-选型",normalizedTitle:"14. rpc 选型",charIndex:14940},{level:3,title:"14.1. 限定语言 RPC",slug:"_14-1-限定语言-rpc",normalizedTitle:"14.1. 限定语言 rpc",charIndex:14955},{level:3,title:"14.2. 跨语言 RPC",slug:"_14-2-跨语言-rpc",normalizedTitle:"14.2. 跨语言 rpc",charIndex:15674},{level:2,title:"15. Service Mesh",slug:"_15-service-mesh",normalizedTitle:"15. service mesh",charIndex:16306},{level:3,title:"15.1. Service Mesh 的实现原理",slug:"_15-1-service-mesh-的实现原理",normalizedTitle:"15.1. service mesh 的实现原理",charIndex:16329},{level:2,title:"16. 参考资料",slug:"_16-参考资料",normalizedTitle:"16. 参考资料",charIndex:16522}],headersStr:"1. 微服务简介 1.1. 什么是微服务架构 1.2. 如何权衡微服务的利弊 1.3. 康威定律 1.4. 如何拆分微服务 2. 微服务技术架构 3. 服务注册发现 3.1. 注册中心的工作流程 3.2. 注册中心实现模式 3.2.1. 应用内注册和发现 3.2.2. 应用外注册和发现 3.2.3. 注册中心选型 3.2.3.1. 高可用性 3.2.3.2. 数据一致性 3.3. 服务注册发现的问题 3.3.1. 多注册中心 3.3.2. 并行订阅服务 3.3.3. 批量注销服务 3.3.4. 服务变更信息同步更新 3.4. 识别服务节点是否存活 3.4.1. 心跳开关保护机制 3.4.2. 服务节点摘除保护机制 4. 服务通信 4.1. 序列化方式 4.2. 通信协议 5. 服务监控 5.1. 监控对象 5.2. 系统监控原理 5.2.1. 数据采集 5.2.2. 数据传输 5.2.3. 数据处理 5.2.4. 数据展示 5.3. 监控技术 6. 服务治理 7. API 网关 7.1. Zuul 8. 负载均衡 9. 服务路由 9.1. 服务路由的应用场景 9.2. 服务路由的规则 9.2.1. 条件路由 9.2.2. 脚本路由 9.3. 服务路由的获取方式 9.4. 内部服务调用 9.5. 外部服务调用 10. 配置中心 10.1. Apollo 10.2. Spring Cloud Git 11. 链路追踪 11.1. 链路追踪的作用 11.2. 链路追踪的原理 11.3. 链路追踪的实现 11.3.1. 数据采集层 11.3.2. 数据处理层 11.3.3. 数据展示层 11.4. 链路追踪方案对比 12. 限流熔断 12.1. 限流 12.2. 降级 13. DEVOPS 13.1. 容器和容器平台 14. RPC 选型 14.1. 限定语言 RPC 14.2. 跨语言 RPC 15. Service Mesh 15.1. Service Mesh 的实现原理 16. 参考资料",content:'# 微服务基本原理\n\n\n# 1. 微服务简介\n\n\n# 1.1. 什么是微服务架构\n\n互联网应用架构大致的演进方向为：单体架构 -> 服务化架构 -> 微服务架构。\n\n微服务架构的特点：\n\n * 服务拆分粒度更细：根据业务拆分。\n * 独立部署：每个服务部署在物理上隔离，互不影响。\n * 独立维护：根据组织架构拆分，分团队维护。\n * 服务治理：服务数量变多，需要有统一的服务治理平台。\n\n\n# 1.2. 如何权衡微服务的利弊\n\n优点\n\n * 强模块化边界\n * 可独立部署\n * 技术多样性\n\n缺点\n\n * 分布式复杂度\n * 最终一致性\n * 运维复杂度\n * 测试复杂度\n\n\n# 1.3. 康威定律\n\n * 第一定律：组织沟通方式会通过系统设计表达出来\n * 第二定律：时间再多一件事情也不可能做的完美，但总有时间做完一件事情\n * 第三定律：线型系统和线型组织架构间有潜在的异质同态特性\n * 第四定律：大的系统组织总是比小系统更倾向于分解\n\n\n# 1.4. 如何拆分微服务\n\n应用微服务化架构前，要思考几个问题：\n\n什么时候进行服务化拆分？如何拆分服务？\n\n当应用复杂度、开发团队膨胀到难以维护时，就该考虑服务化拆分了。\n\n拆分服务的思考维度：\n\n * 业务维度：业务和数据关系密切的应该放在一起。\n * 功能维度：公共功能聚合为一个服务。\n * 组织架构：根据实际组织架构，天然分为不同的团队，每个团队独立维护若干微服务。\n\n拆分服务的前置条件：\n\n应用微服务架构要先解决以下问题：\n\n * 服务如何定\n * 服务如何发布和订阅\n * 服务如何监控\n * 服务如何治理\n * 故障如何定位\n\n\n# 2. 微服务技术架构\n\n\n\n第一层：接入层\n\n外部设备访问的统一接入层。\n\n第二层：聚合服务层\n\n对下层的基础服务做一些聚合，剪裁的工作，适配上层不同设备的数据输出。\n\n第三层：基础服务层\n\n比较细粒度的微服务层，提供基础的核心服务，公共服务。\n\n\n\n\n# 3. 服务注册发现\n\n在微服务架构下，主要有三种角色：\n\n * 服务提供者（RPC Server / Provider）\n * 服务消费者（RPC Client / Consumer）\n * 服务注册中心（Registry）\n\n注册中心的实现依赖以下机制：\n\n * 注册中心 API\n * 集群部署：如果注册中心是单点，无法保障高可用。\n * 元数据存储：例如 ZooKeeper 将数据以层次化的目录结构存储。\n * 服务健康检查：使用长连接或心跳探测方式检查服务健康状态。\n * 服务状态变更通知：可以基于订阅者模式实现，例如 ZooKeeper 的 Watch 机制。\n * 白名单机制\n\n注册中心的服务注册和发现都是基于 API 的。一般需要支持以下功能：\n\n * 服务注册\n * 服务注销\n * 接口续约（心跳）\n * 服务订阅\n * 可用服务同步\n * 服务查询\n * 服务修改\n\n\n# 3.1. 注册中心的工作流程\n\n一般来讲，注册中心的工作流程是：\n\n * 服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。\n * 服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。\n * 注册中心返回服务提供者地址列表给服务消费者。\n * 当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。\n\n\n# 3.2. 注册中心实现模式\n\n# 3.2.1. 应用内注册和发现\n\n采用应用内注册与发现的方式，最典型的案例要属 Netflix 开源的 Eureka，官方架构图如下。\n\n\n\n对着这张图，我来介绍下 Eureka 的架构，它主要由三个重要的组件组成：\n\n * Eureka Server：注册中心的服务端，实现了服务信息注册、存储以及查询等功能。\n * 服务端的 Eureka Client：集成在服务端的注册中心 SDK，服务提供者通过调用 SDK，实现服务注册、反注册等功能。\n * 客户端的 Eureka Client：集成在客户端的注册中心 SDK，服务消费者通过调用 SDK，实现服务订阅、服务更新等功能。\n\n# 3.2.2. 应用外注册和发现\n\n\n\n通过这张架构图，可以看出来使用 Consul 实现应用外服务注册和发现主要依靠三个重要的组件：\n\n * Consul：注册中心的服务端，实现服务注册信息的存储，并提供注册和发现服务。\n * Registrator：一个开源的第三方服务管理器项目，它通过监听服务部署的 Docker 实例是否存活，来负责服务提供者的注册和销毁。\n * Consul Template：定时从注册中心服务端获取最新的服务提供者节点列表并刷新 LB 配置（比如 Nginx 的 upstream），这样服务消费者就通过访问 Nginx 就可以获取最新的服务提供者信息。\n\n# 3.2.3. 注册中心选型\n\n# 3.2.3.1. 高可用性\n\n集群部署，通过部署多个实例组成集群来保证高可用性。\n\n多 IDC 部署，即部署在不止一个机房。\n\n# 3.2.3.2. 数据一致性\n\n根据 CAP 理论，三者不能同时满足：\n\n * CP 型注册中心，牺牲可用性来保证数据强一致性，最典型的例子就是 ZooKeeper，etcd，Consul 了。ZooKeeper 集群内只有一个 Leader，而且在 Leader 无法使用的时候通过 Paxos 算法选举出一个新的 Leader。这个 Leader 的目的就是保证写信息的时候只向这个 Leader 写入，Leader 会同步信息到 Followers，这个过程就可以保证数据的强一致性。但如果多个 ZooKeeper 之间网络出现问题，造成出现多个 Leader，发生脑裂的话，注册中心就不可用了。而 etcd 和 Consul 集群内都是通过 raft 协议来保证强一致性，如果出现脑裂的话， 注册中心也不可用。\n * AP 型注册中心，牺牲一致性来保证可用性，最典型的例子就是 Eureka 了。对比下 Zookeeper，Eureka 不用选举一个 Leader，每个 Eureka 服务器单独保存服务注册地址，因此有可能出现数据信息不一致的情况。但是当网络出现问题的时候，每台服务器都可以完成独立的服务。\n\n\n# 3.3. 服务注册发现的问题\n\n# 3.3.1. 多注册中心\n\n对于服务消费者来说，要能够同时从多个注册中心订阅服务；对于服务提供者来说，要能够同时向多个注册中心注册服务。\n\n# 3.3.2. 并行订阅服务\n\n可以每订阅一个服务就单独用一个线程来处理，这样的话即使遇到个别服务节点连接超时，其他服务节点的初始化连接也不受影响，最慢也就是这个服务节点的初始化连接耗费的时间，最终所有服务节点的初始化连接耗时控制在了 30 秒以内。\n\n# 3.3.3. 批量注销服务\n\n需要定时去清理注册中心中的“僵尸节点”，如果支持批量注销服务，就可以一次调用就把该节点上提供的所有服务同时注销掉。\n\n# 3.3.4. 服务变更信息同步更新\n\n为了减少服务消费者从注册中心中拉取的服务可用节点信息的数据量，这个时候可以通过增量更新的方式，注册中心只返回变化的那部分节点信息，尤其在只有少数节点信息变更时，此举可以大大减少服务消费者从注册中心拉取的数据量，从而最大程度避免产生网络风暴。\n\n\n# 3.4. 识别服务节点是否存活\n\n# 3.4.1. 心跳开关保护机制\n\n在网络频繁抖动的情况下，注册中心中可用的节点会不断变化，这时候服务消费者会频繁收到服务提供者节点变更的信息，于是就不断地请求注册中心来拉取最新的可用服务节点信息。当有成百上千个服务消费者，同时请求注册中心获取最新的服务提供者的节点信息时，可能会把注册中心的带宽给占满，尤其是注册中心是百兆网卡的情况下。\n\n所以针对这种情况，需要一种保护机制，即使在网络频繁抖动的时候，服务消费者也不至于同时去请求注册中心获取最新的服务节点信息。\n\n我曾经就遇到过这种情况，一个可行的解决方案就是给注册中心设置一个开关，当开关打开时，即使网络频繁抖动，注册中心也不会通知所有的服务消费者有服务节点信息变更，比如只给 10% 的服务消费者返回变更，这样的话就能将注册中心的请求量减少到原来的 1/10。\n\n当然打开这个开关也是有一定代价的，它会导致服务消费者感知最新的服务节点信息延迟，原先可能在 10s 内就能感知到服务提供者节点信息的变更，现在可能会延迟到几分钟，所以在网络正常的情况下，开关并不适合打开；可以作为一个紧急措施，在网络频繁抖动的时候，才打开这个开关。\n\n# 3.4.2. 服务节点摘除保护机制\n\n服务提供者在进程启动时，会注册服务到注册中心，并每隔一段时间，汇报心跳给注册中心，以标识自己的存活状态。如果隔了一段固定时间后，服务提供者仍然没有汇报心跳给注册中心，注册中心就会认为该节点已经处于“dead”状态，于是从服务的可用节点信息中移除出去。\n\n如果遇到网络问题，大批服务提供者节点汇报给注册中心的心跳信息都可能会传达失败，注册中心就会把它们都从可用节点列表中移除出去，造成剩下的可用节点难以承受所有的调用，引起“雪崩”。但是这种情况下，可能大部分服务提供者节点是可用的，仅仅因为网络原因无法汇报心跳给注册中心就被“无情”的摘除了。\n\n这个时候就需要根据实际业务的情况，设定一个阈值比例，即使遇到刚才说的这种情况，注册中心也不能摘除超过这个阈值比例的节点。\n\n这个阈值比例可以根据实际业务的冗余度来确定，我通常会把这个比例设定在 20%，就是说注册中心不能摘除超过 20% 的节点。因为大部分情况下，节点的变化不会这么频繁，只有在网络抖动或者业务明确要下线大批量节点的情况下才有可能发生。而业务明确要下线大批量节点的情况是可以预知的，这种情况下可以关闭阈值保护；而正常情况下，应该打开阈值保护，以防止网络抖动时，大批量可用的服务节点被摘除。\n\n\n# 4. 服务通信\n\n通过注册中心，服务消费者和服务提供者就可以感知彼此，但是，要实现交互还必须解决通信问题：\n\n * 通信协议。即服务提供者和服务消费者之间以什么样的 协议 进行网络通信，说白了，是要解决客户端和服务端如何建立连接、管理连接以及服务端如何处理请求的问题。是采用四层 TCP、UDP 协议，还是采用七层 HTTP 协议，还是采用其他协议？例如：Dubbo 基于 TCP 通信；而 Spring Cloud 基于 HTTP REST 通信。TCP 通信方式，传输效率更高；但是 HTTP 方式天然可以提供对外服务。\n * 传输方式。即服务提供者和服务消费者之间的数据传输采用哪种方式。是同步还是异步？是在单连接上传输，还是多路复用。\n * 序列化和反序列化。它主要解决客户端和服务端采用哪种数据编解码的问题。常见的序列化方式包括：XML、JSON；二进制类如：thrift、protobuf、hessian、JDK。\n\n\n# 4.1. 序列化方式\n\n序列化方式的选型，一般基于以下考虑：\n\n * 支持数据结构类型的丰富度\n * 跨语言支持\n * 性能\n\n> 👉 参考：Java 序列化\n\n\n# 4.2. 通信协议\n\n微服务框架对比：\n\n       RPC                                       REST\n耦合性    强耦合                                       松散耦合\n协议     Tcp                                       Http、Http2\n序列化    二进制（Thrift、Protobuf、Hessian、Avro、JDK 等）   Xml、Json\n性能     高                                         低\n客户端    对编程语言有限制                                  跨语言支持更好（支持 Http 即可）\n代表技术   Dubbo、Motan、Tars、gRpc、Thrift              Spring Cloud\n\n\n# 5. 服务监控\n\n当服务消费者与服务提供者之间建立了通信，作为管理者需要通过监控手段来观察服务是否正常，调用是否成功。服务监控是很复杂的，在微服务架构下，一次用户调用会因为服务化拆分后，变成多个不同服务之间的相互调用，这也就需要对拆分后的每个服务都监控起来。\n\n\n# 5.1. 监控对象\n\n服务监控一定是通过观察数据来量化分析，所以首先要明确需要监控什么。\n\n一般来说，服务监控数据有以下分类：\n\n * 业务监控：核心指标、登录、登出、下单、支付等。\n * 应用监控：访问接口、访问服务、SQL、内存使用率、响应时间、TPS、QPS 等。\n * 系统监控：CPU、内存、网络、磁盘等。\n * 基础监控：网络流量、丢包数、错包数、连接数等。\n * 客户端监控：性能、返回码、地域、运营商、版本、系统等。\n\n\n# 5.2. 系统监控原理\n\n一旦明确了要监控的对象，接下就是考虑如何监控。\n\n监控系统主要包括四个环节：数据采集、数据传输、数据处理和数据展示\n\n# 5.2.1. 数据采集\n\n通常有两种数据收集方式：\n\n * 服务主动上报：这种处理方式通过在业务代码或者服务框架里加入数据收集代码逻辑，在每一次服务调用完成后，主动上报服务的调用信息。这种方式在链路跟踪中较为常见，主流的技术方案有：Zipkin。\n * 代理收集：这种处理方式通过服务调用后把调用的详细信息记录到本地日志文件中，然后再通过代理去解析本地日志文件，然后再上报服务的调用信息。主流的技术方案有：ELK、Flume。\n\n# 5.2.2. 数据传输\n\n数据传输最常用的方式有两种：\n\n * UDP 传输：这种处理方式是数据处理单元提供服务器的请求地址，数据采集后通过 UDP 协议与服务器建立连接，然后把数据发送过去。\n * Kafka 传输：这种处理方式是数据采集后发送到指定的 Topic，然后数据处理单元再订阅对应的 Topic，就可以从 Kafka 消息队列中读取到对应的数据。由于 Kafka 有非常高的吞吐能力，所以很适合作为大数据量的缓冲池。\n\n# 5.2.3. 数据处理\n\n数据处理是对收集来的原始数据进行聚合并存储。数据聚合通常有两个维度：\n\n * 接口维度聚合：这个维度是把实时收到的数据按照接口名维度实时聚合在一起，这样就可以得到每个接口的每秒请求量、平均耗时、成功率等信息。\n * 机器维度聚合：这个维度是把实时收到的数据按照调用的节点维度聚合在一起，这样就可以从单机维度去查看每个接口的实时请求量、平均耗时等信息。\n\n聚合后的数据需要持久化到数据库中存储，所选用的数据库一般分为两种：\n\n * 全文检索数据库：比如 Elasticsearch，以倒排索引的数据结构存储，需要查询的时候，根据索引来查询。\n * 时序数据库：比如 OpenTSDB，以时序序列数据的方式存储，查询的时候按照时序如 1min、5min 等维度来查询。\n\n# 5.2.4. 数据展示\n\n数据展示是把处理后的数据以 Dashboard 的方式展示给用户。数据展示有多种方式，比如曲线图、饼状图、格子图展示等。\n\n\n# 5.3. 监控技术\n\n\n\n * ELK 的技术栈比较成熟，应用范围也比较广，除了可用作监控系统外，还可以用作日志查询和分析。\n * Graphite 是基于时间序列数据库存储的监控系统，并且提供了功能强大的各种聚合函数比如 sum、average、top5 等可用于监控分析，而且对外提供了 API 也可以接入其他图形化监控系统如 Grafana。\n * TICK 的核心在于其时间序列数据库 InfluxDB 的存储功能强大，且支持类似 SQL 语言的复杂数据处理操作。\n * Prometheus 的独特之处在于它采用了拉数据的方式，对业务影响较小，同时也采用了时间序列数据库存储，而且支持独有的 PromQL 查询语言，功能强大而且简洁。\n\n\n# 6. 服务治理\n\n微服务治理平台就是与服务打交道的统一入口，无论是开发人员还是运维人员，都能通过这个平台对服务进行各种操作，比如开发人员可以通过这个平台对服务进行降级操作，运维人员可以通过这个平台对服务进行上下线操作，而不需要关心这个操作背后的具体实现。\n\n微服务治理平台关键之处就在于它能够封装对微服务架构内的各个基础设施组件的调用，从而对外提供统一的服务操作 API，而且还提供了可视化的界面，以方便开发人员和运维人员操作。\n\n\n\n服务治理的常用手段有：\n\n * 节点管理\n   * 注册中心主动摘除机制\n   * 服务消费者摘除机制\n * 负载均衡\n   * 轮询\n   * 随机\n   * 最近最少连接\n   * 一致性 Hash\n * 服务路由\n   * 业务存在灰度发布的需求\n   * 多机房就近访问的需求\n * 服务容错\n   * FailOver：失败自动切换\n   * FailBack：失败通知\n   * FailCache：失败缓存\n   * FailFast：快速失败\n\n\n# 7. API 网关\n\nAPI 网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API 网关封装了系统内部架构，为每个客户端提供一个定制的 API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。 API 网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供 REST/HTTP 的访问 API。服务端通过 API-GW 注册和管理服务。\n\n\n# 7.1. Zuul\n\n\n\n在 zuul 中， 整个请求的过程是这样的，首先将请求给 zuulservlet 处理，zuulservlet 中有一个 zuulRunner 对象，该对象中初始化了 RequestContext：作为存储整个请求的一些数据，并被所有的 zuulfilter 共享。zuulRunner 中还有 FilterProcessor，FilterProcessor 作为执行所有的 zuulfilter 的管理器。FilterProcessor 从 filterloader 中获取 zuulfilter，而 zuulfilter 是被 filterFileManager 所加载，并支持 groovy 热加载，采用了轮询的方式热加载。有了这些 filter 之后，zuulservelet 首先执行的 Pre 类型的过滤器，再执行 route 类型的过滤器，最后执行的是 post 类型的过滤器，如果在执行这些过滤器有错误的时候则会执行 error 类型的过滤器。执行完这些过滤器，最终将请求的结果返回给客户端。\n\n\n# 8. 负载均衡\n\n> 参考：负载均衡基本原理\n\n\n# 9. 服务路由\n\n服务路由就是服务消费者在发起服务调用时，必须根据特定的规则来选择服务节点，从而满足某些特定的需求。\n\n\n# 9.1. 服务路由的应用场景\n\n * 分组调用。一般来讲，为了保证服务的高可用性，实现异地多活的需求，一个服务往往不止部署在一个数据中心，而且出于节省成本等考虑，有些业务可能不仅在私有机房部署，还会采用公有云部署，甚至采用多家公有云部署。服务节点也会按照不同的数据中心分成不同的分组，这时对于服务消费者来说，选择哪一个分组调用，就必须有相应的路由规则。\n * 灰度发布。在服务上线发布的过程中，一般需要先在一小部分规模的服务节点上先发布服务，然后验证功能是否正常。如果正常的话就继续扩大发布范围；如果不正常的话，就需要排查问题，解决问题后继续发布。这个过程就叫作灰度发布，也叫金丝雀部署。\n * 流量切换。在业务线上运行过程中，经常会遇到一些不可抗力因素导致业务故障，比如某个机房的光缆被挖断，或者发生着火等事故导致整个机房的服务都不可用。这个时候就需要按照某个指令，能够把原来调用这个机房服务的流量切换到其他正常的机房。\n * 读写分离。对于大多数互联网业务来说都是读多写少，所以在进行服务部署的时候，可以把读写分开部署，所有写接口可以部署在一起，而读接口部署在另外的节点上。\n\n\n# 9.2. 服务路由的规则\n\n服务路由主要有两种规则：一种是条件路由，一种是脚本路由。\n\n# 9.2.1. 条件路由\n\n条件路由是基于条件表达式的路由规则。\n\ncondition://0.0.0.0/dubbo.test.interfaces.TestService?category=routers&dynamic=true&priority=2&enabled=true&rule=" + URL.encode(" host = 10.20.153.10=> host = 10.20.153.11")\n\n\n这里面 condition:// 代表了这是一段用条件表达式编写的路由规则，具体的规则是\n\nhost = 10.20.153.10 => host = 10.20.153.11\n\n\n分隔符“=>”前面是服务消费者的匹配条件，后面是服务提供者的过滤条件。当服务消费者节点满足匹配条件时，就对该服务消费者执行后面的过滤规则。那么上面这段表达式表达的意义就是 IP 为“10.20.153.10”的服务消费者都调用 IP 为“10.20.153.11”的服务提供者节点。\n\n如果服务消费者的匹配条件为空，就表示对所有的服务消费者应用，就像下面的表达式一样。\n\n=> host ！= 10.20.153.11\n\n\n如果服务提供者的过滤条件为空，就表示禁止服务消费者访问，就像下面的表达式一样。\n\nhost = 10.20.153.10=>\n\n\n下面我举一些 Dubbo 框架中的条件路由，来给你讲解下条件路由的具体应用场景。\n\n * 排除某个服务节点\n\n=> host != 172.22.3.91\n\n\n一旦这条路由规则被应用到线上，所有的服务消费者都不会访问 IP 为 172.22.3.91 的服务节点，这种路由规则一般应用在线上流量排除预发布机以及摘除某个故障节点的场景。\n\n * 白名单和黑名单功能\n\nhost != 10.20.153.10,10.20.153.11 =>\n\n\n这条路由规则意思是除了 IP 为 10.20.153.10 和 10.20.153.11 的服务消费者可以发起服务调用以外，其他服务消费者都不可以，主要用于白名单访问逻辑，比如某个后台服务只允许特定的几台机器才可以访问，这样的话可以机器控制访问权限。\n\nhost = 10.20.153.10,10.20.153.11 =>\n\n\n同理，这条路由规则意思是除了 IP 为 10.20.153.10 和 10.20.153.11 的服务消费者不能发起服务调用以外，其他服务消费者都可以，也就是实现了黑名单功能，比如线上经常会遇到某些调用方不管是出于有意还是无意的不合理调用，影响了服务的稳定性，这时候可以通过黑名单功能暂时予以封杀。\n\n * 机房隔离\n\nhost = 172.22.3.* => host = 172.22.3.*\n\n\n这条路由规则意思是 IP 网段为 172.22.3.* 的服务消费者，才可以访问同网段的服务节点，这种规则一般应用于服务部署在多个 IDC，理论上同一个 IDC 内的调用性能要比跨 IDC 调用性能要好，应用这个规则是为了实现同 IDC 就近访问。\n\n * 读写分离\n\nmethod = find*,list*,get*,is* => host =172.22.3.94,172.22.3.95\nmethod != find*,list*,get*,is* => host = 172.22.3.97,172.22.3.98\n\n\n这条路由规则意思是 find*、get*、is* 等读方法调用 IP 为 172.22.3.94 和 172.22.3.95 的节点，除此以外的写方法调用 IP 为 172.22.3.97 和 172.22.3.98 的节点。对于大部分互联网业务来说，往往读请求要远远大于写请求，而写请求的重要性往往要远远高于读请求，所以需要把读写请求进行分离，以避免读请求异常影响到写请求，这时候就可以应用这种规则。\n\n# 9.2.2. 脚本路由\n\n脚本路由是基于脚本语言的路由规则，常用的脚本语言比如 JavaScript、Groovy、JRuby 等。\n\n"script://0.0.0.0/com.foo.BarService?category=routers&dynamic=false&rule=" + URL.encode("（function route(invokers) { ... } (invokers)）")\n\n\n这里面“script://”就代表了这是一段脚本语言编写的路由规则，具体规则定义在脚本语言的 route 方法实现里，比如下面这段用 JavaScript 编写的 route() 方法表达的意思是，只有 IP 为 10.20.153.10 的服务消费者可以发起服务调用。\n\nfunction route(invokers){\n  var result = new java.util.ArrayList(invokers.size());\n  for(i =0; i < invokers.size(); i ++){\n    if("10.20.153.10".equals(invokers.get(i).getUrl().getHost())){\n       result.add(invokers.get(i));\n    }\n  }\n  return result;\n } (invokers)）;\n\n\n\n# 9.3. 服务路由的获取方式\n\n服务路由的获取方式主要有三种：\n\n * 本地配置\n\n顾名思义就是路由规则存储在服务消费者本地上。服务消费者发起调用时，从本地固定位置读取路由规则，然后按照路由规则选取一个服务节点发起调用。\n\n * 配置中心管理\n\n这种方式下，所有的服务消费者都从配置中心获取路由规则，由配置中心来统一管理。\n\n * 动态下发\n\n这种方式下，一般是运维人员或者开发人员，通过服务治理平台修改路由规则，服务治理平台调用配置中心接口，把修改后的路由规则持久化到配置中心。因为服务消费者订阅了路由规则的变更，于是就会从配置中心获取最新的路由规则，按照最新的路由规则来执行。\n\n\n# 9.4. 内部服务调用\n\n基础服务之间的调用：结合服务注册中心以及专属的具有负载均衡功能的客户端，如 Eureka+（restTemplate+Ribbon）或者 Eureka+Feign 聚合服务调用：结合服务注册中心以及专属的具有负载均衡功能的客户端，如 Eureka+（restTemplate+Ribbon）或者 Eureka+Feign\n\n\n\n\n# 9.5. 外部服务调用\n\n基于 Netflix 的 zuul，做了简单了解，SpringCloud 与 zuul 集成的方式。这里先对核心流程做个简单了解，后续会有深入的应用、分析。\n\nSpring Cloud 很好的集成了 zuul，并且可以通过注解的形式来进行请求的反向路由以及 API 网关功能 Spring Cloud 集成 zuul，对与 url 映射的处理方式与 SpringMVC 对 url 的请求方式类似，都是通过 RequestMapping 来进行请求绑定的。核心类：ZuulHandlerMapping zuul 的核心是 ZuulServlet，一个请求核心流程：HttpServletRequest –>ZuulHandlerMapping –>ZuulController –> ZuulServlet –> ZuulFilter –> HttpServletResponse\n\n\n# 10. 配置中心\n\n配置中心的思路就是把服务的各种配置，如代码里配置的各种参数、服务降级的开关甚至依赖的资源等都在一个地方统一进行管理。服务启动时，可以自动从配置中心中拉取所需的配置，并且如果有配置变更的情况，同样可以自动从配置中心拉取最新的配置信息，服务无须重新发布。\n\n配置中心一般包含下面几个功能：\n\n * 配置注册功能\n * 配置反注册功能\n * 配置查看功能\n * 配置变更订阅功能\n\n\n# 10.1. Apollo\n\n携程开源的分布式配置中心，支持 Java 和.Net 语言，客户端和配置中心通过 HTTP 长连接实现实时推送，并且有统一的管理界面来实现配置管理。\n\n\n\n\n# 10.2. Spring Cloud Git\n\nSpring Cloud 中使用的配置中心组件，只支持 Java 语言，配置存储在 git 中，变更配置也需要通过 git 操作，如果配置中心有配置变更，需要手动刷新。\n\n\n\n\n# 11. 链路追踪\n\n\n# 11.1. 链路追踪的作用\n\n * 优化系统瓶颈\n * 优化链路调用\n * 生成网络拓扑\n * 透明传输数据\n\n\n# 11.2. 链路追踪的原理\n\n理解链路追踪必须先了解以下概念：\n\n * traceId，用于标识某一次具体的请求 ID。当用户的请求进入系统后，会在 RPC 调用网络的第一层生成一个全局唯一的 traceId，并且会随着每一层的 RPC 调用，不断往后传递，这样的话通过 traceId 就可以把一次用户请求在系统中调用的路径串联起来。\n * spanId，用于标识一次 RPC 调用在分布式请求中的位置。当用户的请求进入系统后，处在 RPC 调用网络的第一层 A 时 spanId 初始值是 0，进入下一层 RPC 调用 B 的时候 spanId 是 0.1，继续进入下一层 RPC 调用 C 时 spanId 是 0.1.1，而与 B 处在同一层的 RPC 调用 E 的 spanId 是 0.2，这样的话通过 spanId 就可以定位某一次 RPC 请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。\n * annotation，用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户 UID。\n\n\n\n\n# 11.3. 链路追踪的实现\n\n一个服务追踪系统一般可以分为三层：\n\n * 数据采集层，负责数据埋点并上报。\n * 数据处理层，负责数据的存储与计算。\n * 数据展示层，负责数据的图形化展示。\n\n# 11.3.1. 数据采集层\n\n一次 RPC 请求可以分为四个阶段。\n\n * CS（Client Send）阶段 : 客户端发起请求，并生成调用的上下文。\n * SR（Server Recieve）阶段 : 服务端接收请求，并生成上下文。\n * SS（Server Send）阶段 : 服务端返回请求，这个阶段会将服务端上下文数据上报，下面这张图可以说明上报的数据有：traceId=123456，spanId=0.1，appKey=B，method=B.method，start=103，duration=38。\n * CR（Client Recieve）阶段 : 客户端接收返回结果，这个阶段会将客户端上下文数据上报，上报的数据有：traceid=123456，spanId=0.1，appKey=A，method=B.method，start=103，duration=38。\n\n# 11.3.2. 数据处理层\n\n数据处理层的作用就是把数据采集层上报的数据按需计算，然后落地存储供查询使用。\n\n * 实时数据处理\n\n针对实时数据处理，一般采用 Storm 或者 Spark Streaming 来对链路数据进行实时聚合加工，存储一般使用 OLTP 数据仓库，比如 HBase，使用 traceId 作为 RowKey，能天然地把一整条调用链聚合在一起，提高查询效率。\n\n * 离线数据处理\n\n针对离线数据处理，一般通过运行 MapReduce 或者 Spark 批处理程序来对链路数据进行离线计算，存储一般使用 Hive。\n\n# 11.3.3. 数据展示层\n\n数据展示层的作用就是将处理后的链路信息以图形化的方式展示给用户。\n\n实际项目中主要用到两种图形展示，一种是调用链路图，一种是调用拓扑图。\n\n\n# 11.4. 链路追踪方案对比\n\n\n\n\n# 12. 限流熔断\n\n一般而言，集群故障的产生原因不外乎有两种：\n\n一种是代码 bug 所导致，比如说某一段 Java 代码不断地分配大对象，但没有及时回收导致 JVM OOM 退出；\n\n另一种是突发的流量冲击，超出了系统的最大承载能力，比如“双 11”这种购物活动，电商系统会在零点一瞬间涌入大量流量，超出系统的最大承载能力，一下子就把整个系统给压垮了。\n\n应付集群故障的思路，主要有两种：限流和降级。\n\n\n# 12.1. 限流\n\n限流就是限制流量。通常情况下，系统能够承载的流量根据集群规模的大小是固定的，可以称之为系统的最大容量。当真实流量超过了系统的最大容量后，就会导致系统响应变慢，服务调用出现大量超时，反映给用户的感觉就是卡顿、无响应。所以，应该根据系统的最大容量，给系统设置一个阈值，超过这个阈值的请求会被自动抛弃，这样的话可以最大限度地保证系统提供的服务正常。\n\n除此之外，通常一个微服务系统会同时提供多个服务，每个服务在同一时刻的请求量也是不同的，很可能出现的一种情况就是，系统中某个服务的请求量突增，占用了系统中大部分资源，导致其他服务没有资源可用。因此，还要针对系统中每个服务的请求量也设置一个阈值，超过这个阈值的请求也要被自动抛弃，这样的话不至于因为一个服务影响了其他所有服务。\n\n在实际项目中，可以用两个指标来衡量服务的请求量，一个是 QPS 即每秒请求量，一个是工作线程数。不过 QPS 因为不同服务的响应快慢不同，所以系统能够承载的 QPS 相差很大，因此一般选择工作线程数来作为限流的指标，给系统设置一个总的最大工作线程数以及单个服务的最大工作线程数，这样的话无论是系统的总请求量过大导致整体工作线程数量达到最大工作线程数，还是某个服务的请求量超过单个服务的最大工作线程数，都会被限流，以起到保护整个系统的作用。\n\n\n# 12.2. 降级\n\n什么是降级呢？在我看来，降级就是通过停止系统中的某些功能，来保证系统整体的可用性。降级可以说是一种被动防御的措施，为什么这么说呢？因为它一般是系统已经出现故障后所采取的一种止损措施。\n\n那么降级一般是如何实现的呢？根据我的实践来看， 一种可行的方案是通过开关来实现。\n\n具体来讲，就是在系统运行的内存中开辟一块区域，专门用于存储开关的状态，也就是开启还是关闭。并且需要监听某个端口，通过这个端口可以向系统下发命令，来改变内存中开关的状态。当开关开启时，业务的某一段逻辑就不再执行，而正常情况下，开关是关闭的状态。\n\n开关一般用在两种地方，一种是新增的业务逻辑，因为新增的业务逻辑相对来说不成熟，往往具备一定的风险，所以需要加开关来控制新业务逻辑是否执行；另一种是依赖的服务或资源，因为依赖的服务或者资源不总是可靠的，所以最好是有开关能够控制是否对依赖服务或资源发起调用，来保证即使依赖出现问题，也能通过降级来避免影响。\n\n在实际业务应用的时候，降级要按照对业务的影响程度进行分级，一般分为三级：一级降级是对业务影响最小的降级，在故障的情况下，首先执行一级降级，所以一级降级也可以设置成自动降级，不需要人为干预；二级降级是对业务有一定影响的降级，在故障的情况下，如果一级降级起不到多大作用的时候，可以人为采取措施，执行二级降级；三级降级是对业务有较大影响的降级，这种降级要么是对商业收入有重大影响，要么是对用户体验有重大影响，所以操作起来要非常谨慎，不在最后时刻一般不予采用。\n\n\n# 13. DEVOPS\n\n\n# 13.1. 容器和容器平台\n\nMesos、Marathon、Kubernetes\n\n\n# 14. RPC 选型\n\n\n# 14.1. 限定语言 RPC\n\n跟语言平台绑定的开源 RPC 框架主要有下面几种。\n\n * Dubbo：国内最早开源的 RPC 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 Java 语言。\n * Motan：微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 Java 语言。\n * Tars：腾讯内部使用的 RPC 框架，于 2017 年对外开源，仅支持 C++ 语言。\n * Spring Cloud：国外 Pivotal 公司 2014 年对外开源的 RPC 框架，仅支持 Java 语言，最近几年生态发展得比较好，是比较火的 RPC 框架。\n\n所以很明显，如果你的业务场景仅仅局限于一种语言的话，可以选择跟语言绑定的 RPC 框架中的一种；如果涉及多个语言平台之间的相互调用，就应该选择跨语言平台的 RPC 框架。\n\n仔细分析，可以看出 Spring Cloud 不仅提供了基本的 RPC 框架功能，还提供了服务注册组件、配置中心组件、负载均衡组件、断路器组件、分布式消息追踪组件等一系列组件，也难怪被技术圈的人称之为“Spring Cloud 全家桶”。如果你不想自己实现以上这些功能，那么 Spring Cloud 基本可以满足你的全部需求。而 Dubbo、Motan 基本上只提供了最基础的 RPC 框架的功能，其他微服务组件都需要自己去实现。不过由于 Spring Cloud 的 RPC 通信采用了 HTTP 协议，相比 Dubbo 和 Motan 所采用的私有协议来说，在高并发的通信场景下，性能相对要差一些，所以对性能有苛刻要求的情况下，可以考虑 Dubbo 和 Motan。\n\n\n# 14.2. 跨语言 RPC\n\n而跨语言平台的开源 RPC 框架主要有以下几种。\n\n * gRPC：Google 于 2015 年对外开源的跨语言 RPC 框架，支持常用的 C++、Java、Python、Go、Ruby、PHP、Android Java、Objective-C 等多种语言。\n * Thrift：最初是由 Facebook 开发的内部系统跨语言的 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持常用的 C++、Java、PHP、Python、Ruby、Erlang 等多种语言。\n\n从成熟度上来讲，Thrift 因为诞生的时间要早于 gRPC，所以使用的范围要高于 gRPC，在 HBase、Hadoop、Scribe、Cassandra 等许多开源组件中都得到了广泛地应用。而且 Thrift 支持多达 25 种语言，这要比 gRPC 支持的语言更多，所以如果遇到 gRPC 不支持的语言场景下，选择 Thrift 更合适。\n\n但 gRPC 作为后起之秀，因为采用了 HTTP/2 作为通信协议、ProtoBuf 作为数据序列化格式，在移动端设备的应用以及对传输带宽比较敏感的场景下具有很大的优势，而且开发文档丰富，根据 ProtoBuf 文件生成的代码要比 Thrift 更简洁一些，从使用难易程度上更占优势，所以如果使用的语言平台 gRPC 支持的话，建议还是采用 gRPC 比较好。\n\n\n# 15. Service Mesh\n\n\n\n\n# 15.1. Service Mesh 的实现原理\n\nService Mesh 实现的关键就在于两点：\n\n一个是上面提到的轻量级的网络代理也叫 SideCar，它的作用就是转发服务之间的调用；\n\n一个是基于 SideCar 的服务治理也被叫作 Control Plane，它的作用是向 SideCar 发送各种指令，以完成各种服务治理功能。下面我就来详细讲解这两点是如何实现的。\n\n\n# 16. 参考资料\n\n * 从 0 开始学微服务\n * RPC 实战与核心原理\n * 微服务架构核心 20 讲\n * 谈谈微服务中的 API 网关（API Gateway）',normalizedContent:'# 微服务基本原理\n\n\n# 1. 微服务简介\n\n\n# 1.1. 什么是微服务架构\n\n互联网应用架构大致的演进方向为：单体架构 -> 服务化架构 -> 微服务架构。\n\n微服务架构的特点：\n\n * 服务拆分粒度更细：根据业务拆分。\n * 独立部署：每个服务部署在物理上隔离，互不影响。\n * 独立维护：根据组织架构拆分，分团队维护。\n * 服务治理：服务数量变多，需要有统一的服务治理平台。\n\n\n# 1.2. 如何权衡微服务的利弊\n\n优点\n\n * 强模块化边界\n * 可独立部署\n * 技术多样性\n\n缺点\n\n * 分布式复杂度\n * 最终一致性\n * 运维复杂度\n * 测试复杂度\n\n\n# 1.3. 康威定律\n\n * 第一定律：组织沟通方式会通过系统设计表达出来\n * 第二定律：时间再多一件事情也不可能做的完美，但总有时间做完一件事情\n * 第三定律：线型系统和线型组织架构间有潜在的异质同态特性\n * 第四定律：大的系统组织总是比小系统更倾向于分解\n\n\n# 1.4. 如何拆分微服务\n\n应用微服务化架构前，要思考几个问题：\n\n什么时候进行服务化拆分？如何拆分服务？\n\n当应用复杂度、开发团队膨胀到难以维护时，就该考虑服务化拆分了。\n\n拆分服务的思考维度：\n\n * 业务维度：业务和数据关系密切的应该放在一起。\n * 功能维度：公共功能聚合为一个服务。\n * 组织架构：根据实际组织架构，天然分为不同的团队，每个团队独立维护若干微服务。\n\n拆分服务的前置条件：\n\n应用微服务架构要先解决以下问题：\n\n * 服务如何定\n * 服务如何发布和订阅\n * 服务如何监控\n * 服务如何治理\n * 故障如何定位\n\n\n# 2. 微服务技术架构\n\n\n\n第一层：接入层\n\n外部设备访问的统一接入层。\n\n第二层：聚合服务层\n\n对下层的基础服务做一些聚合，剪裁的工作，适配上层不同设备的数据输出。\n\n第三层：基础服务层\n\n比较细粒度的微服务层，提供基础的核心服务，公共服务。\n\n\n\n\n# 3. 服务注册发现\n\n在微服务架构下，主要有三种角色：\n\n * 服务提供者（rpc server / provider）\n * 服务消费者（rpc client / consumer）\n * 服务注册中心（registry）\n\n注册中心的实现依赖以下机制：\n\n * 注册中心 api\n * 集群部署：如果注册中心是单点，无法保障高可用。\n * 元数据存储：例如 zookeeper 将数据以层次化的目录结构存储。\n * 服务健康检查：使用长连接或心跳探测方式检查服务健康状态。\n * 服务状态变更通知：可以基于订阅者模式实现，例如 zookeeper 的 watch 机制。\n * 白名单机制\n\n注册中心的服务注册和发现都是基于 api 的。一般需要支持以下功能：\n\n * 服务注册\n * 服务注销\n * 接口续约（心跳）\n * 服务订阅\n * 可用服务同步\n * 服务查询\n * 服务修改\n\n\n# 3.1. 注册中心的工作流程\n\n一般来讲，注册中心的工作流程是：\n\n * 服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。\n * 服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。\n * 注册中心返回服务提供者地址列表给服务消费者。\n * 当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。\n\n\n# 3.2. 注册中心实现模式\n\n# 3.2.1. 应用内注册和发现\n\n采用应用内注册与发现的方式，最典型的案例要属 netflix 开源的 eureka，官方架构图如下。\n\n\n\n对着这张图，我来介绍下 eureka 的架构，它主要由三个重要的组件组成：\n\n * eureka server：注册中心的服务端，实现了服务信息注册、存储以及查询等功能。\n * 服务端的 eureka client：集成在服务端的注册中心 sdk，服务提供者通过调用 sdk，实现服务注册、反注册等功能。\n * 客户端的 eureka client：集成在客户端的注册中心 sdk，服务消费者通过调用 sdk，实现服务订阅、服务更新等功能。\n\n# 3.2.2. 应用外注册和发现\n\n\n\n通过这张架构图，可以看出来使用 consul 实现应用外服务注册和发现主要依靠三个重要的组件：\n\n * consul：注册中心的服务端，实现服务注册信息的存储，并提供注册和发现服务。\n * registrator：一个开源的第三方服务管理器项目，它通过监听服务部署的 docker 实例是否存活，来负责服务提供者的注册和销毁。\n * consul template：定时从注册中心服务端获取最新的服务提供者节点列表并刷新 lb 配置（比如 nginx 的 upstream），这样服务消费者就通过访问 nginx 就可以获取最新的服务提供者信息。\n\n# 3.2.3. 注册中心选型\n\n# 3.2.3.1. 高可用性\n\n集群部署，通过部署多个实例组成集群来保证高可用性。\n\n多 idc 部署，即部署在不止一个机房。\n\n# 3.2.3.2. 数据一致性\n\n根据 cap 理论，三者不能同时满足：\n\n * cp 型注册中心，牺牲可用性来保证数据强一致性，最典型的例子就是 zookeeper，etcd，consul 了。zookeeper 集群内只有一个 leader，而且在 leader 无法使用的时候通过 paxos 算法选举出一个新的 leader。这个 leader 的目的就是保证写信息的时候只向这个 leader 写入，leader 会同步信息到 followers，这个过程就可以保证数据的强一致性。但如果多个 zookeeper 之间网络出现问题，造成出现多个 leader，发生脑裂的话，注册中心就不可用了。而 etcd 和 consul 集群内都是通过 raft 协议来保证强一致性，如果出现脑裂的话， 注册中心也不可用。\n * ap 型注册中心，牺牲一致性来保证可用性，最典型的例子就是 eureka 了。对比下 zookeeper，eureka 不用选举一个 leader，每个 eureka 服务器单独保存服务注册地址，因此有可能出现数据信息不一致的情况。但是当网络出现问题的时候，每台服务器都可以完成独立的服务。\n\n\n# 3.3. 服务注册发现的问题\n\n# 3.3.1. 多注册中心\n\n对于服务消费者来说，要能够同时从多个注册中心订阅服务；对于服务提供者来说，要能够同时向多个注册中心注册服务。\n\n# 3.3.2. 并行订阅服务\n\n可以每订阅一个服务就单独用一个线程来处理，这样的话即使遇到个别服务节点连接超时，其他服务节点的初始化连接也不受影响，最慢也就是这个服务节点的初始化连接耗费的时间，最终所有服务节点的初始化连接耗时控制在了 30 秒以内。\n\n# 3.3.3. 批量注销服务\n\n需要定时去清理注册中心中的“僵尸节点”，如果支持批量注销服务，就可以一次调用就把该节点上提供的所有服务同时注销掉。\n\n# 3.3.4. 服务变更信息同步更新\n\n为了减少服务消费者从注册中心中拉取的服务可用节点信息的数据量，这个时候可以通过增量更新的方式，注册中心只返回变化的那部分节点信息，尤其在只有少数节点信息变更时，此举可以大大减少服务消费者从注册中心拉取的数据量，从而最大程度避免产生网络风暴。\n\n\n# 3.4. 识别服务节点是否存活\n\n# 3.4.1. 心跳开关保护机制\n\n在网络频繁抖动的情况下，注册中心中可用的节点会不断变化，这时候服务消费者会频繁收到服务提供者节点变更的信息，于是就不断地请求注册中心来拉取最新的可用服务节点信息。当有成百上千个服务消费者，同时请求注册中心获取最新的服务提供者的节点信息时，可能会把注册中心的带宽给占满，尤其是注册中心是百兆网卡的情况下。\n\n所以针对这种情况，需要一种保护机制，即使在网络频繁抖动的时候，服务消费者也不至于同时去请求注册中心获取最新的服务节点信息。\n\n我曾经就遇到过这种情况，一个可行的解决方案就是给注册中心设置一个开关，当开关打开时，即使网络频繁抖动，注册中心也不会通知所有的服务消费者有服务节点信息变更，比如只给 10% 的服务消费者返回变更，这样的话就能将注册中心的请求量减少到原来的 1/10。\n\n当然打开这个开关也是有一定代价的，它会导致服务消费者感知最新的服务节点信息延迟，原先可能在 10s 内就能感知到服务提供者节点信息的变更，现在可能会延迟到几分钟，所以在网络正常的情况下，开关并不适合打开；可以作为一个紧急措施，在网络频繁抖动的时候，才打开这个开关。\n\n# 3.4.2. 服务节点摘除保护机制\n\n服务提供者在进程启动时，会注册服务到注册中心，并每隔一段时间，汇报心跳给注册中心，以标识自己的存活状态。如果隔了一段固定时间后，服务提供者仍然没有汇报心跳给注册中心，注册中心就会认为该节点已经处于“dead”状态，于是从服务的可用节点信息中移除出去。\n\n如果遇到网络问题，大批服务提供者节点汇报给注册中心的心跳信息都可能会传达失败，注册中心就会把它们都从可用节点列表中移除出去，造成剩下的可用节点难以承受所有的调用，引起“雪崩”。但是这种情况下，可能大部分服务提供者节点是可用的，仅仅因为网络原因无法汇报心跳给注册中心就被“无情”的摘除了。\n\n这个时候就需要根据实际业务的情况，设定一个阈值比例，即使遇到刚才说的这种情况，注册中心也不能摘除超过这个阈值比例的节点。\n\n这个阈值比例可以根据实际业务的冗余度来确定，我通常会把这个比例设定在 20%，就是说注册中心不能摘除超过 20% 的节点。因为大部分情况下，节点的变化不会这么频繁，只有在网络抖动或者业务明确要下线大批量节点的情况下才有可能发生。而业务明确要下线大批量节点的情况是可以预知的，这种情况下可以关闭阈值保护；而正常情况下，应该打开阈值保护，以防止网络抖动时，大批量可用的服务节点被摘除。\n\n\n# 4. 服务通信\n\n通过注册中心，服务消费者和服务提供者就可以感知彼此，但是，要实现交互还必须解决通信问题：\n\n * 通信协议。即服务提供者和服务消费者之间以什么样的 协议 进行网络通信，说白了，是要解决客户端和服务端如何建立连接、管理连接以及服务端如何处理请求的问题。是采用四层 tcp、udp 协议，还是采用七层 http 协议，还是采用其他协议？例如：dubbo 基于 tcp 通信；而 spring cloud 基于 http rest 通信。tcp 通信方式，传输效率更高；但是 http 方式天然可以提供对外服务。\n * 传输方式。即服务提供者和服务消费者之间的数据传输采用哪种方式。是同步还是异步？是在单连接上传输，还是多路复用。\n * 序列化和反序列化。它主要解决客户端和服务端采用哪种数据编解码的问题。常见的序列化方式包括：xml、json；二进制类如：thrift、protobuf、hessian、jdk。\n\n\n# 4.1. 序列化方式\n\n序列化方式的选型，一般基于以下考虑：\n\n * 支持数据结构类型的丰富度\n * 跨语言支持\n * 性能\n\n> 👉 参考：java 序列化\n\n\n# 4.2. 通信协议\n\n微服务框架对比：\n\n       rpc                                       rest\n耦合性    强耦合                                       松散耦合\n协议     tcp                                       http、http2\n序列化    二进制（thrift、protobuf、hessian、avro、jdk 等）   xml、json\n性能     高                                         低\n客户端    对编程语言有限制                                  跨语言支持更好（支持 http 即可）\n代表技术   dubbo、motan、tars、grpc、thrift              spring cloud\n\n\n# 5. 服务监控\n\n当服务消费者与服务提供者之间建立了通信，作为管理者需要通过监控手段来观察服务是否正常，调用是否成功。服务监控是很复杂的，在微服务架构下，一次用户调用会因为服务化拆分后，变成多个不同服务之间的相互调用，这也就需要对拆分后的每个服务都监控起来。\n\n\n# 5.1. 监控对象\n\n服务监控一定是通过观察数据来量化分析，所以首先要明确需要监控什么。\n\n一般来说，服务监控数据有以下分类：\n\n * 业务监控：核心指标、登录、登出、下单、支付等。\n * 应用监控：访问接口、访问服务、sql、内存使用率、响应时间、tps、qps 等。\n * 系统监控：cpu、内存、网络、磁盘等。\n * 基础监控：网络流量、丢包数、错包数、连接数等。\n * 客户端监控：性能、返回码、地域、运营商、版本、系统等。\n\n\n# 5.2. 系统监控原理\n\n一旦明确了要监控的对象，接下就是考虑如何监控。\n\n监控系统主要包括四个环节：数据采集、数据传输、数据处理和数据展示\n\n# 5.2.1. 数据采集\n\n通常有两种数据收集方式：\n\n * 服务主动上报：这种处理方式通过在业务代码或者服务框架里加入数据收集代码逻辑，在每一次服务调用完成后，主动上报服务的调用信息。这种方式在链路跟踪中较为常见，主流的技术方案有：zipkin。\n * 代理收集：这种处理方式通过服务调用后把调用的详细信息记录到本地日志文件中，然后再通过代理去解析本地日志文件，然后再上报服务的调用信息。主流的技术方案有：elk、flume。\n\n# 5.2.2. 数据传输\n\n数据传输最常用的方式有两种：\n\n * udp 传输：这种处理方式是数据处理单元提供服务器的请求地址，数据采集后通过 udp 协议与服务器建立连接，然后把数据发送过去。\n * kafka 传输：这种处理方式是数据采集后发送到指定的 topic，然后数据处理单元再订阅对应的 topic，就可以从 kafka 消息队列中读取到对应的数据。由于 kafka 有非常高的吞吐能力，所以很适合作为大数据量的缓冲池。\n\n# 5.2.3. 数据处理\n\n数据处理是对收集来的原始数据进行聚合并存储。数据聚合通常有两个维度：\n\n * 接口维度聚合：这个维度是把实时收到的数据按照接口名维度实时聚合在一起，这样就可以得到每个接口的每秒请求量、平均耗时、成功率等信息。\n * 机器维度聚合：这个维度是把实时收到的数据按照调用的节点维度聚合在一起，这样就可以从单机维度去查看每个接口的实时请求量、平均耗时等信息。\n\n聚合后的数据需要持久化到数据库中存储，所选用的数据库一般分为两种：\n\n * 全文检索数据库：比如 elasticsearch，以倒排索引的数据结构存储，需要查询的时候，根据索引来查询。\n * 时序数据库：比如 opentsdb，以时序序列数据的方式存储，查询的时候按照时序如 1min、5min 等维度来查询。\n\n# 5.2.4. 数据展示\n\n数据展示是把处理后的数据以 dashboard 的方式展示给用户。数据展示有多种方式，比如曲线图、饼状图、格子图展示等。\n\n\n# 5.3. 监控技术\n\n\n\n * elk 的技术栈比较成熟，应用范围也比较广，除了可用作监控系统外，还可以用作日志查询和分析。\n * graphite 是基于时间序列数据库存储的监控系统，并且提供了功能强大的各种聚合函数比如 sum、average、top5 等可用于监控分析，而且对外提供了 api 也可以接入其他图形化监控系统如 grafana。\n * tick 的核心在于其时间序列数据库 influxdb 的存储功能强大，且支持类似 sql 语言的复杂数据处理操作。\n * prometheus 的独特之处在于它采用了拉数据的方式，对业务影响较小，同时也采用了时间序列数据库存储，而且支持独有的 promql 查询语言，功能强大而且简洁。\n\n\n# 6. 服务治理\n\n微服务治理平台就是与服务打交道的统一入口，无论是开发人员还是运维人员，都能通过这个平台对服务进行各种操作，比如开发人员可以通过这个平台对服务进行降级操作，运维人员可以通过这个平台对服务进行上下线操作，而不需要关心这个操作背后的具体实现。\n\n微服务治理平台关键之处就在于它能够封装对微服务架构内的各个基础设施组件的调用，从而对外提供统一的服务操作 api，而且还提供了可视化的界面，以方便开发人员和运维人员操作。\n\n\n\n服务治理的常用手段有：\n\n * 节点管理\n   * 注册中心主动摘除机制\n   * 服务消费者摘除机制\n * 负载均衡\n   * 轮询\n   * 随机\n   * 最近最少连接\n   * 一致性 hash\n * 服务路由\n   * 业务存在灰度发布的需求\n   * 多机房就近访问的需求\n * 服务容错\n   * failover：失败自动切换\n   * failback：失败通知\n   * failcache：失败缓存\n   * failfast：快速失败\n\n\n# 7. api 网关\n\napi 网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。api 网关封装了系统内部架构，为每个客户端提供一个定制的 api。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。 api 网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供 rest/http 的访问 api。服务端通过 api-gw 注册和管理服务。\n\n\n# 7.1. zuul\n\n\n\n在 zuul 中， 整个请求的过程是这样的，首先将请求给 zuulservlet 处理，zuulservlet 中有一个 zuulrunner 对象，该对象中初始化了 requestcontext：作为存储整个请求的一些数据，并被所有的 zuulfilter 共享。zuulrunner 中还有 filterprocessor，filterprocessor 作为执行所有的 zuulfilter 的管理器。filterprocessor 从 filterloader 中获取 zuulfilter，而 zuulfilter 是被 filterfilemanager 所加载，并支持 groovy 热加载，采用了轮询的方式热加载。有了这些 filter 之后，zuulservelet 首先执行的 pre 类型的过滤器，再执行 route 类型的过滤器，最后执行的是 post 类型的过滤器，如果在执行这些过滤器有错误的时候则会执行 error 类型的过滤器。执行完这些过滤器，最终将请求的结果返回给客户端。\n\n\n# 8. 负载均衡\n\n> 参考：负载均衡基本原理\n\n\n# 9. 服务路由\n\n服务路由就是服务消费者在发起服务调用时，必须根据特定的规则来选择服务节点，从而满足某些特定的需求。\n\n\n# 9.1. 服务路由的应用场景\n\n * 分组调用。一般来讲，为了保证服务的高可用性，实现异地多活的需求，一个服务往往不止部署在一个数据中心，而且出于节省成本等考虑，有些业务可能不仅在私有机房部署，还会采用公有云部署，甚至采用多家公有云部署。服务节点也会按照不同的数据中心分成不同的分组，这时对于服务消费者来说，选择哪一个分组调用，就必须有相应的路由规则。\n * 灰度发布。在服务上线发布的过程中，一般需要先在一小部分规模的服务节点上先发布服务，然后验证功能是否正常。如果正常的话就继续扩大发布范围；如果不正常的话，就需要排查问题，解决问题后继续发布。这个过程就叫作灰度发布，也叫金丝雀部署。\n * 流量切换。在业务线上运行过程中，经常会遇到一些不可抗力因素导致业务故障，比如某个机房的光缆被挖断，或者发生着火等事故导致整个机房的服务都不可用。这个时候就需要按照某个指令，能够把原来调用这个机房服务的流量切换到其他正常的机房。\n * 读写分离。对于大多数互联网业务来说都是读多写少，所以在进行服务部署的时候，可以把读写分开部署，所有写接口可以部署在一起，而读接口部署在另外的节点上。\n\n\n# 9.2. 服务路由的规则\n\n服务路由主要有两种规则：一种是条件路由，一种是脚本路由。\n\n# 9.2.1. 条件路由\n\n条件路由是基于条件表达式的路由规则。\n\ncondition://0.0.0.0/dubbo.test.interfaces.testservice?category=routers&dynamic=true&priority=2&enabled=true&rule=" + url.encode(" host = 10.20.153.10=> host = 10.20.153.11")\n\n\n这里面 condition:// 代表了这是一段用条件表达式编写的路由规则，具体的规则是\n\nhost = 10.20.153.10 => host = 10.20.153.11\n\n\n分隔符“=>”前面是服务消费者的匹配条件，后面是服务提供者的过滤条件。当服务消费者节点满足匹配条件时，就对该服务消费者执行后面的过滤规则。那么上面这段表达式表达的意义就是 ip 为“10.20.153.10”的服务消费者都调用 ip 为“10.20.153.11”的服务提供者节点。\n\n如果服务消费者的匹配条件为空，就表示对所有的服务消费者应用，就像下面的表达式一样。\n\n=> host ！= 10.20.153.11\n\n\n如果服务提供者的过滤条件为空，就表示禁止服务消费者访问，就像下面的表达式一样。\n\nhost = 10.20.153.10=>\n\n\n下面我举一些 dubbo 框架中的条件路由，来给你讲解下条件路由的具体应用场景。\n\n * 排除某个服务节点\n\n=> host != 172.22.3.91\n\n\n一旦这条路由规则被应用到线上，所有的服务消费者都不会访问 ip 为 172.22.3.91 的服务节点，这种路由规则一般应用在线上流量排除预发布机以及摘除某个故障节点的场景。\n\n * 白名单和黑名单功能\n\nhost != 10.20.153.10,10.20.153.11 =>\n\n\n这条路由规则意思是除了 ip 为 10.20.153.10 和 10.20.153.11 的服务消费者可以发起服务调用以外，其他服务消费者都不可以，主要用于白名单访问逻辑，比如某个后台服务只允许特定的几台机器才可以访问，这样的话可以机器控制访问权限。\n\nhost = 10.20.153.10,10.20.153.11 =>\n\n\n同理，这条路由规则意思是除了 ip 为 10.20.153.10 和 10.20.153.11 的服务消费者不能发起服务调用以外，其他服务消费者都可以，也就是实现了黑名单功能，比如线上经常会遇到某些调用方不管是出于有意还是无意的不合理调用，影响了服务的稳定性，这时候可以通过黑名单功能暂时予以封杀。\n\n * 机房隔离\n\nhost = 172.22.3.* => host = 172.22.3.*\n\n\n这条路由规则意思是 ip 网段为 172.22.3.* 的服务消费者，才可以访问同网段的服务节点，这种规则一般应用于服务部署在多个 idc，理论上同一个 idc 内的调用性能要比跨 idc 调用性能要好，应用这个规则是为了实现同 idc 就近访问。\n\n * 读写分离\n\nmethod = find*,list*,get*,is* => host =172.22.3.94,172.22.3.95\nmethod != find*,list*,get*,is* => host = 172.22.3.97,172.22.3.98\n\n\n这条路由规则意思是 find*、get*、is* 等读方法调用 ip 为 172.22.3.94 和 172.22.3.95 的节点，除此以外的写方法调用 ip 为 172.22.3.97 和 172.22.3.98 的节点。对于大部分互联网业务来说，往往读请求要远远大于写请求，而写请求的重要性往往要远远高于读请求，所以需要把读写请求进行分离，以避免读请求异常影响到写请求，这时候就可以应用这种规则。\n\n# 9.2.2. 脚本路由\n\n脚本路由是基于脚本语言的路由规则，常用的脚本语言比如 javascript、groovy、jruby 等。\n\n"script://0.0.0.0/com.foo.barservice?category=routers&dynamic=false&rule=" + url.encode("（function route(invokers) { ... } (invokers)）")\n\n\n这里面“script://”就代表了这是一段脚本语言编写的路由规则，具体规则定义在脚本语言的 route 方法实现里，比如下面这段用 javascript 编写的 route() 方法表达的意思是，只有 ip 为 10.20.153.10 的服务消费者可以发起服务调用。\n\nfunction route(invokers){\n  var result = new java.util.arraylist(invokers.size());\n  for(i =0; i < invokers.size(); i ++){\n    if("10.20.153.10".equals(invokers.get(i).geturl().gethost())){\n       result.add(invokers.get(i));\n    }\n  }\n  return result;\n } (invokers)）;\n\n\n\n# 9.3. 服务路由的获取方式\n\n服务路由的获取方式主要有三种：\n\n * 本地配置\n\n顾名思义就是路由规则存储在服务消费者本地上。服务消费者发起调用时，从本地固定位置读取路由规则，然后按照路由规则选取一个服务节点发起调用。\n\n * 配置中心管理\n\n这种方式下，所有的服务消费者都从配置中心获取路由规则，由配置中心来统一管理。\n\n * 动态下发\n\n这种方式下，一般是运维人员或者开发人员，通过服务治理平台修改路由规则，服务治理平台调用配置中心接口，把修改后的路由规则持久化到配置中心。因为服务消费者订阅了路由规则的变更，于是就会从配置中心获取最新的路由规则，按照最新的路由规则来执行。\n\n\n# 9.4. 内部服务调用\n\n基础服务之间的调用：结合服务注册中心以及专属的具有负载均衡功能的客户端，如 eureka+（resttemplate+ribbon）或者 eureka+feign 聚合服务调用：结合服务注册中心以及专属的具有负载均衡功能的客户端，如 eureka+（resttemplate+ribbon）或者 eureka+feign\n\n\n\n\n# 9.5. 外部服务调用\n\n基于 netflix 的 zuul，做了简单了解，springcloud 与 zuul 集成的方式。这里先对核心流程做个简单了解，后续会有深入的应用、分析。\n\nspring cloud 很好的集成了 zuul，并且可以通过注解的形式来进行请求的反向路由以及 api 网关功能 spring cloud 集成 zuul，对与 url 映射的处理方式与 springmvc 对 url 的请求方式类似，都是通过 requestmapping 来进行请求绑定的。核心类：zuulhandlermapping zuul 的核心是 zuulservlet，一个请求核心流程：httpservletrequest –>zuulhandlermapping –>zuulcontroller –> zuulservlet –> zuulfilter –> httpservletresponse\n\n\n# 10. 配置中心\n\n配置中心的思路就是把服务的各种配置，如代码里配置的各种参数、服务降级的开关甚至依赖的资源等都在一个地方统一进行管理。服务启动时，可以自动从配置中心中拉取所需的配置，并且如果有配置变更的情况，同样可以自动从配置中心拉取最新的配置信息，服务无须重新发布。\n\n配置中心一般包含下面几个功能：\n\n * 配置注册功能\n * 配置反注册功能\n * 配置查看功能\n * 配置变更订阅功能\n\n\n# 10.1. apollo\n\n携程开源的分布式配置中心，支持 java 和.net 语言，客户端和配置中心通过 http 长连接实现实时推送，并且有统一的管理界面来实现配置管理。\n\n\n\n\n# 10.2. spring cloud git\n\nspring cloud 中使用的配置中心组件，只支持 java 语言，配置存储在 git 中，变更配置也需要通过 git 操作，如果配置中心有配置变更，需要手动刷新。\n\n\n\n\n# 11. 链路追踪\n\n\n# 11.1. 链路追踪的作用\n\n * 优化系统瓶颈\n * 优化链路调用\n * 生成网络拓扑\n * 透明传输数据\n\n\n# 11.2. 链路追踪的原理\n\n理解链路追踪必须先了解以下概念：\n\n * traceid，用于标识某一次具体的请求 id。当用户的请求进入系统后，会在 rpc 调用网络的第一层生成一个全局唯一的 traceid，并且会随着每一层的 rpc 调用，不断往后传递，这样的话通过 traceid 就可以把一次用户请求在系统中调用的路径串联起来。\n * spanid，用于标识一次 rpc 调用在分布式请求中的位置。当用户的请求进入系统后，处在 rpc 调用网络的第一层 a 时 spanid 初始值是 0，进入下一层 rpc 调用 b 的时候 spanid 是 0.1，继续进入下一层 rpc 调用 c 时 spanid 是 0.1.1，而与 b 处在同一层的 rpc 调用 e 的 spanid 是 0.2，这样的话通过 spanid 就可以定位某一次 rpc 请求在系统调用中所处的位置，以及它的上下游依赖分别是谁。\n * annotation，用于业务自定义埋点数据，可以是业务感兴趣的想上传到后端的数据，比如一次请求的用户 uid。\n\n\n\n\n# 11.3. 链路追踪的实现\n\n一个服务追踪系统一般可以分为三层：\n\n * 数据采集层，负责数据埋点并上报。\n * 数据处理层，负责数据的存储与计算。\n * 数据展示层，负责数据的图形化展示。\n\n# 11.3.1. 数据采集层\n\n一次 rpc 请求可以分为四个阶段。\n\n * cs（client send）阶段 : 客户端发起请求，并生成调用的上下文。\n * sr（server recieve）阶段 : 服务端接收请求，并生成上下文。\n * ss（server send）阶段 : 服务端返回请求，这个阶段会将服务端上下文数据上报，下面这张图可以说明上报的数据有：traceid=123456，spanid=0.1，appkey=b，method=b.method，start=103，duration=38。\n * cr（client recieve）阶段 : 客户端接收返回结果，这个阶段会将客户端上下文数据上报，上报的数据有：traceid=123456，spanid=0.1，appkey=a，method=b.method，start=103，duration=38。\n\n# 11.3.2. 数据处理层\n\n数据处理层的作用就是把数据采集层上报的数据按需计算，然后落地存储供查询使用。\n\n * 实时数据处理\n\n针对实时数据处理，一般采用 storm 或者 spark streaming 来对链路数据进行实时聚合加工，存储一般使用 oltp 数据仓库，比如 hbase，使用 traceid 作为 rowkey，能天然地把一整条调用链聚合在一起，提高查询效率。\n\n * 离线数据处理\n\n针对离线数据处理，一般通过运行 mapreduce 或者 spark 批处理程序来对链路数据进行离线计算，存储一般使用 hive。\n\n# 11.3.3. 数据展示层\n\n数据展示层的作用就是将处理后的链路信息以图形化的方式展示给用户。\n\n实际项目中主要用到两种图形展示，一种是调用链路图，一种是调用拓扑图。\n\n\n# 11.4. 链路追踪方案对比\n\n\n\n\n# 12. 限流熔断\n\n一般而言，集群故障的产生原因不外乎有两种：\n\n一种是代码 bug 所导致，比如说某一段 java 代码不断地分配大对象，但没有及时回收导致 jvm oom 退出；\n\n另一种是突发的流量冲击，超出了系统的最大承载能力，比如“双 11”这种购物活动，电商系统会在零点一瞬间涌入大量流量，超出系统的最大承载能力，一下子就把整个系统给压垮了。\n\n应付集群故障的思路，主要有两种：限流和降级。\n\n\n# 12.1. 限流\n\n限流就是限制流量。通常情况下，系统能够承载的流量根据集群规模的大小是固定的，可以称之为系统的最大容量。当真实流量超过了系统的最大容量后，就会导致系统响应变慢，服务调用出现大量超时，反映给用户的感觉就是卡顿、无响应。所以，应该根据系统的最大容量，给系统设置一个阈值，超过这个阈值的请求会被自动抛弃，这样的话可以最大限度地保证系统提供的服务正常。\n\n除此之外，通常一个微服务系统会同时提供多个服务，每个服务在同一时刻的请求量也是不同的，很可能出现的一种情况就是，系统中某个服务的请求量突增，占用了系统中大部分资源，导致其他服务没有资源可用。因此，还要针对系统中每个服务的请求量也设置一个阈值，超过这个阈值的请求也要被自动抛弃，这样的话不至于因为一个服务影响了其他所有服务。\n\n在实际项目中，可以用两个指标来衡量服务的请求量，一个是 qps 即每秒请求量，一个是工作线程数。不过 qps 因为不同服务的响应快慢不同，所以系统能够承载的 qps 相差很大，因此一般选择工作线程数来作为限流的指标，给系统设置一个总的最大工作线程数以及单个服务的最大工作线程数，这样的话无论是系统的总请求量过大导致整体工作线程数量达到最大工作线程数，还是某个服务的请求量超过单个服务的最大工作线程数，都会被限流，以起到保护整个系统的作用。\n\n\n# 12.2. 降级\n\n什么是降级呢？在我看来，降级就是通过停止系统中的某些功能，来保证系统整体的可用性。降级可以说是一种被动防御的措施，为什么这么说呢？因为它一般是系统已经出现故障后所采取的一种止损措施。\n\n那么降级一般是如何实现的呢？根据我的实践来看， 一种可行的方案是通过开关来实现。\n\n具体来讲，就是在系统运行的内存中开辟一块区域，专门用于存储开关的状态，也就是开启还是关闭。并且需要监听某个端口，通过这个端口可以向系统下发命令，来改变内存中开关的状态。当开关开启时，业务的某一段逻辑就不再执行，而正常情况下，开关是关闭的状态。\n\n开关一般用在两种地方，一种是新增的业务逻辑，因为新增的业务逻辑相对来说不成熟，往往具备一定的风险，所以需要加开关来控制新业务逻辑是否执行；另一种是依赖的服务或资源，因为依赖的服务或者资源不总是可靠的，所以最好是有开关能够控制是否对依赖服务或资源发起调用，来保证即使依赖出现问题，也能通过降级来避免影响。\n\n在实际业务应用的时候，降级要按照对业务的影响程度进行分级，一般分为三级：一级降级是对业务影响最小的降级，在故障的情况下，首先执行一级降级，所以一级降级也可以设置成自动降级，不需要人为干预；二级降级是对业务有一定影响的降级，在故障的情况下，如果一级降级起不到多大作用的时候，可以人为采取措施，执行二级降级；三级降级是对业务有较大影响的降级，这种降级要么是对商业收入有重大影响，要么是对用户体验有重大影响，所以操作起来要非常谨慎，不在最后时刻一般不予采用。\n\n\n# 13. devops\n\n\n# 13.1. 容器和容器平台\n\nmesos、marathon、kubernetes\n\n\n# 14. rpc 选型\n\n\n# 14.1. 限定语言 rpc\n\n跟语言平台绑定的开源 rpc 框架主要有下面几种。\n\n * dubbo：国内最早开源的 rpc 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 java 语言。\n * motan：微博内部使用的 rpc 框架，于 2016 年对外开源，仅支持 java 语言。\n * tars：腾讯内部使用的 rpc 框架，于 2017 年对外开源，仅支持 c++ 语言。\n * spring cloud：国外 pivotal 公司 2014 年对外开源的 rpc 框架，仅支持 java 语言，最近几年生态发展得比较好，是比较火的 rpc 框架。\n\n所以很明显，如果你的业务场景仅仅局限于一种语言的话，可以选择跟语言绑定的 rpc 框架中的一种；如果涉及多个语言平台之间的相互调用，就应该选择跨语言平台的 rpc 框架。\n\n仔细分析，可以看出 spring cloud 不仅提供了基本的 rpc 框架功能，还提供了服务注册组件、配置中心组件、负载均衡组件、断路器组件、分布式消息追踪组件等一系列组件，也难怪被技术圈的人称之为“spring cloud 全家桶”。如果你不想自己实现以上这些功能，那么 spring cloud 基本可以满足你的全部需求。而 dubbo、motan 基本上只提供了最基础的 rpc 框架的功能，其他微服务组件都需要自己去实现。不过由于 spring cloud 的 rpc 通信采用了 http 协议，相比 dubbo 和 motan 所采用的私有协议来说，在高并发的通信场景下，性能相对要差一些，所以对性能有苛刻要求的情况下，可以考虑 dubbo 和 motan。\n\n\n# 14.2. 跨语言 rpc\n\n而跨语言平台的开源 rpc 框架主要有以下几种。\n\n * grpc：google 于 2015 年对外开源的跨语言 rpc 框架，支持常用的 c++、java、python、go、ruby、php、android java、objective-c 等多种语言。\n * thrift：最初是由 facebook 开发的内部系统跨语言的 rpc 框架，2007 年贡献给了 apache 基金，成为 apache 开源项目之一，支持常用的 c++、java、php、python、ruby、erlang 等多种语言。\n\n从成熟度上来讲，thrift 因为诞生的时间要早于 grpc，所以使用的范围要高于 grpc，在 hbase、hadoop、scribe、cassandra 等许多开源组件中都得到了广泛地应用。而且 thrift 支持多达 25 种语言，这要比 grpc 支持的语言更多，所以如果遇到 grpc 不支持的语言场景下，选择 thrift 更合适。\n\n但 grpc 作为后起之秀，因为采用了 http/2 作为通信协议、protobuf 作为数据序列化格式，在移动端设备的应用以及对传输带宽比较敏感的场景下具有很大的优势，而且开发文档丰富，根据 protobuf 文件生成的代码要比 thrift 更简洁一些，从使用难易程度上更占优势，所以如果使用的语言平台 grpc 支持的话，建议还是采用 grpc 比较好。\n\n\n# 15. service mesh\n\n\n\n\n# 15.1. service mesh 的实现原理\n\nservice mesh 实现的关键就在于两点：\n\n一个是上面提到的轻量级的网络代理也叫 sidecar，它的作用就是转发服务之间的调用；\n\n一个是基于 sidecar 的服务治理也被叫作 control plane，它的作用是向 sidecar 发送各种指令，以完成各种服务治理功能。下面我就来详细讲解这两点是如何实现的。\n\n\n# 16. 参考资料\n\n * 从 0 开始学微服务\n * rpc 实战与核心原理\n * 微服务架构核心 20 讲\n * 谈谈微服务中的 api 网关（api gateway）',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"微服务简介",frontmatter:{title:"微服务简介",categories:["分布式","分布式应用","微服务"],tags:["分布式","分布式应用","微服务"],abbrlink:"2c46bfa7",date:"2022-04-15T16:42:51.000Z",permalink:"/pages/f13c06/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/04.%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B.html",relativePath:"02.分布式/04.分布式应用/01.微服务/01.微服务简介.md",key:"v-056e1262",path:"/pages/f13c06/",headers:[{level:2,title:"什么是微服务",slug:"什么是微服务",normalizedTitle:"什么是微服务",charIndex:12},{level:3,title:"单体应用",slug:"单体应用",normalizedTitle:"单体应用",charIndex:285},{level:3,title:"微服务",slug:"微服务",normalizedTitle:"微服务",charIndex:2},{level:2,title:"何时需要微服务",slug:"何时需要微服务",normalizedTitle:"何时需要微服务",charIndex:889},{level:3,title:"拆分服务的思考维度",slug:"拆分服务的思考维度",normalizedTitle:"拆分服务的思考维度",charIndex:973},{level:3,title:"拆分服务的原则",slug:"拆分服务的原则",normalizedTitle:"拆分服务的原则",charIndex:1209},{level:3,title:"拆分服务的前置条件",slug:"拆分服务的前置条件",normalizedTitle:"拆分服务的前置条件",charIndex:1261},{level:2,title:"微服务的基础架构",slug:"微服务的基础架构",normalizedTitle:"微服务的基础架构",charIndex:1973},{level:3,title:"服务描述",slug:"服务描述",normalizedTitle:"服务描述",charIndex:2012},{level:3,title:"注册中心",slug:"注册中心",normalizedTitle:"注册中心",charIndex:1506},{level:3,title:"服务框架",slug:"服务框架",normalizedTitle:"服务框架",charIndex:2028},{level:3,title:"服务监控",slug:"服务监控",normalizedTitle:"服务监控",charIndex:2036},{level:3,title:"服务链路追踪",slug:"服务链路追踪",normalizedTitle:"服务链路追踪",charIndex:3373},{level:3,title:"服务治理",slug:"服务治理",normalizedTitle:"服务治理",charIndex:792},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:4299}],headersStr:"什么是微服务 单体应用 微服务 何时需要微服务 拆分服务的思考维度 拆分服务的原则 拆分服务的前置条件 微服务的基础架构 服务描述 注册中心 服务框架 服务监控 服务链路追踪 服务治理 参考资料",content:"# 微服务简介\n\n\n# 什么是微服务\n\n> Martin Fowler 与 James Lewis 共同提出了微服务的概念，定义了微服务是由单一应用程序构成的小服务，自己拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 HTTP API 通信。同时服务会使用最小的规模的集中管理 (例如 Docker) 能力，服务可以用不同的编程语言与数据库等组件实现。——微服务的维基百科词条定义\n\n互联网应用架构大致的演进方向为：单体架构 -> 服务化架构 -> 微服务架构。在演化过程中，架构越来越复杂，一个应用被拆分的服务也越来越细。\n\n\n# 单体应用\n\n互联网早期的技术栈通常为 LAMP（Linux + Apache + MySQL + PHP）或 MVC（Spring + iBatis/Hibernate + Tomcat）。这两种架构都是典型的单体应用架构。其优点是技术栈简单，因此学习上手快，部署也容易。\n\n随着业务越来越复杂，开发团队规模不断扩张，单体应用架构就难以适应开发迭代节奏，主要有以下问题：\n\n * 构建、部署效率低：代码越多，依赖资源越多，则构建、部署的耗费时间自然会越长。即使每次修改一个很小的功能点，也不得不全量构建、全部部署，耗时耗力。\n * 团队协作成本高：单体应用的代码往往在一个工程中，而一个工程中的开发人员越多，显然沟通成本越高。\n * 可用性差：因为所有的功能开发最后都部署到同一个 WAR 包里，运行在同一个 Tomcat 进程之中，一旦某一功能涉及的代码或者资源有问题，那就会影响整个 WAR 包中部署的功能。\n\n\n# 微服务\n\n微服务架构有以下 4 个特点：\n\n * 服务拆分粒度更细：根据业务拆分。\n * 独立部署：每个服务部署在物理上隔离，互不影响。\n * 独立维护：根据组织架构拆分，分团队维护。\n * 服务治理：服务数量变多，需要有统一的服务治理平台。\n\n简单来说，微服务就是将庞杂臃肿的单体应用拆分成细粒度的服务，独立部署，并交给各个中小团队来负责开发、测试、上线和运维整个生命周期。\n\n\n# 何时需要微服务\n\n应用微服务化架构前，要思考几个问题：什么时候进行服务化拆分？如何拆分服务？\n\n当应用复杂度、开发团队膨胀到难以维护时，就该考虑服务化拆分了。\n\n\n# 拆分服务的思考维度\n\n * 业务维度：业务和数据关系密切的应该拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。\n * 功能维度：公共功能聚合为一个服务。标准是是否被多个其他服务调用，且依赖的资源独立不与其他业务耦合。\n * 组织架构：根据实际组织架构，天然分为不同的团队，每个团队独立维护若干微服务。\n\n但并不是说功能拆分的越细越好，过度的拆分反而会让服务数量膨胀变得难以管理，因此找到符合自己业务现状和团队人员技术水平的拆分粒度才是可取的。\n\n\n# 拆分服务的原则\n\n单一职责\n\n高内聚，低耦合\n\n先粗后细，逐渐细化\n\n渐进式迭代\n\n考虑扩展性\n\n\n# 拆分服务的前置条件\n\n * 服务如何定义？\n   * 对于单体应用来说，不同功能模块之前相互交互时，通常是以类库的方式来提供各个模块的功能。\n   * 对于微服务来说，每个服务都运行在各自的进程之中，无论采用哪种通讯协议，是 HTTP 还是 RPC，服务之间的调用都通过接口来约定如何交互。约定内容包括接口名、接口参数以及接口返回值。\n * 服务如何发布和订阅？\n   * 单体应用由于部署在同一个 WAR 包里，接口之间的调用属于进程内的调用。\n   * 对于微服务来说，服务提供者需要向注册中心发布自己提供的服务（暴露接口信息以及接口地址）；服务消费者向注册中心订阅哪些服务可用。\n * 服务如何监控？通常对于一个服务，我们最关心的是 QPS（调用量）、AvgTime（平均耗时）以及 P999（99.9% 的请求性能在多少毫秒以内）这些指标。这时候你就需要一种通用的监控方案，能够覆盖业务埋点、数据收集、数据处理，最后到数据展示的全链路功能。\n * 服务如何治理？可以想象，拆分为微服务架构后，服务的数量变多了，依赖关系也变复杂了。比如一个服务的性能有问题时，依赖的服务都势必会受到影响。可以设定一个调用性能阈值，如果一段时间内一直超过这个值，那么依赖服务的调用可以直接返回，这就是熔断，也是服务治理最常用的手段之一。\n * 故障如何定位？在单体应用拆分为微服务之后，一次用户调用可能依赖多个服务，每个服务又部署在不同的节点上，如果用户调用出现问题，你需要有一种解决方案能够将一次用户请求进行标记，并在多个依赖的服务系统中继续传递，以便串联所有路径，从而进行故障定位。\n\n应用微服务架构，必须要先解决以上问题\n\n\n# 微服务的基础架构\n\n微服务架构下，服务调用主要依赖下面几个基本组件：\n\n * 服务描述\n * 注册中心\n * 服务框架\n * 服务监控\n * 服务追踪\n * 服务治理\n\n\n# 服务描述\n\n服务调用首先要解决的问题就是服务如何对外描述。比如，你对外提供了一个服务，那么这个服务的服务名叫什么？调用这个服务需要提供哪些信息？调用这个服务返回的结果是什么格式的？该如何解析？这些就是服务描述要解决的问题。\n\n常用的服务描述方式包括 RESTful API、XML 配置以及 IDL 文件三种。\n\n其中，RESTful API 方式通常用于 HTTP 协议的服务描述，并且常用 Wiki 或者Swagger来进行管理。下面是一个 RESTful API 方式的服务描述的例子。\n\nXML 配置方式多用作 RPC 协议的服务描述，通过 *.xml 配置文件来定义接口名、参数以及返回值类型等。下面是一个 XML 配置方式的服务描述的例子。\n\nIDL 文件方式通常用作 Thrift 和 gRPC 这类跨语言服务调用框架中，比如 gRPC 就是通过 Protobuf 文件来定义服务的接口名、参数以及返回值的数据结构。\n\n\n# 注册中心\n\n\n\n有了服务的接口描述，下一步要解决的问题就是服务的发布和订阅，就是说你提供了一个服务，如何让外部想调用你的服务的人知道。这个时候就需要一个类似注册中心的角色，服务提供者将自己提供的服务以及地址登记到注册中心，服务消费者则从注册中心查询所需要调用的服务的地址，然后发起请求。\n\n一般来讲，注册中心的工作流程是：\n\n * 服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。\n * 服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。\n * 注册中心返回服务提供者地址列表给服务消费者。\n * 当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。\n\n\n# 服务框架\n\n服务消费者发起调用需解决以下问题：\n\n * 服务通信采用什么协议？就是说服务提供者和服务消费者之间以什么样的协议进行网络通信，是采用四层 TCP、UDP 协议，还是采用七层 HTTP 协议，还是采用其他协议？\n * 数据传输采用什么方式？就是说服务提供者和服务消费者之间的数据传输采用哪种方式，是同步还是异步，是在单连接上传输，还是多路复用。\n * 数据压缩采用什么格式？通常数据传输都会对数据进行压缩，来减少网络传输的数据量，从而减少带宽消耗和网络传输时间，比如常见的 JSON 序列化、Java 对象序列化以及 Protobuf 序列化等。\n\n\n# 服务监控\n\n一旦服务消费者与服务提供者之间能够正常发起服务调用，你就需要对调用情况进行监控，以了解服务是否正常。通常来讲，服务监控主要包括三个流程。\n\n * 数据收集。就是要把每一次服务调用的请求耗时以及成功与否收集起来，并上传到集中的数据处理中心。\n * 数据处理。有了每次调用的请求耗时以及成功与否等信息，就可以计算每秒服务请求量、平均耗时以及成功率等指标。\n * 数据展示。数据收集起来，经过处理之后，还需要以友好的方式对外展示，才能发挥价值。通常都是将数据展示在 Dashboard 面板上，并且每隔 10s 等间隔自动刷新，用作业务监控和报警等。\n\n\n# 服务链路追踪\n\n除了需要对服务调用情况进行监控之外，你还需要记录服务调用经过的每一层链路，以便进行问题追踪和故障定位。\n\n服务链路追踪的工作原理大致如下：\n\n * 服务消费者发起调用前，会在本地按照一定的规则生成一个 requestid，发起调用时，将 requestid 当作请求参数的一部分，传递给服务提供者。\n * 服务提供者接收到请求后，记录下这次请求的 requestid，然后处理请求。如果服务提供者继续请求其他服务，会在本地再生成一个自己的 requestid，然后把这两个 requestid 都当作请求参数继续往下传递。\n\n以此类推，通过这种层层往下传递的方式，一次请求，无论最后依赖多少次服务调用、经过多少服务节点，都可以通过最开始生成的 requestid 串联所有节点，从而达到服务追踪的目的。\n\n\n# 服务治理\n\n服务监控能够发现问题，服务追踪能够定位问题所在，而解决问题就得靠服务治理了。服务治理就是通过一系列的手段来保证在各种意外情况下，服务调用仍然能够正常进行。\n\n在生产环境中，你应该经常会遇到下面几种状况。\n\n * 单机故障。通常遇到单机故障，都是靠运维发现并重启服务或者从线上摘除故障节点。然而集群的规模越大，越是容易遇到单机故障，在机器规模超过一百台以上时，靠传统的人肉运维显然难以应对。而服务治理可以通过一定的策略，自动摘除故障节点，不需要人为干预，就能保证单机故障不会影响业务。\n * 单 IDC 故障。你应该经常听说某某 App，因为施工挖断光缆导致大批量用户无法使用的严重故障。而服务治理可以通过自动切换故障 IDC 的流量到其他正常 IDC，可以避免因为单 IDC 故障引起的大批量业务受影响。\n * 依赖服务不可用。比如你的服务依赖依赖了另一个服务，当另一个服务出现问题时，会拖慢甚至拖垮你的服务。而服务治理可以通过熔断，在依赖服务异常的情况下，一段时期内停止发起调用而直接返回。这样一方面保证了服务消费者能够不被拖垮，另一方面也给服务提供者减少压力，使其能够尽快恢复。\n\n上面是三种最常见的需要引入服务治理的场景，当然还有一些其他服务治理的手段比如自动扩缩容，可以用来解决服务的容量问题。\n\n\n# 参考资料\n\n * 从 0 开始学微服务",normalizedContent:"# 微服务简介\n\n\n# 什么是微服务\n\n> martin fowler 与 james lewis 共同提出了微服务的概念，定义了微服务是由单一应用程序构成的小服务，自己拥有自己的进程与轻量化处理，服务依业务功能设计，以全自动的方式部署，与其他服务使用 http api 通信。同时服务会使用最小的规模的集中管理 (例如 docker) 能力，服务可以用不同的编程语言与数据库等组件实现。——微服务的维基百科词条定义\n\n互联网应用架构大致的演进方向为：单体架构 -> 服务化架构 -> 微服务架构。在演化过程中，架构越来越复杂，一个应用被拆分的服务也越来越细。\n\n\n# 单体应用\n\n互联网早期的技术栈通常为 lamp（linux + apache + mysql + php）或 mvc（spring + ibatis/hibernate + tomcat）。这两种架构都是典型的单体应用架构。其优点是技术栈简单，因此学习上手快，部署也容易。\n\n随着业务越来越复杂，开发团队规模不断扩张，单体应用架构就难以适应开发迭代节奏，主要有以下问题：\n\n * 构建、部署效率低：代码越多，依赖资源越多，则构建、部署的耗费时间自然会越长。即使每次修改一个很小的功能点，也不得不全量构建、全部部署，耗时耗力。\n * 团队协作成本高：单体应用的代码往往在一个工程中，而一个工程中的开发人员越多，显然沟通成本越高。\n * 可用性差：因为所有的功能开发最后都部署到同一个 war 包里，运行在同一个 tomcat 进程之中，一旦某一功能涉及的代码或者资源有问题，那就会影响整个 war 包中部署的功能。\n\n\n# 微服务\n\n微服务架构有以下 4 个特点：\n\n * 服务拆分粒度更细：根据业务拆分。\n * 独立部署：每个服务部署在物理上隔离，互不影响。\n * 独立维护：根据组织架构拆分，分团队维护。\n * 服务治理：服务数量变多，需要有统一的服务治理平台。\n\n简单来说，微服务就是将庞杂臃肿的单体应用拆分成细粒度的服务，独立部署，并交给各个中小团队来负责开发、测试、上线和运维整个生命周期。\n\n\n# 何时需要微服务\n\n应用微服务化架构前，要思考几个问题：什么时候进行服务化拆分？如何拆分服务？\n\n当应用复杂度、开发团队膨胀到难以维护时，就该考虑服务化拆分了。\n\n\n# 拆分服务的思考维度\n\n * 业务维度：业务和数据关系密切的应该拆分为一个微服务，而功能相对比较独立的业务适合单独拆分为一个微服务。\n * 功能维度：公共功能聚合为一个服务。标准是是否被多个其他服务调用，且依赖的资源独立不与其他业务耦合。\n * 组织架构：根据实际组织架构，天然分为不同的团队，每个团队独立维护若干微服务。\n\n但并不是说功能拆分的越细越好，过度的拆分反而会让服务数量膨胀变得难以管理，因此找到符合自己业务现状和团队人员技术水平的拆分粒度才是可取的。\n\n\n# 拆分服务的原则\n\n单一职责\n\n高内聚，低耦合\n\n先粗后细，逐渐细化\n\n渐进式迭代\n\n考虑扩展性\n\n\n# 拆分服务的前置条件\n\n * 服务如何定义？\n   * 对于单体应用来说，不同功能模块之前相互交互时，通常是以类库的方式来提供各个模块的功能。\n   * 对于微服务来说，每个服务都运行在各自的进程之中，无论采用哪种通讯协议，是 http 还是 rpc，服务之间的调用都通过接口来约定如何交互。约定内容包括接口名、接口参数以及接口返回值。\n * 服务如何发布和订阅？\n   * 单体应用由于部署在同一个 war 包里，接口之间的调用属于进程内的调用。\n   * 对于微服务来说，服务提供者需要向注册中心发布自己提供的服务（暴露接口信息以及接口地址）；服务消费者向注册中心订阅哪些服务可用。\n * 服务如何监控？通常对于一个服务，我们最关心的是 qps（调用量）、avgtime（平均耗时）以及 p999（99.9% 的请求性能在多少毫秒以内）这些指标。这时候你就需要一种通用的监控方案，能够覆盖业务埋点、数据收集、数据处理，最后到数据展示的全链路功能。\n * 服务如何治理？可以想象，拆分为微服务架构后，服务的数量变多了，依赖关系也变复杂了。比如一个服务的性能有问题时，依赖的服务都势必会受到影响。可以设定一个调用性能阈值，如果一段时间内一直超过这个值，那么依赖服务的调用可以直接返回，这就是熔断，也是服务治理最常用的手段之一。\n * 故障如何定位？在单体应用拆分为微服务之后，一次用户调用可能依赖多个服务，每个服务又部署在不同的节点上，如果用户调用出现问题，你需要有一种解决方案能够将一次用户请求进行标记，并在多个依赖的服务系统中继续传递，以便串联所有路径，从而进行故障定位。\n\n应用微服务架构，必须要先解决以上问题\n\n\n# 微服务的基础架构\n\n微服务架构下，服务调用主要依赖下面几个基本组件：\n\n * 服务描述\n * 注册中心\n * 服务框架\n * 服务监控\n * 服务追踪\n * 服务治理\n\n\n# 服务描述\n\n服务调用首先要解决的问题就是服务如何对外描述。比如，你对外提供了一个服务，那么这个服务的服务名叫什么？调用这个服务需要提供哪些信息？调用这个服务返回的结果是什么格式的？该如何解析？这些就是服务描述要解决的问题。\n\n常用的服务描述方式包括 restful api、xml 配置以及 idl 文件三种。\n\n其中，restful api 方式通常用于 http 协议的服务描述，并且常用 wiki 或者swagger来进行管理。下面是一个 restful api 方式的服务描述的例子。\n\nxml 配置方式多用作 rpc 协议的服务描述，通过 *.xml 配置文件来定义接口名、参数以及返回值类型等。下面是一个 xml 配置方式的服务描述的例子。\n\nidl 文件方式通常用作 thrift 和 grpc 这类跨语言服务调用框架中，比如 grpc 就是通过 protobuf 文件来定义服务的接口名、参数以及返回值的数据结构。\n\n\n# 注册中心\n\n\n\n有了服务的接口描述，下一步要解决的问题就是服务的发布和订阅，就是说你提供了一个服务，如何让外部想调用你的服务的人知道。这个时候就需要一个类似注册中心的角色，服务提供者将自己提供的服务以及地址登记到注册中心，服务消费者则从注册中心查询所需要调用的服务的地址，然后发起请求。\n\n一般来讲，注册中心的工作流程是：\n\n * 服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。\n * 服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。\n * 注册中心返回服务提供者地址列表给服务消费者。\n * 当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。\n\n\n# 服务框架\n\n服务消费者发起调用需解决以下问题：\n\n * 服务通信采用什么协议？就是说服务提供者和服务消费者之间以什么样的协议进行网络通信，是采用四层 tcp、udp 协议，还是采用七层 http 协议，还是采用其他协议？\n * 数据传输采用什么方式？就是说服务提供者和服务消费者之间的数据传输采用哪种方式，是同步还是异步，是在单连接上传输，还是多路复用。\n * 数据压缩采用什么格式？通常数据传输都会对数据进行压缩，来减少网络传输的数据量，从而减少带宽消耗和网络传输时间，比如常见的 json 序列化、java 对象序列化以及 protobuf 序列化等。\n\n\n# 服务监控\n\n一旦服务消费者与服务提供者之间能够正常发起服务调用，你就需要对调用情况进行监控，以了解服务是否正常。通常来讲，服务监控主要包括三个流程。\n\n * 数据收集。就是要把每一次服务调用的请求耗时以及成功与否收集起来，并上传到集中的数据处理中心。\n * 数据处理。有了每次调用的请求耗时以及成功与否等信息，就可以计算每秒服务请求量、平均耗时以及成功率等指标。\n * 数据展示。数据收集起来，经过处理之后，还需要以友好的方式对外展示，才能发挥价值。通常都是将数据展示在 dashboard 面板上，并且每隔 10s 等间隔自动刷新，用作业务监控和报警等。\n\n\n# 服务链路追踪\n\n除了需要对服务调用情况进行监控之外，你还需要记录服务调用经过的每一层链路，以便进行问题追踪和故障定位。\n\n服务链路追踪的工作原理大致如下：\n\n * 服务消费者发起调用前，会在本地按照一定的规则生成一个 requestid，发起调用时，将 requestid 当作请求参数的一部分，传递给服务提供者。\n * 服务提供者接收到请求后，记录下这次请求的 requestid，然后处理请求。如果服务提供者继续请求其他服务，会在本地再生成一个自己的 requestid，然后把这两个 requestid 都当作请求参数继续往下传递。\n\n以此类推，通过这种层层往下传递的方式，一次请求，无论最后依赖多少次服务调用、经过多少服务节点，都可以通过最开始生成的 requestid 串联所有节点，从而达到服务追踪的目的。\n\n\n# 服务治理\n\n服务监控能够发现问题，服务追踪能够定位问题所在，而解决问题就得靠服务治理了。服务治理就是通过一系列的手段来保证在各种意外情况下，服务调用仍然能够正常进行。\n\n在生产环境中，你应该经常会遇到下面几种状况。\n\n * 单机故障。通常遇到单机故障，都是靠运维发现并重启服务或者从线上摘除故障节点。然而集群的规模越大，越是容易遇到单机故障，在机器规模超过一百台以上时，靠传统的人肉运维显然难以应对。而服务治理可以通过一定的策略，自动摘除故障节点，不需要人为干预，就能保证单机故障不会影响业务。\n * 单 idc 故障。你应该经常听说某某 app，因为施工挖断光缆导致大批量用户无法使用的严重故障。而服务治理可以通过自动切换故障 idc 的流量到其他正常 idc，可以避免因为单 idc 故障引起的大批量业务受影响。\n * 依赖服务不可用。比如你的服务依赖依赖了另一个服务，当另一个服务出现问题时，会拖慢甚至拖垮你的服务。而服务治理可以通过熔断，在依赖服务异常的情况下，一段时期内停止发起调用而直接返回。这样一方面保证了服务消费者能够不被拖垮，另一方面也给服务提供者减少压力，使其能够尽快恢复。\n\n上面是三种最常见的需要引入服务治理的场景，当然还有一些其他服务治理的手段比如自动扩缩容，可以用来解决服务的容量问题。\n\n\n# 参考资料\n\n * 从 0 开始学微服务",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"RPC 基本原理",frontmatter:{title:"RPC 基本原理",categories:["分布式","分布式应用","微服务"],tags:["分布式","分布式应用","微服务","RPC"],abbrlink:"65334efa",date:"2020-06-10T16:00:00.000Z",permalink:"/pages/ebf86b/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/04.%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1/02.RPC.html",relativePath:"02.分布式/04.分布式应用/01.微服务/02.RPC.md",key:"v-ecdbd4a2",path:"/pages/ebf86b/",headers:[{level:2,title:"1. RPC 简介",slug:"_1-rpc-简介",normalizedTitle:"1. rpc 简介",charIndex:15},{level:3,title:"1.1. 什么是 RPC",slug:"_1-1-什么是-rpc",normalizedTitle:"1.1. 什么是 rpc",charIndex:29},{level:3,title:"1.2. RPC 通信",slug:"_1-2-rpc-通信",normalizedTitle:"1.2. rpc 通信",charIndex:137},{level:3,title:"1.3. RPC 协议",slug:"_1-3-rpc-协议",normalizedTitle:"1.3. rpc 协议",charIndex:455},{level:2,title:"2. 序列化",slug:"_2-序列化",normalizedTitle:"2. 序列化",charIndex:647},{level:3,title:"2.1. 常见序列化方式",slug:"_2-1-常见序列化方式",normalizedTitle:"2.1. 常见序列化方式",charIndex:713},{level:4,title:"2.1.1. JDK 序列化",slug:"_2-1-1-jdk-序列化",normalizedTitle:"2.1.1. jdk 序列化",charIndex:729},{level:4,title:"2.1.2. JSON",slug:"_2-1-2-json",normalizedTitle:"2.1.2. json",charIndex:787},{level:4,title:"2.1.3. Hessian",slug:"_2-1-3-hessian",normalizedTitle:"2.1.3. hessian",charIndex:866},{level:4,title:"2.1.4. Thrift / Protobuf",slug:"_2-1-4-thrift-protobuf",normalizedTitle:"2.1.4. thrift / protobuf",charIndex:1130},{level:3,title:"2.2. 序列化问题",slug:"_2-2-序列化问题",normalizedTitle:"2.2. 序列化问题",charIndex:1364},{level:2,title:"3. 反射+动态代理",slug:"_3-反射-动态代理",normalizedTitle:"3. 反射+动态代理",charIndex:1955},{level:2,title:"4. 网络通信",slug:"_4-网络通信",normalizedTitle:"4. 网络通信",charIndex:2226},{level:3,title:"4.1. IO 多路复用",slug:"_4-1-io-多路复用",normalizedTitle:"4.1. io 多路复用",charIndex:2343},{level:3,title:"4.2. 零拷贝",slug:"_4-2-零拷贝",normalizedTitle:"4.2. 零拷贝",charIndex:2529},{level:2,title:"5. RPC 架构模型",slug:"_5-rpc-架构模型",normalizedTitle:"5. rpc 架构模型",charIndex:3387},{level:2,title:"6. 服务注册和发现",slug:"_6-服务注册和发现",normalizedTitle:"6. 服务注册和发现",charIndex:3913},{level:3,title:"6.1. 基于 ZooKeeper 的服务发现",slug:"_6-1-基于-zookeeper-的服务发现",normalizedTitle:"6.1. 基于 zookeeper 的服务发现",charIndex:4096},{level:3,title:"6.2. 基于消息总线的最终一致性的注册中心",slug:"_6-2-基于消息总线的最终一致性的注册中心",normalizedTitle:"6.2. 基于消息总线的最终一致性的注册中心",charIndex:4567},{level:2,title:"7. 健康检查",slug:"_7-健康检查",normalizedTitle:"7. 健康检查",charIndex:4894},{level:2,title:"8. 路由和负载均衡",slug:"_8-路由和负载均衡",normalizedTitle:"8. 路由和负载均衡",charIndex:5123},{level:3,title:"8.1. 超时重试",slug:"_8-1-超时重试",normalizedTitle:"8.1. 超时重试",charIndex:5522},{level:3,title:"8.2. 限流、降级、熔断",slug:"_8-2-限流、降级、熔断",normalizedTitle:"8.2. 限流、降级、熔断",charIndex:5615},{level:3,title:"8.3. 优雅启动关闭",slug:"_8-3-优雅启动关闭",normalizedTitle:"8.3. 优雅启动关闭",charIndex:5674},{level:2,title:"9. 容错处理",slug:"_9-容错处理",normalizedTitle:"9. 容错处理",charIndex:5732},{level:3,title:"9.1. 异常重试",slug:"_9-1-异常重试",normalizedTitle:"9.1. 异常重试",charIndex:5744},{level:3,title:"9.2. 重试超时时间",slug:"_9-2-重试超时时间",normalizedTitle:"9.2. 重试超时时间",charIndex:5969},{level:3,title:"9.3. 业务异常",slug:"_9-3-业务异常",normalizedTitle:"9.3. 业务异常",charIndex:6242},{level:2,title:"10. 优雅上线下线",slug:"_10-优雅上线下线",normalizedTitle:"10. 优雅上线下线",charIndex:6497},{level:3,title:"10.1. 优雅下线",slug:"_10-1-优雅下线",normalizedTitle:"10.1. 优雅下线",charIndex:6530},{level:3,title:"10.2. 优雅上线",slug:"_10-2-优雅上线",normalizedTitle:"10.2. 优雅上线",charIndex:6947},{level:4,title:"10.2.1. 启动预热",slug:"_10-2-1-启动预热",normalizedTitle:"10.2.1. 启动预热",charIndex:6961},{level:4,title:"10.2.2. 延迟暴露",slug:"_10-2-2-延迟暴露",normalizedTitle:"10.2.2. 延迟暴露",charIndex:7262},{level:2,title:"11. 限流熔断",slug:"_11-限流熔断",normalizedTitle:"11. 限流熔断",charIndex:7727},{level:2,title:"12. 业务分组",slug:"_12-业务分组",normalizedTitle:"12. 业务分组",charIndex:8174},{level:3,title:"12.1. 动态分组",slug:"_12-1-动态分组",normalizedTitle:"12.1. 动态分组",charIndex:8482},{level:2,title:"13. 链路跟踪",slug:"_13-链路跟踪",normalizedTitle:"13. 链路跟踪",charIndex:8734},{level:2,title:"14. 泛化调用",slug:"_14-泛化调用",normalizedTitle:"14. 泛化调用",charIndex:9432},{level:2,title:"15. 时钟轮",slug:"_15-时钟轮",normalizedTitle:"15. 时钟轮",charIndex:10082},{level:2,title:"16. 流量回放",slug:"_16-流量回放",normalizedTitle:"16. 流量回放",charIndex:10691},{level:2,title:"17. RPC 高级",slug:"_17-rpc-高级",normalizedTitle:"17. rpc 高级",charIndex:11136},{level:3,title:"17.1. RPC 性能",slug:"_17-1-rpc-性能",normalizedTitle:"17.1. rpc 性能",charIndex:11151},{level:3,title:"17.2. RPC 安全",slug:"_17-2-rpc-安全",normalizedTitle:"17.2. rpc 安全",charIndex:11368},{level:2,title:"18. 参考资料",slug:"_18-参考资料",normalizedTitle:"18. 参考资料",charIndex:11684}],headersStr:"1. RPC 简介 1.1. 什么是 RPC 1.2. RPC 通信 1.3. RPC 协议 2. 序列化 2.1. 常见序列化方式 2.1.1. JDK 序列化 2.1.2. JSON 2.1.3. Hessian 2.1.4. Thrift / Protobuf 2.2. 序列化问题 3. 反射+动态代理 4. 网络通信 4.1. IO 多路复用 4.2. 零拷贝 5. RPC 架构模型 6. 服务注册和发现 6.1. 基于 ZooKeeper 的服务发现 6.2. 基于消息总线的最终一致性的注册中心 7. 健康检查 8. 路由和负载均衡 8.1. 超时重试 8.2. 限流、降级、熔断 8.3. 优雅启动关闭 9. 容错处理 9.1. 异常重试 9.2. 重试超时时间 9.3. 业务异常 10. 优雅上线下线 10.1. 优雅下线 10.2. 优雅上线 10.2.1. 启动预热 10.2.2. 延迟暴露 11. 限流熔断 12. 业务分组 12.1. 动态分组 13. 链路跟踪 14. 泛化调用 15. 时钟轮 16. 流量回放 17. RPC 高级 17.1. RPC 性能 17.2. RPC 安全 18. 参考资料",content:"# RPC 基本原理\n\n\n# 1. RPC 简介\n\n\n# 1.1. 什么是 RPC\n\nRPC 的全称是 Remote Procedure Call，即远程过程调用。\n\nRPC 的主要作用是：\n\n * 屏蔽远程调用跟本地调用的区别。\n * 隐藏底层网络通信的复杂性。\n\n\n# 1.2. RPC 通信\n\n远程调用说明了，RPC 需要通信，那么 RPC 的通信过程是怎样的呢？\n\nRPC 常用于业务系统之间的数据交互，需要保证其可靠性，所以 RPC 一般默认采用 TCP 来传输。\n\n网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象，所以必须要将其转换，这个过程叫序列化。\n\n\n\n * RPC 拦截调用方要执行的远程方法，将方法名、参数等序列化为方便在网络中传输的二进制或 JSON 数据，然后将这些请求信息传给服务提供方；\n * 服务提供方将请求信息反序列化为本地的方法和请求参数，然后执行，最后将执行结果序列化为二进制或 JSON 数据，再回应给调用方。\n * 调用方将应答数据反序列化。\n\n\n# 1.3. RPC 协议\n\n既然有了现成的 HTTP 协议，还有必要设计 RPC 协议吗？\n\n有必要。因为 HTTP 这些通信标准协议，数据包中的实际请求数据相对于数据包本身要小很多，有很多无用的内容；并且 HTTP 属于无状态协议，无法将请求和响应关联，每次请求要重新建立连接。这对于高性能的 RPC 来说，HTTP 协议难以满足需求，所以有必要设计一个紧凑的私有协议。\n\n\n\n\n# 2. 序列化\n\n> 序列化可以将对象的字节序列持久化——保存在内存、文件、数据库中。\n\n序列化是 RPC 的要点之一。\n\n\n\n\n# 2.1. 常见序列化方式\n\n# 2.1.1. JDK 序列化\n\n> 有兴趣深入了解 JDK 序列化方式，可以参考：深入理解 Java 序列化\n\n# 2.1.2. JSON\n\njackson、gson、fastjson - 适用于对序列化后的数据要求有良好的可读性（转为 json 、xml 形式）。\n\n# 2.1.3. Hessian\n\nhessian - 适用于对开发体验敏感，性能有要求的内外部系统。\n\n但 Hessian 本身也有问题，官方版本对 Java 里面一些常见对象的类型不支持，比如：\n\n * Linked 系列，LinkedHashMap、LinkedHashSet 等，但是可以通过扩展 CollectionDeserializer 类修复；\n * Locale 类，可以通过扩展 ContextSerializerFactory 类修复；\n * Byte/Short 反序列化的时候变成 Integer。\n\n# 2.1.4. Thrift / Protobuf\n\nthrift、protobuf - 适用于对性能敏感，对开发体验要求不高的内部系统。\n\n初次以外，还有很多其他的序列化方案。那么，RPC 的序列化方式如何选择呢？\n\n\n\n综合以上，Java RPC 框架中序列化方式，一般首选 Protobuf 和 Hessian，二者在性能、通用性、安全性、兼容性、空间开销上都表现不错。其中，Protobuf 性能、通用性更好；而 Hessian 在开发体验上更为便捷。\n\n\n# 2.2. 序列化问题\n\nJava 对象序列化，一般要关注以下问题：\n\n常规性问题：\n\n * 当父类继承 Serializable 接口时，所有子类都可以被序列化。\n * 子类实现了 Serializable 接口，父类没有，则父类的属性不会被序列化（不报错，数据丢失），子类的属性仍可以正确序列化。\n * 如果序列化的属性是对象，则这个对象也必须实现 Serializable 接口，否则会报错。\n * 在反序列化时，如果对象的属性有修改或删减，则修改的部分属性会丢失，但不会报错。\n * 在反序列化时，如果 serialVersionUID 被修改，则反序列化时会失败。\n\n设计问题：\n\n * 对象过于复杂、庞大 - 对象过于复杂、庞大，会降低序列化、反序列化的效率，并增加传输开销，从而导致响应时延增大。\n * 对象有复杂的继承关系 - 对象关系越复杂，就越浪费性能，同时又很容易出现序列化上的问题。\n * 使用序列化框架不支持的类作为入参类 - 比如 Hessian 框架，他天然是不支持 LinkHashMap、LinkedHashSet 等，而且大多数情况下最好不要使用第三方集合类，如 Guava 中的集合类，很多开源的序列化框架都是优先支持编程语言原生的对象。因此如果入参是集合类，应尽量选用原生的、最为常用的集合类，如 HashMap、ArrayList。\n\n\n# 3. 反射+动态代理\n\nRPC 的远程过程调用时通过反射+动态代理实现的。\n\n\n\nRPC 框架会自动为要调用的接口生成一个代理类。当在项目中注入接口的时候，运行过程中实际绑定的就是这个接口生成的代理类。在接口方法被调用时，会被代理类拦截，这样，就可以在生成的代理类中，加入远程调用逻辑。\n\n除了 JDK 默认的 InvocationHandler 能完成代理功能，还有很多其他的第三方框架也可以，比如像 Javassist、Byte Buddy 这样的框架。\n\n> 反射+动态代理更多详情可以参考：深入理解 Java 反射和动态代理\n\n\n# 4. 网络通信\n\n一次 RPC 调用，本质就是服务消费者与服务提供者间的一次网络信息交换的过程。可见，通信时 RPC 实现的核心。\n\n常见的网络 IO 模型有：同步阻塞（BIO）、同步非阻塞（NIO）、异步非阻塞（AIO）。\n\n\n# 4.1. IO 多路复用\n\nIO 多路复用（Reactor 模式）在高并发场景下使用最为广泛，很多知名软件都应用了这一技术，如：Netty、Redis、Nginx 等。\n\nIO 多路复用分为 select，poll 和 epoll。\n\n什么是 IO 多路复用？字面上的理解，多路就是指多个通道，也就是多个网络连接的 IO，而复用就是指多个通道复用在一个复用器上。\n\n\n# 4.2. 零拷贝\n\n系统内核处理 IO 操作分为两个阶段——等待数据和拷贝数据。等待数据，就是系统内核在等待网卡接收到数据后，把数据写到内核中；而拷贝数据，就是系统内核在获取到数据后，将数据拷贝到用户进程的空间中。\n\n\n\n应用进程的每一次写操作，都会把数据写到用户空间的缓冲区中，再由 CPU 将数据拷贝到系统内核的缓冲区中，之后再由 DMA 将这份数据拷贝到网卡中，最后由网卡发送出去。这里我们可以看到，一次写操作数据要拷贝两次才能通过网卡发送出去，而用户进程的读操作则是将整个流程反过来，数据同样会拷贝两次才能让应用程序读取到数据。\n\n应用进程的一次完整的读写操作，都需要在用户空间与内核空间中来回拷贝，并且每一次拷贝，都需要 CPU 进行一次上下文切换（由用户进程切换到系统内核，或由系统内核切换到用户进程），这样很浪费 CPU 和性能。\n\n所谓的零拷贝，就是取消用户空间与内核空间之间的数据拷贝操作，应用进程每一次的读写操作，可以通过一种方式，直接将数据写入内核或从内核中读取数据，再通过 DMA 将内核中的数据拷贝到网卡，或将网卡中的数据 copy 到内核。\n\n\n\nNetty 的零拷贝偏向于用户空间中对数据操作的优化，这对处理 TCP 传输中的拆包粘包问题有着重要的意义，对应用程序处理请求数据与返回数据也有重要的意义。\n\nNetty 框架中很多内部的 ChannelHandler 实现类，都是通过 CompositeByteBuf、slice、wrap 操作来处理 TCP 传输中的拆包与粘包问题的。\n\nNetty 的 ByteBuffer 可以采用 Direct Buffers，使用堆外直接内存进行 Socketd 的读写 操作，最终的效果与我刚才讲解的虚拟内存所实现的效果是一样的。\n\nNetty 还提供 FileRegion 中包装 NIO 的 FileChannel.transferTo() 方法实现了零拷 贝，这与 Linux 中的 sendfile 方式在原理上也是一样的。\n\n\n# 5. RPC 架构模型\n\n了解前面的知识点（序列化、动态代理、通信），其实已经可以实现一个点对点的 RPC 架构了。\n\n采用微内核架构的 RPC 架构模型：\n\n\n\n在 RPC 框架里面，怎么支持插件化架构的呢？我们可以将每个功能点抽象成一个接 口，将这个接口作为插件的契约，然后把这个功能的接口与功能的实现分离，并提供接口的默认实现。在 Java 里面，JDK 有自带的 SPI（Service Provider Interface）服务发现机 制，它可以动态地为某个接口寻找服务实现。使用 SPI 机制需要在 Classpath 下的 META-INF/services 目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体实现类。\n\n但在实际项目中，我们其实很少使用到 JDK 自带的 SPI 机制，首先它不能按需加载， ServiceLoader 加载某个接口实现类的时候，会遍历全部获取，也就是接口的实现类得全部载入并实例化一遍，会造成不必要的浪费。另外就是扩展如果依赖其它的扩展，那就做不到自动注入和装配，这就很难和其他框架集成，比如扩展里面依赖了一个 Spring Bean，原生的 Java SPI 就不支持。\n\n\n# 6. 服务注册和发现\n\nRPC 框架必须要有服务注册和发现机制，这样，集群中的节点才能知道通信方的请求地址。\n\n * 服务注册：在服务提供方启动的时候，将对外暴露的接口注册到注册中心之中，注册中心将这个服务节点的 IP 和接口保存下来。\n * 服务订阅：在服务调用方启动的时候，去注册中心查找并订阅服务提供方的 IP，然后缓存到本地，并用于后续的远程调用。\n\n\n# 6.1. 基于 ZooKeeper 的服务发现\n\n使用 ZooKeeper 作为服务注册中心，是 Java 分布式系统的经典方案。\n\n搭建一个 ZooKeeper 集群作为注册中心集群，服务注册的时候只需要服务节点向 ZooKeeper 节点写入注册信息即可，利用 ZooKeeper 的 Watcher 机制完成服务订阅与服务下发功能\n\n\n\n通常我们可以使用 ZooKeeper、etcd 或者分布式缓存（如 Hazelcast）来解决事件通知问题，但当集群达到一定规模之后，依赖的 ZooKeeper 集群、etcd 集群可能就不稳定了，无法满足我们的需求。\n\n在超大规模的服务集群下，注册中心所面临的挑战就是超大批量服务节点同时上下线，注册中心集群接受到大量服务变更请求，集群间各节点间需要同步大量服务节点数据，最终导致如下问题：\n\n * 注册中心负载过高；\n * 各节点数据不一致；\n * 服务下发不及时或下发错误的服务节点列表。\n\nRPC 框架依赖的注册中心的服务数据的一致性其实并不需要满足 CP，只要满足 AP 即可。\n\n\n# 6.2. 基于消息总线的最终一致性的注册中心\n\nZooKeeper 的一大特点就是强一致性，ZooKeeper 集群的每个节点的数据每次发生更新操作，都会通知其它 ZooKeeper 节点同时执行更新。它要求保证每个节点的数据能够实时的完全一致，这也就直接导致了 ZooKeeper 集群性能上的下降。\n\n而 RPC 框架的服务发现，在服务节点刚上线时，服务调用方是可以容忍在一段时间之后 （比如几秒钟之后）发现这个新上线的节点的。毕竟服务节点刚上线之后的几秒内，甚至更长的一段时间内没有接收到请求流量，对整个服务集群是没有什么影响的，所以我们可以牺牲掉 CP（强制一致性），而选择 AP（最终一致），来换取整个注册中心集群的性能和稳定性。\n\n\n\n\n# 7. 健康检查\n\n使用频率适中的心跳去检测目标机器的健康状态。\n\n * 健康状态：建立连接成功，并且心跳探活也一直成功；\n * 亚健康状态：建立连接成功，但是心跳请求连续失败；\n * 死亡状态：建立连接失败。\n\n可以使用可用率来作为健康状态的量化标准：\n\n可用率 = 一个时间窗口内接口调用成功次数 / 总调用次数\n\n\n当可用率低于某个比例，就认为这个节点存在问题，把它挪到亚健康列表，这样既考虑了高低频的调用接口，也兼顾了接口响应时间不同的问题。\n\n\n# 8. 路由和负载均衡\n\n对于服务调用方来说，一个接口会有多个服务提供方同时提供服务，所以我们的 RPC 在每次发起请求的时候，都需要从多个服务提供方节点里面选择一个用于发请求的节点。这被称为路由策略。\n\n * IP 路由：最简单的当然是 IP 路由，因为服务上线后，会暴露服务到注册中心，将自身 IP、端口等元信息告知注册中心。这样消费方就可以在向注册中心请求服务地址时，感知其存在。\n * 参数路由：但有时，会有一些复杂的场景，如：灰度发布、定点调用，我们并不希望上线的服务被所有消费者感知，为了更加细粒度的控制，可以使用参数路由。通过参数控制通信的路由策略。\n\n除了特殊场景的路由策略以外，对于机器中多个服务方，如何选择调用哪个服务节点，可以应用负载均衡策略。RPC 负载均衡策略一般包括随机、轮询、一致性 Hash、最近最少连接等。\n\n\n\n> 负载均衡详情可以参考：负载均衡基本原理\n\n\n# 8.1. 超时重试\n\n超时重试机制是指：当调用端发起的请求失败或超时未收到响应时，RPC 框架自身可以进行重试，再重新发送请求，用户可以自行设置是否开启重试以及重试的次数。\n\n\n\n\n# 8.2. 限流、降级、熔断\n\n限流方案：Redis + lua、Sentinel\n\n熔断方案：Hystrix\n\n\n# 8.3. 优雅启动关闭\n\n如何避免服务停机带来的业务损失：\n\n\n\n如何避免流量打到没有启动完成的节点：\n\n\n\n\n# 9. 容错处理\n\n\n# 9.1. 异常重试\n\n就是当调用端发起的请求失败时，RPC 框架自身可以进行重试，再重新发送请求，用户可以自行设置是否开启重试以及重试的次数。\n\n当然，不是所有的异常都要触发重试，只有符合重试条件的异常才能触发重试，比如网络超时异常、网络连接异常等等（这个需要 RPC 去判定）。\n\n> 注意：有时网络可能发生抖动，导致请求超时，这时如果 RPC 触发超时重试，会触发业务逻辑重复执行，如果接口没有幂等性设计，就可能引发问题。如：重发写表。\n\n\n# 9.2. 重试超时时间\n\n连续的异常重试可能会出现一种不可靠的情况，那就是连续的异常重试并且每次处理的请求时间比较长，最终会导致请求处理的时间过长，超出用户设置的超时时间。\n\n解决这个问题最直接的方式就是，在每次重试后都重置一下请求的超时时间。\n\n当调用端发起 RPC 请求时，如果发送请求发生异常并触发了异常重试，我们可以先判定下这个请求是否已经超时，如果已经超时了就直接返回超时异常，否则就先重置下这个请求的超时时间，之后再发起重试。\n\n在所有发起重试、负载均衡选择节点的时候，去掉重试之前出现过问题的那个节点，以保证重试的成功率。\n\n\n# 9.3. 业务异常\n\nRPC 框架是不会知道哪些业务异常能够去进行异常重试的，我们可以加个重试异常的白名 单，用户可以将允许重试的异常加入到这个白名单中。当调用端发起调用，并且配置了异常重试策略，捕获到异常之后，我们就可以采用这样的异常处理策略。如果这个异常是 RPC 框架允许重试的异常，或者这个异常类型存在于可重试异常的白名单中，我们就允许对这个请求进行重试。\n\n----------------------------------------\n\n综上，一个可靠的 RPC 容错处理机制如下：\n\n\n\n\n# 10. 优雅上线下线\n\n如何避免服务停机带来的业务损失？\n\n\n# 10.1. 优雅下线\n\n当服务提供方正在关闭，如果这之后还收到了新的业务请求，服务提供方直接返回一个特定的异常给调用方（比如 ShutdownException）。这个异常就是告诉调用方“我已经收到这个请求了，但是我正在关闭，并没有处理这个请求”，然后调用方收到这个异常响应后，RPC 框架把这个节点从健康列表挪出，并把请求自动重试到其他节点，因为这个请求是没有被服务提供方处理过，所以可以安全地重试到其他节点，这样就可以实现对业务无损。\n\n在 Java 语言里面，对应的是 Runtime.addShutdownHook 方法，可以注册关闭的钩子。在 RPC 启动的时候，我们提前注册关闭钩子，并在里面添加了两个处理程序，一个负责开启关闭标识，一个负责安全关闭服务对象，服务对象在关闭的时候会通知调用方下线节点。同时需要在我们调用链里面加上挡板处理器，当新的请求来的时候，会判断关闭标识，如果正在关闭，则抛出特定异常。\n\n\n\n\n# 10.2. 优雅上线\n\n# 10.2.1. 启动预热\n\n启动预热，就是让刚启动的服务提供方应用不承担全部的流量，而是让它被调用的次数随着时间的移动慢慢增加，最终让流量缓和地增加到跟已经运行一段时间后的水平一样。\n\n首先，在真实环境中机器都会默认开启 NTP 时间同步功能，来保证所有机器时间的一致性。\n\n调用方通过服务发现，除了可以拿到 IP 列表，还可以拿到对应的启动时间。我们需要把这个时间作用在负载均衡上。\n\n\n\n通过这个小逻辑的改动，我们就可以保证当服务提供方运行时长小于预热时间时，对服务提供方进行降权，减少被负载均衡选择的概率，避免让应用在启动之初就处于高负载状态，从而实现服务提供方在启动后有一个预热的过程。\n\n# 10.2.2. 延迟暴露\n\n服务提供方应用在没有启动完成的时候，调用方的请求就过来了，而调用方请求过来的原因是，服务提供方应用在启动过程中把解析到的 RPC 服务注册到了注册中心，这就导致在后续加载没有完成的情况下服务提供方的地址就被服务调用方感知到了。\n\n为了解决这个问题，需要在应用启动加载、解析 Bean 的时候，如果遇到了 RPC 服务的 Bean，只先把这个 Bean 注册到 Spring-BeanFactory 里面去，而并不把这个 Bean 对应的接口注册到注册中心，只有等应用启动完成后，才把接口注册到注册中心用于服务发现，从而实现让服务调用方延迟获取到服务提供方地址。\n\n具体如何实现呢？\n\n我们可以在服务提供方应用启动后，接口注册到注册中心前，预留一个 Hook 过程，让用户可以实现可扩展的 Hook 逻辑。用户可以在 Hook 里面模拟调用逻辑，从而使 JVM 指令能够预热起来，并且用户也可以在 Hook 里面事先预加载一些资源，只有等所有的资源都加载完成后，最后才把接口注册到注册中心。\n\n\n\n\n# 11. 限流熔断\n\n限流算法有很多，比如最简单的计数器，还有可以做到平滑限流的滑动窗口、漏斗算法以及令牌桶算法等等。其中令牌桶算法最为常用。\n\n服务端主要是通过限流来进行自我保护，我们在实现限流时要考虑到应用和 IP 级别，方便我们在服务治理的时候，对部分访问量特别大的应用进行合理的限流。\n\n服务端的限流阈值配置都是作用于单机的，而在有些场景下，例如对整个服务设置限流阈值，服务进行扩容时， 限流的配置并不方便，我们可以在注册中心或配置中心下发限流阈值配置的时候，将总服务节点数也下发给服务节点，让 RPC 框架自己去计算限流阈值。\n\n我们还可以让 RPC 框架的限流模块依赖一个专门的限流服务，对服务设置限流阈值进行精准地控制，但是这种方式依赖了限流服务，相比单机的限流方式，在性能和耗时上有劣势。\n\n调用端可以通过熔断机制进行自我保护，防止调用下游服务出现异常，或者耗时过长影响调 用端的业务逻辑，RPC 框架可以在动态代理的逻辑中去整合熔断器，实现 RPC 框架的熔断 功能。\n\n\n# 12. 业务分组\n\n\n\n在 RPC 里面我们可以通过分组的方式人为地给不同的调用方划分出不同的小集群，从而实现调用方流量隔离的效果，保障我们的核心业务不受非核心业务的干扰。但我们在考虑问题的时候，不能顾此失彼，不能因为新加一个的功能而影响到原有系统的稳定性。\n\n其实我们不仅可以通过分组把服务提供方划分成不同规模的小集群，我们还可以利用分组完成一个接口多种实现的功能。正常情况下，为了方便我们自己管理服务，我一般都会建议每个接口完成的功能尽量保证唯一。但在有些特殊场景下，两个接口也会完全一样，只是具体实现上有那么一点不同，那么我们就可以在服务提供方应用里面同时暴露两个相同接口，但只是接口分组不一样罢了。\n\n\n# 12.1. 动态分组\n\n分组可以帮助服务提供方实现调用方的隔离。但是因为调用方流量并不是一成不变的，而且还可能会因为突发事件导致某个分组的流量溢出，而在整个大集群还有富余能力的时候，又因为分组隔离不能为出问题的集群提供帮助。\n\n为了解决这种突发流量的问题，我们提供了一种更高效的方案，可以实现分组的快速伸缩。事实上我们还可以利用动态分组解决分组后给每个分组预留机器冗余的问题，我们没有必要把所有冗余的机器都分配到分组里面，我们可以把这些预留的机器做成一个共享的池子，从而减少整体预留的实例数量。\n\n\n# 13. 链路跟踪\n\n分布式链路跟踪就是将一次分布式请求还原为一个完整的调用链路，我们可以在整个调用链路中跟踪到这一次分布式请求的每一个环节的调用情况，比如调用是否成功，返回什么异常，调用的哪个服务节点以及请求耗时等等。\n\nTrace 就是代表整个链路，每次分布式都会产生一个 Trace，每个 Trace 都有它的唯一标识即 TraceId，在分布式链路跟踪系统中，就是通过 TraceId 来区分每个 Trace 的。 Span 就是代表了整个链路中的一段链路，也就是说 Trace 是由多个 Span 组成的。在一个 Trace 下，每个 Span 也都有它的唯一标识 SpanId，而 Span 是存在父子关系的。还是以讲过的例子为例子，在 A->B->C->D 的情况下，在整个调用链中，正常情况下会产生 3 个 Span，分别是 Span1（A->B）、Span2（B->C）、Span3（C->D），这时 Span3 的父 Span 就是 Span2，而 Span2 的父 Span 就是 Span1。\n\nRPC 在整合分布式链路跟踪需要做的最核心的两件事就是“埋点”和“传递”。\n\n我们前面说是因为各子应用、子服务间复杂的依赖关系，所以通过日志难定位问题。那我们就想办法通过日志定位到是哪个子应用的子服务出现问题就行了。\n\n其实，在 RPC 框架打印的异常信息中，是包括定位异常所需要的异常信息的，比如是哪类异常引起的问题（如序列化问题或网络超时问题），是调用端还是服务端出现的异常，调用端与服务端的 IP 是什么，以及服务接口与服务分组都是什么等等。具体如下图所示：\n\n\n\n\n# 14. 泛化调用\n\n在一些特定场景下，需要在没有接口的情况下进行 RPC 调用。例如：\n\n场景一：搭建一个统一的测试平台，可以让各个业务方在测试平台中通过输入接口、分组名、方法名以及参数值，在线测试自己发布的 RPC 服务。\n\n\n\n场景二：搭建一个轻量级的服务网关，可以让各个业务方用 HTTP 的方式，通过服务网关调用其它服务。\n\n\n\n为了解决这些场景的问题，可以使用泛化调用。\n\n就是 RPC 框架提供统一的泛化调用接口（GenericService），调用端在创建 GenericService 代理时指定真正需要调用的接口的接口名以及分组名，通过调用 GenericService 代理的 $invoke 方法将服务端所需要的所有信息，包括接口名、业务分组名、方法名以及参数信息等封装成请求消息，发送给服务端，实现在没有接口的情况下进行 RPC 调用的功能。\n\nclass GenericService {\nObject $invoke(String methodName, String[] paramTypes, Object[] params);\nCompletableFuture<Object> $asyncInvoke(String methodName, String[] paramTypes\n}\n\n\n而通过泛化调用的方式发起调用，由于调用端没有服务端提供方提供的接口 API，不能正常地进行序列化与反序列化，我们可以为泛化调用提供专属的序列化插件，来解决实际问题。\n\n\n# 15. 时钟轮\n\n时钟轮这个机制很好地解决了定时任务中，因每个任务都创建一个线程，导致的创建过多线程的问题，以及一个线程扫描所有的定时任务，让 CPU 做了很多额外的轮询遍历操作而浪费 CPU 的问题。\n\n时钟轮的实现机制就是模拟现实生活中的时钟，将每个定时任务放到对应的时间槽位上，这样可以减少扫描任务时对其它时间槽位定时任务的额外遍历操作。\n\n在时间轮的使用中，有些问题需要你额外注意：\n\n时间槽位的单位时间越短，时间轮触发任务的时间就越精确。例如时间槽位的单位时间是 10 毫秒，那么执行定时任务的时间误差就在 10 毫秒内，如果是 100 毫秒，那么误差就在 100 毫秒内。\n\n时间轮的槽位越多，那么一个任务被重复扫描的概率就越小，因为只有在多层时钟轮中的任务才会被重复扫描。比如一个时间轮的槽位有 1000 个，一个槽位的单位时间是 10 毫秒，那么下一层时间轮的一个槽位的单位时间就是 10 秒，超过 10 秒的定时任务会被放到下一层时间轮中，也就是只有超过 10 秒的定时任务会被扫描遍历两次，但如果槽位是 10 个，那么超过 100 毫秒的任务，就会被扫描遍历两次。\n\n结合这些特点，我们就可以视具体的业务场景而定，对时钟轮的周期和时间槽数进行设置。\n\n在 RPC 框架中，只要涉及到定时任务，我们都可以应用时钟轮，比较典型的就是调用端的超时处理、调用端与服务端的启动超时以及定时心跳等等。\n\n\n# 16. 流量回放\n\n所谓的流量就是某个时间段内的所有请求，我们通过某种手段把发送到 A 应用的所有请求录制下来，然后把这些请求统一转发到 B 应用，让 B 应用接收到的请求参数跟 A 应用保持一致，从而实现 A 接收到的请求在 B 应用里面重新请求了一遍。整个过程称之为“流量回放”。\n\n流量回放可以做什么？\n\n为了保障应用升级后，我们的业务行为还能保持和升级前一样，我们在大多数情况下都是依靠已有的 TestCase 去验证，但这种方式在一定程度上并不是完全可靠的。最可靠的方式就是引入线上 Case 去验证改造后的应用，把线上的真实流量在改造后的应用里面进行回放，这样不仅节省整个上线时间，还能弥补手动维护 Case 存在的缺陷。\n\n应用引入了 RPC 后，所有的请求流量都会被 RPC 接管，所以我们可以很自然地在 RPC 里面支持流量回放功能。虽然这个功能本身并不是 RPC 的核心功能，但对于使用 RPC 的人来说，他们有了这个功能之后，就可以更放心地升级自己的应用了。\n\n\n# 17. RPC 高级\n\n\n# 17.1. RPC 性能\n\n如何提升单机吞吐量？\n\n大多数情况下，影响到 RPC 调用的吞吐量的原因也就是业务逻辑处理慢了，CPU 大部分时间都在等待资源。\n\n为了解决等待的耗时，可以使用异步。异步可以使用 Future 或 Callback 方式，Future 最为简单。\n\n\n\n另外，我们可以通过对 CompletableFuture 的支持，实现 RPC 调用在调用端与服务端之间的完全异步，同时提升两端的单机吞吐量。\n\n\n# 17.2. RPC 安全\n\n虽然 RPC 经常用于解决内网应用之间的调用，内网环境相对公网也没有那么恶劣，但我们也有必要去建立一套可控的安全体系，去防止一些错误行为。对于 RPC 来说，我们所关心的安全问题不会有公网应用那么复杂，我们只要保证让服务调用方能拿到真实的服务提供方 IP 地址集合，且服务提供方可以管控调用自己的应用就够了。\n\n服务提供方应用里面放一个用于 HMAC 签名的私钥，在授权平台上用这个私钥为申请调用的调用方应用进行签名，这个签名生成的串就变成了调用方唯一的身份。服务提供方在收到调用方的授权请求之后，我们只要需要验证下这个签名跟调用方应用信息是否对应得上就行了，这样集中式授权的瓶颈也就不存在了。\n\n\n# 18. 参考资料\n\n * 《RPC 实战与核心原理》",normalizedContent:"# rpc 基本原理\n\n\n# 1. rpc 简介\n\n\n# 1.1. 什么是 rpc\n\nrpc 的全称是 remote procedure call，即远程过程调用。\n\nrpc 的主要作用是：\n\n * 屏蔽远程调用跟本地调用的区别。\n * 隐藏底层网络通信的复杂性。\n\n\n# 1.2. rpc 通信\n\n远程调用说明了，rpc 需要通信，那么 rpc 的通信过程是怎样的呢？\n\nrpc 常用于业务系统之间的数据交互，需要保证其可靠性，所以 rpc 一般默认采用 tcp 来传输。\n\n网络传输的数据必须是二进制数据，但调用方请求的出入参数都是对象，所以必须要将其转换，这个过程叫序列化。\n\n\n\n * rpc 拦截调用方要执行的远程方法，将方法名、参数等序列化为方便在网络中传输的二进制或 json 数据，然后将这些请求信息传给服务提供方；\n * 服务提供方将请求信息反序列化为本地的方法和请求参数，然后执行，最后将执行结果序列化为二进制或 json 数据，再回应给调用方。\n * 调用方将应答数据反序列化。\n\n\n# 1.3. rpc 协议\n\n既然有了现成的 http 协议，还有必要设计 rpc 协议吗？\n\n有必要。因为 http 这些通信标准协议，数据包中的实际请求数据相对于数据包本身要小很多，有很多无用的内容；并且 http 属于无状态协议，无法将请求和响应关联，每次请求要重新建立连接。这对于高性能的 rpc 来说，http 协议难以满足需求，所以有必要设计一个紧凑的私有协议。\n\n\n\n\n# 2. 序列化\n\n> 序列化可以将对象的字节序列持久化——保存在内存、文件、数据库中。\n\n序列化是 rpc 的要点之一。\n\n\n\n\n# 2.1. 常见序列化方式\n\n# 2.1.1. jdk 序列化\n\n> 有兴趣深入了解 jdk 序列化方式，可以参考：深入理解 java 序列化\n\n# 2.1.2. json\n\njackson、gson、fastjson - 适用于对序列化后的数据要求有良好的可读性（转为 json 、xml 形式）。\n\n# 2.1.3. hessian\n\nhessian - 适用于对开发体验敏感，性能有要求的内外部系统。\n\n但 hessian 本身也有问题，官方版本对 java 里面一些常见对象的类型不支持，比如：\n\n * linked 系列，linkedhashmap、linkedhashset 等，但是可以通过扩展 collectiondeserializer 类修复；\n * locale 类，可以通过扩展 contextserializerfactory 类修复；\n * byte/short 反序列化的时候变成 integer。\n\n# 2.1.4. thrift / protobuf\n\nthrift、protobuf - 适用于对性能敏感，对开发体验要求不高的内部系统。\n\n初次以外，还有很多其他的序列化方案。那么，rpc 的序列化方式如何选择呢？\n\n\n\n综合以上，java rpc 框架中序列化方式，一般首选 protobuf 和 hessian，二者在性能、通用性、安全性、兼容性、空间开销上都表现不错。其中，protobuf 性能、通用性更好；而 hessian 在开发体验上更为便捷。\n\n\n# 2.2. 序列化问题\n\njava 对象序列化，一般要关注以下问题：\n\n常规性问题：\n\n * 当父类继承 serializable 接口时，所有子类都可以被序列化。\n * 子类实现了 serializable 接口，父类没有，则父类的属性不会被序列化（不报错，数据丢失），子类的属性仍可以正确序列化。\n * 如果序列化的属性是对象，则这个对象也必须实现 serializable 接口，否则会报错。\n * 在反序列化时，如果对象的属性有修改或删减，则修改的部分属性会丢失，但不会报错。\n * 在反序列化时，如果 serialversionuid 被修改，则反序列化时会失败。\n\n设计问题：\n\n * 对象过于复杂、庞大 - 对象过于复杂、庞大，会降低序列化、反序列化的效率，并增加传输开销，从而导致响应时延增大。\n * 对象有复杂的继承关系 - 对象关系越复杂，就越浪费性能，同时又很容易出现序列化上的问题。\n * 使用序列化框架不支持的类作为入参类 - 比如 hessian 框架，他天然是不支持 linkhashmap、linkedhashset 等，而且大多数情况下最好不要使用第三方集合类，如 guava 中的集合类，很多开源的序列化框架都是优先支持编程语言原生的对象。因此如果入参是集合类，应尽量选用原生的、最为常用的集合类，如 hashmap、arraylist。\n\n\n# 3. 反射+动态代理\n\nrpc 的远程过程调用时通过反射+动态代理实现的。\n\n\n\nrpc 框架会自动为要调用的接口生成一个代理类。当在项目中注入接口的时候，运行过程中实际绑定的就是这个接口生成的代理类。在接口方法被调用时，会被代理类拦截，这样，就可以在生成的代理类中，加入远程调用逻辑。\n\n除了 jdk 默认的 invocationhandler 能完成代理功能，还有很多其他的第三方框架也可以，比如像 javassist、byte buddy 这样的框架。\n\n> 反射+动态代理更多详情可以参考：深入理解 java 反射和动态代理\n\n\n# 4. 网络通信\n\n一次 rpc 调用，本质就是服务消费者与服务提供者间的一次网络信息交换的过程。可见，通信时 rpc 实现的核心。\n\n常见的网络 io 模型有：同步阻塞（bio）、同步非阻塞（nio）、异步非阻塞（aio）。\n\n\n# 4.1. io 多路复用\n\nio 多路复用（reactor 模式）在高并发场景下使用最为广泛，很多知名软件都应用了这一技术，如：netty、redis、nginx 等。\n\nio 多路复用分为 select，poll 和 epoll。\n\n什么是 io 多路复用？字面上的理解，多路就是指多个通道，也就是多个网络连接的 io，而复用就是指多个通道复用在一个复用器上。\n\n\n# 4.2. 零拷贝\n\n系统内核处理 io 操作分为两个阶段——等待数据和拷贝数据。等待数据，就是系统内核在等待网卡接收到数据后，把数据写到内核中；而拷贝数据，就是系统内核在获取到数据后，将数据拷贝到用户进程的空间中。\n\n\n\n应用进程的每一次写操作，都会把数据写到用户空间的缓冲区中，再由 cpu 将数据拷贝到系统内核的缓冲区中，之后再由 dma 将这份数据拷贝到网卡中，最后由网卡发送出去。这里我们可以看到，一次写操作数据要拷贝两次才能通过网卡发送出去，而用户进程的读操作则是将整个流程反过来，数据同样会拷贝两次才能让应用程序读取到数据。\n\n应用进程的一次完整的读写操作，都需要在用户空间与内核空间中来回拷贝，并且每一次拷贝，都需要 cpu 进行一次上下文切换（由用户进程切换到系统内核，或由系统内核切换到用户进程），这样很浪费 cpu 和性能。\n\n所谓的零拷贝，就是取消用户空间与内核空间之间的数据拷贝操作，应用进程每一次的读写操作，可以通过一种方式，直接将数据写入内核或从内核中读取数据，再通过 dma 将内核中的数据拷贝到网卡，或将网卡中的数据 copy 到内核。\n\n\n\nnetty 的零拷贝偏向于用户空间中对数据操作的优化，这对处理 tcp 传输中的拆包粘包问题有着重要的意义，对应用程序处理请求数据与返回数据也有重要的意义。\n\nnetty 框架中很多内部的 channelhandler 实现类，都是通过 compositebytebuf、slice、wrap 操作来处理 tcp 传输中的拆包与粘包问题的。\n\nnetty 的 bytebuffer 可以采用 direct buffers，使用堆外直接内存进行 socketd 的读写 操作，最终的效果与我刚才讲解的虚拟内存所实现的效果是一样的。\n\nnetty 还提供 fileregion 中包装 nio 的 filechannel.transferto() 方法实现了零拷 贝，这与 linux 中的 sendfile 方式在原理上也是一样的。\n\n\n# 5. rpc 架构模型\n\n了解前面的知识点（序列化、动态代理、通信），其实已经可以实现一个点对点的 rpc 架构了。\n\n采用微内核架构的 rpc 架构模型：\n\n\n\n在 rpc 框架里面，怎么支持插件化架构的呢？我们可以将每个功能点抽象成一个接 口，将这个接口作为插件的契约，然后把这个功能的接口与功能的实现分离，并提供接口的默认实现。在 java 里面，jdk 有自带的 spi（service provider interface）服务发现机 制，它可以动态地为某个接口寻找服务实现。使用 spi 机制需要在 classpath 下的 meta-inf/services 目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体实现类。\n\n但在实际项目中，我们其实很少使用到 jdk 自带的 spi 机制，首先它不能按需加载， serviceloader 加载某个接口实现类的时候，会遍历全部获取，也就是接口的实现类得全部载入并实例化一遍，会造成不必要的浪费。另外就是扩展如果依赖其它的扩展，那就做不到自动注入和装配，这就很难和其他框架集成，比如扩展里面依赖了一个 spring bean，原生的 java spi 就不支持。\n\n\n# 6. 服务注册和发现\n\nrpc 框架必须要有服务注册和发现机制，这样，集群中的节点才能知道通信方的请求地址。\n\n * 服务注册：在服务提供方启动的时候，将对外暴露的接口注册到注册中心之中，注册中心将这个服务节点的 ip 和接口保存下来。\n * 服务订阅：在服务调用方启动的时候，去注册中心查找并订阅服务提供方的 ip，然后缓存到本地，并用于后续的远程调用。\n\n\n# 6.1. 基于 zookeeper 的服务发现\n\n使用 zookeeper 作为服务注册中心，是 java 分布式系统的经典方案。\n\n搭建一个 zookeeper 集群作为注册中心集群，服务注册的时候只需要服务节点向 zookeeper 节点写入注册信息即可，利用 zookeeper 的 watcher 机制完成服务订阅与服务下发功能\n\n\n\n通常我们可以使用 zookeeper、etcd 或者分布式缓存（如 hazelcast）来解决事件通知问题，但当集群达到一定规模之后，依赖的 zookeeper 集群、etcd 集群可能就不稳定了，无法满足我们的需求。\n\n在超大规模的服务集群下，注册中心所面临的挑战就是超大批量服务节点同时上下线，注册中心集群接受到大量服务变更请求，集群间各节点间需要同步大量服务节点数据，最终导致如下问题：\n\n * 注册中心负载过高；\n * 各节点数据不一致；\n * 服务下发不及时或下发错误的服务节点列表。\n\nrpc 框架依赖的注册中心的服务数据的一致性其实并不需要满足 cp，只要满足 ap 即可。\n\n\n# 6.2. 基于消息总线的最终一致性的注册中心\n\nzookeeper 的一大特点就是强一致性，zookeeper 集群的每个节点的数据每次发生更新操作，都会通知其它 zookeeper 节点同时执行更新。它要求保证每个节点的数据能够实时的完全一致，这也就直接导致了 zookeeper 集群性能上的下降。\n\n而 rpc 框架的服务发现，在服务节点刚上线时，服务调用方是可以容忍在一段时间之后 （比如几秒钟之后）发现这个新上线的节点的。毕竟服务节点刚上线之后的几秒内，甚至更长的一段时间内没有接收到请求流量，对整个服务集群是没有什么影响的，所以我们可以牺牲掉 cp（强制一致性），而选择 ap（最终一致），来换取整个注册中心集群的性能和稳定性。\n\n\n\n\n# 7. 健康检查\n\n使用频率适中的心跳去检测目标机器的健康状态。\n\n * 健康状态：建立连接成功，并且心跳探活也一直成功；\n * 亚健康状态：建立连接成功，但是心跳请求连续失败；\n * 死亡状态：建立连接失败。\n\n可以使用可用率来作为健康状态的量化标准：\n\n可用率 = 一个时间窗口内接口调用成功次数 / 总调用次数\n\n\n当可用率低于某个比例，就认为这个节点存在问题，把它挪到亚健康列表，这样既考虑了高低频的调用接口，也兼顾了接口响应时间不同的问题。\n\n\n# 8. 路由和负载均衡\n\n对于服务调用方来说，一个接口会有多个服务提供方同时提供服务，所以我们的 rpc 在每次发起请求的时候，都需要从多个服务提供方节点里面选择一个用于发请求的节点。这被称为路由策略。\n\n * ip 路由：最简单的当然是 ip 路由，因为服务上线后，会暴露服务到注册中心，将自身 ip、端口等元信息告知注册中心。这样消费方就可以在向注册中心请求服务地址时，感知其存在。\n * 参数路由：但有时，会有一些复杂的场景，如：灰度发布、定点调用，我们并不希望上线的服务被所有消费者感知，为了更加细粒度的控制，可以使用参数路由。通过参数控制通信的路由策略。\n\n除了特殊场景的路由策略以外，对于机器中多个服务方，如何选择调用哪个服务节点，可以应用负载均衡策略。rpc 负载均衡策略一般包括随机、轮询、一致性 hash、最近最少连接等。\n\n\n\n> 负载均衡详情可以参考：负载均衡基本原理\n\n\n# 8.1. 超时重试\n\n超时重试机制是指：当调用端发起的请求失败或超时未收到响应时，rpc 框架自身可以进行重试，再重新发送请求，用户可以自行设置是否开启重试以及重试的次数。\n\n\n\n\n# 8.2. 限流、降级、熔断\n\n限流方案：redis + lua、sentinel\n\n熔断方案：hystrix\n\n\n# 8.3. 优雅启动关闭\n\n如何避免服务停机带来的业务损失：\n\n\n\n如何避免流量打到没有启动完成的节点：\n\n\n\n\n# 9. 容错处理\n\n\n# 9.1. 异常重试\n\n就是当调用端发起的请求失败时，rpc 框架自身可以进行重试，再重新发送请求，用户可以自行设置是否开启重试以及重试的次数。\n\n当然，不是所有的异常都要触发重试，只有符合重试条件的异常才能触发重试，比如网络超时异常、网络连接异常等等（这个需要 rpc 去判定）。\n\n> 注意：有时网络可能发生抖动，导致请求超时，这时如果 rpc 触发超时重试，会触发业务逻辑重复执行，如果接口没有幂等性设计，就可能引发问题。如：重发写表。\n\n\n# 9.2. 重试超时时间\n\n连续的异常重试可能会出现一种不可靠的情况，那就是连续的异常重试并且每次处理的请求时间比较长，最终会导致请求处理的时间过长，超出用户设置的超时时间。\n\n解决这个问题最直接的方式就是，在每次重试后都重置一下请求的超时时间。\n\n当调用端发起 rpc 请求时，如果发送请求发生异常并触发了异常重试，我们可以先判定下这个请求是否已经超时，如果已经超时了就直接返回超时异常，否则就先重置下这个请求的超时时间，之后再发起重试。\n\n在所有发起重试、负载均衡选择节点的时候，去掉重试之前出现过问题的那个节点，以保证重试的成功率。\n\n\n# 9.3. 业务异常\n\nrpc 框架是不会知道哪些业务异常能够去进行异常重试的，我们可以加个重试异常的白名 单，用户可以将允许重试的异常加入到这个白名单中。当调用端发起调用，并且配置了异常重试策略，捕获到异常之后，我们就可以采用这样的异常处理策略。如果这个异常是 rpc 框架允许重试的异常，或者这个异常类型存在于可重试异常的白名单中，我们就允许对这个请求进行重试。\n\n----------------------------------------\n\n综上，一个可靠的 rpc 容错处理机制如下：\n\n\n\n\n# 10. 优雅上线下线\n\n如何避免服务停机带来的业务损失？\n\n\n# 10.1. 优雅下线\n\n当服务提供方正在关闭，如果这之后还收到了新的业务请求，服务提供方直接返回一个特定的异常给调用方（比如 shutdownexception）。这个异常就是告诉调用方“我已经收到这个请求了，但是我正在关闭，并没有处理这个请求”，然后调用方收到这个异常响应后，rpc 框架把这个节点从健康列表挪出，并把请求自动重试到其他节点，因为这个请求是没有被服务提供方处理过，所以可以安全地重试到其他节点，这样就可以实现对业务无损。\n\n在 java 语言里面，对应的是 runtime.addshutdownhook 方法，可以注册关闭的钩子。在 rpc 启动的时候，我们提前注册关闭钩子，并在里面添加了两个处理程序，一个负责开启关闭标识，一个负责安全关闭服务对象，服务对象在关闭的时候会通知调用方下线节点。同时需要在我们调用链里面加上挡板处理器，当新的请求来的时候，会判断关闭标识，如果正在关闭，则抛出特定异常。\n\n\n\n\n# 10.2. 优雅上线\n\n# 10.2.1. 启动预热\n\n启动预热，就是让刚启动的服务提供方应用不承担全部的流量，而是让它被调用的次数随着时间的移动慢慢增加，最终让流量缓和地增加到跟已经运行一段时间后的水平一样。\n\n首先，在真实环境中机器都会默认开启 ntp 时间同步功能，来保证所有机器时间的一致性。\n\n调用方通过服务发现，除了可以拿到 ip 列表，还可以拿到对应的启动时间。我们需要把这个时间作用在负载均衡上。\n\n\n\n通过这个小逻辑的改动，我们就可以保证当服务提供方运行时长小于预热时间时，对服务提供方进行降权，减少被负载均衡选择的概率，避免让应用在启动之初就处于高负载状态，从而实现服务提供方在启动后有一个预热的过程。\n\n# 10.2.2. 延迟暴露\n\n服务提供方应用在没有启动完成的时候，调用方的请求就过来了，而调用方请求过来的原因是，服务提供方应用在启动过程中把解析到的 rpc 服务注册到了注册中心，这就导致在后续加载没有完成的情况下服务提供方的地址就被服务调用方感知到了。\n\n为了解决这个问题，需要在应用启动加载、解析 bean 的时候，如果遇到了 rpc 服务的 bean，只先把这个 bean 注册到 spring-beanfactory 里面去，而并不把这个 bean 对应的接口注册到注册中心，只有等应用启动完成后，才把接口注册到注册中心用于服务发现，从而实现让服务调用方延迟获取到服务提供方地址。\n\n具体如何实现呢？\n\n我们可以在服务提供方应用启动后，接口注册到注册中心前，预留一个 hook 过程，让用户可以实现可扩展的 hook 逻辑。用户可以在 hook 里面模拟调用逻辑，从而使 jvm 指令能够预热起来，并且用户也可以在 hook 里面事先预加载一些资源，只有等所有的资源都加载完成后，最后才把接口注册到注册中心。\n\n\n\n\n# 11. 限流熔断\n\n限流算法有很多，比如最简单的计数器，还有可以做到平滑限流的滑动窗口、漏斗算法以及令牌桶算法等等。其中令牌桶算法最为常用。\n\n服务端主要是通过限流来进行自我保护，我们在实现限流时要考虑到应用和 ip 级别，方便我们在服务治理的时候，对部分访问量特别大的应用进行合理的限流。\n\n服务端的限流阈值配置都是作用于单机的，而在有些场景下，例如对整个服务设置限流阈值，服务进行扩容时， 限流的配置并不方便，我们可以在注册中心或配置中心下发限流阈值配置的时候，将总服务节点数也下发给服务节点，让 rpc 框架自己去计算限流阈值。\n\n我们还可以让 rpc 框架的限流模块依赖一个专门的限流服务，对服务设置限流阈值进行精准地控制，但是这种方式依赖了限流服务，相比单机的限流方式，在性能和耗时上有劣势。\n\n调用端可以通过熔断机制进行自我保护，防止调用下游服务出现异常，或者耗时过长影响调 用端的业务逻辑，rpc 框架可以在动态代理的逻辑中去整合熔断器，实现 rpc 框架的熔断 功能。\n\n\n# 12. 业务分组\n\n\n\n在 rpc 里面我们可以通过分组的方式人为地给不同的调用方划分出不同的小集群，从而实现调用方流量隔离的效果，保障我们的核心业务不受非核心业务的干扰。但我们在考虑问题的时候，不能顾此失彼，不能因为新加一个的功能而影响到原有系统的稳定性。\n\n其实我们不仅可以通过分组把服务提供方划分成不同规模的小集群，我们还可以利用分组完成一个接口多种实现的功能。正常情况下，为了方便我们自己管理服务，我一般都会建议每个接口完成的功能尽量保证唯一。但在有些特殊场景下，两个接口也会完全一样，只是具体实现上有那么一点不同，那么我们就可以在服务提供方应用里面同时暴露两个相同接口，但只是接口分组不一样罢了。\n\n\n# 12.1. 动态分组\n\n分组可以帮助服务提供方实现调用方的隔离。但是因为调用方流量并不是一成不变的，而且还可能会因为突发事件导致某个分组的流量溢出，而在整个大集群还有富余能力的时候，又因为分组隔离不能为出问题的集群提供帮助。\n\n为了解决这种突发流量的问题，我们提供了一种更高效的方案，可以实现分组的快速伸缩。事实上我们还可以利用动态分组解决分组后给每个分组预留机器冗余的问题，我们没有必要把所有冗余的机器都分配到分组里面，我们可以把这些预留的机器做成一个共享的池子，从而减少整体预留的实例数量。\n\n\n# 13. 链路跟踪\n\n分布式链路跟踪就是将一次分布式请求还原为一个完整的调用链路，我们可以在整个调用链路中跟踪到这一次分布式请求的每一个环节的调用情况，比如调用是否成功，返回什么异常，调用的哪个服务节点以及请求耗时等等。\n\ntrace 就是代表整个链路，每次分布式都会产生一个 trace，每个 trace 都有它的唯一标识即 traceid，在分布式链路跟踪系统中，就是通过 traceid 来区分每个 trace 的。 span 就是代表了整个链路中的一段链路，也就是说 trace 是由多个 span 组成的。在一个 trace 下，每个 span 也都有它的唯一标识 spanid，而 span 是存在父子关系的。还是以讲过的例子为例子，在 a->b->c->d 的情况下，在整个调用链中，正常情况下会产生 3 个 span，分别是 span1（a->b）、span2（b->c）、span3（c->d），这时 span3 的父 span 就是 span2，而 span2 的父 span 就是 span1。\n\nrpc 在整合分布式链路跟踪需要做的最核心的两件事就是“埋点”和“传递”。\n\n我们前面说是因为各子应用、子服务间复杂的依赖关系，所以通过日志难定位问题。那我们就想办法通过日志定位到是哪个子应用的子服务出现问题就行了。\n\n其实，在 rpc 框架打印的异常信息中，是包括定位异常所需要的异常信息的，比如是哪类异常引起的问题（如序列化问题或网络超时问题），是调用端还是服务端出现的异常，调用端与服务端的 ip 是什么，以及服务接口与服务分组都是什么等等。具体如下图所示：\n\n\n\n\n# 14. 泛化调用\n\n在一些特定场景下，需要在没有接口的情况下进行 rpc 调用。例如：\n\n场景一：搭建一个统一的测试平台，可以让各个业务方在测试平台中通过输入接口、分组名、方法名以及参数值，在线测试自己发布的 rpc 服务。\n\n\n\n场景二：搭建一个轻量级的服务网关，可以让各个业务方用 http 的方式，通过服务网关调用其它服务。\n\n\n\n为了解决这些场景的问题，可以使用泛化调用。\n\n就是 rpc 框架提供统一的泛化调用接口（genericservice），调用端在创建 genericservice 代理时指定真正需要调用的接口的接口名以及分组名，通过调用 genericservice 代理的 $invoke 方法将服务端所需要的所有信息，包括接口名、业务分组名、方法名以及参数信息等封装成请求消息，发送给服务端，实现在没有接口的情况下进行 rpc 调用的功能。\n\nclass genericservice {\nobject $invoke(string methodname, string[] paramtypes, object[] params);\ncompletablefuture<object> $asyncinvoke(string methodname, string[] paramtypes\n}\n\n\n而通过泛化调用的方式发起调用，由于调用端没有服务端提供方提供的接口 api，不能正常地进行序列化与反序列化，我们可以为泛化调用提供专属的序列化插件，来解决实际问题。\n\n\n# 15. 时钟轮\n\n时钟轮这个机制很好地解决了定时任务中，因每个任务都创建一个线程，导致的创建过多线程的问题，以及一个线程扫描所有的定时任务，让 cpu 做了很多额外的轮询遍历操作而浪费 cpu 的问题。\n\n时钟轮的实现机制就是模拟现实生活中的时钟，将每个定时任务放到对应的时间槽位上，这样可以减少扫描任务时对其它时间槽位定时任务的额外遍历操作。\n\n在时间轮的使用中，有些问题需要你额外注意：\n\n时间槽位的单位时间越短，时间轮触发任务的时间就越精确。例如时间槽位的单位时间是 10 毫秒，那么执行定时任务的时间误差就在 10 毫秒内，如果是 100 毫秒，那么误差就在 100 毫秒内。\n\n时间轮的槽位越多，那么一个任务被重复扫描的概率就越小，因为只有在多层时钟轮中的任务才会被重复扫描。比如一个时间轮的槽位有 1000 个，一个槽位的单位时间是 10 毫秒，那么下一层时间轮的一个槽位的单位时间就是 10 秒，超过 10 秒的定时任务会被放到下一层时间轮中，也就是只有超过 10 秒的定时任务会被扫描遍历两次，但如果槽位是 10 个，那么超过 100 毫秒的任务，就会被扫描遍历两次。\n\n结合这些特点，我们就可以视具体的业务场景而定，对时钟轮的周期和时间槽数进行设置。\n\n在 rpc 框架中，只要涉及到定时任务，我们都可以应用时钟轮，比较典型的就是调用端的超时处理、调用端与服务端的启动超时以及定时心跳等等。\n\n\n# 16. 流量回放\n\n所谓的流量就是某个时间段内的所有请求，我们通过某种手段把发送到 a 应用的所有请求录制下来，然后把这些请求统一转发到 b 应用，让 b 应用接收到的请求参数跟 a 应用保持一致，从而实现 a 接收到的请求在 b 应用里面重新请求了一遍。整个过程称之为“流量回放”。\n\n流量回放可以做什么？\n\n为了保障应用升级后，我们的业务行为还能保持和升级前一样，我们在大多数情况下都是依靠已有的 testcase 去验证，但这种方式在一定程度上并不是完全可靠的。最可靠的方式就是引入线上 case 去验证改造后的应用，把线上的真实流量在改造后的应用里面进行回放，这样不仅节省整个上线时间，还能弥补手动维护 case 存在的缺陷。\n\n应用引入了 rpc 后，所有的请求流量都会被 rpc 接管，所以我们可以很自然地在 rpc 里面支持流量回放功能。虽然这个功能本身并不是 rpc 的核心功能，但对于使用 rpc 的人来说，他们有了这个功能之后，就可以更放心地升级自己的应用了。\n\n\n# 17. rpc 高级\n\n\n# 17.1. rpc 性能\n\n如何提升单机吞吐量？\n\n大多数情况下，影响到 rpc 调用的吞吐量的原因也就是业务逻辑处理慢了，cpu 大部分时间都在等待资源。\n\n为了解决等待的耗时，可以使用异步。异步可以使用 future 或 callback 方式，future 最为简单。\n\n\n\n另外，我们可以通过对 completablefuture 的支持，实现 rpc 调用在调用端与服务端之间的完全异步，同时提升两端的单机吞吐量。\n\n\n# 17.2. rpc 安全\n\n虽然 rpc 经常用于解决内网应用之间的调用，内网环境相对公网也没有那么恶劣，但我们也有必要去建立一套可控的安全体系，去防止一些错误行为。对于 rpc 来说，我们所关心的安全问题不会有公网应用那么复杂，我们只要保证让服务调用方能拿到真实的服务提供方 ip 地址集合，且服务提供方可以管控调用自己的应用就够了。\n\n服务提供方应用里面放一个用于 hmac 签名的私钥，在授权平台上用这个私钥为申请调用的调用方应用进行签名，这个签名生成的串就变成了调用方唯一的身份。服务提供方在收到调用方的授权请求之后，我们只要需要验证下这个签名跟调用方应用信息是否对应得上就行了，这样集中式授权的瓶颈也就不存在了。\n\n\n# 18. 参考资料\n\n * 《rpc 实战与核心原理》",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"kong",frontmatter:{title:"kong",categories:["分布式","分布式应用","微服务"],tags:["分布式","分布式应用","微服务"],abbrlink:"a64091d1",date:"2018-10-11T13:08:18.000Z",permalink:"/pages/3c87eb/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/04.%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1/22.Kong.html",relativePath:"02.分布式/04.分布式应用/01.微服务/22.Kong.md",key:"v-27b2649e",path:"/pages/3c87eb/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:90},{level:3,title:"为什么选择 Kong",slug:"为什么选择-kong",normalizedTitle:"为什么选择 kong",charIndex:97},{level:2,title:"Quickstart",slug:"quickstart",normalizedTitle:"quickstart",charIndex:120},{level:3,title:"安装配置",slug:"安装配置",normalizedTitle:"安装配置",charIndex:135},{level:3,title:"使用 Kong",slug:"使用-kong",normalizedTitle:"使用 kong",charIndex:794},{level:3,title:"配置服务",slug:"配置服务",normalizedTitle:"配置服务",charIndex:955},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:2227}],headersStr:"简介 为什么选择 Kong Quickstart 安装配置 使用 Kong 配置服务 参考资料",content:'# Kong\n\n> Kong 是一个云原生、快速、可扩展和分布式的微服务抽象层（也称为 API 网关，API 中间件）。\n> \n> 关键词：nginx,api网关,微服务\n\n\n# 简介\n\n\n# 为什么选择 Kong\n\n\n\n\n\n\n\n\n\n\n# Quickstart\n\n\n# 安装配置\n\n> 本文仅以 Centos7 为例。\n\nKong 支持在多种环境下安装。\n\n官方安装说明：https://konghq.com/install/\n\n\n\n\n\n\n\n\n\n以下为 Centos7 安装步骤：\n\n（1）下载 rpm 安装包到本地\n\n（2）安装 Kong\n\n$ sudo yum install epel-release\n$ sudo yum install kong-community-edition-0.14.1.*.noarch.rpm --nogpgcheck\n\n\n（3）准备数据库\n\nKong 需要存储数据，支持两种数据库：PostgreSQL 9.5+ 和 Cassandra 3.x.x\n\n本人选择了 PostgreSQL，安装方法可以参考 —— PostgreSQL 安装\n\n安装 PostgreSQL 后，配置一个数据库和数据库用户：\n\nCREATE USER kong;\nCREATE DATABASE kong OWNER kong;\n\n\n（4）执行 Kong 迁移\n\n执行以下命令：\n\n$ kong migrations up [-c /path/to/kong.conf]\n\n\n注意：永远不应同时运行迁移；一个 Kong 节点应该只执行一次迁移。\n\n（5）启动 Kong\n\n$ kong start [-c /path/to/kong.conf]\n\n\n（6）测试启动成功\n\n$ curl -i http://localhost:8001/\n\n\n至此，安装配置完成。\n\n\n# 使用 Kong\n\n * 启动（必须确保执行过 kong migrations up） - kong start [-c /path/to/kong.conf]\n   * -c /path/to/kong.conf 参数用来指定用户的配置\n * 停止 - kong stop\n * 重启 - kong reload\n\n\n# 配置服务\n\n（1）添加第一个服务\n\n$ curl -i -X POST \\\n  --url http://localhost:8001/services/ \\\n  --data \'name=example-service\' \\\n  --data \'url=http://mockbin.org\'\n\n\n应答类似下面形式：\n\nHTTP/1.1 201 Created\nContent-Type: application/json\nConnection: keep-alive\n\n{\n   "host":"mockbin.org",\n   "created_at":1519130509,\n   "connect_timeout":60000,\n   "id":"92956672-f5ea-4e9a-b096-667bf55bc40c",\n   "protocol":"http",\n   "name":"example-service",\n   "read_timeout":60000,\n   "port":80,\n   "path":null,\n   "updated_at":1519130509,\n   "retries":5,\n   "write_timeout":60000\n}\n\n\n（2）为服务添加路由\n\n$ curl -i -X POST \\\n  --url http://localhost:8001/services/example-service/routes \\\n  --data \'hosts[]=example.com\'\n\n\n应答类似下面形式：\n\nHTTP/1.1 201 Created\nContent-Type: application/json\nConnection: keep-alive\n\n{\n   "created_at":1519131139,\n   "strip_path":true,\n   "hosts":[\n      "example.com"\n   ],\n   "preserve_host":false,\n   "regex_priority":0,\n   "updated_at":1519131139,\n   "paths":null,\n   "service":{\n      "id":"79d7ee6e-9fc7-4b95-aa3b-61d2e17e7516"\n   },\n   "methods":null,\n   "protocols":[\n      "http",\n      "https"\n   ],\n   "id":"f9ce2ed7-c06e-4e16-bd5d-3a82daef3f9d"\n}\n\n\n此时，Kong 已经关注这个服务，并准备代理请求。\n\n（3）通过 Kong 转发请求\n\n$ curl -i -X GET \\\n  --url http://localhost:8000/ \\\n  --header \'Host: example.com\'\n\n\n\n# 参考资料\n\nhttps://www.itcodemonkey.com/article/5980.html',normalizedContent:'# kong\n\n> kong 是一个云原生、快速、可扩展和分布式的微服务抽象层（也称为 api 网关，api 中间件）。\n> \n> 关键词：nginx,api网关,微服务\n\n\n# 简介\n\n\n# 为什么选择 kong\n\n\n\n\n\n\n\n\n\n\n# quickstart\n\n\n# 安装配置\n\n> 本文仅以 centos7 为例。\n\nkong 支持在多种环境下安装。\n\n官方安装说明：https://konghq.com/install/\n\n\n\n\n\n\n\n\n\n以下为 centos7 安装步骤：\n\n（1）下载 rpm 安装包到本地\n\n（2）安装 kong\n\n$ sudo yum install epel-release\n$ sudo yum install kong-community-edition-0.14.1.*.noarch.rpm --nogpgcheck\n\n\n（3）准备数据库\n\nkong 需要存储数据，支持两种数据库：postgresql 9.5+ 和 cassandra 3.x.x\n\n本人选择了 postgresql，安装方法可以参考 —— postgresql 安装\n\n安装 postgresql 后，配置一个数据库和数据库用户：\n\ncreate user kong;\ncreate database kong owner kong;\n\n\n（4）执行 kong 迁移\n\n执行以下命令：\n\n$ kong migrations up [-c /path/to/kong.conf]\n\n\n注意：永远不应同时运行迁移；一个 kong 节点应该只执行一次迁移。\n\n（5）启动 kong\n\n$ kong start [-c /path/to/kong.conf]\n\n\n（6）测试启动成功\n\n$ curl -i http://localhost:8001/\n\n\n至此，安装配置完成。\n\n\n# 使用 kong\n\n * 启动（必须确保执行过 kong migrations up） - kong start [-c /path/to/kong.conf]\n   * -c /path/to/kong.conf 参数用来指定用户的配置\n * 停止 - kong stop\n * 重启 - kong reload\n\n\n# 配置服务\n\n（1）添加第一个服务\n\n$ curl -i -x post \\\n  --url http://localhost:8001/services/ \\\n  --data \'name=example-service\' \\\n  --data \'url=http://mockbin.org\'\n\n\n应答类似下面形式：\n\nhttp/1.1 201 created\ncontent-type: application/json\nconnection: keep-alive\n\n{\n   "host":"mockbin.org",\n   "created_at":1519130509,\n   "connect_timeout":60000,\n   "id":"92956672-f5ea-4e9a-b096-667bf55bc40c",\n   "protocol":"http",\n   "name":"example-service",\n   "read_timeout":60000,\n   "port":80,\n   "path":null,\n   "updated_at":1519130509,\n   "retries":5,\n   "write_timeout":60000\n}\n\n\n（2）为服务添加路由\n\n$ curl -i -x post \\\n  --url http://localhost:8001/services/example-service/routes \\\n  --data \'hosts[]=example.com\'\n\n\n应答类似下面形式：\n\nhttp/1.1 201 created\ncontent-type: application/json\nconnection: keep-alive\n\n{\n   "created_at":1519131139,\n   "strip_path":true,\n   "hosts":[\n      "example.com"\n   ],\n   "preserve_host":false,\n   "regex_priority":0,\n   "updated_at":1519131139,\n   "paths":null,\n   "service":{\n      "id":"79d7ee6e-9fc7-4b95-aa3b-61d2e17e7516"\n   },\n   "methods":null,\n   "protocols":[\n      "http",\n      "https"\n   ],\n   "id":"f9ce2ed7-c06e-4e16-bd5d-3a82daef3f9d"\n}\n\n\n此时，kong 已经关注这个服务，并准备代理请求。\n\n（3）通过 kong 转发请求\n\n$ curl -i -x get \\\n  --url http://localhost:8000/ \\\n  --header \'host: example.com\'\n\n\n\n# 参考资料\n\nhttps://www.itcodemonkey.com/article/5980.html',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"微服务",frontmatter:{title:"微服务",categories:["分布式","分布式应用","微服务"],tags:["分布式","分布式应用","微服务"],abbrlink:"460c1130",date:"2021-06-02T11:22:02.000Z",permalink:"/pages/7e2fd1/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/04.%E5%88%86%E5%B8%83%E5%BC%8F%E5%BA%94%E7%94%A8/01.%E5%BE%AE%E6%9C%8D%E5%8A%A1/",relativePath:"02.分布式/04.分布式应用/01.微服务/README.md",key:"v-55732b48",path:"/pages/7e2fd1/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:10},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:169},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:472}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# 微服务\n\n\n# 📖 内容\n\n * 微服务基本原理 - 关键词：微服务、序列化、动态代理、通信、服务注册发现、健康检查、路由、负载均衡、容错处理、优雅上线下线、限流、熔断、业务分组\n * RPC - 关键词：微服务、序列化、动态代理、通信、服务注册发现、健康检查、路由、负载均衡、容错处理、优雅上线下线、限流、熔断、业务分组\n\n\n# 📚 资料\n\n * 书籍\n   * 《大型网站技术架构：核心原理与案例分析》 - 浅显易懂的将解大型网站架构演进之路；简介了大型系统所面临的挑战以及核心技术点。\n   * 大型网站系统与 Java 中间件实践\n   * 亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统\n   * 企业 IT 架构转型之道：阿里巴巴中台战略思想与架构实战 - 阐述阿里巴巴中台系统发展，更多的是讲解应用场景和能力，没有讲解技术细节。\n   * 逆流而上：阿里巴巴技术成长之路 - 主要以运维的视角阐述系统运维中遇到的困难，定位思路以及解决方法。\n * 教程\n   * system-design-primer\n\n\n# 🚪 传送\n\n◾ 🎯 我的博客 ◾",normalizedContent:"# 微服务\n\n\n# 📖 内容\n\n * 微服务基本原理 - 关键词：微服务、序列化、动态代理、通信、服务注册发现、健康检查、路由、负载均衡、容错处理、优雅上线下线、限流、熔断、业务分组\n * rpc - 关键词：微服务、序列化、动态代理、通信、服务注册发现、健康检查、路由、负载均衡、容错处理、优雅上线下线、限流、熔断、业务分组\n\n\n# 📚 资料\n\n * 书籍\n   * 《大型网站技术架构：核心原理与案例分析》 - 浅显易懂的将解大型网站架构演进之路；简介了大型系统所面临的挑战以及核心技术点。\n   * 大型网站系统与 java 中间件实践\n   * 亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统\n   * 企业 it 架构转型之道：阿里巴巴中台战略思想与架构实战 - 阐述阿里巴巴中台系统发展，更多的是讲解应用场景和能力，没有讲解技术细节。\n   * 逆流而上：阿里巴巴技术成长之路 - 主要以运维的视角阐述系统运维中遇到的困难，定位思路以及解决方法。\n * 教程\n   * system-design-primer\n\n\n# 🚪 传送\n\n◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"分布式",frontmatter:{title:"分布式",categories:["分布式"],tags:["分布式"],abbrlink:"fe3c2cd2",date:"2019-03-08T13:16:53.000Z",permalink:"/pages/3cb60a/"},regularPath:"/02.%E5%88%86%E5%B8%83%E5%BC%8F/",relativePath:"02.分布式/README.md",key:"v-12aaaa7d",path:"/pages/3cb60a/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:70},{level:3,title:"分布式综合",slug:"分布式综合",normalizedTitle:"分布式综合",charIndex:80},{level:3,title:"分布式理论",slug:"分布式理论",normalizedTitle:"分布式理论",charIndex:102},{level:3,title:"分布式关键技术",slug:"分布式关键技术",normalizedTitle:"分布式关键技术",charIndex:232},{level:4,title:"流量调度",slug:"流量调度",normalizedTitle:"流量调度",charIndex:268},{level:4,title:"数据调度",slug:"数据调度",normalizedTitle:"数据调度",charIndex:463},{level:4,title:"资源调度",slug:"资源调度",normalizedTitle:"资源调度",charIndex:700},{level:4,title:"通信",slug:"通信",normalizedTitle:"通信",charIndex:717},{level:4,title:"服务治理",slug:"服务治理",normalizedTitle:"服务治理",charIndex:759},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:970},{level:3,title:"分布式理论",slug:"分布式理论-2",normalizedTitle:"分布式理论",charIndex:102},{level:3,title:"分布式算法",slug:"分布式算法",normalizedTitle:"分布式算法",charIndex:151},{level:3,title:"分布式架构",slug:"分布式架构",normalizedTitle:"分布式架构",charIndex:2016},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:2146}],headersStr:"📖 内容 分布式综合 分布式理论 分布式关键技术 流量调度 数据调度 资源调度 通信 服务治理 📚 资料 分布式理论 分布式算法 分布式架构 🚪 传送",content:"# 分布式\n\n> 大型软件为了应对海量数据、高并发，一般都会被设计为分布式系统。\n> \n> 分布式系统需要解决很多不同领域的问题。\n\n\n# 📖 内容\n\n\n# 分布式综合\n\n * 分布式面试总结\n\n\n# 分布式理论\n\n * 分布式理论 - 关键词：拜占庭将军、CAP、BASE、错误的分布式假设\n * 分布式算法 Paxos - 关键词：共识性算法\n * 分布式算法 Raft - 关键词：共识性算法\n * 分布式算法 Gossip - 关键词：数据传播\n\n\n# 分布式关键技术\n\n * 集群\n * 复制\n * 分区\n * 选主\n\n# 流量调度\n\n * 流量控制 - 关键词：限流、熔断、降级、计数器法、时间窗口法、令牌桶法、漏桶法\n * 负载均衡 - 关键词：轮询、随机、最少连接、源地址哈希、一致性哈希、虚拟 hash 槽\n * 服务路由 - 关键词：路由、条件路由、脚本路由、标签路由\n * 服务网关\n * 分布式会话 - 关键词：粘性 Session、Session 复制共享、基于缓存的 session 共享\n\n# 数据调度\n\n * 数据缓存 - 关键词：进程内缓存、分布式缓存、缓存雪崩、缓存穿透、缓存击穿、缓存更新、缓存预热、缓存降级\n * 读写分离\n * 分库分表 - 关键词：分片、路由、迁移、扩容、双写、聚合\n * 分布式 ID - 关键词：UUID、自增序列、雪花算法、Leaf\n * 分布式事务 - 关键词：2PC、3PC、TCC、本地消息表、MQ 消息、SAGA\n * 分布式锁 - 关键词：数据库、Redis、ZooKeeper、互斥、可重入、死锁、容错、自旋尝试\n\n# 资源调度\n\n * 弹性伸缩\n\n# 通信\n\n * 消息队列 - 关键词：重复消费、消息丢失、消息顺序性、消息积压\n\n# 服务治理\n\n * 服务注册和发现\n * 服务监控\n * 服务链路监控\n * 服务容错\n * 服务编排\n * 服务版本管理\n * 流量调度\n   * 流量控制 - 关键词：限流、熔断、降级、计数器法、时间窗口法、令牌桶法、漏桶法\n   * 负载均衡 - 关键词：轮询、随机、最少连接、源地址哈希、一致性哈希、虚拟 hash 槽\n   * 服务路由 - 关键词：路由、条件路由、脚本路由、标签路由\n   * 服务网关\n\n\n# 📚 资料\n\n\n# 分布式理论\n\n * The Google File System：Google 三大经典论文之一\n * Bigtable: A Distributed Storage System for Structured Data：Google 三大经典论文之一\n * MapReduce: Simplifed Data Processing on Large Clusters：Google 三大经典论文之一\n * 分布式系统原理与范型：书原名 Distributed Systems Principles and Paradigms。经典分布式教程，介绍了分布式系统的七大核心原理，并给出了大量的例子；系统讲述了分布式系统的概念和技术，包括通信、进程、命名、同步化、一致性和复制、容错以及安全等。\n * The fallacies of distributed computing\n * Distributed Systems for fun and profit：全书分为五章，讲述了扩展性、可用性、性能和容错等基础知识，FLP 不可能性和 CAP 定理，探讨了大量的一致性模型；讨论了时间和顺序，及时钟的各种用法。随后，探讨了复制问题，如何防止差异，以及如何接受差异。此外，每章末尾都给出了针对本章内容的扩展阅读资源列表，这些资料是对本书内容的很好补充。\n\n\n# 分布式算法\n\n * Paxos\n   * Part-time Parliament 论文 - Lamport 的 Paxos 论文。这篇论文很权威，但较为晦涩难懂。\n   * Paxos Made Simple 论文\n   * Paxos 算法详解\n   * Neat Algorithms - Paxos\n   * Wiki - Paxos 算法\n   * 一致性算法（Paxos、Raft、Zab）\n   * Raft 作者讲解 Paxos 视频\n   * Paxos 算法讲解视频\n * Raft\n   * Raft 一致性算法论文原文\n   * Raft 一致性算法论文译文\n   * Raft 作者讲解视频\n   * Raft 作者讲解视频对应的 PPT\n   * Raft 算法详解\n   * Raft: Understandable Distributed Consensus - 一个动画教程\n   * The Raft Consensus Algorithm - 一个交互式动画教程\n\n\n# 分布式架构\n\n * An introduction to distributed systems - 这是一份分布式系统的提纲挈领的介绍，几乎涵盖了所有知识点，并辅以简洁并切中要害的说明文字，适合初学者了解知识全貌，快速与现有知识结合，形成知识体系。\n\n\n# 🚪 传送\n\n◾ 🏠 DESIGN 首页 ◾ 🎯 我的博客 ◾",normalizedContent:"# 分布式\n\n> 大型软件为了应对海量数据、高并发，一般都会被设计为分布式系统。\n> \n> 分布式系统需要解决很多不同领域的问题。\n\n\n# 📖 内容\n\n\n# 分布式综合\n\n * 分布式面试总结\n\n\n# 分布式理论\n\n * 分布式理论 - 关键词：拜占庭将军、cap、base、错误的分布式假设\n * 分布式算法 paxos - 关键词：共识性算法\n * 分布式算法 raft - 关键词：共识性算法\n * 分布式算法 gossip - 关键词：数据传播\n\n\n# 分布式关键技术\n\n * 集群\n * 复制\n * 分区\n * 选主\n\n# 流量调度\n\n * 流量控制 - 关键词：限流、熔断、降级、计数器法、时间窗口法、令牌桶法、漏桶法\n * 负载均衡 - 关键词：轮询、随机、最少连接、源地址哈希、一致性哈希、虚拟 hash 槽\n * 服务路由 - 关键词：路由、条件路由、脚本路由、标签路由\n * 服务网关\n * 分布式会话 - 关键词：粘性 session、session 复制共享、基于缓存的 session 共享\n\n# 数据调度\n\n * 数据缓存 - 关键词：进程内缓存、分布式缓存、缓存雪崩、缓存穿透、缓存击穿、缓存更新、缓存预热、缓存降级\n * 读写分离\n * 分库分表 - 关键词：分片、路由、迁移、扩容、双写、聚合\n * 分布式 id - 关键词：uuid、自增序列、雪花算法、leaf\n * 分布式事务 - 关键词：2pc、3pc、tcc、本地消息表、mq 消息、saga\n * 分布式锁 - 关键词：数据库、redis、zookeeper、互斥、可重入、死锁、容错、自旋尝试\n\n# 资源调度\n\n * 弹性伸缩\n\n# 通信\n\n * 消息队列 - 关键词：重复消费、消息丢失、消息顺序性、消息积压\n\n# 服务治理\n\n * 服务注册和发现\n * 服务监控\n * 服务链路监控\n * 服务容错\n * 服务编排\n * 服务版本管理\n * 流量调度\n   * 流量控制 - 关键词：限流、熔断、降级、计数器法、时间窗口法、令牌桶法、漏桶法\n   * 负载均衡 - 关键词：轮询、随机、最少连接、源地址哈希、一致性哈希、虚拟 hash 槽\n   * 服务路由 - 关键词：路由、条件路由、脚本路由、标签路由\n   * 服务网关\n\n\n# 📚 资料\n\n\n# 分布式理论\n\n * the google file system：google 三大经典论文之一\n * bigtable: a distributed storage system for structured data：google 三大经典论文之一\n * mapreduce: simplifed data processing on large clusters：google 三大经典论文之一\n * 分布式系统原理与范型：书原名 distributed systems principles and paradigms。经典分布式教程，介绍了分布式系统的七大核心原理，并给出了大量的例子；系统讲述了分布式系统的概念和技术，包括通信、进程、命名、同步化、一致性和复制、容错以及安全等。\n * the fallacies of distributed computing\n * distributed systems for fun and profit：全书分为五章，讲述了扩展性、可用性、性能和容错等基础知识，flp 不可能性和 cap 定理，探讨了大量的一致性模型；讨论了时间和顺序，及时钟的各种用法。随后，探讨了复制问题，如何防止差异，以及如何接受差异。此外，每章末尾都给出了针对本章内容的扩展阅读资源列表，这些资料是对本书内容的很好补充。\n\n\n# 分布式算法\n\n * paxos\n   * part-time parliament 论文 - lamport 的 paxos 论文。这篇论文很权威，但较为晦涩难懂。\n   * paxos made simple 论文\n   * paxos 算法详解\n   * neat algorithms - paxos\n   * wiki - paxos 算法\n   * 一致性算法（paxos、raft、zab）\n   * raft 作者讲解 paxos 视频\n   * paxos 算法讲解视频\n * raft\n   * raft 一致性算法论文原文\n   * raft 一致性算法论文译文\n   * raft 作者讲解视频\n   * raft 作者讲解视频对应的 ppt\n   * raft 算法详解\n   * raft: understandable distributed consensus - 一个动画教程\n   * the raft consensus algorithm - 一个交互式动画教程\n\n\n# 分布式架构\n\n * an introduction to distributed systems - 这是一份分布式系统的提纲挈领的介绍，几乎涵盖了所有知识点，并辅以简洁并切中要害的说明文字，适合初学者了解知识全貌，快速与现有知识结合，形成知识体系。\n\n\n# 🚪 传送\n\n◾ 🏠 design 首页 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"UML 快速入门",frontmatter:{title:"UML 快速入门",date:"2019-03-06T00:00:00.000Z",categories:["设计","UML"],tags:["设计","UML"],permalink:"/pages/eae6a0/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.UML/01.UML%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.html",relativePath:"03.设计/01.UML/01.UML快速入门.md",key:"v-6dbfe670",path:"/pages/eae6a0/",headers:[{level:2,title:"UML 简介",slug:"uml-简介",normalizedTitle:"uml 简介",charIndex:15},{level:3,title:"UML 图类型",slug:"uml-图类型",normalizedTitle:"uml 图类型",charIndex:26},{level:4,title:"结构式建模图",slug:"结构式建模图",normalizedTitle:"结构式建模图",charIndex:54},{level:4,title:"行为式建模图",slug:"行为式建模图",normalizedTitle:"行为式建模图",charIndex:227},{level:3,title:"UML 概念",slug:"uml-概念",normalizedTitle:"uml 概念",charIndex:410},{level:2,title:"UML 工具",slug:"uml-工具",normalizedTitle:"uml 工具",charIndex:680},{level:3,title:"亿图",slug:"亿图",normalizedTitle:"亿图",charIndex:742},{level:3,title:"Visio",slug:"visio",normalizedTitle:"visio",charIndex:816},{level:3,title:"StarUML",slug:"staruml",normalizedTitle:"staruml",charIndex:868},{level:3,title:"Astah",slug:"astah",normalizedTitle:"astah",charIndex:920},{level:3,title:"ArgoUML",slug:"argouml",normalizedTitle:"argouml",charIndex:965},{level:3,title:"ProcessOn",slug:"processon",normalizedTitle:"processon",charIndex:1006},{level:3,title:"drawio",slug:"drawio",normalizedTitle:"drawio",charIndex:1058},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:1107}],headersStr:"UML 简介 UML 图类型 结构式建模图 行为式建模图 UML 概念 UML 工具 亿图 Visio StarUML Astah ArgoUML ProcessOn drawio 参考资料",content:"# UML 快速入门\n\n\n# UML 简介\n\n\n# UML 图类型\n\nUML 图类型如下图所示：\n\n\n\n# 结构式建模图\n\n> 结构式建模图（Structure diagrams）强调的是系统式的建模。结构图定义了一个模型的静态架构。它们通常被用来对那些构成模型的‘要素'建模，诸如：类，对象，接口和物理组件。另外，它们也被用来对元素间关联和依赖关系进行建模。\n\n * 类图\n * 对象图\n * 包图\n * 组件图\n * 部署图\n * 复合结构图\n\n# 行为式建模图\n\n> 行为式建模图（Behavior diagrams）强调系统模型中触发的事。行为图用来记录在一个模型内部，随时间的变化，模型执行的交互变化和瞬间的状态；并跟踪系统在真实环境下如何表现，以及观察系统对一个操作或事件的反应，以及它的结果。\n\n * 活动图\n * 状态图\n * 用例图\n * 通信图\n * 交互概述图\n * 时序图\n * 时间图\n\n\n# UML 概念\n\nUML 从来源中使用相当多的概念。我们将之定义于统一建模语言术语汇表。下面仅列代表性的概念。\n\n * 对于结构而言 - 执行者，属性，类，元件，接口，对象，包。\n * 对于行为而言 - 活动（UML），事件（UML），消息（UML），方法（UML），操作（UML），状态（UML），用例（UML）。\n * 对于关系而言 - 聚合，关联，组合，相依，广义化（or 继承）。\n * 其他概念\n   * 构造型—这规范符号应用到的模型\n   * 多重性—多重性标记法与资料库建模基数对应，例如：1, 0..1, 1..*\n\n\n# UML 工具\n\nUML 工具非常多，到底哪种工具好，真的是仁者见仁智者见智。这里列举一些我接触过的 UML 工具：\n\n\n# 亿图\n\n> 国内开发的、收费的绘图工具。图形模板、素材非常全面，样式也很精美，可以导出为 word、pdf、图片。\n> \n> 亿图官网\n\n\n\n\n# Visio\n\n> Office 的绘图工具，特点是简单、清晰。\n> \n> Visio 官网\n\n\n\n\n# StarUML\n\n> 样式精美，功能全面的 UML 工具。\n> \n> StarUML 官网\n\n\n\n\n# Astah\n\n> 样式不错，功能全面的绘图工具。\n> \n> Astah 官网\n\n\n\n\n# ArgoUML\n\n> UML 工具。\n> \n> ArgoUML 官网\n\n\n\n\n# ProcessOn\n\n> 在线绘图工具，特点是简洁、清晰。\n> \n> ProcessOn 官网\n\n\n# drawio\n\n> 开源的在线绘图工具，特点是简洁、清晰。\n> \n> drawio 官网\n\n\n# 参考资料\n\n * Wiki-UML\n * Sparx UML 教程\n * OMG UML\n * UML Tutorial\n * W3Cschool UML 教程\n * UML 学习入门就这一篇文章\n * http://www.cnblogs.com/ywqu/category/223486.html",normalizedContent:"# uml 快速入门\n\n\n# uml 简介\n\n\n# uml 图类型\n\numl 图类型如下图所示：\n\n\n\n# 结构式建模图\n\n> 结构式建模图（structure diagrams）强调的是系统式的建模。结构图定义了一个模型的静态架构。它们通常被用来对那些构成模型的‘要素'建模，诸如：类，对象，接口和物理组件。另外，它们也被用来对元素间关联和依赖关系进行建模。\n\n * 类图\n * 对象图\n * 包图\n * 组件图\n * 部署图\n * 复合结构图\n\n# 行为式建模图\n\n> 行为式建模图（behavior diagrams）强调系统模型中触发的事。行为图用来记录在一个模型内部，随时间的变化，模型执行的交互变化和瞬间的状态；并跟踪系统在真实环境下如何表现，以及观察系统对一个操作或事件的反应，以及它的结果。\n\n * 活动图\n * 状态图\n * 用例图\n * 通信图\n * 交互概述图\n * 时序图\n * 时间图\n\n\n# uml 概念\n\numl 从来源中使用相当多的概念。我们将之定义于统一建模语言术语汇表。下面仅列代表性的概念。\n\n * 对于结构而言 - 执行者，属性，类，元件，接口，对象，包。\n * 对于行为而言 - 活动（uml），事件（uml），消息（uml），方法（uml），操作（uml），状态（uml），用例（uml）。\n * 对于关系而言 - 聚合，关联，组合，相依，广义化（or 继承）。\n * 其他概念\n   * 构造型—这规范符号应用到的模型\n   * 多重性—多重性标记法与资料库建模基数对应，例如：1, 0..1, 1..*\n\n\n# uml 工具\n\numl 工具非常多，到底哪种工具好，真的是仁者见仁智者见智。这里列举一些我接触过的 uml 工具：\n\n\n# 亿图\n\n> 国内开发的、收费的绘图工具。图形模板、素材非常全面，样式也很精美，可以导出为 word、pdf、图片。\n> \n> 亿图官网\n\n\n\n\n# visio\n\n> office 的绘图工具，特点是简单、清晰。\n> \n> visio 官网\n\n\n\n\n# staruml\n\n> 样式精美，功能全面的 uml 工具。\n> \n> staruml 官网\n\n\n\n\n# astah\n\n> 样式不错，功能全面的绘图工具。\n> \n> astah 官网\n\n\n\n\n# argouml\n\n> uml 工具。\n> \n> argouml 官网\n\n\n\n\n# processon\n\n> 在线绘图工具，特点是简洁、清晰。\n> \n> processon 官网\n\n\n# drawio\n\n> 开源的在线绘图工具，特点是简洁、清晰。\n> \n> drawio 官网\n\n\n# 参考资料\n\n * wiki-uml\n * sparx uml 教程\n * omg uml\n * uml tutorial\n * w3cschool uml 教程\n * uml 学习入门就这一篇文章\n * http://www.cnblogs.com/ywqu/category/223486.html",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"UML 结构建模图",frontmatter:{title:"UML 结构建模图",date:"2018-10-26T17:39:34.000Z",categories:["设计","UML"],tags:["设计","UML"],permalink:"/pages/97f796/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.UML/02.UML%E7%BB%93%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9B%BE.html",relativePath:"03.设计/01.UML/02.UML结构建模图.md",key:"v-43c755b4",path:"/pages/97f796/",headers:[{level:2,title:"部署图",slug:"部署图",normalizedTitle:"部署图",charIndex:104},{level:3,title:"节点",slug:"节点",normalizedTitle:"节点",charIndex:223},{level:3,title:"节点实例",slug:"节点实例",normalizedTitle:"节点实例",charIndex:270},{level:3,title:"节点构造型",slug:"节点构造型",normalizedTitle:"节点构造型",charIndex:365},{level:3,title:"工件",slug:"工件",normalizedTitle:"工件",charIndex:552},{level:3,title:"关联",slug:"关联",normalizedTitle:"关联",charIndex:82},{level:3,title:"作为容器的节点",slug:"作为容器的节点",normalizedTitle:"作为容器的节点",charIndex:740},{level:2,title:"组件图",slug:"组件图",normalizedTitle:"组件图",charIndex:109},{level:3,title:"表现组件",slug:"表现组件",normalizedTitle:"表现组件",charIndex:1168},{level:3,title:"装配连接器",slug:"装配连接器",normalizedTitle:"装配连接器",charIndex:949},{level:3,title:"带端口组件",slug:"带端口组件",normalizedTitle:"带端口组件",charIndex:1323},{level:2,title:"包图",slug:"包图",normalizedTitle:"包图",charIndex:114},{level:2,title:"类图",slug:"类图",normalizedTitle:"类图",charIndex:118},{level:3,title:"类（Classes）",slug:"类-classes",normalizedTitle:"类（classes）",charIndex:2371},{level:3,title:"类的标柱（Class Notation）",slug:"类的标柱-class-notation",normalizedTitle:"类的标柱（class notation）",charIndex:2452},{level:3,title:"接口（Interfaces）",slug:"接口-interfaces",normalizedTitle:"接口（interfaces）",charIndex:2746},{level:3,title:"表（Tables）",slug:"表-tables",normalizedTitle:"表（tables）",charIndex:2918},{level:3,title:"关联（Associations）",slug:"关联-associations",normalizedTitle:"关联（associations）",charIndex:3119},{level:3,title:"泛化（Generalizations）",slug:"泛化-generalizations",normalizedTitle:"泛化（generalizations）",charIndex:2143},{level:3,title:"聚合（Aggregations）",slug:"聚合-aggregations",normalizedTitle:"聚合（aggregations）",charIndex:3518},{level:3,title:"关联类（Association Classes）",slug:"关联类-association-classes",normalizedTitle:"关联类（association classes）",charIndex:3963},{level:3,title:"依赖（Dependencies）",slug:"依赖-dependencies",normalizedTitle:"依赖（dependencies）",charIndex:4169},{level:3,title:"跟踪（Traces）",slug:"跟踪-traces",normalizedTitle:"跟踪（traces）",charIndex:4352},{level:3,title:"实现（Realizations）",slug:"实现-realizations",normalizedTitle:"实现（realizations）",charIndex:4490},{level:3,title:"嵌套（Nestings）",slug:"嵌套-nestings",normalizedTitle:"嵌套（nestings）",charIndex:4667},{level:2,title:"复合结构图",slug:"复合结构图",normalizedTitle:"复合结构图",charIndex:122},{level:3,title:"部件",slug:"部件",normalizedTitle:"部件",charIndex:3667},{level:3,title:"端口",slug:"端口",normalizedTitle:"端口",charIndex:1324},{level:3,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:61},{level:3,title:"委托",slug:"委托",normalizedTitle:"委托",charIndex:5559},{level:3,title:"协作",slug:"协作",normalizedTitle:"协作",charIndex:1703},{level:3,title:"角色绑定",slug:"角色绑定",normalizedTitle:"角色绑定",charIndex:5773},{level:3,title:"表现",slug:"表现",normalizedTitle:"表现",charIndex:1168},{level:2,title:"对象图",slug:"对象图",normalizedTitle:"对象图",charIndex:129},{level:3,title:"类和对象元素",slug:"类和对象元素",normalizedTitle:"类和对象元素",charIndex:6074},{level:3,title:"运行状态",slug:"运行状态",normalizedTitle:"运行状态",charIndex:6188},{level:3,title:"类和对象图示例",slug:"类和对象图示例",normalizedTitle:"类和对象图示例",charIndex:6259},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:6392}],headersStr:"部署图 节点 节点实例 节点构造型 工件 关联 作为容器的节点 组件图 表现组件 装配连接器 带端口组件 包图 类图 类（Classes） 类的标柱（Class Notation） 接口（Interfaces） 表（Tables） 关联（Associations） 泛化（Generalizations） 聚合（Aggregations） 关联类（Association Classes） 依赖（Dependencies） 跟踪（Traces） 实现（Realizations） 嵌套（Nestings） 复合结构图 部件 端口 接口 委托 协作 角色绑定 表现 对象图 类和对象元素 运行状态 类和对象图示例 参考资料",content:'# UML 结构建模图\n\n> 结构图定义了一个模型的静态架构。它们通常被用来对那些构成模型的‘要素\'建模，诸如：类，对象，接口和物理组件。另外，它们也被用来对元素间关联和依赖关系进行建模。\n> \n> 关键词：部署图, 组件图, 包图, 类图, 复合结构图, 对象图\n\n\n# 部署图\n\n> 部署图（Deployment Diagram）用于对系统的物理结构建模。部署图将显示系统中的软件组件和硬件组件之间的关系以及处理工作的物理分布。\n\n\n\n\n# 节点\n\n节点既可以是硬件元素，也可以是软件元素。它显示为一个立方体，如下图所示。\n\n\n\n\n# 节点实例\n\n图可以显示节点实例，实例与节点的区分是：实例的名称带下划线，冒号放在它的基本节点类型之前。实例在冒号之前可以有名称，也可以没有名称。下图显示了一个具名的计算机实例。\n\n\n\n\n# 节点构造型\n\n为节点提供了许多标准的构造型，分别命名为 «cdrom»， «cd-rom»， «computer»， «disk array»， «pc»， «pc client»， «pc server»， «secure»， «server»， «storage»， «unix server»， «user pc»。 并在节点符号的右上角显示适当的图标。\n\n\n\n\n# 工件\n\n工件是软件开发过程中的产品。包括过程模型（如：用例模型，设计模型等），源文件，执行文件，设计文档，测试报告，构造型，用户手册等等。\n\n工件表示为带有工件名称的矩形，并显示«artifact»关键字和文档符号。\n\n\n\n\n# 关联\n\n在部署图的上下文联系中，关联代表节点间的联系通道。下图显示了一个网络系统的部署图，描述了网络协议为构造型和关联终端的多重性，\n\n\n\n\n# 作为容器的节点\n\n节点可以包含其他元素，如组件和工件。下图显示了一个嵌入式系统某个部分的部署图。描写了一个被主板节点包含的可执行工件。\n\n\n\n\n# 组件图\n\n> 组件图（Component Diagram）描绘了组成一个软件系统的模块和嵌入控件。组件图比类图具有更高层次的抽象－通常运行时一个组件被一个或多个类（或对象）实现。它们象积木那样使得组件能最终构成系统的绝大部分。\n\n\n\n上图演示了一些组件和它们的内部关系。装配连接器（Assembly connectors）“连接”由"Product"和"Customer"的提供接口到由 "Order"指定的需求接口。 一个依赖关系映射了客户相关的帐户信息到“Order”需要的 "Payment"需求接口。\n\n实际上，组件图同包图很相似，它们都有明确的界限，把元素分组到逻辑结构中。他们之间的不同是：组件图提供了语义更丰富的分组机制，在组件图中，所有的模型元素都是私有的，而包图只显示公有的成员。\n\n\n# 表现组件\n\n组件可表示为带关键字 «component»的矩形类元；也可用右上角有组件图标的矩形表示。\n\n\n\n\n# 装配连接器\n\n装配连接器在组件 “Component1”的需求接口和另一个组件 “Component2”的提供接口之间建立桥梁; 这个桥梁使得一个组件能提供另一个组件所需要的服务。\n\n\n\n\n# 带端口组件\n\n使用端口的组件图允许在它的环境指定一个服务和行为，同时这个服务和行为也是组件需要的。当端口进行双向操作的时候，它可以指定输入和输出。下图详述了用于在线服务的带端口组件，它有两个提供接口 “order entry”和 “tracking”，也有 “payment” 需求接口。\n\n\n\n\n# 包图\n\n> 包图（Package Diagram）用来表现包和它所包含元素的组织。当用来代表类元素时，包图提供了命名空间的可视化。包图最常用的用途是用来组织用例图和类图，尽管它不局限于这些 UML 元素。\n\n下面是一个包图的例子。\n\n\n\n包中的元素共享相同的命名空间，因此，一个指定命名空间的元素必须有唯一的名称。\n\n包可以用来代表物理或逻辑关系。选择把类包括在指定的包里，有助于在同一个包里赋予这些类相同继承层次。通常认为把通过复合相关联的类，以及与它们相协作的类放在同一个包里。\n\n\n\n在 UML2.5 中，包用文件夹来表示，包中的元素共享同一个命名空间，并且必须是可识别的，因此要有唯一的名称或类型。包必须显示包名，在附属方框部分有选择的显示包内的元素。\n\n * 包的合并 - 包之间的合并连接符«merge»定义了源包元素与目标包同名元素之间的泛化关系。源包元素的定义被扩展来包含目标包元素定义。当源包元素与目标包内没有同名元素时，目标包元素的定义不受影响。\n * 包的导入 - 导入连接符 «import»表明目标包的元素，在该例中是一个类 ，在源包中被引用要用非限定修饰名。源包的命名空间获得目标类的接口，目标包的命名空间则不受影响。\n * 嵌套连接符 - 源包和目标包间的嵌套连接符说明目标包完全包含源包。\n\n\n# 类图\n\n> 类图（Class Diagram）展示了面向对象系统的构造模块。描绘了模型或部分模型的静态视图，显示它包含的属性和行为，而不是详细描述操作的功能或完善方法。类图最常用来表达多个类和接口之间的关系。泛化（Generalizations），聚合（aggregations）和关联（associations）分别是类之间继承，复合或应用，及连接的表现。\n\n下面的图显示了类之间的聚合关系。弱聚合（浅色箭头）表现在类 "Account" 使用 "AddressBook"，但是不必要包含它的一个实例。强聚合（图中的黑色箭头）表示了目标类包含源类，例如，"Contact" 和 "ContactGroup"值被包含在 "AddressBook"中。\n\n\n\n\n# 类（Classes）\n\n类是定义对象所具有的属性和行为的元素。行为用类能理解的合适消息和适合每条消息的操作来描述。 类中也可能定义约束，标记值，构造型。\n\n\n# 类的标柱（Class Notation）\n\n类用矩形表示。除类的名称外，还可以选择性地显示属性和操作。 分栏分别用来显示类的名称，属性和操作。\n\n在下面图中，类的类名显示在最上面的分栏，它下面的分栏显示详细属性，如："center" 属性显示初始化的值。最后面的分栏显示操作，如： setWidth，setLength 和 setPosition 以及他们的参数。 属性和操作名前的标注表示了该属性或操作的可见性: 如果使用 "+"号，这个属性或操作是公共的 ; "-" 号则代表这个属性或操作是私有的。 "#"号是这个属性或操作被定义为保护的，" ~" 号代表包的可见性。\n\n\n\n\n# 接口（Interfaces）\n\n接口是实施者同意满足的行为规范，是一种约定。实现一个接口，类必需支持其要求的行为，使系统按照同样的方式，即公共的接口，处理不相关的元素。\n\n\n\n接口有相似于类的外形风格，含有指定的操作，如下图所示。如果没有明确的详细操作，也可以画成一个圆环。当画成圆环的时候，到这个环形标柱的实现连接没有目标箭头。\n\n\n\n\n# 表（Tables）\n\n表尽管不是基本 UML 的一部分，仍然是“图型”能完成的实例用。在右上角画一个表的小图标来表示。表属性用“图型” «column»表示。 绝大多数表单有一个主键，是由一个或几个字段组成的一个唯一的字码组合加主键操作来访问表格，主键操作“图型”为«PK»。 一些表有一个或多个外键，使用一个或多个字段加一个外键操作，映射到相关表的主键上去，外键操作“图型”为«FK»。\n\n\n\n\n# 关联（Associations）\n\n关联表明两个模型元素之间有关系，通常用在一个类中被实现为一个实例变量。连接符可以包含两端的命名的角色，基数性，方向和约束。关联是元素之间普通的关系。如果多于两个元素，也可以使用菱形的关联关系。当从类图生成代码时，关联末端的对象将变成目标类中实例变量。见下图示例 "playsFor" 将变成"Player"类中的实例变量。\n\n\n\n\n# 泛化（Generalizations）\n\n泛化被用来说明继承关系。连接从特定类元到一般类元。泛化的含义是源类继承了目标类的特性。下图的图显示了一个父类泛化一个子类， 类“Circle”的一个实例将会有属性 “ x_position”，“ y_position” ， “radius” 和 方法 “display()”。 注意：类 "Shape" 是抽象的，类名显示为斜体。\n\n\n\n下图显示了与上图相同信息的视图。\n\n\n\n\n# 聚合（Aggregations）\n\n聚合通常被用来描述由更小的组件所构成的元素。聚合关系表示为白色菱形箭头指向目标类或父类。\n\n聚合的更强形式 -组合聚合（强聚合） - 显示为黑色菱形箭头，用来组合每次最大化的包含组件。如果一个组合聚合的父类被删除，通常与他相关的所有部分都会被删除，但是，如果一个部件从组合中去掉，将不用删除整个组合。组合是可迁，非对称的关系和递归的。\n\n下面的图示：显示了弱聚合和强聚合的不同。“ address book” 由许多 “contacts” 和 “contact groups”组成。 “contact group” 是一个“contacts”的虚分组; “contact”可以被包含在不止一个 “ contact group”。 如果你删除一个“ address book”，所有的 “contacts” 和 “contact groups” 也将会被删除；如果你删除“ contact group”， 没有 “contacts”会被删除。\n\n\n\n\n# 关联类（Association Classes）\n\n关联类是一个允许关联连接有属性和操作的构造。下面的示例：显示了远不止简单连接两个类的连接，如给“employee”分配项目。“ employee”在项目中所起的作用是一个复杂的实体，既有自身的也有不属于“employee” 或 “project” 类的细节。 例如，“ employee”可以同时为几个项目工作，有不同的职务头衔和对应的安全权限。\n\n\n\n\n# 依赖（Dependencies）\n\n依赖被用来描述模型元素间广泛的依赖关系。通常在设计过程早期显示两个元素之间存在某种关系，因为是初期而不能确定具体是什么关系，在设计过程末期，该继承关系会被归入已有构造型 (构造型 可以是实例化 «instantiate»，跟踪 «trace»，导入 «import»， 和其它的关系)，或被替换成一个更明确类型的连接符。\n\n\n# 跟踪（Traces）\n\n跟踪关系是一种特殊化的依赖关系。连接模型元素或跨模型但是具有相同概念的模型元素集。跟踪被经常用来追踪需求和模型的变化。由于变化是双向的，这种依赖关系的顺序通常被忽略。这种关系的属性可以被指定为单向映射，但跟踪是双向的，非正式的和很少可计算的。\n\n\n# 实现（Realizations）\n\n是源对象执行或实现目标，实现被用来表达模型的可跟踪性和完整性－业务模型或需求被一个或多个用例实现，用例则被类实现，类被组件实现，等等。这种实现贯穿于系统设计的映射需求和类等，直至抽象建模水平级。从而确保整个系统的一张宏图，它也反映系统的所有微小组成，以及约束和定义它的细节。实现关系用带虚线的实箭头表示。\n\n\n\n\n# 嵌套（Nestings）\n\n嵌套连接符用来表示源元素嵌套在目标元素中。下图显示“ inner class”的定义，尽管在 EA 中，更多地按照着他们在项目层次视图中的位置来显示这种关系。\n\n\n\n\n# 复合结构图\n\n> 复合结构图显示类的内部结构，包括它与系统其他部分的交互点。也显示各部分的配置与关系，这些部分一起执行类元的行为。\n\n类元素已经在类图部分被详细地阐述，这部分用来说明类表现复合元素的方式，如：暴露接口，包含端口和部件。\n\n\n\n\n# 部件\n\n部件是代表一组（一个或多个）实例的元素，这组实例的拥有者是一类元实例，例如：如果一个图的实例有一组图形元素，则这些图形元素可以被表示为部件，并可以对他们之间的某种关系建模。注意：一个部件可以在它的父类被删除之前从父类中被去掉，这样部件就不会被同时删除了。 部件在类或组件内部显示为不加修饰的方框。\n\n\n\n\n# 端口\n\n端口是类型化的元素，代表一个包含类元实例的外部可视的部分。端口定义了类元和它的环境之间的交互。端口显示在包含它的部件，类或组合结构的边缘上。端口指定了类元提供的服务，以及类元要求环境提供的服务。 端口显示为所属类元边界指定的方框。\n\n\n\n\n# 接口\n\n接口与类相似，但是有一些限制，所有的接口操作都是公共和抽象的，不提供任何默认的实现。所有的接口属性都必须是常量。然而，当一个类从一个单独的超级类继承而来，它可以实现多个接口。 当一个接口在图中单列出来，它既可以显示为类元素的方框，带 «interface» 关键字和表明它是抽象的斜体名称，也可以显示为圆环。\n\n\n\n注意：圆环标注不显示接口操作。当接口显示为类所有的接口，它们会被当作暴露接口引用。暴露接口可以定义为是提供的，还是需求的。提供接口确认包含它的类元提供指定接口元素定义的操作，可通过类和接口间实现的连接来定义。需求接口说明该类元能与其他类元进行通信，这些类元提供了指定接口元素所定义的操作。需求接口可通过在类和接口间建立依赖连接来定义。 提供接口显示为“带棒球体”，依附在类元边缘。需求接口显示为“带棒杯体”，也是依附在类元边缘。\n\n\n\n\n# 委托\n\n委托连接器用来定义组件外部端口和接口的内部工作方式。委托连接器表示为带有 «delegate» 关键字的箭头。它连接组件的外部约定，表现为它的端口，到组件部件行为的内部实现。\n\n\n\n\n# 协作\n\n协作定义了一系列共同协作的角色，它们集体展示一个指定的设计功能。协作图应仅仅显示完成指定任务或功能的角色与属性。隔离主要角色是用来简化结构和澄清行为，也用于重用。一个协作通常实现一个模式。 协作元素显示为椭圆。\n\n\n\n\n# 角色绑定\n\n角色绑定连接器是一条从连接协作到所要完成该任务类元的连线。它显示为虚线，并在类元端显示作用名。\n\n\n\n\n# 表现\n\n表现连接器用于连接协作到类元来表示此类元中使用了该协作。显示为带关键字 «represents»的虚线箭头。\n\n\n\n发生 发生连接器用于连接协作到类元来表示此协作表现了（同原文）该类元；显示为带关键字«occurrence»的虚线箭头。\n\n\n\n\n# 对象图\n\n> 对象图（Object Diagram）可以认为是类图的特殊情形，是类图元素子集，被用来及时强调在某些点，类的实例间的关系。这对理解类图很有帮助。他们在构造上与类图显示没有不同，但是反映出多样性和作用。\n\n\n# 类和对象元素\n\n下面的图显示了类元素和对象元素外观上的不同。注意：类元素包括三个部分，分别是名字栏，属性栏和操作栏；对象元素默认为没有分栏。名称显示也有不同：对象名称有下划线，并可能显示该对象实例化所用类元的名称。\n\n\n\n\n# 运行状态\n\n类元元素可以有任意数量的属性和操作。在对象实例中不会被显示出来。但可能定义对象的运行状态，显示特殊实例的属性设置值。\n\n\n\n\n# 类和对象图示例\n\n下图是一个对象图，其中插入了类定义图。它例示如何用对象图来测试类图中任务多重性的方法。“car” 类对 “wheel” 类有“1 对多” 的多重性，但是如果已经选择用“1 对 4” 来替代，那样就不会在对象图显示“3 个轮子”的汽车。\n\n\n\n\n# 参考资料\n\n * https://sparxsystems.cn/resources/uml2_tutorial/index.html\n * http://www.cnblogs.com/ywqu/category/223486.html',normalizedContent:'# uml 结构建模图\n\n> 结构图定义了一个模型的静态架构。它们通常被用来对那些构成模型的‘要素\'建模，诸如：类，对象，接口和物理组件。另外，它们也被用来对元素间关联和依赖关系进行建模。\n> \n> 关键词：部署图, 组件图, 包图, 类图, 复合结构图, 对象图\n\n\n# 部署图\n\n> 部署图（deployment diagram）用于对系统的物理结构建模。部署图将显示系统中的软件组件和硬件组件之间的关系以及处理工作的物理分布。\n\n\n\n\n# 节点\n\n节点既可以是硬件元素，也可以是软件元素。它显示为一个立方体，如下图所示。\n\n\n\n\n# 节点实例\n\n图可以显示节点实例，实例与节点的区分是：实例的名称带下划线，冒号放在它的基本节点类型之前。实例在冒号之前可以有名称，也可以没有名称。下图显示了一个具名的计算机实例。\n\n\n\n\n# 节点构造型\n\n为节点提供了许多标准的构造型，分别命名为 «cdrom»， «cd-rom»， «computer»， «disk array»， «pc»， «pc client»， «pc server»， «secure»， «server»， «storage»， «unix server»， «user pc»。 并在节点符号的右上角显示适当的图标。\n\n\n\n\n# 工件\n\n工件是软件开发过程中的产品。包括过程模型（如：用例模型，设计模型等），源文件，执行文件，设计文档，测试报告，构造型，用户手册等等。\n\n工件表示为带有工件名称的矩形，并显示«artifact»关键字和文档符号。\n\n\n\n\n# 关联\n\n在部署图的上下文联系中，关联代表节点间的联系通道。下图显示了一个网络系统的部署图，描述了网络协议为构造型和关联终端的多重性，\n\n\n\n\n# 作为容器的节点\n\n节点可以包含其他元素，如组件和工件。下图显示了一个嵌入式系统某个部分的部署图。描写了一个被主板节点包含的可执行工件。\n\n\n\n\n# 组件图\n\n> 组件图（component diagram）描绘了组成一个软件系统的模块和嵌入控件。组件图比类图具有更高层次的抽象－通常运行时一个组件被一个或多个类（或对象）实现。它们象积木那样使得组件能最终构成系统的绝大部分。\n\n\n\n上图演示了一些组件和它们的内部关系。装配连接器（assembly connectors）“连接”由"product"和"customer"的提供接口到由 "order"指定的需求接口。 一个依赖关系映射了客户相关的帐户信息到“order”需要的 "payment"需求接口。\n\n实际上，组件图同包图很相似，它们都有明确的界限，把元素分组到逻辑结构中。他们之间的不同是：组件图提供了语义更丰富的分组机制，在组件图中，所有的模型元素都是私有的，而包图只显示公有的成员。\n\n\n# 表现组件\n\n组件可表示为带关键字 «component»的矩形类元；也可用右上角有组件图标的矩形表示。\n\n\n\n\n# 装配连接器\n\n装配连接器在组件 “component1”的需求接口和另一个组件 “component2”的提供接口之间建立桥梁; 这个桥梁使得一个组件能提供另一个组件所需要的服务。\n\n\n\n\n# 带端口组件\n\n使用端口的组件图允许在它的环境指定一个服务和行为，同时这个服务和行为也是组件需要的。当端口进行双向操作的时候，它可以指定输入和输出。下图详述了用于在线服务的带端口组件，它有两个提供接口 “order entry”和 “tracking”，也有 “payment” 需求接口。\n\n\n\n\n# 包图\n\n> 包图（package diagram）用来表现包和它所包含元素的组织。当用来代表类元素时，包图提供了命名空间的可视化。包图最常用的用途是用来组织用例图和类图，尽管它不局限于这些 uml 元素。\n\n下面是一个包图的例子。\n\n\n\n包中的元素共享相同的命名空间，因此，一个指定命名空间的元素必须有唯一的名称。\n\n包可以用来代表物理或逻辑关系。选择把类包括在指定的包里，有助于在同一个包里赋予这些类相同继承层次。通常认为把通过复合相关联的类，以及与它们相协作的类放在同一个包里。\n\n\n\n在 uml2.5 中，包用文件夹来表示，包中的元素共享同一个命名空间，并且必须是可识别的，因此要有唯一的名称或类型。包必须显示包名，在附属方框部分有选择的显示包内的元素。\n\n * 包的合并 - 包之间的合并连接符«merge»定义了源包元素与目标包同名元素之间的泛化关系。源包元素的定义被扩展来包含目标包元素定义。当源包元素与目标包内没有同名元素时，目标包元素的定义不受影响。\n * 包的导入 - 导入连接符 «import»表明目标包的元素，在该例中是一个类 ，在源包中被引用要用非限定修饰名。源包的命名空间获得目标类的接口，目标包的命名空间则不受影响。\n * 嵌套连接符 - 源包和目标包间的嵌套连接符说明目标包完全包含源包。\n\n\n# 类图\n\n> 类图（class diagram）展示了面向对象系统的构造模块。描绘了模型或部分模型的静态视图，显示它包含的属性和行为，而不是详细描述操作的功能或完善方法。类图最常用来表达多个类和接口之间的关系。泛化（generalizations），聚合（aggregations）和关联（associations）分别是类之间继承，复合或应用，及连接的表现。\n\n下面的图显示了类之间的聚合关系。弱聚合（浅色箭头）表现在类 "account" 使用 "addressbook"，但是不必要包含它的一个实例。强聚合（图中的黑色箭头）表示了目标类包含源类，例如，"contact" 和 "contactgroup"值被包含在 "addressbook"中。\n\n\n\n\n# 类（classes）\n\n类是定义对象所具有的属性和行为的元素。行为用类能理解的合适消息和适合每条消息的操作来描述。 类中也可能定义约束，标记值，构造型。\n\n\n# 类的标柱（class notation）\n\n类用矩形表示。除类的名称外，还可以选择性地显示属性和操作。 分栏分别用来显示类的名称，属性和操作。\n\n在下面图中，类的类名显示在最上面的分栏，它下面的分栏显示详细属性，如："center" 属性显示初始化的值。最后面的分栏显示操作，如： setwidth，setlength 和 setposition 以及他们的参数。 属性和操作名前的标注表示了该属性或操作的可见性: 如果使用 "+"号，这个属性或操作是公共的 ; "-" 号则代表这个属性或操作是私有的。 "#"号是这个属性或操作被定义为保护的，" ~" 号代表包的可见性。\n\n\n\n\n# 接口（interfaces）\n\n接口是实施者同意满足的行为规范，是一种约定。实现一个接口，类必需支持其要求的行为，使系统按照同样的方式，即公共的接口，处理不相关的元素。\n\n\n\n接口有相似于类的外形风格，含有指定的操作，如下图所示。如果没有明确的详细操作，也可以画成一个圆环。当画成圆环的时候，到这个环形标柱的实现连接没有目标箭头。\n\n\n\n\n# 表（tables）\n\n表尽管不是基本 uml 的一部分，仍然是“图型”能完成的实例用。在右上角画一个表的小图标来表示。表属性用“图型” «column»表示。 绝大多数表单有一个主键，是由一个或几个字段组成的一个唯一的字码组合加主键操作来访问表格，主键操作“图型”为«pk»。 一些表有一个或多个外键，使用一个或多个字段加一个外键操作，映射到相关表的主键上去，外键操作“图型”为«fk»。\n\n\n\n\n# 关联（associations）\n\n关联表明两个模型元素之间有关系，通常用在一个类中被实现为一个实例变量。连接符可以包含两端的命名的角色，基数性，方向和约束。关联是元素之间普通的关系。如果多于两个元素，也可以使用菱形的关联关系。当从类图生成代码时，关联末端的对象将变成目标类中实例变量。见下图示例 "playsfor" 将变成"player"类中的实例变量。\n\n\n\n\n# 泛化（generalizations）\n\n泛化被用来说明继承关系。连接从特定类元到一般类元。泛化的含义是源类继承了目标类的特性。下图的图显示了一个父类泛化一个子类， 类“circle”的一个实例将会有属性 “ x_position”，“ y_position” ， “radius” 和 方法 “display()”。 注意：类 "shape" 是抽象的，类名显示为斜体。\n\n\n\n下图显示了与上图相同信息的视图。\n\n\n\n\n# 聚合（aggregations）\n\n聚合通常被用来描述由更小的组件所构成的元素。聚合关系表示为白色菱形箭头指向目标类或父类。\n\n聚合的更强形式 -组合聚合（强聚合） - 显示为黑色菱形箭头，用来组合每次最大化的包含组件。如果一个组合聚合的父类被删除，通常与他相关的所有部分都会被删除，但是，如果一个部件从组合中去掉，将不用删除整个组合。组合是可迁，非对称的关系和递归的。\n\n下面的图示：显示了弱聚合和强聚合的不同。“ address book” 由许多 “contacts” 和 “contact groups”组成。 “contact group” 是一个“contacts”的虚分组; “contact”可以被包含在不止一个 “ contact group”。 如果你删除一个“ address book”，所有的 “contacts” 和 “contact groups” 也将会被删除；如果你删除“ contact group”， 没有 “contacts”会被删除。\n\n\n\n\n# 关联类（association classes）\n\n关联类是一个允许关联连接有属性和操作的构造。下面的示例：显示了远不止简单连接两个类的连接，如给“employee”分配项目。“ employee”在项目中所起的作用是一个复杂的实体，既有自身的也有不属于“employee” 或 “project” 类的细节。 例如，“ employee”可以同时为几个项目工作，有不同的职务头衔和对应的安全权限。\n\n\n\n\n# 依赖（dependencies）\n\n依赖被用来描述模型元素间广泛的依赖关系。通常在设计过程早期显示两个元素之间存在某种关系，因为是初期而不能确定具体是什么关系，在设计过程末期，该继承关系会被归入已有构造型 (构造型 可以是实例化 «instantiate»，跟踪 «trace»，导入 «import»， 和其它的关系)，或被替换成一个更明确类型的连接符。\n\n\n# 跟踪（traces）\n\n跟踪关系是一种特殊化的依赖关系。连接模型元素或跨模型但是具有相同概念的模型元素集。跟踪被经常用来追踪需求和模型的变化。由于变化是双向的，这种依赖关系的顺序通常被忽略。这种关系的属性可以被指定为单向映射，但跟踪是双向的，非正式的和很少可计算的。\n\n\n# 实现（realizations）\n\n是源对象执行或实现目标，实现被用来表达模型的可跟踪性和完整性－业务模型或需求被一个或多个用例实现，用例则被类实现，类被组件实现，等等。这种实现贯穿于系统设计的映射需求和类等，直至抽象建模水平级。从而确保整个系统的一张宏图，它也反映系统的所有微小组成，以及约束和定义它的细节。实现关系用带虚线的实箭头表示。\n\n\n\n\n# 嵌套（nestings）\n\n嵌套连接符用来表示源元素嵌套在目标元素中。下图显示“ inner class”的定义，尽管在 ea 中，更多地按照着他们在项目层次视图中的位置来显示这种关系。\n\n\n\n\n# 复合结构图\n\n> 复合结构图显示类的内部结构，包括它与系统其他部分的交互点。也显示各部分的配置与关系，这些部分一起执行类元的行为。\n\n类元素已经在类图部分被详细地阐述，这部分用来说明类表现复合元素的方式，如：暴露接口，包含端口和部件。\n\n\n\n\n# 部件\n\n部件是代表一组（一个或多个）实例的元素，这组实例的拥有者是一类元实例，例如：如果一个图的实例有一组图形元素，则这些图形元素可以被表示为部件，并可以对他们之间的某种关系建模。注意：一个部件可以在它的父类被删除之前从父类中被去掉，这样部件就不会被同时删除了。 部件在类或组件内部显示为不加修饰的方框。\n\n\n\n\n# 端口\n\n端口是类型化的元素，代表一个包含类元实例的外部可视的部分。端口定义了类元和它的环境之间的交互。端口显示在包含它的部件，类或组合结构的边缘上。端口指定了类元提供的服务，以及类元要求环境提供的服务。 端口显示为所属类元边界指定的方框。\n\n\n\n\n# 接口\n\n接口与类相似，但是有一些限制，所有的接口操作都是公共和抽象的，不提供任何默认的实现。所有的接口属性都必须是常量。然而，当一个类从一个单独的超级类继承而来，它可以实现多个接口。 当一个接口在图中单列出来，它既可以显示为类元素的方框，带 «interface» 关键字和表明它是抽象的斜体名称，也可以显示为圆环。\n\n\n\n注意：圆环标注不显示接口操作。当接口显示为类所有的接口，它们会被当作暴露接口引用。暴露接口可以定义为是提供的，还是需求的。提供接口确认包含它的类元提供指定接口元素定义的操作，可通过类和接口间实现的连接来定义。需求接口说明该类元能与其他类元进行通信，这些类元提供了指定接口元素所定义的操作。需求接口可通过在类和接口间建立依赖连接来定义。 提供接口显示为“带棒球体”，依附在类元边缘。需求接口显示为“带棒杯体”，也是依附在类元边缘。\n\n\n\n\n# 委托\n\n委托连接器用来定义组件外部端口和接口的内部工作方式。委托连接器表示为带有 «delegate» 关键字的箭头。它连接组件的外部约定，表现为它的端口，到组件部件行为的内部实现。\n\n\n\n\n# 协作\n\n协作定义了一系列共同协作的角色，它们集体展示一个指定的设计功能。协作图应仅仅显示完成指定任务或功能的角色与属性。隔离主要角色是用来简化结构和澄清行为，也用于重用。一个协作通常实现一个模式。 协作元素显示为椭圆。\n\n\n\n\n# 角色绑定\n\n角色绑定连接器是一条从连接协作到所要完成该任务类元的连线。它显示为虚线，并在类元端显示作用名。\n\n\n\n\n# 表现\n\n表现连接器用于连接协作到类元来表示此类元中使用了该协作。显示为带关键字 «represents»的虚线箭头。\n\n\n\n发生 发生连接器用于连接协作到类元来表示此协作表现了（同原文）该类元；显示为带关键字«occurrence»的虚线箭头。\n\n\n\n\n# 对象图\n\n> 对象图（object diagram）可以认为是类图的特殊情形，是类图元素子集，被用来及时强调在某些点，类的实例间的关系。这对理解类图很有帮助。他们在构造上与类图显示没有不同，但是反映出多样性和作用。\n\n\n# 类和对象元素\n\n下面的图显示了类元素和对象元素外观上的不同。注意：类元素包括三个部分，分别是名字栏，属性栏和操作栏；对象元素默认为没有分栏。名称显示也有不同：对象名称有下划线，并可能显示该对象实例化所用类元的名称。\n\n\n\n\n# 运行状态\n\n类元元素可以有任意数量的属性和操作。在对象实例中不会被显示出来。但可能定义对象的运行状态，显示特殊实例的属性设置值。\n\n\n\n\n# 类和对象图示例\n\n下图是一个对象图，其中插入了类定义图。它例示如何用对象图来测试类图中任务多重性的方法。“car” 类对 “wheel” 类有“1 对多” 的多重性，但是如果已经选择用“1 对 4” 来替代，那样就不会在对象图显示“3 个轮子”的汽车。\n\n\n\n\n# 参考资料\n\n * https://sparxsystems.cn/resources/uml2_tutorial/index.html\n * http://www.cnblogs.com/ywqu/category/223486.html',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"UML行为建模图",frontmatter:{title:"UML行为建模图",date:"2018-10-17T13:25:36.000Z",categories:["设计","UML"],tags:["设计","UML"],permalink:"/pages/dba425/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.UML/03.UML%E8%A1%8C%E4%B8%BA%E5%BB%BA%E6%A8%A1%E5%9B%BE.html",relativePath:"03.设计/01.UML/03.UML行为建模图.md",key:"v-2b866fe8",path:"/pages/dba425/",headers:[{level:2,title:"活动图",slug:"活动图",normalizedTitle:"活动图",charIndex:100},{level:3,title:"活动",slug:"活动",normalizedTitle:"活动",charIndex:100},{level:3,title:"动作",slug:"动作",normalizedTitle:"动作",charIndex:332},{level:3,title:"动作约束",slug:"动作约束",normalizedTitle:"动作约束",charIndex:392},{level:3,title:"控制流",slug:"控制流",normalizedTitle:"控制流",charIndex:435},{level:3,title:"初始节点",slug:"初始节点",normalizedTitle:"初始节点",charIndex:473},{level:3,title:"结束节点",slug:"结束节点",normalizedTitle:"结束节点",charIndex:506},{level:3,title:"对象和对象流",slug:"对象和对象流",normalizedTitle:"对象和对象流",charIndex:634},{level:3,title:"判断节点和合并节点",slug:"判断节点和合并节点",normalizedTitle:"判断节点和合并节点",charIndex:781},{level:3,title:"分叉和结合节点",slug:"分叉和结合节点",normalizedTitle:"分叉和结合节点",charIndex:876},{level:3,title:"扩展域",slug:"扩展域",normalizedTitle:"扩展域",charIndex:1087},{level:3,title:"异常处理器",slug:"异常处理器",normalizedTitle:"异常处理器",charIndex:1190},{level:3,title:"可中断活动区",slug:"可中断活动区",normalizedTitle:"可中断活动区",charIndex:1219},{level:3,title:"分割",slug:"分割",normalizedTitle:"分割",charIndex:1377},{level:2,title:"状态机图",slug:"状态机图",normalizedTitle:"状态机图",charIndex:105},{level:3,title:"状态",slug:"状态",normalizedTitle:"状态",charIndex:46},{level:3,title:"起始和结束状态",slug:"起始和结束状态",normalizedTitle:"起始和结束状态",charIndex:1878},{level:3,title:"转移",slug:"转移",normalizedTitle:"转移",charIndex:1758},{level:3,title:"状态活动",slug:"状态活动",normalizedTitle:"状态活动",charIndex:2151},{level:3,title:"自转移",slug:"自转移",normalizedTitle:"自转移",charIndex:2331},{level:3,title:"复合状态",slug:"复合状态",normalizedTitle:"复合状态",charIndex:2379},{level:3,title:"入口点",slug:"入口点",normalizedTitle:"入口点",charIndex:2474},{level:3,title:"出口点",slug:"出口点",normalizedTitle:"出口点",charIndex:2596},{level:3,title:"选择伪状态",slug:"选择伪状态",normalizedTitle:"选择伪状态",charIndex:2673},{level:3,title:"连接伪状态",slug:"连接伪状态",normalizedTitle:"连接伪状态",charIndex:2760},{level:3,title:"终止伪状态",slug:"终止伪状态",normalizedTitle:"终止伪状态",charIndex:2896},{level:3,title:"历史状态",slug:"历史状态",normalizedTitle:"历史状态",charIndex:2941},{level:3,title:"并发区",slug:"并发区",normalizedTitle:"并发区",charIndex:3146},{level:2,title:"用例图",slug:"用例图",normalizedTitle:"用例图",charIndex:111},{level:3,title:"执行者",slug:"执行者",normalizedTitle:"执行者",charIndex:3339},{level:3,title:"用例",slug:"用例",normalizedTitle:"用例",charIndex:111},{level:3,title:"用例定义",slug:"用例定义",normalizedTitle:"用例定义",charIndex:3686},{level:3,title:"包含用例",slug:"包含用例",normalizedTitle:"包含用例",charIndex:4049},{level:3,title:"扩展用例",slug:"扩展用例",normalizedTitle:"扩展用例",charIndex:4208},{level:2,title:"通信图",slug:"通信图",normalizedTitle:"通信图",charIndex:116},{level:2,title:"交互概述图",slug:"交互概述图",normalizedTitle:"交互概述图",charIndex:121},{level:3,title:"交互发生",slug:"交互发生",normalizedTitle:"交互发生",charIndex:4704},{level:3,title:"交互元素",slug:"交互元素",normalizedTitle:"交互元素",charIndex:4709},{level:3,title:"将它们放在一起",slug:"将它们放在一起",normalizedTitle:"将它们放在一起",charIndex:4847},{level:2,title:"时序图",slug:"时序图",normalizedTitle:"时序图",charIndex:128},{level:3,title:"生命线",slug:"生命线",normalizedTitle:"生命线",charIndex:2915},{level:3,title:"消息",slug:"消息",normalizedTitle:"消息",charIndex:2748},{level:3,title:"执行发生",slug:"执行发生",normalizedTitle:"执行发生",charIndex:5353},{level:3,title:"内部通信",slug:"内部通信",normalizedTitle:"内部通信",charIndex:5470},{level:3,title:"迷路消息和拾取消息",slug:"迷路消息和拾取消息",normalizedTitle:"迷路消息和拾取消息",charIndex:5539},{level:3,title:"生命线开始与结束",slug:"生命线开始与结束",normalizedTitle:"生命线开始与结束",charIndex:5649},{level:3,title:"时间和期限约束",slug:"时间和期限约束",normalizedTitle:"时间和期限约束",charIndex:5776},{level:3,title:"复合片段",slug:"复合片段",normalizedTitle:"复合片段",charIndex:5894},{level:3,title:"门",slug:"门",normalizedTitle:"门",charIndex:1573},{level:3,title:"部分分解",slug:"部分分解",normalizedTitle:"部分分解",charIndex:6700},{level:3,title:"状态常量/延续",slug:"状态常量-延续",normalizedTitle:"状态常量/延续",charIndex:6749},{level:2,title:"时间图",slug:"时间图",normalizedTitle:"时间图",charIndex:133},{level:3,title:"状态生命线",slug:"状态生命线",normalizedTitle:"状态生命线",charIndex:6914},{level:3,title:"值生命线",slug:"值生命线",normalizedTitle:"值生命线",charIndex:6997},{level:3,title:"将它们放在一起",slug:"将它们放在一起-2",normalizedTitle:"将它们放在一起",charIndex:4847},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:7230}],headersStr:"活动图 活动 动作 动作约束 控制流 初始节点 结束节点 对象和对象流 判断节点和合并节点 分叉和结合节点 扩展域 异常处理器 可中断活动区 分割 状态机图 状态 起始和结束状态 转移 状态活动 自转移 复合状态 入口点 出口点 选择伪状态 连接伪状态 终止伪状态 历史状态 并发区 用例图 执行者 用例 用例定义 包含用例 扩展用例 通信图 交互概述图 交互发生 交互元素 将它们放在一起 时序图 生命线 消息 执行发生 内部通信 迷路消息和拾取消息 生命线开始与结束 时间和期限约束 复合片段 门 部分分解 状态常量/延续 时间图 状态生命线 值生命线 将它们放在一起 参考资料",content:'# 行为建模图\n\n> 行为图用来记录在一个模型内部，随时间的变化，模型执行的交互变化和瞬间的状态；并跟踪系统在真实环境下如何表现，以及观察系统对一个操作或事件的反应，以及它的结果。\n> \n> 关键词：活动图, 状态机图, 用例图, 通信图, 交互概述图, 时序图, 时间图\n\n\n# 活动图\n\n> UML 中，活动图用来展示活动的顺序。显示了从起始点到终点的工作流，描述了活动图中存在于事件进程的判断路径。活动图可以用来详细阐述某些活动执行中发生并行处理的情况。活动图对业务建模也比较有用，用来详细描述发生在业务活动中的过程。 一个活动图的示例如下所示。\n\n\n\n下面描述组成活动图的元素。\n\n\n# 活动\n\n活动是行为参数化顺序的规范。活动被表示为圆角矩形，内含全部的动作，工作流和其他组成活动的元素。\n\n\n\n\n# 动作\n\n一个动作代表活动中的一个步骤。动作用圆角矩形表示。\n\n\n\n\n# 动作约束\n\n动作可以附带约束，下图显示了一个带前置条件和后置条件的动作。\n\n\n\n\n# 控制流\n\n控制流显示一个动作到下一个动作的流。表示为带箭头实线\n\n\n\n\n# 初始节点\n\n一个开始或起始点用大黑圆点表示，如下图。\n\n\n\n\n# 结束节点\n\n结束节点有两种类型：活动结束节点和流结束节点。活动结束节点表示为中心带黑点的圆环。\n\n\n\n流结束节点表示为内部为叉号的圆环。\n\n\n\n这两种不同类型节点的区别为：流结束节点表明单独的控制流的终点。活动结束终点是活动图内所有控制流的结束。\n\n\n# 对象和对象流\n\n对象流是对象和数据转递的通道。对象显示为矩形。\n\n\n\n对象流显示为带箭头的连接器，表明方向和通过的对象。\n\n\n\n一个对象流在它的至少一个终端有一个对象。在上图中，可以采用带输入输出引脚的速记标柱表示。\n\n\n\n数据存储显示为带 «datastore» 关键字的对象。\n\n\n\n\n# 判断节点和合并节点\n\n判断节点和合并节点是相同标注：菱形。它们可以被命名。从判断节点出来的控制流有监护条件，当监护条件满足时，可以对流控制。下图显示了判断节点和合并节点的使用。\n\n\n\n\n# 分叉和结合节点\n\n分叉和结合节点有同样的标柱：垂直或水平条（方向取决于工作流从左到右，还是从上到下）。它们说明了控制的并发线程的起始和终点，下图显示他们的使用示例。\n\n\n\n结合节点与合并节点不同之处在于：结合节点同步两个输入量，产生一个单独的输出量。来自结合节点的输出量要接收到所有的输入量后才能执行。合并节点直接将控制流传递通过。如果两个或更多的输入量到达合并节点。则它的输出流指定的动作会被执行两次或更多次。\n\n\n# 扩展域\n\n扩展域是会执行多次的结构活动域。输入输出扩展节点表示为一组“3 厢” ，代表多个选择项。关键词 "iterative"， "parallel" 或 "stream"显示在区域的左上角\n\n\n\n\n# 异常处理器\n\n异常处理器在活动图中可以建模。\n\n\n\n\n# 可中断活动区\n\n可中断活动区环绕一组可以中断的动作。在下面非常简单的例子中： 当控制被传递到结束订单 "Close Order" 动作，定单处理"Process Order" 动作会执行直到完成，除非"Cancel Request"取消请求中断被接受，这会将控制传递给"Cancel Order"动作。\n\n\n\n\n# 分割\n\n一个活动分割显示为垂直或水平泳道。在下图中，分割被用来在活动图中分隔动作，有在 "accounting department"中执行的，有在 "customer"中执行的。\n\n\n\n\n# 状态机图\n\n> 状态机图（state-machine-diagram）对一个单独对象的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。\n\n如下示例， 下列的状态机图显示了门在它的整个生命周期里如何运作。\n\n\n\n门可以处于以下的三种状态之一： "Opened"打开状态， "Closed"关闭状态，或者"Locked"锁定状态。 它分别响应事件：“Open”开门， “Close”关门， “Lock”锁门 和 “Unlock”解锁。 注意：不是所有的事件，在所有的状态下都是有效的。如：一个门打开的时候是不可能锁定的，除非你关上门。并且，状态转移可能有附加监护条件：假设门是开的，如果“doorWay->isEmpty”（门是空的）被满足，那么它只能响应关门事件。状态机图使用的语法和约定将在下面的部分进行讨论。\n\n\n# 状态\n\n状态被表示为圆角矩形，状态名写在里面。\n\n\n\n\n# 起始和结束状态\n\n初始状态表示为实心黑圆环，可以标注名称。结束状态表示为中心带黑点圆环，也可以被标注名称。\n\n\n\n\n# 转移\n\n一个状态到下一个状态的转移表示为带箭头实线。转移可以有一个“Trigger”触发器，一个“Guard”监护条件和一个“effect”效果。如下所示：\n\n\n\n"Trigger"触发器是转移的起因，它可以是某个条件下的一个信号，一个事件，一个变化或一个时间通路。"Guard"监护是一个条件，而且必须为真，以便于让触发器引起转移。效果"Effect"是直接作用到对象上的一个动作，该对象具有做为转移结果的状态机。\n\n\n# 状态活动\n\n在上面的状态转移示例中，一个效果与该转移相关联。如果目标状态有多个转移到达，并且每一个转移都有相同的效果与它相关联，那最好将该效果与目标状态相关联，而不与转移相关联。你可以通过为这个状态定义初始动作来实现。下图显示了一个带入口动作和出口动作的状态。\n\n\n\n可以定义发生在事件上的动作或一直发生的动作。每一种类型的动作是可以定义任意数量的。\n\n\n# 自转移\n\n一个状态可能有一个返回到自身的转移，如下图。效果与转移关联是十分有帮助。\n\n\n\n\n# 复合状态\n\n一个状态机图可以有子状态机图，如下图所示：\n\n\n\n可选择不同方式显示相同信息，如下图所示：\n\n\n\n上面版本的标注说明"Check PIN"的子状态机图显示在单独的图中。\n\n\n# 入口点\n\n有时，你不想在正常的初始状态进入子状态机。例如下面的子状态机，它通常从"初始化"状态开始，但是如果因为某些原因，它不必执行初始化，可能靠转移到指定的入口点来从 "Ready" 状态开始。\n\n\n\n下图显示了状态机的上一层。\n\n\n\n\n# 出口点\n\n有与入口点相类似的方式，它可能也指定可选择的出口点。下图给出了主处理状态执行后，所执行状态的去向将取决于该状态转移时所使用的路径。\n\n\n\n\n# 选择伪状态\n\n选择伪状态显示为菱形，有一个转移输入，两个或多个输出。下图显示不管到达哪一个状态，经过选择伪状态后的去向，取决于在伪状态中执行时所选择的消息格式。\n\n\n\n\n# 连接伪状态\n\n连接伪状态用来将多个状态转移链接在一起。一个单独的连接伪状态可以有一个或多个输入和一个或多个输出，监护可能应用于每一个转移，连接是没有语义的。连接可以把一个输入转移分成多个输出转移来实现一个静态分支。与之对照的是选择伪状态实现一个动态条件分支。\n\n\n\n\n# 终止伪状态\n\n进入终止伪状态是指状态机生命线已经终止。终止伪状态表示为叉号。\n\n\n\n\n# 历史状态\n\n历史状态用来当状态机中断时，恢复状态机之前状态。下面例图说明了历史状态的使用。这个例子是关于洗衣机的状态机。\n\n在这个状态机中，当洗衣机运行时，它会按照"Washing" 到 Rinsing"再到"Spinning"来进行。如果电源被切断 ，洗衣机会停止运行并进入"Power Off" 状态。当电源恢复，运行状态在"History State"符号处进入，表示它会从上次离开的地方恢复。\n\n\n# 并发区\n\n一个状态可以被分成几个不同的区，包含同时存在和执行的子状态。下面的例子显示状态 "Applying Brakes"， "front brake"和"rear brakes" 将同时独立运作。注意使用了分叉和结合伪状态而不是选择和合并伪状态。这些符号用来同步并发的线程。\n\n\n\n\n# 用例图\n\n> 用例图用来记录系统的需求，它提供系统与用户及其他参与者的一种通信手段。\n\n\n# 执行者\n\n用例图显示了系统和系统外实体之间的交互。这些实体被引用为执行者。执行者代表角色，可以包括：用户，外部硬件和其他系统。执行者往往被画成简笔画小人。也可以用带«actor»关键字的类矩形表示。\n\n\n\n在下图中，执行者可以详细的泛化其他执行者:\n\n\n\n\n# 用例\n\n用例是有意义的单独工作单元。它向系统外部的人或事提供一个易于观察的高层次行为视图。 用例的标注符号是一个椭圆。\n\n\n\n使用用例的符号是带可选择箭头的连接线，箭头显示控制的方向。下图说明执行者 "Customer"使用 "Withdraw"用例。\n\n\n\n用途连接器（uses connector）可以有选择性的在每一个端点有多重性值，如下图，显示客户一次可能只执行一次取款交易。但是银行可以同时执行许多取款交易。\n\n\n\n\n# 用例定义\n\n一个典型的用例包括:\n\n * 名称和描述 - 用例通常用一个动词词组定义，而且有一个简短的文字说明。\n * 需求 - 需求定义了一个用例必须提供给终端用户的正式功能性需求。它们符合构造方法建立的功能性规范。一个需求是用例将执行一个动作或提供多个值给系统的约定或承诺。\n * 约束 - 一个约束是一个用例运行的条件或限制。它包括：前置条件，后置条件和不变化条件 。前置条件指明了用例在发生之前需要符合的条件。后置条件用来说明在用例执行之后一些条件必须为"真"。不变化条件说明用例整个执行过程中该条件始终为"真"。\n * 情形 - 情形是用例的实例在执行过程中，事件发生流程的形式描述。它定义了系统和外部执行者之间的事件指定顺序。通常用文本方式来表示，并对应时序图中的文字描述。\n * 情形图\n * 附加信息\n\n\n# 包含用例\n\n用例可能包含其他用例的功能来作为它正常处理的一部分。通常它假设，任何被包含的用例在基本程序运行时每一次都会被调用。下面例子：用例“卡的确认” 在运行时，被用例“取钱”当作一个子部分。\n\n\n\n用例可以被一个或多个用例包含。通过提炼通用的行为，将它变成可以多次重复使用的用例。有助于降低功能重复级别。\n\n\n# 扩展用例\n\n一个用例可以被用来扩展另一个用例的行为，通常使用在特别情况下。例如：假设在修改一个特别类型的客户订单之前，用户必须得到某种更高级别的许可，然后“获得许可”用例将有选择的扩展常规的“修改订单”用例。\n\n\n\n扩展点 - 扩展用例的加入点被定义为扩展点。\n\n\n\n系统边界 - 它用来显示用例在系统内部，执行者在系统的外部。\n\n\n\n\n# 通信图\n\n> 通信图，以前称之为协作图，是一种交互图，所显示消息与时序图相似，但是它更侧重于对象间的联系。\n\n在通信图中，对象之间显示关联连接器。消息附加到这些关联上，显示短箭头指向消息流的方向。消息的顺序通过编号码显示。\n\n下面的两个图用通信图和时序图分别显示相同的信息。尽管我们可能从通信图的编号码得到消息顺序，但它不是立即可见的。通信图十分清楚的显示了邻近对象间全部完整的消息传递。\n\n\n\n\n\n# 交互概述图\n\n> 一个交互概览图是活动图的一种形式，它的节点代表交互图。交互图包含时序图，通信图，交互概览图和时间图。 大多数交互概览图标注与活动图一样。例如：起始，结束，判断，合并，分叉和结合节点是完全相同。并且，交互概览图介绍了两种新的元素：交互发生和交互元素。\n\n\n# 交互发生\n\n交互发生引用现有的交互图。显示为一个引用框，左上角显示 "ref" 。被引用的图名显示在框的中央。\n\n\n\n\n# 交互元素\n\n交互元素与交互发生相似之处在于都是在一个矩形框中显示一个现有的交互图。不同之处在内部显示参考图的内容不同。\n\n\n\n\n# 将它们放在一起\n\n所有的活动图控件，都可以相同地被使用于交互概览图，如：分叉，结合，合并等等。它把控制逻辑放入较低一级的图中。下面的例子就说明了一个典型的销售过程。子过程是从交互发生抽象而来。\n\n\n\n\n# 时序图\n\n> 时序图是交互图的一种形式，它显示对象沿生命线发展，对象之间随时间的交互表示为从源生命线指向目标生命线的消息。时序图能很好地显示那些对象与其它那些对象通信，什么消息触发了这些通信，时序图不能很好显示复杂过程的逻辑。\n\n\n# 生命线\n\n一条生命线在时序图中代表一个独立的参与者。表示为包含对象名的矩形，如果它的名字是"self"，则说明该生命线代表控制带时序图的类元。\n\n\n\n有时，时序图会包含一个顶端是执行者的生命线。这情况说明掌握这个时序图的是用例。健壮图中的边界，控制和实体元素也可以有生命线。\n\n\n\n\n# 消息\n\n消息显示为箭头。消息可以完成传输，也可能丢失和找回，它可以是同步的，也可以是异步的，即可以是调用，也可以是信号。在下图中，第一条消息是同步消息(标为实箭头)完成传输，并隐含一条返回消息。第二条消息是异步消息 (标为实线箭头)，第三条是异步返回消息(标为虚线)。\n\n\n\n\n# 执行发生\n\n向下延伸的细条状矩形表示执行事件或控制焦点的激活。在上图中有三个执行事件。第一个是源对象发送两条消息和收到两条回复。第二个是目标对象收到一条同步消息并返回一条回复。第三个是目标对象收到一条异步消息并返回一条回复。\n\n\n# 内部通信\n\n内部消息表现为一个操作的递归调用，或一个方法调用属于同一个对象的其他方法。显示为生命线上执行事件的嵌套控制焦点。\n\n\n\n\n# 迷路消息和拾取消息\n\n迷路消息是那些发送了却没有到达指定接收者，或者到达的接收者不再当前图中。拾取消息是收到来自那些未知的发送者，或者来自没有显示在当前图的发送者的消息。它们都表明是去往或来自一个终点元素。\n\n\n\n\n# 生命线开始与结束\n\n生命线可以在时序图时间刻度范围内创建和销毁，在下面的例子中，生命线被停止符号（叉号）终止。在前面的例子中，生命线顶端的符号（Child）显示在比创建它的对象符号（parent）沿页面要低的位置上。下图显示创建和终止对象。\n\n\n\n\n# 时间和期限约束\n\n消息默认显示为水平线。因为生命线显示为沿屏幕向下的时间通道，所以当给实时系统建模，或是有时间约束的业务过程建模，考虑执行动作所需时间长度是很重要的。因此可以给消息设置一个期限约束，这样的消息显示为下斜线。\n\n\n\n\n# 复合片段\n\n如前面所说，时序图不适合表达复杂的过程逻辑。在一种情况下，有许多机制允许把一定程度的过程逻辑加入到图中，并把它们放到复合片段的标题下。复合片段是一个或多个处理顺序被包含在一个框架中，并在指定名称的环境下执行。片段可以是:\n\n * 选择性片段 (显示 “alt”) 为 if…then…else 结构建模。\n * 选项片段 (显示 “opt”) 为 "switch"(开关) 结构建模。\n * 中断片段对被处理事件的可选择顺序建模，而不是该图的其他部分。\n * 并行片段(显示 “par”) 为并发处理建模。\n * 弱顺序片段 (显示 “seq”) 包含了一组消息，这组消息必须在后继片段开始之前被处理。但不会把片段内消息的先后顺序强加到不共享同一条生命线的消息上。\n * 严格顺序片段 (显示 “strict”) 包含了一系列需要按照给定顺序处理的消息。\n * 非片段 (显示 “neg”) 包含了一系列不可用的消息。\n * 关键片段 具有关键部分。\n * 忽略片段 声明一个没有意义的消息，如果它出现在当前上下文中。\n * 考虑片段与忽略片段相反，不包含在考虑片段内的消息都应该被忽略。\n * 断言片段 (显示 “assert”)标明任何没有显示为声明操作数的顺序都是无效的。\n * 循环片段 包含一系列被重复的消息。\n\n下图显示的是循环片段：\n\n\n\n这也是一个类似于复合片段的交互发生。 交互发生被其他图参考，显示为左上角带"ref"，将被参考图名显示在方框的中间。\n\n\n# 门\n\n门是连接片段内消息和片段外消息的连接点。 在 EA 中，门显示为片段框架上的小正方形。作用为时序图与页面外的连接器。 用来表示进来的消息源，或者出去消息的终点。下面两个图显示它们在实践中的使用。注意：" top level diagram"中的门用消息箭头指向参考片段，在这里没有必要把它画成方块。\n\n\n\n\n\n# 部分分解\n\n一个对象可以引出多条生命线，使得对象内部和对象之间的消息显示在同一图上。\n\n\n\n\n# 状态常量/延续\n\n状态常量是生命线的约束，运行时始终为"真"。显示为两侧半圆的矩形，如下图：\n\n\n\n延续虽与状态常量有同样的标注，但是被用于复合片段，并可以延伸跨越多条生命线。\n\n\n# 时间图\n\n> UML 时间图被用来显示随时间变化，一个或多个元素的值或状态的更改。也显示时控事件之间的交互和管理它们的时间和期限约束。\n\n\n# 状态生命线\n\n状态生命线显示随时间变化，一个单项状态的改变。不论时间单位如何选择，X 轴显示经过的时间，Y 轴被标为给出状态的列表。状态生命线如下所示：\n\n\n\n\n# 值生命线\n\n值生命线显示随时间变化，一个单项的值的变化。X 轴显示经过的时间，时间单位为任意，和状态生命线一样。平行线之间显示值，每次值变化，平行线交叉。如下图所示。\n\n\n\n\n# 将它们放在一起\n\n状态和值的生命线能叠加组合。它们必须有相同的 X 轴。 消息可以从一个生命线传递到另一个。每一个状态和值的变换能有一个定义的事件，一个时间限制是指一个事件何时必须发生，和一个期限限制说明状态或值多长时间必须有效。一旦这些已经被应用，其时间图可能显示如下。\n\n\n\n\n# 参考资料\n\n * https://sparxsystems.cn/resources/uml2_tutorial/index.html',normalizedContent:'# 行为建模图\n\n> 行为图用来记录在一个模型内部，随时间的变化，模型执行的交互变化和瞬间的状态；并跟踪系统在真实环境下如何表现，以及观察系统对一个操作或事件的反应，以及它的结果。\n> \n> 关键词：活动图, 状态机图, 用例图, 通信图, 交互概述图, 时序图, 时间图\n\n\n# 活动图\n\n> uml 中，活动图用来展示活动的顺序。显示了从起始点到终点的工作流，描述了活动图中存在于事件进程的判断路径。活动图可以用来详细阐述某些活动执行中发生并行处理的情况。活动图对业务建模也比较有用，用来详细描述发生在业务活动中的过程。 一个活动图的示例如下所示。\n\n\n\n下面描述组成活动图的元素。\n\n\n# 活动\n\n活动是行为参数化顺序的规范。活动被表示为圆角矩形，内含全部的动作，工作流和其他组成活动的元素。\n\n\n\n\n# 动作\n\n一个动作代表活动中的一个步骤。动作用圆角矩形表示。\n\n\n\n\n# 动作约束\n\n动作可以附带约束，下图显示了一个带前置条件和后置条件的动作。\n\n\n\n\n# 控制流\n\n控制流显示一个动作到下一个动作的流。表示为带箭头实线\n\n\n\n\n# 初始节点\n\n一个开始或起始点用大黑圆点表示，如下图。\n\n\n\n\n# 结束节点\n\n结束节点有两种类型：活动结束节点和流结束节点。活动结束节点表示为中心带黑点的圆环。\n\n\n\n流结束节点表示为内部为叉号的圆环。\n\n\n\n这两种不同类型节点的区别为：流结束节点表明单独的控制流的终点。活动结束终点是活动图内所有控制流的结束。\n\n\n# 对象和对象流\n\n对象流是对象和数据转递的通道。对象显示为矩形。\n\n\n\n对象流显示为带箭头的连接器，表明方向和通过的对象。\n\n\n\n一个对象流在它的至少一个终端有一个对象。在上图中，可以采用带输入输出引脚的速记标柱表示。\n\n\n\n数据存储显示为带 «datastore» 关键字的对象。\n\n\n\n\n# 判断节点和合并节点\n\n判断节点和合并节点是相同标注：菱形。它们可以被命名。从判断节点出来的控制流有监护条件，当监护条件满足时，可以对流控制。下图显示了判断节点和合并节点的使用。\n\n\n\n\n# 分叉和结合节点\n\n分叉和结合节点有同样的标柱：垂直或水平条（方向取决于工作流从左到右，还是从上到下）。它们说明了控制的并发线程的起始和终点，下图显示他们的使用示例。\n\n\n\n结合节点与合并节点不同之处在于：结合节点同步两个输入量，产生一个单独的输出量。来自结合节点的输出量要接收到所有的输入量后才能执行。合并节点直接将控制流传递通过。如果两个或更多的输入量到达合并节点。则它的输出流指定的动作会被执行两次或更多次。\n\n\n# 扩展域\n\n扩展域是会执行多次的结构活动域。输入输出扩展节点表示为一组“3 厢” ，代表多个选择项。关键词 "iterative"， "parallel" 或 "stream"显示在区域的左上角\n\n\n\n\n# 异常处理器\n\n异常处理器在活动图中可以建模。\n\n\n\n\n# 可中断活动区\n\n可中断活动区环绕一组可以中断的动作。在下面非常简单的例子中： 当控制被传递到结束订单 "close order" 动作，定单处理"process order" 动作会执行直到完成，除非"cancel request"取消请求中断被接受，这会将控制传递给"cancel order"动作。\n\n\n\n\n# 分割\n\n一个活动分割显示为垂直或水平泳道。在下图中，分割被用来在活动图中分隔动作，有在 "accounting department"中执行的，有在 "customer"中执行的。\n\n\n\n\n# 状态机图\n\n> 状态机图（state-machine-diagram）对一个单独对象的行为建模，指明对象在它的整个生命周期里，响应不同事件时，执行相关事件的顺序。\n\n如下示例， 下列的状态机图显示了门在它的整个生命周期里如何运作。\n\n\n\n门可以处于以下的三种状态之一： "opened"打开状态， "closed"关闭状态，或者"locked"锁定状态。 它分别响应事件：“open”开门， “close”关门， “lock”锁门 和 “unlock”解锁。 注意：不是所有的事件，在所有的状态下都是有效的。如：一个门打开的时候是不可能锁定的，除非你关上门。并且，状态转移可能有附加监护条件：假设门是开的，如果“doorway->isempty”（门是空的）被满足，那么它只能响应关门事件。状态机图使用的语法和约定将在下面的部分进行讨论。\n\n\n# 状态\n\n状态被表示为圆角矩形，状态名写在里面。\n\n\n\n\n# 起始和结束状态\n\n初始状态表示为实心黑圆环，可以标注名称。结束状态表示为中心带黑点圆环，也可以被标注名称。\n\n\n\n\n# 转移\n\n一个状态到下一个状态的转移表示为带箭头实线。转移可以有一个“trigger”触发器，一个“guard”监护条件和一个“effect”效果。如下所示：\n\n\n\n"trigger"触发器是转移的起因，它可以是某个条件下的一个信号，一个事件，一个变化或一个时间通路。"guard"监护是一个条件，而且必须为真，以便于让触发器引起转移。效果"effect"是直接作用到对象上的一个动作，该对象具有做为转移结果的状态机。\n\n\n# 状态活动\n\n在上面的状态转移示例中，一个效果与该转移相关联。如果目标状态有多个转移到达，并且每一个转移都有相同的效果与它相关联，那最好将该效果与目标状态相关联，而不与转移相关联。你可以通过为这个状态定义初始动作来实现。下图显示了一个带入口动作和出口动作的状态。\n\n\n\n可以定义发生在事件上的动作或一直发生的动作。每一种类型的动作是可以定义任意数量的。\n\n\n# 自转移\n\n一个状态可能有一个返回到自身的转移，如下图。效果与转移关联是十分有帮助。\n\n\n\n\n# 复合状态\n\n一个状态机图可以有子状态机图，如下图所示：\n\n\n\n可选择不同方式显示相同信息，如下图所示：\n\n\n\n上面版本的标注说明"check pin"的子状态机图显示在单独的图中。\n\n\n# 入口点\n\n有时，你不想在正常的初始状态进入子状态机。例如下面的子状态机，它通常从"初始化"状态开始，但是如果因为某些原因，它不必执行初始化，可能靠转移到指定的入口点来从 "ready" 状态开始。\n\n\n\n下图显示了状态机的上一层。\n\n\n\n\n# 出口点\n\n有与入口点相类似的方式，它可能也指定可选择的出口点。下图给出了主处理状态执行后，所执行状态的去向将取决于该状态转移时所使用的路径。\n\n\n\n\n# 选择伪状态\n\n选择伪状态显示为菱形，有一个转移输入，两个或多个输出。下图显示不管到达哪一个状态，经过选择伪状态后的去向，取决于在伪状态中执行时所选择的消息格式。\n\n\n\n\n# 连接伪状态\n\n连接伪状态用来将多个状态转移链接在一起。一个单独的连接伪状态可以有一个或多个输入和一个或多个输出，监护可能应用于每一个转移，连接是没有语义的。连接可以把一个输入转移分成多个输出转移来实现一个静态分支。与之对照的是选择伪状态实现一个动态条件分支。\n\n\n\n\n# 终止伪状态\n\n进入终止伪状态是指状态机生命线已经终止。终止伪状态表示为叉号。\n\n\n\n\n# 历史状态\n\n历史状态用来当状态机中断时，恢复状态机之前状态。下面例图说明了历史状态的使用。这个例子是关于洗衣机的状态机。\n\n在这个状态机中，当洗衣机运行时，它会按照"washing" 到 rinsing"再到"spinning"来进行。如果电源被切断 ，洗衣机会停止运行并进入"power off" 状态。当电源恢复，运行状态在"history state"符号处进入，表示它会从上次离开的地方恢复。\n\n\n# 并发区\n\n一个状态可以被分成几个不同的区，包含同时存在和执行的子状态。下面的例子显示状态 "applying brakes"， "front brake"和"rear brakes" 将同时独立运作。注意使用了分叉和结合伪状态而不是选择和合并伪状态。这些符号用来同步并发的线程。\n\n\n\n\n# 用例图\n\n> 用例图用来记录系统的需求，它提供系统与用户及其他参与者的一种通信手段。\n\n\n# 执行者\n\n用例图显示了系统和系统外实体之间的交互。这些实体被引用为执行者。执行者代表角色，可以包括：用户，外部硬件和其他系统。执行者往往被画成简笔画小人。也可以用带«actor»关键字的类矩形表示。\n\n\n\n在下图中，执行者可以详细的泛化其他执行者:\n\n\n\n\n# 用例\n\n用例是有意义的单独工作单元。它向系统外部的人或事提供一个易于观察的高层次行为视图。 用例的标注符号是一个椭圆。\n\n\n\n使用用例的符号是带可选择箭头的连接线，箭头显示控制的方向。下图说明执行者 "customer"使用 "withdraw"用例。\n\n\n\n用途连接器（uses connector）可以有选择性的在每一个端点有多重性值，如下图，显示客户一次可能只执行一次取款交易。但是银行可以同时执行许多取款交易。\n\n\n\n\n# 用例定义\n\n一个典型的用例包括:\n\n * 名称和描述 - 用例通常用一个动词词组定义，而且有一个简短的文字说明。\n * 需求 - 需求定义了一个用例必须提供给终端用户的正式功能性需求。它们符合构造方法建立的功能性规范。一个需求是用例将执行一个动作或提供多个值给系统的约定或承诺。\n * 约束 - 一个约束是一个用例运行的条件或限制。它包括：前置条件，后置条件和不变化条件 。前置条件指明了用例在发生之前需要符合的条件。后置条件用来说明在用例执行之后一些条件必须为"真"。不变化条件说明用例整个执行过程中该条件始终为"真"。\n * 情形 - 情形是用例的实例在执行过程中，事件发生流程的形式描述。它定义了系统和外部执行者之间的事件指定顺序。通常用文本方式来表示，并对应时序图中的文字描述。\n * 情形图\n * 附加信息\n\n\n# 包含用例\n\n用例可能包含其他用例的功能来作为它正常处理的一部分。通常它假设，任何被包含的用例在基本程序运行时每一次都会被调用。下面例子：用例“卡的确认” 在运行时，被用例“取钱”当作一个子部分。\n\n\n\n用例可以被一个或多个用例包含。通过提炼通用的行为，将它变成可以多次重复使用的用例。有助于降低功能重复级别。\n\n\n# 扩展用例\n\n一个用例可以被用来扩展另一个用例的行为，通常使用在特别情况下。例如：假设在修改一个特别类型的客户订单之前，用户必须得到某种更高级别的许可，然后“获得许可”用例将有选择的扩展常规的“修改订单”用例。\n\n\n\n扩展点 - 扩展用例的加入点被定义为扩展点。\n\n\n\n系统边界 - 它用来显示用例在系统内部，执行者在系统的外部。\n\n\n\n\n# 通信图\n\n> 通信图，以前称之为协作图，是一种交互图，所显示消息与时序图相似，但是它更侧重于对象间的联系。\n\n在通信图中，对象之间显示关联连接器。消息附加到这些关联上，显示短箭头指向消息流的方向。消息的顺序通过编号码显示。\n\n下面的两个图用通信图和时序图分别显示相同的信息。尽管我们可能从通信图的编号码得到消息顺序，但它不是立即可见的。通信图十分清楚的显示了邻近对象间全部完整的消息传递。\n\n\n\n\n\n# 交互概述图\n\n> 一个交互概览图是活动图的一种形式，它的节点代表交互图。交互图包含时序图，通信图，交互概览图和时间图。 大多数交互概览图标注与活动图一样。例如：起始，结束，判断，合并，分叉和结合节点是完全相同。并且，交互概览图介绍了两种新的元素：交互发生和交互元素。\n\n\n# 交互发生\n\n交互发生引用现有的交互图。显示为一个引用框，左上角显示 "ref" 。被引用的图名显示在框的中央。\n\n\n\n\n# 交互元素\n\n交互元素与交互发生相似之处在于都是在一个矩形框中显示一个现有的交互图。不同之处在内部显示参考图的内容不同。\n\n\n\n\n# 将它们放在一起\n\n所有的活动图控件，都可以相同地被使用于交互概览图，如：分叉，结合，合并等等。它把控制逻辑放入较低一级的图中。下面的例子就说明了一个典型的销售过程。子过程是从交互发生抽象而来。\n\n\n\n\n# 时序图\n\n> 时序图是交互图的一种形式，它显示对象沿生命线发展，对象之间随时间的交互表示为从源生命线指向目标生命线的消息。时序图能很好地显示那些对象与其它那些对象通信，什么消息触发了这些通信，时序图不能很好显示复杂过程的逻辑。\n\n\n# 生命线\n\n一条生命线在时序图中代表一个独立的参与者。表示为包含对象名的矩形，如果它的名字是"self"，则说明该生命线代表控制带时序图的类元。\n\n\n\n有时，时序图会包含一个顶端是执行者的生命线。这情况说明掌握这个时序图的是用例。健壮图中的边界，控制和实体元素也可以有生命线。\n\n\n\n\n# 消息\n\n消息显示为箭头。消息可以完成传输，也可能丢失和找回，它可以是同步的，也可以是异步的，即可以是调用，也可以是信号。在下图中，第一条消息是同步消息(标为实箭头)完成传输，并隐含一条返回消息。第二条消息是异步消息 (标为实线箭头)，第三条是异步返回消息(标为虚线)。\n\n\n\n\n# 执行发生\n\n向下延伸的细条状矩形表示执行事件或控制焦点的激活。在上图中有三个执行事件。第一个是源对象发送两条消息和收到两条回复。第二个是目标对象收到一条同步消息并返回一条回复。第三个是目标对象收到一条异步消息并返回一条回复。\n\n\n# 内部通信\n\n内部消息表现为一个操作的递归调用，或一个方法调用属于同一个对象的其他方法。显示为生命线上执行事件的嵌套控制焦点。\n\n\n\n\n# 迷路消息和拾取消息\n\n迷路消息是那些发送了却没有到达指定接收者，或者到达的接收者不再当前图中。拾取消息是收到来自那些未知的发送者，或者来自没有显示在当前图的发送者的消息。它们都表明是去往或来自一个终点元素。\n\n\n\n\n# 生命线开始与结束\n\n生命线可以在时序图时间刻度范围内创建和销毁，在下面的例子中，生命线被停止符号（叉号）终止。在前面的例子中，生命线顶端的符号（child）显示在比创建它的对象符号（parent）沿页面要低的位置上。下图显示创建和终止对象。\n\n\n\n\n# 时间和期限约束\n\n消息默认显示为水平线。因为生命线显示为沿屏幕向下的时间通道，所以当给实时系统建模，或是有时间约束的业务过程建模，考虑执行动作所需时间长度是很重要的。因此可以给消息设置一个期限约束，这样的消息显示为下斜线。\n\n\n\n\n# 复合片段\n\n如前面所说，时序图不适合表达复杂的过程逻辑。在一种情况下，有许多机制允许把一定程度的过程逻辑加入到图中，并把它们放到复合片段的标题下。复合片段是一个或多个处理顺序被包含在一个框架中，并在指定名称的环境下执行。片段可以是:\n\n * 选择性片段 (显示 “alt”) 为 if…then…else 结构建模。\n * 选项片段 (显示 “opt”) 为 "switch"(开关) 结构建模。\n * 中断片段对被处理事件的可选择顺序建模，而不是该图的其他部分。\n * 并行片段(显示 “par”) 为并发处理建模。\n * 弱顺序片段 (显示 “seq”) 包含了一组消息，这组消息必须在后继片段开始之前被处理。但不会把片段内消息的先后顺序强加到不共享同一条生命线的消息上。\n * 严格顺序片段 (显示 “strict”) 包含了一系列需要按照给定顺序处理的消息。\n * 非片段 (显示 “neg”) 包含了一系列不可用的消息。\n * 关键片段 具有关键部分。\n * 忽略片段 声明一个没有意义的消息，如果它出现在当前上下文中。\n * 考虑片段与忽略片段相反，不包含在考虑片段内的消息都应该被忽略。\n * 断言片段 (显示 “assert”)标明任何没有显示为声明操作数的顺序都是无效的。\n * 循环片段 包含一系列被重复的消息。\n\n下图显示的是循环片段：\n\n\n\n这也是一个类似于复合片段的交互发生。 交互发生被其他图参考，显示为左上角带"ref"，将被参考图名显示在方框的中间。\n\n\n# 门\n\n门是连接片段内消息和片段外消息的连接点。 在 ea 中，门显示为片段框架上的小正方形。作用为时序图与页面外的连接器。 用来表示进来的消息源，或者出去消息的终点。下面两个图显示它们在实践中的使用。注意：" top level diagram"中的门用消息箭头指向参考片段，在这里没有必要把它画成方块。\n\n\n\n\n\n# 部分分解\n\n一个对象可以引出多条生命线，使得对象内部和对象之间的消息显示在同一图上。\n\n\n\n\n# 状态常量/延续\n\n状态常量是生命线的约束，运行时始终为"真"。显示为两侧半圆的矩形，如下图：\n\n\n\n延续虽与状态常量有同样的标注，但是被用于复合片段，并可以延伸跨越多条生命线。\n\n\n# 时间图\n\n> uml 时间图被用来显示随时间变化，一个或多个元素的值或状态的更改。也显示时控事件之间的交互和管理它们的时间和期限约束。\n\n\n# 状态生命线\n\n状态生命线显示随时间变化，一个单项状态的改变。不论时间单位如何选择，x 轴显示经过的时间，y 轴被标为给出状态的列表。状态生命线如下所示：\n\n\n\n\n# 值生命线\n\n值生命线显示随时间变化，一个单项的值的变化。x 轴显示经过的时间，时间单位为任意，和状态生命线一样。平行线之间显示值，每次值变化，平行线交叉。如下图所示。\n\n\n\n\n# 将它们放在一起\n\n状态和值的生命线能叠加组合。它们必须有相同的 x 轴。 消息可以从一个生命线传递到另一个。每一个状态和值的变换能有一个定义的事件，一个时间限制是指一个事件何时必须发生，和一个期限限制说明状态或值多长时间必须有效。一旦这些已经被应用，其时间图可能显示如下。\n\n\n\n\n# 参考资料\n\n * https://sparxsystems.cn/resources/uml2_tutorial/index.html',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"README",frontmatter:{title:"README",date:"2020-08-10T10:59:18.000Z",categories:["设计","UML"],tags:["设计","UML"],permalink:"/pages/8f04b3/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/01.UML/",relativePath:"03.设计/01.UML/README.md",key:"v-bad396a0",path:"/pages/8f04b3/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:192},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:241},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:345}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# UML 教程\n\n> 统一建模语言（英语 - Unified Modeling Language，缩写 UML）是非专利的第三代建模和规约语言。UML 是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML 展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。\n\n\n# 📖 内容\n\n * UML 快速入门\n * UML 结构建模图\n * UML 行为建模图\n\n\n# 📚 资料\n\n * Wiki-UML\n * Sparx UML 教程\n * OMG UML\n * UML Tutorial\n * W3Cschool UML 教程\n * UML 学习入门就这一篇文章\n\n\n# 🚪 传送\n\n◾ 🏠 DESIGN 首页 ◾ 🎯 我的博客 ◾",normalizedContent:"# uml 教程\n\n> 统一建模语言（英语 - unified modeling language，缩写 uml）是非专利的第三代建模和规约语言。uml 是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。uml 展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。\n\n\n# 📖 内容\n\n * uml 快速入门\n * uml 结构建模图\n * uml 行为建模图\n\n\n# 📚 资料\n\n * wiki-uml\n * sparx uml 教程\n * omg uml\n * uml tutorial\n * w3cschool uml 教程\n * uml 学习入门就这一篇文章\n\n\n# 🚪 传送\n\n◾ 🏠 design 首页 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式概述",frontmatter:{title:"设计模式概述",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-27T16:50:00.000Z",permalink:"/pages/dad9fd/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/00.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0.html",relativePath:"03.设计/02.设计模式/00.设计模式概述.md",key:"v-33b23c84",path:"/pages/dad9fd/",headers:[{level:2,title:"1. 创建型模式",slug:"_1-创建型模式",normalizedTitle:"1. 创建型模式",charIndex:137},{level:3,title:"1.1. 创建型模式简介",slug:"_1-1-创建型模式简介",normalizedTitle:"1.1. 创建型模式简介",charIndex:150},{level:3,title:"1.2. 创建型模式应用",slug:"_1-2-创建型模式应用",normalizedTitle:"1.2. 创建型模式应用",charIndex:549},{level:3,title:"1.3. 创建型模式代表",slug:"_1-3-创建型模式代表",normalizedTitle:"1.3. 创建型模式代表",charIndex:990},{level:3,title:"1.4. 结构型模式",slug:"_1-4-结构型模式",normalizedTitle:"1.4. 结构型模式",charIndex:1150},{level:3,title:"1.5. 行为型模式",slug:"_1-5-行为型模式",normalizedTitle:"1.5. 行为型模式",charIndex:1295},{level:2,title:"2. 📚 资料",slug:"_2-📚-资料",normalizedTitle:"2. 📚 资料",charIndex:1548},{level:2,title:"3. 🚪 传送",slug:"_3-🚪-传送",normalizedTitle:"3. 🚪 传送",charIndex:1595}],headersStr:"1. 创建型模式 1.1. 创建型模式简介 1.2. 创建型模式应用 1.3. 创建型模式代表 1.4. 结构型模式 1.5. 行为型模式 2. 📚 资料 3. 🚪 传送",content:"# 设计模式概述\n\n> 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n\n# 1. 创建型模式\n\n\n# 1.1. 创建型模式简介\n\n创建型模式抽象了实例化的过程。它将系统与它的对象创建、结合、表示的方式分离。\n\n创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。\n\n在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。\n\n基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。\n\n创建型模式的指导思想是：\n\n * 将系统使用的具体类封装起来。\n * 隐藏这些具体类的实例创建和结合的方式。\n\n创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。\n\n * 对象创建型模式把对象创建的一部分推迟到另一个对象中。（代表模式：单例模式、建造者模式、原型模式、抽象工厂模式）\n * 类创建型模式将它对象的创建推迟到子类中。（代表模式：工厂方法模式）\n\n\n# 1.2. 创建型模式应用\n\n现代软件工程更加依赖对象的组合，而不是类的继承，强调从硬编码的行为转变到定义一组基本行为来组合成复杂的行为。\n\n硬编码的行为不够灵活，因为如果想要改变设计的一部分，需要通过重写或者重新实现才能完成。\n\n另外，硬编码没有提高重用性，而且难以跟踪错误。由于这些原因，创建型模式比硬编码的行为更有用。\n\n创建型模式使设计变得更灵活，提供了不同的方式，从代码中移除了对需要实例化的具体类的引用。换句话说，这些模式增强了对象和类之间的独立性。\n\n在以下情况中，可以考虑应用创建型模式：\n\n * 一个系统需要和它的对象和产品的创建相互独立。\n * 一组相关的对象被设计为一起使用。\n * 隐藏一个类库的具体实现，仅暴露它们的接口。\n * 创建独立复杂对象的不同表示。\n * 一个类希望它的子类实现它所创建的对象。\n * 类的实例化在运行时才指定。\n * 一个类只能有一个实例，而且这个实例能在任何时候访问到。\n * 实例应该能在不修改的情况下具有可扩展性。\n\n\n# 1.3. 创建型模式代表\n\n * 单例模式 (Singleton)\n * 简单工厂模式 (Simple Factory)\n * 工厂方法模式 (Factory Method)\n * 抽象工厂模式 (Abstract Factory)\n * 建造者模式 (Builder)\n * 原型模式 (Prototype)\n\n\n# 1.4. 结构型模式\n\n * 适配器模式 (Adapter)\n * 桥接模式 (Bridge)\n * 装饰模式 (Decorator)\n * 组合模式 (Composite)\n * 外观模式 (Facade)\n * 享元模式 (Flyweight)\n * 代理模式 (Proxy)\n\n\n# 1.5. 行为型模式\n\n * 模板方法模式 (Template Method)\n * 命令模式 (Command)\n * 迭代器模式 (Iterator)\n * 观察者模式 (Observer)\n * 解释器模式 (Interpreter)\n * 中介者模式 (Mediator)\n * 职责链模式 (Chain of Responsibility)\n * 备忘录模式 (Memento)\n * 策略模式 (Strategy)\n * 访问者模式 (Visitor)\n * 状态模式 (State)\n\n\n# 2. 📚 资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n\n\n# 3. 🚪 传送\n\n◾ 🏠 DESIGN 首页 ◾ 🎯 我的博客 ◾",normalizedContent:"# 设计模式概述\n\n> 设计模式（design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n\n# 1. 创建型模式\n\n\n# 1.1. 创建型模式简介\n\n创建型模式抽象了实例化的过程。它将系统与它的对象创建、结合、表示的方式分离。\n\n创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。\n\n在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。\n\n基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。\n\n创建型模式的指导思想是：\n\n * 将系统使用的具体类封装起来。\n * 隐藏这些具体类的实例创建和结合的方式。\n\n创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。\n\n * 对象创建型模式把对象创建的一部分推迟到另一个对象中。（代表模式：单例模式、建造者模式、原型模式、抽象工厂模式）\n * 类创建型模式将它对象的创建推迟到子类中。（代表模式：工厂方法模式）\n\n\n# 1.2. 创建型模式应用\n\n现代软件工程更加依赖对象的组合，而不是类的继承，强调从硬编码的行为转变到定义一组基本行为来组合成复杂的行为。\n\n硬编码的行为不够灵活，因为如果想要改变设计的一部分，需要通过重写或者重新实现才能完成。\n\n另外，硬编码没有提高重用性，而且难以跟踪错误。由于这些原因，创建型模式比硬编码的行为更有用。\n\n创建型模式使设计变得更灵活，提供了不同的方式，从代码中移除了对需要实例化的具体类的引用。换句话说，这些模式增强了对象和类之间的独立性。\n\n在以下情况中，可以考虑应用创建型模式：\n\n * 一个系统需要和它的对象和产品的创建相互独立。\n * 一组相关的对象被设计为一起使用。\n * 隐藏一个类库的具体实现，仅暴露它们的接口。\n * 创建独立复杂对象的不同表示。\n * 一个类希望它的子类实现它所创建的对象。\n * 类的实例化在运行时才指定。\n * 一个类只能有一个实例，而且这个实例能在任何时候访问到。\n * 实例应该能在不修改的情况下具有可扩展性。\n\n\n# 1.3. 创建型模式代表\n\n * 单例模式 (singleton)\n * 简单工厂模式 (simple factory)\n * 工厂方法模式 (factory method)\n * 抽象工厂模式 (abstract factory)\n * 建造者模式 (builder)\n * 原型模式 (prototype)\n\n\n# 1.4. 结构型模式\n\n * 适配器模式 (adapter)\n * 桥接模式 (bridge)\n * 装饰模式 (decorator)\n * 组合模式 (composite)\n * 外观模式 (facade)\n * 享元模式 (flyweight)\n * 代理模式 (proxy)\n\n\n# 1.5. 行为型模式\n\n * 模板方法模式 (template method)\n * 命令模式 (command)\n * 迭代器模式 (iterator)\n * 观察者模式 (observer)\n * 解释器模式 (interpreter)\n * 中介者模式 (mediator)\n * 职责链模式 (chain of responsibility)\n * 备忘录模式 (memento)\n * 策略模式 (strategy)\n * 访问者模式 (visitor)\n * 状态模式 (state)\n\n\n# 2. 📚 资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n\n\n# 3. 🚪 传送\n\n◾ 🏠 design 首页 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之简单工厂模式",frontmatter:{title:"设计模式之简单工厂模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-06-03T09:41:00.000Z",permalink:"/pages/4244b2/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/01.简单工厂模式.md",key:"v-13d9f031",path:"/pages/4244b2/",headers:[{level:2,title:"1. 简介",slug:"_1-简介",normalizedTitle:"1. 简介",charIndex:18},{level:3,title:"1.1. 简单工厂模式思想",slug:"_1-1-简单工厂模式思想",normalizedTitle:"1.1. 简单工厂模式思想",charIndex:28},{level:3,title:"1.2. 简单工厂模式要点",slug:"_1-2-简单工厂模式要点",normalizedTitle:"1.2. 简单工厂模式要点",charIndex:193},{level:2,title:"2. 实例",slug:"_2-实例",normalizedTitle:"2. 实例",charIndex:432},{level:2,title:"3. 参考资料",slug:"_3-参考资料",normalizedTitle:"3. 参考资料",charIndex:2540}],headersStr:"1. 简介 1.1. 简单工厂模式思想 1.2. 简单工厂模式要点 2. 实例 3. 参考资料",content:"# 设计模式之简单工厂模式\n\n\n# 1. 简介\n\n\n# 1.1. 简单工厂模式思想\n\n简单工厂模式 (Simple Factory) 又叫静态工厂方法（Static Factory Method）模式。\n\n简单工厂模式通常是定义一个工厂类，这个类可以根据不同变量返回不同类的产品实例。\n\n简单工厂模式是一种对象创建型模式。但是简单工厂模式不属于23 种 Gof 设计模式之一。\n\n\n# 1.2. 简单工厂模式要点\n\n优点：简单工厂模式的工厂类是整个模式的关键。其中包含了必要的逻辑判断，根据外部信息，决定究竟应该创建哪个具体类的对象。通过使用简单工厂模式，用户无需了解对象如何创建的，只要传入必要信息就可以了。\n\n缺点：工厂类集中了所有实例的创建逻辑，违背了高内聚责任分配原则。随着系统中具体产品类不断增多，势必要不断修改工厂类，不易维护和扩展。同时，这也违背了开放封闭原则。\n\n> 开放封闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n\n# 2. 实例\n\n如何实现一个具有加减乘除基本功能的计算器？\n\n对于这四种运算来说，都需要两个操作数，差别仅在于返回的结果不同。\n\n由此，我们可以抽象化它们的共性，提炼出一个父类。这个类中包含两个操作数，一个返回结果方法，这个方法期望在子类中得以实现。\n\n以下通过具体代码来说明。\n\n\n\n【Product (Operation) 】\n\n产品角色，简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。\n\n// Product角色，所有实例所共有的公共接口\nabstract class Operation {\n    public int numA;\n    public int numB;\n    public abstract int GetResult();\n}\n\n\n【ConcreteProduct 组】\n\n具体产品角色，实现 Product 中的接口。\n\n// ConcreteProduct 角色，实现 Product 中的接口\nclass Add extends Operation {\n    @Override\n    public int GetResult() {\n        return numA + numB;\n    }\n}\n\n//ConcreteProduct 角色，实现 Product 中的接口\nclass Sub extends Operation {\n    @Override\n    public int GetResult() {\n        return numA - numB;\n    }\n}\n\n//ConcreteProduct 角色，实现 Product 中的接口\nclass Mul extends Operation {\n    @Override\n    public int GetResult() {\n        return numA * numB;\n    }\n}\n\n//ConcreteProduct 角色，实现 Product 中的接口\nclass Div extends Operation {\n    @Override\n    public int GetResult() {\n        if (numB == 0) {\n            System.out.println(\"ERROR!\");\n            return -1;\n        }\n        return numA / numB;\n    }\n}\n\n\n【Factory (OperationFactory) 】\n\n工厂角色，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。\n\n// 工厂角色，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑\nclass OperationFactory {\n    public static Operation CreateOperation (char operate) {\n        Operation oper = null;\n        switch(operate) {\n        case '+':\n            oper = new Add();\n            break;\n        case '-':\n            oper = new Sub();\n            break;\n        case '*':\n            oper = new Mul();\n            break;\n        case '/':\n            oper = new Div();\n            break;\n        default:\n            break;\n        }\n        return oper;\n    }\n}\n\n\n【客户端】\n\npublic class SimpleFactoryPattern {\n    public static void main(String[] args) {\n        int numA = 10;\n        int numB = 3;\n        int result = 0;\n        Operation oper = OperationFactory.CreateOperation('+');\n        oper.numA = numA;\n        oper.numB = numB;\n        result = oper.GetResult();\n        System.out.println(numA + \" + \" + numB + \" = \" + result);\n    }\n}\n\n\n【输出】\n\n10 + 3 = 13\n\n\n\n# 3. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》",normalizedContent:"# 设计模式之简单工厂模式\n\n\n# 1. 简介\n\n\n# 1.1. 简单工厂模式思想\n\n简单工厂模式 (simple factory) 又叫静态工厂方法（static factory method）模式。\n\n简单工厂模式通常是定义一个工厂类，这个类可以根据不同变量返回不同类的产品实例。\n\n简单工厂模式是一种对象创建型模式。但是简单工厂模式不属于23 种 gof 设计模式之一。\n\n\n# 1.2. 简单工厂模式要点\n\n优点：简单工厂模式的工厂类是整个模式的关键。其中包含了必要的逻辑判断，根据外部信息，决定究竟应该创建哪个具体类的对象。通过使用简单工厂模式，用户无需了解对象如何创建的，只要传入必要信息就可以了。\n\n缺点：工厂类集中了所有实例的创建逻辑，违背了高内聚责任分配原则。随着系统中具体产品类不断增多，势必要不断修改工厂类，不易维护和扩展。同时，这也违背了开放封闭原则。\n\n> 开放封闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n\n# 2. 实例\n\n如何实现一个具有加减乘除基本功能的计算器？\n\n对于这四种运算来说，都需要两个操作数，差别仅在于返回的结果不同。\n\n由此，我们可以抽象化它们的共性，提炼出一个父类。这个类中包含两个操作数，一个返回结果方法，这个方法期望在子类中得以实现。\n\n以下通过具体代码来说明。\n\n\n\n【product (operation) 】\n\n产品角色，简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。\n\n// product角色，所有实例所共有的公共接口\nabstract class operation {\n    public int numa;\n    public int numb;\n    public abstract int getresult();\n}\n\n\n【concreteproduct 组】\n\n具体产品角色，实现 product 中的接口。\n\n// concreteproduct 角色，实现 product 中的接口\nclass add extends operation {\n    @override\n    public int getresult() {\n        return numa + numb;\n    }\n}\n\n//concreteproduct 角色，实现 product 中的接口\nclass sub extends operation {\n    @override\n    public int getresult() {\n        return numa - numb;\n    }\n}\n\n//concreteproduct 角色，实现 product 中的接口\nclass mul extends operation {\n    @override\n    public int getresult() {\n        return numa * numb;\n    }\n}\n\n//concreteproduct 角色，实现 product 中的接口\nclass div extends operation {\n    @override\n    public int getresult() {\n        if (numb == 0) {\n            system.out.println(\"error!\");\n            return -1;\n        }\n        return numa / numb;\n    }\n}\n\n\n【factory (operationfactory) 】\n\n工厂角色，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。\n\n// 工厂角色，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑\nclass operationfactory {\n    public static operation createoperation (char operate) {\n        operation oper = null;\n        switch(operate) {\n        case '+':\n            oper = new add();\n            break;\n        case '-':\n            oper = new sub();\n            break;\n        case '*':\n            oper = new mul();\n            break;\n        case '/':\n            oper = new div();\n            break;\n        default:\n            break;\n        }\n        return oper;\n    }\n}\n\n\n【客户端】\n\npublic class simplefactorypattern {\n    public static void main(string[] args) {\n        int numa = 10;\n        int numb = 3;\n        int result = 0;\n        operation oper = operationfactory.createoperation('+');\n        oper.numa = numa;\n        oper.numb = numb;\n        result = oper.getresult();\n        system.out.println(numa + \" + \" + numb + \" = \" + result);\n    }\n}\n\n\n【输出】\n\n10 + 3 = 13\n\n\n\n# 3. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之工厂方法模式",frontmatter:{title:"设计模式之工厂方法模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-06-03T10:03:00.000Z",permalink:"/pages/58cd12/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/02.工厂方法模式.md",key:"v-a097a3be",path:"/pages/58cd12/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:18},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:361},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:502},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:514},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:1004},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:1992},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:4077},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:5977},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:6301}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 案例 6. 与其他模式的关系 7. 参考资料",content:'# 设计模式之工厂方法模式\n\n\n# 1. 意图\n\n工厂方法模式 (Factory Method)是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 让子类决定实例化对象的类型。\n\n * 工厂模式中，增加一种产品类，就要增加一个工厂类：因为每个工厂类只能创建一种产品的实例。\n * 工厂模式遵循“开放-封闭原则”：工厂模式中，新增一种产品并不需要修改原有类，仅仅是扩展。\n\n简单工厂模式相比于工厂方法模式\n\n优点：工厂类中包含必要的逻辑判断，可根据客户端的选择条件动态实例化需要的类。对于客户端来说，去除了对具体产品的依赖。\n\n缺点：违背了开放封闭原则。 每添加一个新的产品，都需要对原有类进行修改。增加维护成本，且不易于维护。\n\n> 开放封闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n\n# 2. 适用场景\n\n * 当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。\n * 如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。\n * 如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 产品 （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。\n 2. 具体产品 （Concrete Products） 是产品接口的不同实现。\n 3. 创建者 （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。\n\n * 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。\n * 注意， 尽管它的名字是创建者， 但他最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。\n\n 4. 具体创建者 （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。 注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。\n\n\n# 3.2. 结构代码范式\n\n【Product】\n\n定义产品对象的接口。\n\nabstract class Product {\n    public abstract void use();\n}\n\n\n【ConcreteProduct】\n\n实现 Product 接口。\n\nclass ConcreteProduct extends Product {\n    public ConcreteProduct() {\n        System.out.println("创建 ConcreteProduct 产品");\n    }\n\n    @Override\n    public void Use() {\n        System.out.println("使用 ConcreteProduct 产品");\n    }\n}\n\n\n【Creator】\n\n声明工厂方法，它会返回一个产品类型的对象。 Creator 也可以实现一个默认的工厂方法 factoryMethod() ，以返回一个默认的具体产品类型。\n\ninterface Creator {\n    public Product factoryMethod();\n}\n\n\n【ConcreteCreator】\n\n覆写 Creator 中的工厂方法 factoryMethod() 。\n\nclass ConcreteCreator implements Creator {\n    @Override\n    public Product factoryMethod() {\n        return new ConcreteProduct();\n    }\n}\n\n\n【客户端】\n\npublic class factoryMethodPattern {\n    public static void main(String[] args) {\n        Creator factory = new ConcreteCreator();\n        Product product = factory.factoryMethod();\n        product.Use();\n    }\n}\n\n\n【输出】\n\n创建 ConcreteProduct 产品\n使用 ConcreteProduct 产品\n\n\n\n# 4. 伪代码\n\n以下示例演示了如何使用工厂方法开发跨平台 UI （用户界面） 组件， 并同时避免客户代码与具体 UI 类之间的耦合。\n\n\n\n基础对话框类使用不同的 UI 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 Windows 系统中的按钮在 Linux 系统中仍然是按钮。\n\n如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 Windows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 Windows 样式渲染按钮。\n\n如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。\n\n你可以使用此方法开发其他 UI 组件。 不过， 每向对话框中添加一个新的工厂方法， 你就离抽象工厂模式更近一步。 我们将在稍后谈到这个模式。\n\n// 创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供\n// 该方法的实现。\nclass Dialog is\n    // 创建者还可提供一些工厂方法的默认实现。\n    abstract method createButton():Button\n\n    // 请注意，创建者的主要职责并非是创建产品。其中通常会包含一些核心业务\n    // 逻辑，这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方\n    // 法并使其返回不同类型的产品来间接修改业务逻辑。\n    method render() is\n        // 调用工厂方法创建一个产品对象。\n        Button okButton = createButton()\n        // 现在使用产品。\n        okButton.onClick(closeDialog)\n        okButton.render()\n\n\n// 具体创建者将重写工厂方法以改变其所返回的产品类型。\nclass WindowsDialog extends Dialog is\n    method createButton():Button is\n        return new WindowsButton()\n\nclass WebDialog extends Dialog is\n    method createButton():Button is\n        return new HTMLButton()\n\n\n// 产品接口中将声明所有具体产品都必须实现的操作。\ninterface Button is\n    method render()\n    method onClick(f)\n\n// 具体产品需提供产品接口的各种实现。\nclass WindowsButton implements Button is\n    method render(a, b) is\n        // 根据 Windows 样式渲染按钮。\n    method onClick(f) is\n        // 绑定本地操作系统点击事件。\n\nclass HTMLButton implements Button is\n    method render(a, b) is\n        // 返回一个按钮的 HTML 表述。\n    method onClick(f) is\n        // 绑定网络浏览器的点击事件。\n\n\nclass Application is\n    field dialog: Dialog\n\n    // 程序根据当前配置或环境设定选择创建者的类型。\n    method initialize() is\n        config = readApplicationConfigFile()\n\n        if (config.OS == "Windows") then\n            dialog = new WindowsDialog()\n        else if (config.OS == "Web") then\n            dialog = new WebDialog()\n        else\n            throw new Exception("错误！未知的操作系统。")\n\n    // 当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口\n    // 进行。只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子\n    // 类传递给客户端。\n    method main() is\n        this.initialize()\n        dialog.render()\n\n\n\n# 5. 案例\n\n使用示例： 工厂方法模式在 Java 代码中得到了广泛使用。 当你需要在代码中提供高层次的灵活性时， 该模式会非常实用。\n\n核心 Java 程序库中有该模式的应用：\n\n * java.util.Calendar#getInstance()\n * java.util.ResourceBundle#getBundle()\n * java.text.NumberFormat#getInstance()\n * java.nio.charset.Charset#forName()\n * java.net.URLStreamHandlerFactory#createURLStreamHandler(String) （根据协议返回不同的单例对象）\n * java.util.EnumSet#of()\n * javax.xml.bind.JAXBContext#createMarshaller() 及其他类似的方法。\n\n识别方法： 工厂方法可通过构建方法来识别， 它会创建具体类的对象， 但以抽象类型或接口的形式返回这些对象。\n\n还是以 简单工厂模式 里的例子来进行说明。\n\n如何实现一个具有加减乘除基本功能的计算器？\n\n两种模式的 Product 和 ConcreteProduct 角色代码没有区别，不再赘述。\n\n差异在于 Factory 角色部分，以及客户端部分，请在代码中体会。\n\n【Creator 角色】\n\n// Creator 角色，定义返回产品实例的公共工厂方法\ninterface OperationFactory {\n    public Operation factoryMethod();\n}\n\n\n【ConcreteCreator 角色】\n\n和简单工厂模式相比，每一种产品都会有一个具体的工厂类负责生产实例。\n\n// ConcreteCreator 角色，具体实现 Creator 中的方法\nclass AddFactory implements OperationFactory {\n    @Override\n    public Operation factoryMethod() {\n        return new Add();\n    }\n}\n\n// ConcreteCreator 角色，具体实现 Creator 中的方法\nclass SubFactory implements OperationFactory {\n    @Override\n    public Operation factoryMethod() {\n        return new Sub();\n    }\n}\n\n// ConcreteCreator 角色，具体实现 Creator 中的方法\nclass MulFactory implements OperationFactory {\n    @Override\n    public Operation factoryMethod() {\n        return new Mul();\n    }\n}\n\n// ConcreteCreator 角色，具体实现 Creator 中的方法\nclass DivFactory implements OperationFactory {\n    @Override\n    public Operation factoryMethod() {\n        return new Div();\n    }\n}\n\n\n【Client 角色】\n\n与简单工厂模式中无需关注具体创建不同，工厂模式中需要指定具体工厂，以负责生产具体对应的产品。\n\n// Client 角色，需要指定具体工厂，以负责生产具体产品\npublic class factoryMethodPattern {\n    public static void main(String[] args) {\n        OperationFactory factory = new SubFactory();\n        Operation oper = factory.factoryMethod();\n        oper.numA = 3;\n        oper.numB = 2;\n        double result = oper.getResult();\n        System.out.println("result = " + result);\n    }\n}\n\n\n\n# 6. 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。\n * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。\n * 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。\n * 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。\n * 工厂方法是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之工厂方法模式\n\n\n# 1. 意图\n\n工厂方法模式 (factory method)是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 让子类决定实例化对象的类型。\n\n * 工厂模式中，增加一种产品类，就要增加一个工厂类：因为每个工厂类只能创建一种产品的实例。\n * 工厂模式遵循“开放-封闭原则”：工厂模式中，新增一种产品并不需要修改原有类，仅仅是扩展。\n\n简单工厂模式相比于工厂方法模式\n\n优点：工厂类中包含必要的逻辑判断，可根据客户端的选择条件动态实例化需要的类。对于客户端来说，去除了对具体产品的依赖。\n\n缺点：违背了开放封闭原则。 每添加一个新的产品，都需要对原有类进行修改。增加维护成本，且不易于维护。\n\n> 开放封闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。\n\n\n# 2. 适用场景\n\n * 当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。\n * 如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。\n * 如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 产品 （product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。\n 2. 具体产品 （concrete products） 是产品接口的不同实现。\n 3. 创建者 （creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。\n\n * 你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。\n * 注意， 尽管它的名字是创建者， 但他最主要的职责并不是创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。\n\n 4. 具体创建者 （concrete creators） 将会重写基础工厂方法， 使其返回不同类型的产品。 注意， 并不一定每次调用工厂方法都会创建新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。\n\n\n# 3.2. 结构代码范式\n\n【product】\n\n定义产品对象的接口。\n\nabstract class product {\n    public abstract void use();\n}\n\n\n【concreteproduct】\n\n实现 product 接口。\n\nclass concreteproduct extends product {\n    public concreteproduct() {\n        system.out.println("创建 concreteproduct 产品");\n    }\n\n    @override\n    public void use() {\n        system.out.println("使用 concreteproduct 产品");\n    }\n}\n\n\n【creator】\n\n声明工厂方法，它会返回一个产品类型的对象。 creator 也可以实现一个默认的工厂方法 factorymethod() ，以返回一个默认的具体产品类型。\n\ninterface creator {\n    public product factorymethod();\n}\n\n\n【concretecreator】\n\n覆写 creator 中的工厂方法 factorymethod() 。\n\nclass concretecreator implements creator {\n    @override\n    public product factorymethod() {\n        return new concreteproduct();\n    }\n}\n\n\n【客户端】\n\npublic class factorymethodpattern {\n    public static void main(string[] args) {\n        creator factory = new concretecreator();\n        product product = factory.factorymethod();\n        product.use();\n    }\n}\n\n\n【输出】\n\n创建 concreteproduct 产品\n使用 concreteproduct 产品\n\n\n\n# 4. 伪代码\n\n以下示例演示了如何使用工厂方法开发跨平台 ui （用户界面） 组件， 并同时避免客户代码与具体 ui 类之间的耦合。\n\n\n\n基础对话框类使用不同的 ui 组件渲染窗口。 在不同的操作系统下， 这些组件外观或许略有不同， 但其功能保持一致。 windows 系统中的按钮在 linux 系统中仍然是按钮。\n\n如果使用工厂方法， 就不需要为每种操作系统重写对话框逻辑。 如果我们声明了一个在基本对话框类中生成按钮的工厂方法， 那么我们就可以创建一个对话框子类， 并使其通过工厂方法返回 windows 样式按钮。 子类将继承对话框基础类的大部分代码， 同时在屏幕上根据 windows 样式渲染按钮。\n\n如需该模式正常工作， 基础对话框类必须使用抽象按钮 （例如基类或接口）， 以便将其扩展为具体按钮。 这样一来， 无论对话框中使用何种类型的按钮， 其代码都可以正常工作。\n\n你可以使用此方法开发其他 ui 组件。 不过， 每向对话框中添加一个新的工厂方法， 你就离抽象工厂模式更近一步。 我们将在稍后谈到这个模式。\n\n// 创建者类声明的工厂方法必须返回一个产品类的对象。创建者的子类通常会提供\n// 该方法的实现。\nclass dialog is\n    // 创建者还可提供一些工厂方法的默认实现。\n    abstract method createbutton():button\n\n    // 请注意，创建者的主要职责并非是创建产品。其中通常会包含一些核心业务\n    // 逻辑，这些逻辑依赖于由工厂方法返回的产品对象。子类可通过重写工厂方\n    // 法并使其返回不同类型的产品来间接修改业务逻辑。\n    method render() is\n        // 调用工厂方法创建一个产品对象。\n        button okbutton = createbutton()\n        // 现在使用产品。\n        okbutton.onclick(closedialog)\n        okbutton.render()\n\n\n// 具体创建者将重写工厂方法以改变其所返回的产品类型。\nclass windowsdialog extends dialog is\n    method createbutton():button is\n        return new windowsbutton()\n\nclass webdialog extends dialog is\n    method createbutton():button is\n        return new htmlbutton()\n\n\n// 产品接口中将声明所有具体产品都必须实现的操作。\ninterface button is\n    method render()\n    method onclick(f)\n\n// 具体产品需提供产品接口的各种实现。\nclass windowsbutton implements button is\n    method render(a, b) is\n        // 根据 windows 样式渲染按钮。\n    method onclick(f) is\n        // 绑定本地操作系统点击事件。\n\nclass htmlbutton implements button is\n    method render(a, b) is\n        // 返回一个按钮的 html 表述。\n    method onclick(f) is\n        // 绑定网络浏览器的点击事件。\n\n\nclass application is\n    field dialog: dialog\n\n    // 程序根据当前配置或环境设定选择创建者的类型。\n    method initialize() is\n        config = readapplicationconfigfile()\n\n        if (config.os == "windows") then\n            dialog = new windowsdialog()\n        else if (config.os == "web") then\n            dialog = new webdialog()\n        else\n            throw new exception("错误！未知的操作系统。")\n\n    // 当前客户端代码会与具体创建者的实例进行交互，但是必须通过其基本接口\n    // 进行。只要客户端通过基本接口与创建者进行交互，你就可将任何创建者子\n    // 类传递给客户端。\n    method main() is\n        this.initialize()\n        dialog.render()\n\n\n\n# 5. 案例\n\n使用示例： 工厂方法模式在 java 代码中得到了广泛使用。 当你需要在代码中提供高层次的灵活性时， 该模式会非常实用。\n\n核心 java 程序库中有该模式的应用：\n\n * java.util.calendar#getinstance()\n * java.util.resourcebundle#getbundle()\n * java.text.numberformat#getinstance()\n * java.nio.charset.charset#forname()\n * java.net.urlstreamhandlerfactory#createurlstreamhandler(string) （根据协议返回不同的单例对象）\n * java.util.enumset#of()\n * javax.xml.bind.jaxbcontext#createmarshaller() 及其他类似的方法。\n\n识别方法： 工厂方法可通过构建方法来识别， 它会创建具体类的对象， 但以抽象类型或接口的形式返回这些对象。\n\n还是以 简单工厂模式 里的例子来进行说明。\n\n如何实现一个具有加减乘除基本功能的计算器？\n\n两种模式的 product 和 concreteproduct 角色代码没有区别，不再赘述。\n\n差异在于 factory 角色部分，以及客户端部分，请在代码中体会。\n\n【creator 角色】\n\n// creator 角色，定义返回产品实例的公共工厂方法\ninterface operationfactory {\n    public operation factorymethod();\n}\n\n\n【concretecreator 角色】\n\n和简单工厂模式相比，每一种产品都会有一个具体的工厂类负责生产实例。\n\n// concretecreator 角色，具体实现 creator 中的方法\nclass addfactory implements operationfactory {\n    @override\n    public operation factorymethod() {\n        return new add();\n    }\n}\n\n// concretecreator 角色，具体实现 creator 中的方法\nclass subfactory implements operationfactory {\n    @override\n    public operation factorymethod() {\n        return new sub();\n    }\n}\n\n// concretecreator 角色，具体实现 creator 中的方法\nclass mulfactory implements operationfactory {\n    @override\n    public operation factorymethod() {\n        return new mul();\n    }\n}\n\n// concretecreator 角色，具体实现 creator 中的方法\nclass divfactory implements operationfactory {\n    @override\n    public operation factorymethod() {\n        return new div();\n    }\n}\n\n\n【client 角色】\n\n与简单工厂模式中无需关注具体创建不同，工厂模式中需要指定具体工厂，以负责生产具体对应的产品。\n\n// client 角色，需要指定具体工厂，以负责生产具体产品\npublic class factorymethodpattern {\n    public static void main(string[] args) {\n        operationfactory factory = new subfactory();\n        operation oper = factory.factorymethod();\n        oper.numa = 3;\n        oper.numb = 2;\n        double result = oper.getresult();\n        system.out.println("result = " + result);\n    }\n}\n\n\n\n# 6. 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。\n * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。\n * 你可以同时使用工厂方法和迭代器模式来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。\n * 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。\n * 工厂方法是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之抽象工厂模式",frontmatter:{title:"设计模式之抽象工厂模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-06-03T10:26:00.000Z",permalink:"/pages/d40cbb/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/03.抽象工厂模式.md",key:"v-3a239cb0",path:"/pages/d40cbb/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:18},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:517},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:650},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:662},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:1055},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:3369},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:5966},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:8039},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:8436}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 案例 6. 与其他模式的关系 7. 参考资料",content:'# 设计模式之抽象工厂模式\n\n\n# 1. 意图\n\n抽象工厂模式 （Abstract Factory）是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。\n\n**优点 **\n\n * 抽象工厂模式隔离了具体类的生成，用户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需要改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。\n\n * 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。\n\n * 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开放封闭原则”。\n\n缺点\n\n * 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。\n\n\n# 2. 适用场景\n\n抽象工厂模式适用场景：\n\n一个系统要独立于它的产品的创建、组合和表示时。\n\n一个系统要由多个产品系列中的一个来配置时。\n\n当你要强调一系列相关的产品对象的设计以便进行联合使用时。\n\n当你提供一个产品类库，而只想显示它们的接口而不是实现时。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 抽象产品 （Abstract Product） 为构成系列产品的一组不同但相关的产品声明接口。\n 2. 具体产品 （Concrete Product） 是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。\n 3. 抽象工厂 （Abstract Factory） 接口声明了一组创建各种抽象产品的方法。\n 4. 具体工厂 （Concrete Factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。\n 5. 尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的抽象产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 客户端 （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。\n\n\n# 3.2. 结构代码范式\n\n【AbstractProduct】\n\n声明一个接口，这个接口中包含产品对象类型。\n\nabstract class AbstractProductA {\n    public abstract void show();\n}\n\nabstract class AbstractProductB {\n    public abstract void show();\n}\n\n\n【ConcreteProduct】\n\n定义一个产品对象，这个产品对象是由相关的具体工厂创建的。\n\nclass ConcreteProductA1 extends AbstractProductA {\n    @Override\n    public void show() {\n        System.out.println("ConcreteProductA1");\n    }\n}\n\nclass ConcreteProductA2 extends AbstractProductA {\n    @Override\n    public void show() {\n        System.out.println("ConcreteProductA2");\n    }\n}\n\nclass ConcreteProductB1 extends AbstractProductB {\n    @Override\n    public void show() {\n        System.out.println("ConcreteProductB1");\n    }\n}\n\nclass ConcreteProductB2 extends AbstractProductB {\n    @Override\n    public void show() {\n        System.out.println("ConcreteProductB2");\n    }\n}\n\n\n【AbstractFactory】\n\n声明一个接口，这个接口中包含创建抽象产品对象的方法。\n\nabstract class AbstractFactory {\n    public abstract AbstractProductA createProductA();\n    public abstract AbstractProductB createProductB();\n}\n\n\n【ConcreteFactory】\n\n实现创建具体产品对象的方法。\n\nclass ConcreteFactory1 extends AbstractFactory {\n    @Override\n    public AbstractProductA createProductA() {\n        return new ConcreteProductA1();\n    }\n\n    @Override\n    public AbstractProductB createProductB() {\n        return new ConcreteProductB1();\n    }\n}\n\nclass ConcreteFactory2 extends AbstractFactory {\n    @Override\n    public AbstractProductA createProductA() {\n        return new ConcreteProductA2();\n    }\n\n    @Override\n    public AbstractProductB createProductB() {\n        return new ConcreteProductB2();\n    }\n}\n\n\n【客户端】\n\n只使用 AbstractFactory 和 AbstractProduct 声明的接口。\n\npublic class AbstarctFactoryPattern {\n    public static void main(String[] args) {\n        AbstractFactory  factory1  = new ConcreteFactory1();\n        AbstractProductA productA1 = factory1.createProductA();\n        AbstractProductB productB1 = factory1.createProductB();\n        productA1.show();\n        productB1.show();\n\n        AbstractFactory  factory2  = new ConcreteFactory2();\n        AbstractProductA productA2 = factory2.createProductA();\n        AbstractProductB productB2 = factory2.createProductB();\n        productA2.show();\n        productB2.show();\n    }\n}\n\n\n【输出】\n\nConcreteProductA1\nConcreteProductB1\nConcreteProductA2\nConcreteProductB2\n\n\n\n# 4. 伪代码\n\n下面例子通过应用抽象工厂模式， 使得客户端代码无需与具体 UI 类耦合， 就能创建跨平台的 UI 元素， 同时确保所创建的元素与指定的操作系统匹配。\n\n\n\n跨平台应用中的相同 UI 元素功能类似， 但是在不同操作系统下的外观有一定差异。 此外， 你需要确保 UI 元素与当前操作系统风格一致。 你一定不希望在 Windows 系统下运行的应用程序中显示 macOS 的控件。\n\n抽象工厂接口声明一系列构建方法， 客户端代码可调用它们生成不同风格的 UI 元素。 每个具体工厂对应特定操作系统， 并负责生成符合该操作系统风格的 UI 元素。\n\n其运作方式如下： 应用程序启动后检测当前操作系统。 根据该信息， 应用程序通过与该操作系统对应的类创建工厂对象。 其余代码使用该工厂对象创建 UI 元素。 这样可以避免生成错误类型的元素。\n\n使用这种方法， 客户端代码只需调用抽象接口， 而无需了解具体工厂类和 UI 元素。 此外， 客户端代码还支持未来添加新的工厂或 UI 元素。\n\n这样一来， 每次在应用程序中添加新的 UI 元素变体时， 你都无需修改客户端代码。 你只需创建一个能够生成这些 UI 元素的工厂类， 然后稍微修改应用程序的初始代码， 使其能够选择合适的工厂类即可。\n\n// 抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列\n// 且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产\n// 品可有多个变体，但不同变体的产品不能搭配使用。\ninterface GUIFactory is\n    method createButton():Button\n    method createCheckbox():Checkbox\n\n\n// 具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配\n// 使用。具体工厂方法签名会返回一个抽象产品，但在方法内部则会对具体产品进\n// 行实例化。\nclass WinFactory implements GUIFactory is\n    method createButton():Button is\n        return new WinButton()\n    method createCheckbox():Checkbox is\n        return new WinCheckbox()\n\n// 每个具体工厂中都会包含一个相应的产品变体。\nclass MacFactory implements GUIFactory is\n    method createButton():Button is\n        return new MacButton()\n    method createCheckbox():Checkbox is\n        return new MacCheckbox()\n\n\n// 系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口。\ninterface Button is\n    method paint()\n\n// 具体产品由相应的具体工厂创建。\nclass WinButton implements Button is\n    method paint() is\n        // 根据 Windows 样式渲染按钮。\n\nclass MacButton implements Button is\n    method paint() is\n        // 根据 macOS 样式渲染按钮\n\n// 这是另一个产品的基础接口。所有产品都可以互动，但是只有相同具体变体的产\n// 品之间才能够正确地进行交互。\ninterface Checkbox is\n    method paint()\n\nclass WinCheckbox implements Checkbox is\n    method paint() is\n        // 根据 Windows 样式渲染复选框。\n\nclass MacCheckbox implements Checkbox is\n    method paint() is\n        // 根据 macOS 样式渲染复选框。\n\n// 客户端代码仅通过抽象类型（GUIFactory、Button 和 Checkbox）使用工厂\n// 和产品。这让你无需修改任何工厂或产品子类就能将其传递给客户端代码。\nclass Application is\n    private field factory: GUIFactory\n    private field button: Button\n    constructor Application(factory: GUIFactory) is\n        this.factory = factory\n    method createUI() is\n        this.button = factory.createButton()\n    method paint() is\n        button.paint()\n\n\n// 程序会根据当前配置或环境设定选择工厂类型，并在运行时创建工厂（通常在初\n// 始化阶段）。\nclass ApplicationConfigurator is\n    method main() is\n        config = readApplicationConfigFile()\n\n        if (config.OS == "Windows") then\n            factory = new WinFactory()\n        else if (config.OS == "Mac") then\n            factory = new MacFactory()\n        else\n            throw new Exception("错误！未知的操作系统。")\n\n        Application app = new Application(factory)\n\n\n\n# 5. 案例\n\n众所周知，苹果和三星这两家世界级的电子产品厂商都生产手机和电脑。\n\n我们以生产手机和电脑为例，演示一下抽象工厂模式的应用\n\n【AbstractProduct 角色】\n\n首先，定义手机和电脑两个抽象接口，他们都有各自的产品信息。\n\ninterface Telephone {\n    public String getProductInfo();\n}\n\ninterface Computer {\n    public String getProductInfo();\n}\n\n\n【ConcreteProduct 角色】\n\nConcreteProduct 根据 AbstractProduct 来定义具体的产品属性、方法。\n\n在我们的例子中，苹果、三星两家公司的手机和电脑都有各自的具体产品信息。\n\nclass AppleTelephone implements Telephone {\n\n    @Override\n    public String getProductInfo() {\n        return "苹果手机，采用ios系统";\n    }\n}\n\nclass SamsungTelephone implements Telephone {\n\n    @Override\n    public String getProductInfo() {\n        return "三星手机，采用android系统";\n    }\n}\n\nclass AppleComputer implements Computer {\n\n    @Override\n    public String getProductInfo() {\n        return "苹果电脑，采用mac系统";\n    }\n}\n\nclass SamsungComputer implements Computer {\n\n    @Override\n    public String getProductInfo() {\n        return "三星电脑，采用windows系统";\n    }\n}\n\n\n【AbstractFactory 角色】\n\n苹果，三星这两个厂商都生产手机和电脑。所以它们可以有一个抽象父类或父接口，提供生产手机和生产电脑的方法。\n\ninterface ElectronicFactory {\n\n    public Telephone produceTelephone();\n\n    public Computer produceComputer();\n}\n\n\n【ConcreteFactory 角色】\n\n苹果、三星工厂分别实现父接口，生产不同类型的产品。\n\nclass AppleFactory implements ElectronicFactory {\n\n    @Override\n    public Telephone produceTelephone() {\n        return new AppleTelephone();\n    }\n\n    @Override\n    public Computer produceComputer() {\n        return new AppleComputer();\n    }\n}\n\nclass SamsungFactory implements ElectronicFactory {\n\n    @Override\n    public Telephone produceTelephone() {\n        return new SamsungTelephone();\n    }\n\n    @Override\n    public Computer produceComputer() {\n        return new SamsungComputer();\n    }\n}\n\n\n【客户端】\n\npublic class PhoneFactoryDemo {\n    public static void main(String[] args) {\n        ElectronicFactory appleFactory = new AppleFactory();\n        Telephone phone = appleFactory.produceTelephone();\n        System.out.println(phone.getProductInfo());\n        Computer computer = appleFactory.produceComputer();\n        System.out.println(computer.getProductInfo());\n    }\n}\n\n\n【输出】\n\n苹果手机，采用ios系统\n苹果电脑，采用mac系统\n\n\n\n# 6. 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。\n * 生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。\n * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。\n * 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替外观模式。\n * 你可以将抽象工厂和桥接模式搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。\n * 抽象工厂、 生成器和原型都可以用单例模式来实现。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之抽象工厂模式\n\n\n# 1. 意图\n\n抽象工厂模式 （abstract factory）是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。\n\n**优点 **\n\n * 抽象工厂模式隔离了具体类的生成，用户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需要改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。\n\n * 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。\n\n * 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开放封闭原则”。\n\n缺点\n\n * 在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。\n\n\n# 2. 适用场景\n\n抽象工厂模式适用场景：\n\n一个系统要独立于它的产品的创建、组合和表示时。\n\n一个系统要由多个产品系列中的一个来配置时。\n\n当你要强调一系列相关的产品对象的设计以便进行联合使用时。\n\n当你提供一个产品类库，而只想显示它们的接口而不是实现时。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 抽象产品 （abstract product） 为构成系列产品的一组不同但相关的产品声明接口。\n 2. 具体产品 （concrete product） 是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。\n 3. 抽象工厂 （abstract factory） 接口声明了一组创建各种抽象产品的方法。\n 4. 具体工厂 （concrete factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。\n 5. 尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的抽象产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 客户端 （client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。\n\n\n# 3.2. 结构代码范式\n\n【abstractproduct】\n\n声明一个接口，这个接口中包含产品对象类型。\n\nabstract class abstractproducta {\n    public abstract void show();\n}\n\nabstract class abstractproductb {\n    public abstract void show();\n}\n\n\n【concreteproduct】\n\n定义一个产品对象，这个产品对象是由相关的具体工厂创建的。\n\nclass concreteproducta1 extends abstractproducta {\n    @override\n    public void show() {\n        system.out.println("concreteproducta1");\n    }\n}\n\nclass concreteproducta2 extends abstractproducta {\n    @override\n    public void show() {\n        system.out.println("concreteproducta2");\n    }\n}\n\nclass concreteproductb1 extends abstractproductb {\n    @override\n    public void show() {\n        system.out.println("concreteproductb1");\n    }\n}\n\nclass concreteproductb2 extends abstractproductb {\n    @override\n    public void show() {\n        system.out.println("concreteproductb2");\n    }\n}\n\n\n【abstractfactory】\n\n声明一个接口，这个接口中包含创建抽象产品对象的方法。\n\nabstract class abstractfactory {\n    public abstract abstractproducta createproducta();\n    public abstract abstractproductb createproductb();\n}\n\n\n【concretefactory】\n\n实现创建具体产品对象的方法。\n\nclass concretefactory1 extends abstractfactory {\n    @override\n    public abstractproducta createproducta() {\n        return new concreteproducta1();\n    }\n\n    @override\n    public abstractproductb createproductb() {\n        return new concreteproductb1();\n    }\n}\n\nclass concretefactory2 extends abstractfactory {\n    @override\n    public abstractproducta createproducta() {\n        return new concreteproducta2();\n    }\n\n    @override\n    public abstractproductb createproductb() {\n        return new concreteproductb2();\n    }\n}\n\n\n【客户端】\n\n只使用 abstractfactory 和 abstractproduct 声明的接口。\n\npublic class abstarctfactorypattern {\n    public static void main(string[] args) {\n        abstractfactory  factory1  = new concretefactory1();\n        abstractproducta producta1 = factory1.createproducta();\n        abstractproductb productb1 = factory1.createproductb();\n        producta1.show();\n        productb1.show();\n\n        abstractfactory  factory2  = new concretefactory2();\n        abstractproducta producta2 = factory2.createproducta();\n        abstractproductb productb2 = factory2.createproductb();\n        producta2.show();\n        productb2.show();\n    }\n}\n\n\n【输出】\n\nconcreteproducta1\nconcreteproductb1\nconcreteproducta2\nconcreteproductb2\n\n\n\n# 4. 伪代码\n\n下面例子通过应用抽象工厂模式， 使得客户端代码无需与具体 ui 类耦合， 就能创建跨平台的 ui 元素， 同时确保所创建的元素与指定的操作系统匹配。\n\n\n\n跨平台应用中的相同 ui 元素功能类似， 但是在不同操作系统下的外观有一定差异。 此外， 你需要确保 ui 元素与当前操作系统风格一致。 你一定不希望在 windows 系统下运行的应用程序中显示 macos 的控件。\n\n抽象工厂接口声明一系列构建方法， 客户端代码可调用它们生成不同风格的 ui 元素。 每个具体工厂对应特定操作系统， 并负责生成符合该操作系统风格的 ui 元素。\n\n其运作方式如下： 应用程序启动后检测当前操作系统。 根据该信息， 应用程序通过与该操作系统对应的类创建工厂对象。 其余代码使用该工厂对象创建 ui 元素。 这样可以避免生成错误类型的元素。\n\n使用这种方法， 客户端代码只需调用抽象接口， 而无需了解具体工厂类和 ui 元素。 此外， 客户端代码还支持未来添加新的工厂或 ui 元素。\n\n这样一来， 每次在应用程序中添加新的 ui 元素变体时， 你都无需修改客户端代码。 你只需创建一个能够生成这些 ui 元素的工厂类， 然后稍微修改应用程序的初始代码， 使其能够选择合适的工厂类即可。\n\n// 抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列\n// 且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产\n// 品可有多个变体，但不同变体的产品不能搭配使用。\ninterface guifactory is\n    method createbutton():button\n    method createcheckbox():checkbox\n\n\n// 具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配\n// 使用。具体工厂方法签名会返回一个抽象产品，但在方法内部则会对具体产品进\n// 行实例化。\nclass winfactory implements guifactory is\n    method createbutton():button is\n        return new winbutton()\n    method createcheckbox():checkbox is\n        return new wincheckbox()\n\n// 每个具体工厂中都会包含一个相应的产品变体。\nclass macfactory implements guifactory is\n    method createbutton():button is\n        return new macbutton()\n    method createcheckbox():checkbox is\n        return new maccheckbox()\n\n\n// 系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口。\ninterface button is\n    method paint()\n\n// 具体产品由相应的具体工厂创建。\nclass winbutton implements button is\n    method paint() is\n        // 根据 windows 样式渲染按钮。\n\nclass macbutton implements button is\n    method paint() is\n        // 根据 macos 样式渲染按钮\n\n// 这是另一个产品的基础接口。所有产品都可以互动，但是只有相同具体变体的产\n// 品之间才能够正确地进行交互。\ninterface checkbox is\n    method paint()\n\nclass wincheckbox implements checkbox is\n    method paint() is\n        // 根据 windows 样式渲染复选框。\n\nclass maccheckbox implements checkbox is\n    method paint() is\n        // 根据 macos 样式渲染复选框。\n\n// 客户端代码仅通过抽象类型（guifactory、button 和 checkbox）使用工厂\n// 和产品。这让你无需修改任何工厂或产品子类就能将其传递给客户端代码。\nclass application is\n    private field factory: guifactory\n    private field button: button\n    constructor application(factory: guifactory) is\n        this.factory = factory\n    method createui() is\n        this.button = factory.createbutton()\n    method paint() is\n        button.paint()\n\n\n// 程序会根据当前配置或环境设定选择工厂类型，并在运行时创建工厂（通常在初\n// 始化阶段）。\nclass applicationconfigurator is\n    method main() is\n        config = readapplicationconfigfile()\n\n        if (config.os == "windows") then\n            factory = new winfactory()\n        else if (config.os == "mac") then\n            factory = new macfactory()\n        else\n            throw new exception("错误！未知的操作系统。")\n\n        application app = new application(factory)\n\n\n\n# 5. 案例\n\n众所周知，苹果和三星这两家世界级的电子产品厂商都生产手机和电脑。\n\n我们以生产手机和电脑为例，演示一下抽象工厂模式的应用\n\n【abstractproduct 角色】\n\n首先，定义手机和电脑两个抽象接口，他们都有各自的产品信息。\n\ninterface telephone {\n    public string getproductinfo();\n}\n\ninterface computer {\n    public string getproductinfo();\n}\n\n\n【concreteproduct 角色】\n\nconcreteproduct 根据 abstractproduct 来定义具体的产品属性、方法。\n\n在我们的例子中，苹果、三星两家公司的手机和电脑都有各自的具体产品信息。\n\nclass appletelephone implements telephone {\n\n    @override\n    public string getproductinfo() {\n        return "苹果手机，采用ios系统";\n    }\n}\n\nclass samsungtelephone implements telephone {\n\n    @override\n    public string getproductinfo() {\n        return "三星手机，采用android系统";\n    }\n}\n\nclass applecomputer implements computer {\n\n    @override\n    public string getproductinfo() {\n        return "苹果电脑，采用mac系统";\n    }\n}\n\nclass samsungcomputer implements computer {\n\n    @override\n    public string getproductinfo() {\n        return "三星电脑，采用windows系统";\n    }\n}\n\n\n【abstractfactory 角色】\n\n苹果，三星这两个厂商都生产手机和电脑。所以它们可以有一个抽象父类或父接口，提供生产手机和生产电脑的方法。\n\ninterface electronicfactory {\n\n    public telephone producetelephone();\n\n    public computer producecomputer();\n}\n\n\n【concretefactory 角色】\n\n苹果、三星工厂分别实现父接口，生产不同类型的产品。\n\nclass applefactory implements electronicfactory {\n\n    @override\n    public telephone producetelephone() {\n        return new appletelephone();\n    }\n\n    @override\n    public computer producecomputer() {\n        return new applecomputer();\n    }\n}\n\nclass samsungfactory implements electronicfactory {\n\n    @override\n    public telephone producetelephone() {\n        return new samsungtelephone();\n    }\n\n    @override\n    public computer producecomputer() {\n        return new samsungcomputer();\n    }\n}\n\n\n【客户端】\n\npublic class phonefactorydemo {\n    public static void main(string[] args) {\n        electronicfactory applefactory = new applefactory();\n        telephone phone = applefactory.producetelephone();\n        system.out.println(phone.getproductinfo());\n        computer computer = applefactory.producecomputer();\n        system.out.println(computer.getproductinfo());\n    }\n}\n\n\n【输出】\n\n苹果手机，采用ios系统\n苹果电脑，采用mac系统\n\n\n\n# 6. 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。\n * 生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。\n * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。\n * 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂来代替外观模式。\n * 你可以将抽象工厂和桥接模式搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。\n * 抽象工厂、 生成器和原型都可以用单例模式来实现。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之建造者模式",frontmatter:{title:"设计模式之建造者模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-06-03T10:32:00.000Z",permalink:"/pages/cb480c/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04.%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/04.建造者模式.md",key:"v-1bdc9712",path:"/pages/cb480c/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:17},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:369},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:490},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:2496},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:5481},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:5927},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:6230}],headersStr:"1. 意图 2. 适用场景 3. 结构 4. 伪代码 5. 案例 6. 与其他模式的关系 7. 参考资料",content:'# 设计模式之建造者模式\n\n\n# 1. 意图\n\n建造者模式（Builder）是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。\n\n使用建造者模式，用户就只需要指定需要建造的类型，具体的建造过程和细节并不需要知道。\n\n建造者模式允许修改一个产品的内部表示。\n\n它将构造和表示两块代码隔离开来。\n\n它很好的控制了构建过程。\n\n\n\n建造者模式流程说明：\n\n 1. 客户端创建 Director 对象并配置它所需要的 Builder 对象。\n 2. Director 负责通知 builder 何时建造 product 的部件。\n 3. Builder 处理 director 的请求并添加 product 的部件。\n 4. 客户端从 builder 处获得 product。\n\n\n# 2. 适用场景\n\n * 使用建造者模式可避免 “重叠构造函数 （telescopic constructor）” 的出现。\n * 当你希望使用代码创建不同形式的产品时， 可使用建造者模式。\n * 使用建造者构造组合树或其他复杂对象。\n\n\n# 3. 结构\n\n\n\n 1. 建造者 （Builder） 接口声明在所有类型建造者中通用的产品构造步骤。\n 2. 具体建造者 （Concrete Builders） 提供构造过程的不同实现。 具体建造者也可以构造不遵循通用接口的产品。\n 3. 产品 （Products） 是最终生成的对象。 由不同建造者构造的产品无需属于同一类层次结构或接口。\n 4. 主管 （Director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。\n 5. 客户端 （Client） 必须将某个建造者对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用建造者对象完成后续所有的构造任务。 但在客户端将建造者对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的建造者。\n\n【Product】产品类，由多个部件构成。\n\nclass Product {\n    List<String> parts = new ArrayList<String>();\n\n    public void AddPart(String part) {\n        parts.add(part);\n    }\n\n    public void show() {\n        System.out.println("============== 产品创建 ==============");\n        for (String part : parts) {\n            System.out.println(part);\n        }\n    }\n}\n\n\n【Builder】\n\n抽象建造者，确定产品由 ABC 三个部件构成，并声明一个得到产品建造后结果的方法 getResult。\n\ninterface Builder {\n    public void buildPartA();\n    public void buildPartB();\n    public void buildPartC();\n    public Product getResult();\n}\n\n\n【ConcreteBuilder】\n\n实现 Builder 接口中的具体方法。\n\nclass ConcreteBuilder implements Builder {\n    private Product product = new Product();\n\n    @Override\n    public void buildPartA() {\n        product.AddPart("部件A");\n    }\n\n    @Override\n    public void buildPartB() {\n        product.AddPart("部件B");\n    }\n\n    @Override\n    public void buildPartC() {\n        product.AddPart("部件C");\n    }\n\n    @Override\n    public Product getResult() {\n        return product;\n    }\n}\n\n\n【Director】\n\n指挥者类，指挥建造 Product 的过程（控制构建各部分组件的顺序）。\n\nclass Director {\n    public void construct(Builder builder) {\n        builder.buildPartC();\n        builder.buildPartA();\n        builder.buildPartB();\n    }\n}\n\n\n【客户端】\n\n用户并不需要知道具体的建造过程，只需指定建造 Product 具体类型。\n\npublic class BuilderPattern {\n    public static void main(String[] args) {\n        Director director = new Director();\n        Builder builder = new ConcreteBuilder();\n\n        director.construct(builder);\n        Product product = builder.getResult();\n        product.show();\n    }\n}\n\n\n【输出】\n\n============== 产品创建 ==============\n部件C\n部件A\n部件B\n\n\n\n# 4. 伪代码\n\n下面关于建造者模式的例子演示了你可以如何复用相同的对象构造代码来生成不同类型的产品——例如汽车 （Car）——及其相应的使用手册 （Manual）。\n\n\n\n// 只有当产品较为复杂且需要详细配置时，使用建造者模式才有意义。下面的两个\n// 产品尽管没有同样的接口，但却相互关联。\nclass Car is\n    // 一辆汽车可能配备有 GPS 设备、行车电脑和几个座位。不同型号的汽车（\n    // 运动型轿车、SUV 和敞篷车）可能会安装或启用不同的功能。\n\nclass Manual is\n    // 用户使用手册应该根据汽车配置进行编制，并介绍汽车的所有功能。\n\n\n// 建造者接口声明了创建产品对象不同部件的方法。\ninterface Builder is\n    method reset()\n    method setSeats(...)\n    method setEngine(...)\n    method setTripComputer(...)\n    method setGPS(...)\n\n// 具体建造者类将遵循建造者接口并提供生成步骤的具体实现。你的程序中可能会\n// 有多个以不同方式实现的建造者变体。\nclass CarBuilder implements Builder is\n    private field car:Car\n\n    // 一个新的建造者实例必须包含一个在后续组装过程中使用的空产品对象。\n    constructor CarBuilder() is\n        this.reset()\n\n    // reset（重置）方法可清除正在生成的对象。\n    method reset() is\n        this.car = new Car()\n\n    // 所有生成步骤都会与同一个产品实例进行交互。\n    method setSeats(...) is\n        // 设置汽车座位的数量。\n\n    method setEngine(...) is\n        // 安装指定的引擎。\n\n    method setTripComputer(...) is\n        // 安装行车电脑。\n\n    method setGPS(...) is\n        // 安装全球定位系统。\n\n    // 具体建造者需要自行提供获取结果的方法。这是因为不同类型的建造者可能\n    // 会创建不遵循相同接口的、完全不同的产品。所以也就无法在建造者接口中\n    // 声明这些方法（至少在静态类型的编程语言中是这样的）。\n    //\n    // 通常在建造者实例将结果返回给客户端后，它们应该做好生成另一个产品的\n    // 准备。因此建造者实例通常会在 `getProduct（获取产品）`方法主体末尾\n    // 调用重置方法。但是该行为并不是必需的，你也可让建造者等待客户端明确\n    // 调用重置方法后再去处理之前的结果。\n    method getProduct():Car is\n        product = this.car\n        this.reset()\n        return product\n\n// 建造者与其他创建型模式的不同之处在于：它让你能创建不遵循相同接口的产品。\nclass CarManualBuilder implements Builder is\n    private field manual:Manual\n\n    constructor CarManualBuilder() is\n        this.reset()\n\n    method reset() is\n        this.manual = new Manual()\n\n    method setSeats(...) is\n        // 添加关于汽车座椅功能的文档。\n\n    method setEngine(...) is\n        // 添加关于引擎的介绍。\n\n    method setTripComputer(...) is\n        // 添加关于行车电脑的介绍。\n\n    method setGPS(...) is\n        // 添加关于 GPS 的介绍。\n\n    method getProduct():Manual is\n        // 返回使用手册并重置建造者。\n\n\n// 主管只负责按照特定顺序执行生成步骤。其在根据特定步骤或配置来生成产品时\n// 会很有帮助。由于客户端可以直接控制建造者，所以严格意义上来说，主管类并\n// 不是必需的。\nclass Director is\n    private field builder:Builder\n\n    // 主管可同由客户端代码传递给自身的任何建造者实例进行交互。客户端可通\n    // 过这种方式改变最新组装完毕的产品的最终类型。\n    method setBuilder(builder:Builder)\n        this.builder = builder\n\n    // 主管可使用同样的生成步骤创建多个产品变体。\n    method constructSportsCar(builder: Builder) is\n        builder.reset()\n        builder.setSeats(2)\n        builder.setEngine(new SportEngine())\n        builder.setTripComputer(true)\n        builder.setGPS(true)\n\n    method constructSUV(builder: Builder) is\n        // ...\n\n\n// 客户端代码会创建建造者对象并将其传递给主管，然后执行构造过程。最终结果\n// 将需要从建造者对象中获取。\nclass Application is\n\n    method makeCar() is\n        director = new Director()\n\n        CarBuilder builder = new CarBuilder()\n        director.constructSportsCar(builder)\n        Car car = builder.getProduct()\n\n        CarManualBuilder builder = new CarManualBuilder()\n        director.constructSportsCar(builder)\n\n        // 最终产品通常需要从建造者对象中获取，因为主管不知晓具体建造者和\n        // 产品的存在，也不会对其产生依赖。\n        Manual manual = builder.getProduct()\n\n\n\n# 5. 案例\n\n使用示例： 建造者模式是 Java 世界中的一个著名模式。 当你需要创建一个可能有许多配置选项的对象时， 该模式会特别有用。\n\n建造者在 Java 核心程序库中得到了广泛的应用：\n\n * java.lang.StringBuilder#append() （ 非同步 ）\n * java.lang.StringBuffer#append() （ 同步 ）\n * java.nio.ByteBuffer#put() （还有 Char­Buffer、 Short­Buffer、 Int­Buffer、 Long­Buffer、 Float­Buffer 和 Double­Buffer）\n * java.lang.Appendable的所有实现\n\n识别方法： 建造者模式可以通过类来识别， 它拥有一个构建方法和多个配置结果对象的方法。 建造者方法通常支持方法链 （例如 someBuilder->setValueA(1)->setValueB(2)->create() ）\n\n\n# 6. 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或建造者模式 （更灵活但更加复杂）。\n * 建造者重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 建造者则允许你在获取产品前执行一些额外构造步骤。\n * 你可以在创建复杂组合模式树时使用建造者， 因为这可使其构造步骤以递归的方式运行。\n * 你可以结合使用建造者和桥接模式： 主管类负责抽象工作， 各种不同的建造者负责实现工作。\n * 抽象工厂、 建造者和原型都可以用单例模式来实现。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之建造者模式\n\n\n# 1. 意图\n\n建造者模式（builder）是一种创建型设计模式， 使你能够分步骤创建复杂对象。 该模式允许你使用相同的创建代码生成不同类型和形式的对象。\n\n使用建造者模式，用户就只需要指定需要建造的类型，具体的建造过程和细节并不需要知道。\n\n建造者模式允许修改一个产品的内部表示。\n\n它将构造和表示两块代码隔离开来。\n\n它很好的控制了构建过程。\n\n\n\n建造者模式流程说明：\n\n 1. 客户端创建 director 对象并配置它所需要的 builder 对象。\n 2. director 负责通知 builder 何时建造 product 的部件。\n 3. builder 处理 director 的请求并添加 product 的部件。\n 4. 客户端从 builder 处获得 product。\n\n\n# 2. 适用场景\n\n * 使用建造者模式可避免 “重叠构造函数 （telescopic constructor）” 的出现。\n * 当你希望使用代码创建不同形式的产品时， 可使用建造者模式。\n * 使用建造者构造组合树或其他复杂对象。\n\n\n# 3. 结构\n\n\n\n 1. 建造者 （builder） 接口声明在所有类型建造者中通用的产品构造步骤。\n 2. 具体建造者 （concrete builders） 提供构造过程的不同实现。 具体建造者也可以构造不遵循通用接口的产品。\n 3. 产品 （products） 是最终生成的对象。 由不同建造者构造的产品无需属于同一类层次结构或接口。\n 4. 主管 （director） 类定义调用构造步骤的顺序， 这样你就可以创建和复用特定的产品配置。\n 5. 客户端 （client） 必须将某个建造者对象与主管类关联。 一般情况下， 你只需通过主管类构造函数的参数进行一次性关联即可。 此后主管类就能使用建造者对象完成后续所有的构造任务。 但在客户端将建造者对象传递给主管类制造方法时还有另一种方式。 在这种情况下， 你在使用主管类生产产品时每次都可以使用不同的建造者。\n\n【product】产品类，由多个部件构成。\n\nclass product {\n    list<string> parts = new arraylist<string>();\n\n    public void addpart(string part) {\n        parts.add(part);\n    }\n\n    public void show() {\n        system.out.println("============== 产品创建 ==============");\n        for (string part : parts) {\n            system.out.println(part);\n        }\n    }\n}\n\n\n【builder】\n\n抽象建造者，确定产品由 abc 三个部件构成，并声明一个得到产品建造后结果的方法 getresult。\n\ninterface builder {\n    public void buildparta();\n    public void buildpartb();\n    public void buildpartc();\n    public product getresult();\n}\n\n\n【concretebuilder】\n\n实现 builder 接口中的具体方法。\n\nclass concretebuilder implements builder {\n    private product product = new product();\n\n    @override\n    public void buildparta() {\n        product.addpart("部件a");\n    }\n\n    @override\n    public void buildpartb() {\n        product.addpart("部件b");\n    }\n\n    @override\n    public void buildpartc() {\n        product.addpart("部件c");\n    }\n\n    @override\n    public product getresult() {\n        return product;\n    }\n}\n\n\n【director】\n\n指挥者类，指挥建造 product 的过程（控制构建各部分组件的顺序）。\n\nclass director {\n    public void construct(builder builder) {\n        builder.buildpartc();\n        builder.buildparta();\n        builder.buildpartb();\n    }\n}\n\n\n【客户端】\n\n用户并不需要知道具体的建造过程，只需指定建造 product 具体类型。\n\npublic class builderpattern {\n    public static void main(string[] args) {\n        director director = new director();\n        builder builder = new concretebuilder();\n\n        director.construct(builder);\n        product product = builder.getresult();\n        product.show();\n    }\n}\n\n\n【输出】\n\n============== 产品创建 ==============\n部件c\n部件a\n部件b\n\n\n\n# 4. 伪代码\n\n下面关于建造者模式的例子演示了你可以如何复用相同的对象构造代码来生成不同类型的产品——例如汽车 （car）——及其相应的使用手册 （manual）。\n\n\n\n// 只有当产品较为复杂且需要详细配置时，使用建造者模式才有意义。下面的两个\n// 产品尽管没有同样的接口，但却相互关联。\nclass car is\n    // 一辆汽车可能配备有 gps 设备、行车电脑和几个座位。不同型号的汽车（\n    // 运动型轿车、suv 和敞篷车）可能会安装或启用不同的功能。\n\nclass manual is\n    // 用户使用手册应该根据汽车配置进行编制，并介绍汽车的所有功能。\n\n\n// 建造者接口声明了创建产品对象不同部件的方法。\ninterface builder is\n    method reset()\n    method setseats(...)\n    method setengine(...)\n    method settripcomputer(...)\n    method setgps(...)\n\n// 具体建造者类将遵循建造者接口并提供生成步骤的具体实现。你的程序中可能会\n// 有多个以不同方式实现的建造者变体。\nclass carbuilder implements builder is\n    private field car:car\n\n    // 一个新的建造者实例必须包含一个在后续组装过程中使用的空产品对象。\n    constructor carbuilder() is\n        this.reset()\n\n    // reset（重置）方法可清除正在生成的对象。\n    method reset() is\n        this.car = new car()\n\n    // 所有生成步骤都会与同一个产品实例进行交互。\n    method setseats(...) is\n        // 设置汽车座位的数量。\n\n    method setengine(...) is\n        // 安装指定的引擎。\n\n    method settripcomputer(...) is\n        // 安装行车电脑。\n\n    method setgps(...) is\n        // 安装全球定位系统。\n\n    // 具体建造者需要自行提供获取结果的方法。这是因为不同类型的建造者可能\n    // 会创建不遵循相同接口的、完全不同的产品。所以也就无法在建造者接口中\n    // 声明这些方法（至少在静态类型的编程语言中是这样的）。\n    //\n    // 通常在建造者实例将结果返回给客户端后，它们应该做好生成另一个产品的\n    // 准备。因此建造者实例通常会在 `getproduct（获取产品）`方法主体末尾\n    // 调用重置方法。但是该行为并不是必需的，你也可让建造者等待客户端明确\n    // 调用重置方法后再去处理之前的结果。\n    method getproduct():car is\n        product = this.car\n        this.reset()\n        return product\n\n// 建造者与其他创建型模式的不同之处在于：它让你能创建不遵循相同接口的产品。\nclass carmanualbuilder implements builder is\n    private field manual:manual\n\n    constructor carmanualbuilder() is\n        this.reset()\n\n    method reset() is\n        this.manual = new manual()\n\n    method setseats(...) is\n        // 添加关于汽车座椅功能的文档。\n\n    method setengine(...) is\n        // 添加关于引擎的介绍。\n\n    method settripcomputer(...) is\n        // 添加关于行车电脑的介绍。\n\n    method setgps(...) is\n        // 添加关于 gps 的介绍。\n\n    method getproduct():manual is\n        // 返回使用手册并重置建造者。\n\n\n// 主管只负责按照特定顺序执行生成步骤。其在根据特定步骤或配置来生成产品时\n// 会很有帮助。由于客户端可以直接控制建造者，所以严格意义上来说，主管类并\n// 不是必需的。\nclass director is\n    private field builder:builder\n\n    // 主管可同由客户端代码传递给自身的任何建造者实例进行交互。客户端可通\n    // 过这种方式改变最新组装完毕的产品的最终类型。\n    method setbuilder(builder:builder)\n        this.builder = builder\n\n    // 主管可使用同样的生成步骤创建多个产品变体。\n    method constructsportscar(builder: builder) is\n        builder.reset()\n        builder.setseats(2)\n        builder.setengine(new sportengine())\n        builder.settripcomputer(true)\n        builder.setgps(true)\n\n    method constructsuv(builder: builder) is\n        // ...\n\n\n// 客户端代码会创建建造者对象并将其传递给主管，然后执行构造过程。最终结果\n// 将需要从建造者对象中获取。\nclass application is\n\n    method makecar() is\n        director = new director()\n\n        carbuilder builder = new carbuilder()\n        director.constructsportscar(builder)\n        car car = builder.getproduct()\n\n        carmanualbuilder builder = new carmanualbuilder()\n        director.constructsportscar(builder)\n\n        // 最终产品通常需要从建造者对象中获取，因为主管不知晓具体建造者和\n        // 产品的存在，也不会对其产生依赖。\n        manual manual = builder.getproduct()\n\n\n\n# 5. 案例\n\n使用示例： 建造者模式是 java 世界中的一个著名模式。 当你需要创建一个可能有许多配置选项的对象时， 该模式会特别有用。\n\n建造者在 java 核心程序库中得到了广泛的应用：\n\n * java.lang.stringbuilder#append() （ 非同步 ）\n * java.lang.stringbuffer#append() （ 同步 ）\n * java.nio.bytebuffer#put() （还有 char­buffer、 short­buffer、 int­buffer、 long­buffer、 float­buffer 和 double­buffer）\n * java.lang.appendable的所有实现\n\n识别方法： 建造者模式可以通过类来识别， 它拥有一个构建方法和多个配置结果对象的方法。 建造者方法通常支持方法链 （例如 somebuilder->setvaluea(1)->setvalueb(2)->create() ）\n\n\n# 6. 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或建造者模式 （更灵活但更加复杂）。\n * 建造者重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 建造者则允许你在获取产品前执行一些额外构造步骤。\n * 你可以在创建复杂组合模式树时使用建造者， 因为这可使其构造步骤以递归的方式运行。\n * 你可以结合使用建造者和桥接模式： 主管类负责抽象工作， 各种不同的建造者负责实现工作。\n * 抽象工厂、 建造者和原型都可以用单例模式来实现。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之原型模式",frontmatter:{title:"设计模式之原型模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-06-03T15:00:00.000Z",permalink:"/pages/c5ff69/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05.%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/05.原型模式.md",key:"v-68de8656",path:"/pages/c5ff69/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:16},{level:3,title:"1.1. 浅拷贝与深拷贝",slug:"_1-1-浅拷贝与深拷贝",normalizedTitle:"1.1. 浅拷贝与深拷贝",charIndex:471},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:625},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:757},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:971},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:3102},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:3278},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:3691}],headersStr:"1. 意图 1.1. 浅拷贝与深拷贝 2. 适用场景 3. 结构 4. 伪代码 5. 案例 6. 与其他模式的关系 7. 参考资料",content:"# 设计模式之原型模式\n\n\n# 1. 意图\n\n原型模式（Prototype）是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。\n\n原型模式主要用于对象的复制，它的核心是就是类图中的原型类 Prototype。Prototype 类需要具备以下两个条件：\n\n * 实现 Cloneable 接口。在 java 语言有一个 Cloneable 接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用 clone 方法。在 java 虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出 CloneNotSupportedException 异常。\n * 重写 Object 类中的 clone 方法。Java 中，所有类的父类都是 Object 类，Object 类中有一个 clone 方法，作用是返回对象的一个拷贝，但是其作用域 protected 类型的，一般的类无法调用，因此，Prototype 类需要将 clone 方法的作用域修改为 public 类型。\n\n\n# 1.1. 浅拷贝与深拷贝\n\n浅拷贝是指当对象的字段值被复制时，字段引用的对象不会被复制。\n\n例如：如果一个对象有一个指向字符串的字段，并且我们对该对象做了一个浅拷贝，那麽两个对象将引用同一个字符串。\n\n深拷贝是指当一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝。\n\n\n# 2. 适用场景\n\n * 如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。\n * 如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。\n\n\n# 3. 结构\n\n\n\n 1. 原型 （Prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。\n 2. 具体原型 （Concrete Prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。\n 3. 客户端 （Client） 可以复制实现了原型接口的任何对象。\n\n\n# 4. 伪代码\n\n在本例中， 原型模式能让你生成完全相同的几何对象副本， 同时无需代码与对象所属类耦合。\n\n\n\n所有形状类都遵循同一个提供克隆方法的接口。 在复制自身成员变量值到结果对象前， 子类可调用其父类的克隆方法。\n\n// 基础原型。\nabstract class Shape is\n    field X: int\n    field Y: int\n    field color: string\n\n    // 常规构造函数。\n    constructor Shape() is\n        // ...\n\n    // 原型构造函数。使用已有对象的数值来初始化一个新对象。\n    constructor Shape(source: Shape) is\n        this()\n        this.X = source.X\n        this.Y = source.Y\n        this.color = source.color\n\n    // clone（克隆）操作会返回一个形状子类。\n    abstract method clone():Shape\n\n\n// 具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运\n// 行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生\n// 成的克隆对象。这可以保持克隆结果的一致。\nclass Rectangle extends Shape is\n    field width: int\n    field height: int\n\n    constructor Rectangle(source: Rectangle) is\n        // 需要调用父构造函数来复制父类中定义的私有成员变量。\n        super(source)\n        this.width = source.width\n        this.height = source.height\n\n    method clone():Shape is\n        return new Rectangle(this)\n\n\nclass Circle extends Shape is\n    field radius: int\n\n    constructor Circle(source: Circle) is\n        super(source)\n        this.radius = source.radius\n\n    method clone():Shape is\n        return new Circle(this)\n\n\n// 客户端代码中的某个位置。\nclass Application is\n    field shapes: array of Shape\n\n    constructor Application() is\n        Circle circle = new Circle()\n        circle.X = 10\n        circle.Y = 10\n        circle.radius = 20\n        shapes.add(circle)\n\n        Circle anotherCircle = circle.clone()\n        shapes.add(anotherCircle)\n        // 变量 `anotherCircle（另一个圆）`与 `circle（圆）`对象的内\n        // 容完全一样。\n\n        Rectangle rectangle = new Rectangle()\n        rectangle.width = 10\n        rectangle.height = 20\n        shapes.add(rectangle)\n\n    method businessLogic() is\n        // 原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与\n        // 其完全相同的复制品。\n        Array shapesCopy = new Array of Shapes.\n\n        // 例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。\n        // 但在多态机制的帮助下，当我们在某个形状上调用 `clone（克隆）`\n        // 方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，\n        // 我们将获得一个正确的复制品，而不是一组简单的形状对象。\n        foreach (s in shapes) do\n            shapesCopy.add(s.clone())\n\n        // `shapesCopy（形状副本）`数组中包含 `shape（形状）`数组所有\n        // 子元素的复制品。\n\n\n\n# 5. 案例\n\n使用示例： Java 的 Cloneable （可克隆） 接口就是立即可用的原型模式。\n\n任何类都可通过实现该接口来实现可被克隆的性质。\n\n * java.lang.Object#clone() （类必须实现 java.lang.Cloneable 接口）\n\n识别方法： 原型可以简单地通过 clone或 copy等方法来识别。\n\n\n# 6. 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。\n * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。\n * 原型可用于保存命令模式的历史记录。\n * 大量使用组合模式和装饰模式的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。\n * 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。\n * 有时候原型可以作为备忘录模式的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。\n * 抽象工厂、 生成器和原型都可以用单例模式来实现。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程",normalizedContent:"# 设计模式之原型模式\n\n\n# 1. 意图\n\n原型模式（prototype）是一种创建型设计模式， 使你能够复制已有对象， 而又无需使代码依赖它们所属的类。\n\n原型模式主要用于对象的复制，它的核心是就是类图中的原型类 prototype。prototype 类需要具备以下两个条件：\n\n * 实现 cloneable 接口。在 java 语言有一个 cloneable 接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用 clone 方法。在 java 虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出 clonenotsupportedexception 异常。\n * 重写 object 类中的 clone 方法。java 中，所有类的父类都是 object 类，object 类中有一个 clone 方法，作用是返回对象的一个拷贝，但是其作用域 protected 类型的，一般的类无法调用，因此，prototype 类需要将 clone 方法的作用域修改为 public 类型。\n\n\n# 1.1. 浅拷贝与深拷贝\n\n浅拷贝是指当对象的字段值被复制时，字段引用的对象不会被复制。\n\n例如：如果一个对象有一个指向字符串的字段，并且我们对该对象做了一个浅拷贝，那麽两个对象将引用同一个字符串。\n\n深拷贝是指当一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝。\n\n\n# 2. 适用场景\n\n * 如果你需要复制一些对象， 同时又希望代码独立于这些对象所属的具体类， 可以使用原型模式。\n * 如果子类的区别仅在于其对象的初始化方式， 那么你可以使用该模式来减少子类的数量。 别人创建这些子类的目的可能是为了创建特定类型的对象。\n\n\n# 3. 结构\n\n\n\n 1. 原型 （prototype） 接口将对克隆方法进行声明。 在绝大多数情况下， 其中只会有一个名为 clone克隆的方法。\n 2. 具体原型 （concrete prototype） 类将实现克隆方法。 除了将原始对象的数据复制到克隆体中之外， 该方法有时还需处理克隆过程中的极端情况， 例如克隆关联对象和梳理递归依赖等等。\n 3. 客户端 （client） 可以复制实现了原型接口的任何对象。\n\n\n# 4. 伪代码\n\n在本例中， 原型模式能让你生成完全相同的几何对象副本， 同时无需代码与对象所属类耦合。\n\n\n\n所有形状类都遵循同一个提供克隆方法的接口。 在复制自身成员变量值到结果对象前， 子类可调用其父类的克隆方法。\n\n// 基础原型。\nabstract class shape is\n    field x: int\n    field y: int\n    field color: string\n\n    // 常规构造函数。\n    constructor shape() is\n        // ...\n\n    // 原型构造函数。使用已有对象的数值来初始化一个新对象。\n    constructor shape(source: shape) is\n        this()\n        this.x = source.x\n        this.y = source.y\n        this.color = source.color\n\n    // clone（克隆）操作会返回一个形状子类。\n    abstract method clone():shape\n\n\n// 具体原型。克隆方法会创建一个新对象并将其传递给构造函数。直到构造函数运\n// 行完成前，它都拥有指向新克隆对象的引用。因此，任何人都无法访问未完全生\n// 成的克隆对象。这可以保持克隆结果的一致。\nclass rectangle extends shape is\n    field width: int\n    field height: int\n\n    constructor rectangle(source: rectangle) is\n        // 需要调用父构造函数来复制父类中定义的私有成员变量。\n        super(source)\n        this.width = source.width\n        this.height = source.height\n\n    method clone():shape is\n        return new rectangle(this)\n\n\nclass circle extends shape is\n    field radius: int\n\n    constructor circle(source: circle) is\n        super(source)\n        this.radius = source.radius\n\n    method clone():shape is\n        return new circle(this)\n\n\n// 客户端代码中的某个位置。\nclass application is\n    field shapes: array of shape\n\n    constructor application() is\n        circle circle = new circle()\n        circle.x = 10\n        circle.y = 10\n        circle.radius = 20\n        shapes.add(circle)\n\n        circle anothercircle = circle.clone()\n        shapes.add(anothercircle)\n        // 变量 `anothercircle（另一个圆）`与 `circle（圆）`对象的内\n        // 容完全一样。\n\n        rectangle rectangle = new rectangle()\n        rectangle.width = 10\n        rectangle.height = 20\n        shapes.add(rectangle)\n\n    method businesslogic() is\n        // 原型是很强大的东西，因为它能在不知晓对象类型的情况下生成一个与\n        // 其完全相同的复制品。\n        array shapescopy = new array of shapes.\n\n        // 例如，我们不知晓形状数组中元素的具体类型，只知道它们都是形状。\n        // 但在多态机制的帮助下，当我们在某个形状上调用 `clone（克隆）`\n        // 方法时，程序会检查其所属的类并调用其中所定义的克隆方法。这样，\n        // 我们将获得一个正确的复制品，而不是一组简单的形状对象。\n        foreach (s in shapes) do\n            shapescopy.add(s.clone())\n\n        // `shapescopy（形状副本）`数组中包含 `shape（形状）`数组所有\n        // 子元素的复制品。\n\n\n\n# 5. 案例\n\n使用示例： java 的 cloneable （可克隆） 接口就是立即可用的原型模式。\n\n任何类都可通过实现该接口来实现可被克隆的性质。\n\n * java.lang.object#clone() （类必须实现 java.lang.cloneable 接口）\n\n识别方法： 原型可以简单地通过 clone或 copy等方法来识别。\n\n\n# 6. 与其他模式的关系\n\n * 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。\n * 抽象工厂模式通常基于一组工厂方法， 但你也可以使用原型模式来生成这些类的方法。\n * 原型可用于保存命令模式的历史记录。\n * 大量使用组合模式和装饰模式的设计通常可从对于原型的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。\n * 原型并不基于继承， 因此没有继承的缺点。 另一方面， 原型需要对被复制对象进行复杂的初始化。 工厂方法基于继承， 但是它不需要初始化步骤。\n * 有时候原型可以作为备忘录模式的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。\n * 抽象工厂、 生成器和原型都可以用单例模式来实现。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之单例模式",frontmatter:{title:"设计模式之单例模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-06-03T09:24:00.000Z",permalink:"/pages/b271ff/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06.%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/06.单例模式.md",key:"v-72ea5972",path:"/pages/b271ff/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:16},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:747},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:1210},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:1348},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:2497},{level:3,title:"5.1. 数据库连接类",slug:"_5-1-数据库连接类",normalizedTitle:"5.1. 数据库连接类",charIndex:2731},{level:3,title:"5.2. 懒汉式",slug:"_5-2-懒汉式",normalizedTitle:"5.2. 懒汉式",charIndex:3879},{level:3,title:"5.3. 饿汉式",slug:"_5-3-饿汉式",normalizedTitle:"5.3. 饿汉式",charIndex:4412},{level:3,title:"5.4. 双重锁的形式",slug:"_5-4-双重锁的形式",normalizedTitle:"5.4. 双重锁的形式",charIndex:4846},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:5589},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:5816}],headersStr:"1. 意图 2. 适用场景 3. 结构 4. 伪代码 5. 案例 5.1. 数据库连接类 5.2. 懒汉式 5.3. 饿汉式 5.4. 双重锁的形式 6. 与其他模式的关系 7. 参考资料",content:'# 设计模式之单例模式\n\n\n# 1. 意图\n\n单例模式（Singleton）是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。\n\n单例 （Singleton） 类声明了一个名为 get­Instance 获取实例的静态方法来返回其所属类的一个相同实例。\n\n单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 get­Instance 方法必须是获取单例对象的唯一方式。\n\n所有单例的实现都包含以下两个相同的步骤：\n\n * 将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。\n * 新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。\n\n如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。\n\n单例模式的优点：\n\n * ✔ 你可以保证一个类只有一个实例。\n * ✔ 你获得了一个指向该实例的全局访问节点。\n * ✔ 仅在首次请求单例对象时对其进行初始化。\n\n单例模式的缺点：\n\n * ❌ 违反了单一职责原则。 该模式同时解决了两个问题。\n * ❌ 单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。\n * ❌ 该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。\n * ❌ 单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。\n\n\n# 2. 适用场景\n\n * 如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。 ⚡ 单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。\n * 如果你需要更加严格地控制全局变量， 可以使用单例模式。 ⚡ 单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。\n\n请注意， 你可以随时调整限制并设定生成单例实例的数量， 只需修改 获取实例 方法， 即 getInstance 中的代码即可实现。\n\n举例来说，一些资源管理器常常设计成单例模式。\n\n在计算机系统中，需要管理的资源包括软件外部资源，譬如每台计算机可以有若干个打印机，但只能有一个 Printer Spooler， 以避免两个打印作业同时输出到打印机中。\n\n每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。任务管理器中难以启动两个相同的 task。\n\n\n# 3. 结构\n\n\n\n 1. 单例 （Singleton） 类声明了一个名为 get­Instance获取实例的静态方法来返回其所属类的一个相同实例。\n    * 单例的构造函数必须对客户端 （Client） 代码隐藏。 调用 获取实例方法必须是获取单例对象的唯一方式。\n\n\n# 4. 伪代码\n\n在本例中， 数据库连接类即是一个单例。\n\n该类不提供公有构造函数， 因此获取该对象的唯一方式是调用 获取实例方法。 该方法将缓存首次生成的对象， 并为所有后续调用返回该对象。\n\n// 数据库类会对`getInstance（获取实例）`方法进行定义以让客户端在程序各处\n// 都能访问相同的数据库连接实例。\nclass Database is\n    // 保存单例实例的成员变量必须被声明为静态类型。\n    private static field instance: Database\n\n    // 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构\n    // 造方法。\n    private constructor Database() is\n        // 部分初始化代码（例如到数据库服务器的实际连接）。\n        // ...\n\n    // 用于控制对单例实例的访问权限的静态方法。\n    public static method getInstance() is\n        if (Database.instance == null) then\n            acquireThreadLock() and then\n                // 确保在该线程等待解锁时，其他线程没有初始化该实例。\n                if (Database.instance == null) then\n                    Database.instance = new Database()\n        return Database.instance\n\n    // 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。\n    public method query(sql) is\n        // 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以\n        // 在这里添加限流或缓冲逻辑。\n        // ...\n\nclass Application is\n    method main() is\n        Database foo = Database.getInstance()\n        foo.query("SELECT ...")\n        // ...\n        Database bar = Database.getInstance()\n        bar.query("SELECT ...")\n        // 变量 `bar` 和 `foo` 中将包含同一个对象。\n\n\n\n# 5. 案例\n\n使用示例： 许多开发者将单例模式视为一种反模式。 因此它在 Java 代码中的使用频率正在逐步减少。\n\n尽管如此， Java 核心程序库中仍有相当多的单例示例：\n\n * java.lang.Runtime#getRuntime()\n * java.awt.Desktop#getDesktop()\n * java.lang.System#getSecurityManager()\n\n识别方法： 单例可以通过返回相同缓存对象的静态构建方法来识别。\n\n\n# 5.1. 数据库连接类\n\n数据库连接类即是一个单例。\n\n该类不提供公有构造函数， 因此获取该对象的唯一方式是调用 获取实例方法。 该方法将缓存首次生成的对象， 并为所有后续调用返回该对象。\n\n// 数据库类会对`getInstance（获取实例）`方法进行定义以让客户端在程序各处\n// 都能访问相同的数据库连接实例。\nclass Database is\n    // 保存单例实例的成员变量必须被声明为静态类型。\n    private static field instance: Database\n\n    // 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构\n    // 造方法。\n    private constructor Database() is\n        // 部分初始化代码（例如到数据库服务器的实际连接）。\n        // ...\n\n    // 用于控制对单例实例的访问权限的静态方法。\n    public static method getInstance() is\n        if (Database.instance == null) then\n            acquireThreadLock() and then\n                // 确保在该线程等待解锁时，其他线程没有初始化该实例。\n                if (Database.instance == null) then\n                    Database.instance = new Database()\n        return Database.instance\n\n    // 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。\n    public method query(sql) is\n        // 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以\n        // 在这里添加限流或缓冲逻辑。\n        // ...\n\nclass Application is\n    method main() is\n        Database foo = Database.getInstance()\n        foo.query("SELECT ...")\n        // ...\n        Database bar = Database.getInstance()\n        bar.query("SELECT ...")\n        // 变量 `bar` 和 `foo` 中将包含同一个对象。\n\n\n\n# 5.2. 懒汉式\n\n懒汉式的实现思路是：你不找懒汉，懒汉根本就懒得去初始化自己。\n\ninstance 初始时没有初始化，只有当第一次调 getInstance() 时才创建实例。\n\n缺点：当有两个线程调 getInstance() 方法，当它们同时执行到 if (null == instance) 这行代码，instance 为 null。\n\n继续向下执行，会生成两个实例，违背了单例模式的初衷。\n\npublic class LazySingleton {\n    private LazySingleton() {\n        System.out.println("Singleton()");\n    }\n\n    private static LazySingleton instance = null;\n\n    public static LazySingleton getInstance() {\n        if (null == instance) {\n            instance = new LazySingleton();\n        }\n        return instance;\n    }\n}\n\n\n\n# 5.3. 饿汉式\n\n懒汉式的实现思路是：饿汉根本等不及别人来找他，不管三七二十一先初始化了自身的实例，生怕自己饿着了。\n\n类默认先直接初始化一个实例，以后调用 getInstance() 总是返回这个已创建好的实例。\n\n缺点：在没有必要获取实例时，已经预先产生了开销。\n\n优点：规避了懒汉式方法的线程问题，不用显示编写线程安全代码。\n\npublic class HungerSinleton {\n    private HungerSinleton() {\n        System.out.println("Singleton()");\n    }\n\n    private static HungerSinleton instance = new HungerSinleton();\n\n    public static HungerSinleton getInstance() {\n        return instance;\n    }\n}\n\n\n\n# 5.4. 双重锁的形式\n\n如果既不想在没有调用 getInstance() 方法时产生开销，又不想发生线程安全问题，就可以采用双重锁的形式。\n\npublic class SyncSingleton {\n    private SyncSingleton() {\n        System.out.println("Singleton()");\n    }\n\n    private static SyncSingleton instance = null;\n\n    public static SyncSingleton getInstance() {\n        if (null == instance) {\n            synchronized(SyncSingleton.class) {\n                if (null == instance) {\n                    instance = new SyncSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n\n> 注：在外面判断了 instance 实例是否存在，为什么在锁定后又要在内部又判断一次？\n> \n> 这是因为，如果 instance 为 null 时有两个线程同时调用 getInstance()，由于 synchronized 机制，只允许一个线程进入，另一个需要等待。\n> \n> 这时如果没有第二道 instance 是否为 null 的判断，就可能发生第一个线程创建一个实例，而第二个线程又创建一个实例的情况。\n\n\n# 6. 与其他模式的关系\n\n * 外观模式类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。\n * 如果你能将对象的所有共享状态简化为一个享元对象， 那么享元模式就和单例类似了。 但这两个模式有两个根本性的不同。\n   1. 只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。\n   2. 单例对象可以是可变的。 享元对象是不可变的。\n * 抽象工厂模式、 生成器模式和原型模式都可以用单例来实现。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之单例模式\n\n\n# 1. 意图\n\n单例模式（singleton）是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。\n\n单例 （singleton） 类声明了一个名为 get­instance 获取实例的静态方法来返回其所属类的一个相同实例。\n\n单例的构造函数必须对客户端 （client） 代码隐藏。 调用 get­instance 方法必须是获取单例对象的唯一方式。\n\n所有单例的实现都包含以下两个相同的步骤：\n\n * 将默认构造函数设为私有， 防止其他对象使用单例类的 new运算符。\n * 新建一个静态构建方法作为构造函数。 该函数会 “偷偷” 调用私有构造函数来创建对象， 并将其保存在一个静态成员变量中。 此后所有对于该函数的调用都将返回这一缓存对象。\n\n如果你的代码能够访问单例类， 那它就能调用单例类的静态方法。 无论何时调用该方法， 它总是会返回相同的对象。\n\n单例模式的优点：\n\n * ✔ 你可以保证一个类只有一个实例。\n * ✔ 你获得了一个指向该实例的全局访问节点。\n * ✔ 仅在首次请求单例对象时对其进行初始化。\n\n单例模式的缺点：\n\n * ❌ 违反了单一职责原则。 该模式同时解决了两个问题。\n * ❌ 单例模式可能掩盖不良设计， 比如程序各组件之间相互了解过多等。\n * ❌ 该模式在多线程环境下需要进行特殊处理， 避免多个线程多次创建单例对象。\n * ❌ 单例的客户端代码单元测试可能会比较困难， 因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。\n\n\n# 2. 适用场景\n\n * 如果程序中的某个类对于所有客户端只有一个可用的实例， 可以使用单例模式。 ⚡ 单例模式禁止通过除特殊构建方法以外的任何方式来创建自身类的对象。 该方法可以创建一个新对象， 但如果该对象已经被创建， 则返回已有的对象。\n * 如果你需要更加严格地控制全局变量， 可以使用单例模式。 ⚡ 单例模式与全局变量不同， 它保证类只存在一个实例。 除了单例类自己以外， 无法通过任何方式替换缓存的实例。\n\n请注意， 你可以随时调整限制并设定生成单例实例的数量， 只需修改 获取实例 方法， 即 getinstance 中的代码即可实现。\n\n举例来说，一些资源管理器常常设计成单例模式。\n\n在计算机系统中，需要管理的资源包括软件外部资源，譬如每台计算机可以有若干个打印机，但只能有一个 printer spooler， 以避免两个打印作业同时输出到打印机中。\n\n每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。任务管理器中难以启动两个相同的 task。\n\n\n# 3. 结构\n\n\n\n 1. 单例 （singleton） 类声明了一个名为 get­instance获取实例的静态方法来返回其所属类的一个相同实例。\n    * 单例的构造函数必须对客户端 （client） 代码隐藏。 调用 获取实例方法必须是获取单例对象的唯一方式。\n\n\n# 4. 伪代码\n\n在本例中， 数据库连接类即是一个单例。\n\n该类不提供公有构造函数， 因此获取该对象的唯一方式是调用 获取实例方法。 该方法将缓存首次生成的对象， 并为所有后续调用返回该对象。\n\n// 数据库类会对`getinstance（获取实例）`方法进行定义以让客户端在程序各处\n// 都能访问相同的数据库连接实例。\nclass database is\n    // 保存单例实例的成员变量必须被声明为静态类型。\n    private static field instance: database\n\n    // 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构\n    // 造方法。\n    private constructor database() is\n        // 部分初始化代码（例如到数据库服务器的实际连接）。\n        // ...\n\n    // 用于控制对单例实例的访问权限的静态方法。\n    public static method getinstance() is\n        if (database.instance == null) then\n            acquirethreadlock() and then\n                // 确保在该线程等待解锁时，其他线程没有初始化该实例。\n                if (database.instance == null) then\n                    database.instance = new database()\n        return database.instance\n\n    // 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。\n    public method query(sql) is\n        // 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以\n        // 在这里添加限流或缓冲逻辑。\n        // ...\n\nclass application is\n    method main() is\n        database foo = database.getinstance()\n        foo.query("select ...")\n        // ...\n        database bar = database.getinstance()\n        bar.query("select ...")\n        // 变量 `bar` 和 `foo` 中将包含同一个对象。\n\n\n\n# 5. 案例\n\n使用示例： 许多开发者将单例模式视为一种反模式。 因此它在 java 代码中的使用频率正在逐步减少。\n\n尽管如此， java 核心程序库中仍有相当多的单例示例：\n\n * java.lang.runtime#getruntime()\n * java.awt.desktop#getdesktop()\n * java.lang.system#getsecuritymanager()\n\n识别方法： 单例可以通过返回相同缓存对象的静态构建方法来识别。\n\n\n# 5.1. 数据库连接类\n\n数据库连接类即是一个单例。\n\n该类不提供公有构造函数， 因此获取该对象的唯一方式是调用 获取实例方法。 该方法将缓存首次生成的对象， 并为所有后续调用返回该对象。\n\n// 数据库类会对`getinstance（获取实例）`方法进行定义以让客户端在程序各处\n// 都能访问相同的数据库连接实例。\nclass database is\n    // 保存单例实例的成员变量必须被声明为静态类型。\n    private static field instance: database\n\n    // 单例的构造函数必须永远是私有类型，以防止使用`new`运算符直接调用构\n    // 造方法。\n    private constructor database() is\n        // 部分初始化代码（例如到数据库服务器的实际连接）。\n        // ...\n\n    // 用于控制对单例实例的访问权限的静态方法。\n    public static method getinstance() is\n        if (database.instance == null) then\n            acquirethreadlock() and then\n                // 确保在该线程等待解锁时，其他线程没有初始化该实例。\n                if (database.instance == null) then\n                    database.instance = new database()\n        return database.instance\n\n    // 最后，任何单例都必须定义一些可在其实例上执行的业务逻辑。\n    public method query(sql) is\n        // 比如应用的所有数据库查询请求都需要通过该方法进行。因此，你可以\n        // 在这里添加限流或缓冲逻辑。\n        // ...\n\nclass application is\n    method main() is\n        database foo = database.getinstance()\n        foo.query("select ...")\n        // ...\n        database bar = database.getinstance()\n        bar.query("select ...")\n        // 变量 `bar` 和 `foo` 中将包含同一个对象。\n\n\n\n# 5.2. 懒汉式\n\n懒汉式的实现思路是：你不找懒汉，懒汉根本就懒得去初始化自己。\n\ninstance 初始时没有初始化，只有当第一次调 getinstance() 时才创建实例。\n\n缺点：当有两个线程调 getinstance() 方法，当它们同时执行到 if (null == instance) 这行代码，instance 为 null。\n\n继续向下执行，会生成两个实例，违背了单例模式的初衷。\n\npublic class lazysingleton {\n    private lazysingleton() {\n        system.out.println("singleton()");\n    }\n\n    private static lazysingleton instance = null;\n\n    public static lazysingleton getinstance() {\n        if (null == instance) {\n            instance = new lazysingleton();\n        }\n        return instance;\n    }\n}\n\n\n\n# 5.3. 饿汉式\n\n懒汉式的实现思路是：饿汉根本等不及别人来找他，不管三七二十一先初始化了自身的实例，生怕自己饿着了。\n\n类默认先直接初始化一个实例，以后调用 getinstance() 总是返回这个已创建好的实例。\n\n缺点：在没有必要获取实例时，已经预先产生了开销。\n\n优点：规避了懒汉式方法的线程问题，不用显示编写线程安全代码。\n\npublic class hungersinleton {\n    private hungersinleton() {\n        system.out.println("singleton()");\n    }\n\n    private static hungersinleton instance = new hungersinleton();\n\n    public static hungersinleton getinstance() {\n        return instance;\n    }\n}\n\n\n\n# 5.4. 双重锁的形式\n\n如果既不想在没有调用 getinstance() 方法时产生开销，又不想发生线程安全问题，就可以采用双重锁的形式。\n\npublic class syncsingleton {\n    private syncsingleton() {\n        system.out.println("singleton()");\n    }\n\n    private static syncsingleton instance = null;\n\n    public static syncsingleton getinstance() {\n        if (null == instance) {\n            synchronized(syncsingleton.class) {\n                if (null == instance) {\n                    instance = new syncsingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n\n> 注：在外面判断了 instance 实例是否存在，为什么在锁定后又要在内部又判断一次？\n> \n> 这是因为，如果 instance 为 null 时有两个线程同时调用 getinstance()，由于 synchronized 机制，只允许一个线程进入，另一个需要等待。\n> \n> 这时如果没有第二道 instance 是否为 null 的判断，就可能发生第一个线程创建一个实例，而第二个线程又创建一个实例的情况。\n\n\n# 6. 与其他模式的关系\n\n * 外观模式类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。\n * 如果你能将对象的所有共享状态简化为一个享元对象， 那么享元模式就和单例类似了。 但这两个模式有两个根本性的不同。\n   1. 只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。\n   2. 单例对象可以是可变的。 享元对象是不可变的。\n * 抽象工厂模式、 生成器模式和原型模式都可以用单例来实现。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之适配器模式",frontmatter:{title:"设计模式之适配器模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-14T18:31:00.000Z",permalink:"/pages/2c4733/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07.%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/07.适配器模式.md",key:"v-b5457c16",path:"/pages/2c4733/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:17},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:258},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:392},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:435},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:816},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:1423},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:2771},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:3207},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:3637}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 案例 6. 与其他模式的关系 7. 参考资料",content:'# 设计模式之适配器模式\n\n\n# 1. 意图\n\n适配器模式 (Adapter)是一种结构型设计模式， 它能使不兼容的对象能够相互合作。\n\n适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。\n\n适配器不仅可以转换不同格式的数据， 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下：\n\n * 适配器实现与其中一个现有对象兼容的接口。\n * 现有对象可以使用该接口安全地调用适配器方法。\n * 适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。\n\n\n# 2. 适用场景\n\n * 当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。\n * 如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。\n\n\n# 3. 结构\n\n适配器实现了其中一个对象的接口， 并对另一个对象进行封装。\n\n\n\n\n# 3.1. 结构说明\n\n 1. 客户端 （Client） 是包含当前程序业务逻辑的类。\n 2. 客户端接口 （Client Interface） 描述了其他类与客户端代码合作时必须遵循的协议。\n 3. 服务 （Service） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。\n 4. 适配器 （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。\n 5. 客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。\n\n\n# 3.2. 结构代码范式\n\n【Target】\n\n定义用户实际需要的接口。\n\nabstract class Target {\n    public abstract void Request();\n}\n\n\n【Adaptee】\n\n定义一个需要适配的接口。\n\nclass Adaptee {\n    public void SpecificRequest() {\n        System.out.println("特殊请求");\n    }\n}\n\n\n【Adapter】\n\n通过在内部包装一个 Adaptee 对象，把源接口转换成目标接口。\n\nclass Adapter extends Target {\n    private Adaptee adaptee = new Adaptee();\n\n    @Override\n    public void Request() {\n        adaptee.SpecificRequest();\n    }\n}\n\n\n【客户端】\n\npublic class AdapterPattern {\n    public static void main(String[] args) {\n        Target target = new Adapter();\n        target.Request();\n    }\n}\n\n\n【输出】\n\n特殊请求\n\n\n\n# 4. 伪代码\n\n\n\n适配器假扮成一个圆钉 （Round­Peg）， 其半径等于方钉 （Square­Peg） 横截面对角线的一半 （即能够容纳方钉的最小外接圆的半径）。\n\n// 假设你有两个接口相互兼容的类：圆孔（Round­Hole）和圆钉（Round­Peg）。\nclass RoundHole is\n    constructor RoundHole(radius) { ... }\n\n    method getRadius() is\n        // 返回孔的半径。\n\n    method fits(peg: RoundPeg) is\n        return this.getRadius() >= peg.getRadius()\n\nclass RoundPeg is\n    constructor RoundPeg(radius) { ... }\n\n    method getRadius() is\n        // 返回钉子的半径。\n\n\n// 但还有一个不兼容的类：方钉（Square­Peg）。\nclass SquarePeg is\n    constructor SquarePeg(width) { ... }\n\n    method getWidth() is\n        // 返回方钉的宽度。\n\n\n// 适配器类让你能够将方钉放入圆孔中。它会对 RoundPeg 类进行扩展，以接收适\n// 配器对象作为圆钉。\nclass SquarePegAdapter extends RoundPeg is\n    // 在实际情况中，适配器中会包含一个 SquarePeg 类的实例。\n    private field peg: SquarePeg\n\n    constructor SquarePegAdapter(peg: SquarePeg) is\n        this.peg = peg\n\n    method getRadius() is\n        // 适配器会假扮为一个圆钉，\n        // 其半径刚好能与适配器实际封装的方钉搭配起来。\n        return peg.getWidth() * Math.sqrt(2) / 2\n\n\n// 客户端代码中的某个位置。\nhole = new RoundHole(5)\nrpeg = new RoundPeg(5)\nhole.fits(rpeg) // true\n\nsmall_sqpeg = new SquarePeg(5)\nlarge_sqpeg = new SquarePeg(10)\nhole.fits(small_sqpeg) // 此处无法编译（类型不一致）。\n\nsmall_sqpeg_adapter = new SquarePegAdapter(small_sqpeg)\nlarge_sqpeg_adapter = new SquarePegAdapter(large_sqpeg)\nhole.fits(small_sqpeg_adapter) // true\nhole.fits(large_sqpeg_adapter) // false\n\n\n\n# 5. 案例\n\n适配器模式在 Java 代码中很常见。\n\nJava 核心程序库中有一些标准的适配器：\n\n * java.util.Arrays#asList()\n * java.util.Collections#list()\n * java.util.Collections#enumeration()\n * java.io.InputStreamReader(InputStream) （返回 Reader对象）\n * java.io.OutputStreamWriter(OutputStream) （返回 Writer对象）\n * javax.xml.bind.annotation.adapters.XmlAdapter#marshal() 和 #unmarshal()\n\n识别方法： 适配器可以通过以不同抽象或接口类型实例为参数的构造函数来识别。 当适配器的任何方法被调用时， 它会将参数转换为合适的格式， 然后将调用定向到其封装对象中的一个或多个方法。\n\n\n# 6. 与其他模式的关系\n\n * 桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。\n * 适配器可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。\n * 适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。\n * 外观模式为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。\n * 桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之适配器模式\n\n\n# 1. 意图\n\n适配器模式 (adapter)是一种结构型设计模式， 它能使不兼容的对象能够相互合作。\n\n适配器模式通过封装对象将复杂的转换过程隐藏于幕后。 被封装的对象甚至察觉不到适配器的存在。\n\n适配器不仅可以转换不同格式的数据， 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下：\n\n * 适配器实现与其中一个现有对象兼容的接口。\n * 现有对象可以使用该接口安全地调用适配器方法。\n * 适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。\n\n\n# 2. 适用场景\n\n * 当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类。\n * 如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。\n\n\n# 3. 结构\n\n适配器实现了其中一个对象的接口， 并对另一个对象进行封装。\n\n\n\n\n# 3.1. 结构说明\n\n 1. 客户端 （client） 是包含当前程序业务逻辑的类。\n 2. 客户端接口 （client interface） 描述了其他类与客户端代码合作时必须遵循的协议。\n 3. 服务 （service） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。\n 4. 适配器 （adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。\n 5. 客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。\n\n\n# 3.2. 结构代码范式\n\n【target】\n\n定义用户实际需要的接口。\n\nabstract class target {\n    public abstract void request();\n}\n\n\n【adaptee】\n\n定义一个需要适配的接口。\n\nclass adaptee {\n    public void specificrequest() {\n        system.out.println("特殊请求");\n    }\n}\n\n\n【adapter】\n\n通过在内部包装一个 adaptee 对象，把源接口转换成目标接口。\n\nclass adapter extends target {\n    private adaptee adaptee = new adaptee();\n\n    @override\n    public void request() {\n        adaptee.specificrequest();\n    }\n}\n\n\n【客户端】\n\npublic class adapterpattern {\n    public static void main(string[] args) {\n        target target = new adapter();\n        target.request();\n    }\n}\n\n\n【输出】\n\n特殊请求\n\n\n\n# 4. 伪代码\n\n\n\n适配器假扮成一个圆钉 （round­peg）， 其半径等于方钉 （square­peg） 横截面对角线的一半 （即能够容纳方钉的最小外接圆的半径）。\n\n// 假设你有两个接口相互兼容的类：圆孔（round­hole）和圆钉（round­peg）。\nclass roundhole is\n    constructor roundhole(radius) { ... }\n\n    method getradius() is\n        // 返回孔的半径。\n\n    method fits(peg: roundpeg) is\n        return this.getradius() >= peg.getradius()\n\nclass roundpeg is\n    constructor roundpeg(radius) { ... }\n\n    method getradius() is\n        // 返回钉子的半径。\n\n\n// 但还有一个不兼容的类：方钉（square­peg）。\nclass squarepeg is\n    constructor squarepeg(width) { ... }\n\n    method getwidth() is\n        // 返回方钉的宽度。\n\n\n// 适配器类让你能够将方钉放入圆孔中。它会对 roundpeg 类进行扩展，以接收适\n// 配器对象作为圆钉。\nclass squarepegadapter extends roundpeg is\n    // 在实际情况中，适配器中会包含一个 squarepeg 类的实例。\n    private field peg: squarepeg\n\n    constructor squarepegadapter(peg: squarepeg) is\n        this.peg = peg\n\n    method getradius() is\n        // 适配器会假扮为一个圆钉，\n        // 其半径刚好能与适配器实际封装的方钉搭配起来。\n        return peg.getwidth() * math.sqrt(2) / 2\n\n\n// 客户端代码中的某个位置。\nhole = new roundhole(5)\nrpeg = new roundpeg(5)\nhole.fits(rpeg) // true\n\nsmall_sqpeg = new squarepeg(5)\nlarge_sqpeg = new squarepeg(10)\nhole.fits(small_sqpeg) // 此处无法编译（类型不一致）。\n\nsmall_sqpeg_adapter = new squarepegadapter(small_sqpeg)\nlarge_sqpeg_adapter = new squarepegadapter(large_sqpeg)\nhole.fits(small_sqpeg_adapter) // true\nhole.fits(large_sqpeg_adapter) // false\n\n\n\n# 5. 案例\n\n适配器模式在 java 代码中很常见。\n\njava 核心程序库中有一些标准的适配器：\n\n * java.util.arrays#aslist()\n * java.util.collections#list()\n * java.util.collections#enumeration()\n * java.io.inputstreamreader(inputstream) （返回 reader对象）\n * java.io.outputstreamwriter(outputstream) （返回 writer对象）\n * javax.xml.bind.annotation.adapters.xmladapter#marshal() 和 #unmarshal()\n\n识别方法： 适配器可以通过以不同抽象或接口类型实例为参数的构造函数来识别。 当适配器的任何方法被调用时， 它会将参数转换为合适的格式， 然后将调用定向到其封装对象中的一个或多个方法。\n\n\n# 6. 与其他模式的关系\n\n * 桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。\n * 适配器可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。\n * 适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。\n * 外观模式为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。\n * 桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之桥接模式",frontmatter:{title:"设计模式之桥接模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-16T10:32:00.000Z",permalink:"/pages/9f520d/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08.%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/08.桥接模式.md",key:"v-0569b6f8",path:"/pages/9f520d/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:16},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:243},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:374},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:386},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:771},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:2260},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:3799},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:4125},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:4503}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 案例 6. 与其他模式的关系 7. 参考资料",content:'# 设计模式之桥接模式\n\n\n# 1. 意图\n\n桥接模式 (Bridge) 是一种结构型设计模式， 可将抽象部分与实现部分分离，使它们都可以独立的变化。\n\n如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。抽象化角色和具体化角色都应该可以被子类扩展。在这种情况下，桥接模式可以灵活地组合不同的抽象化角色和具体化角色，并独立化地扩展。\n\n设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。\n\n\n# 2. 适用场景\n\n * 如果你想要拆分或重组一个具有多重功能的庞杂类（例如能与多个数据库服务器进行交互的类），可以使用桥接模式。\n * 如果你希望在几个独立维度上扩展一个类， 可使用该模式。\n * 如果你需要在运行时切换不同实现方法， 可使用桥接模式。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 抽象部分 （Abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。\n 2. 实现部分 （Implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。\n    * 抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。\n 3. 具体实现 （Concrete Implementations） 中包括特定于平台的代码。\n 4. 精确抽象 （Refined Abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。\n 5. 通常情况下， 客户端 （Client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。\n\n\n# 3.2. 结构代码范式\n\n【Implementor】定义实现接口。\n\ninterface Implementor {\n    // 实现抽象部分需要的某些具体功能\n    public void operationImpl();\n}\n\n\n【Abstraction】定义抽象接口。\n\nabstract class Abstraction {\n    // 持有一个 Implementor 对象，形成聚合关系\n    protected Implementor implementor;\n\n    public Abstraction(Implementor implementor) {\n        this.implementor = implementor;\n    }\n\n    // 可能需要转调实现部分的具体实现\n    public void operation() {\n        implementor.operationImpl();\n    }\n}\n\n\n【ConcreteImplementor】实现 Implementor 中定义的接口。\n\nclass ConcreteImplementorA implements Implementor {\n    @Override\n    public void operationImpl() {\n        // 真正的实现\n        System.out.println("具体实现A");\n    }\n}\n\nclass ConcreteImplementorB implements Implementor {\n    @Override\n    public void operationImpl() {\n        // 真正的实现\n        System.out.println("具体实现B");\n    }\n}\n\n\n【RefinedAbstraction】扩展 Abstraction 类。\n\nclass RefinedAbstraction extends Abstraction {\n\n    public RefinedAbstraction(Implementor implementor) {\n        super(implementor);\n    }\n\n    public void otherOperation() {\n        // 实现一定的功能，可能会使用具体实现部分的实现方法,\n        // 但是本方法更大的可能是使用 Abstraction 中定义的方法，\n        // 通过组合使用 Abstraction 中定义的方法来完成更多的功能。\n    }\n}\n\n\n【客户端】\n\npublic class BridgePattern {\n    public static void main(String[] args) {\n        Implementor implementor = new ConcreteImplementorA();\n        RefinedAbstraction abstraction = new RefinedAbstraction(implementor);\n        abstraction.operation();\n        abstraction.otherOperation();\n    }\n}\n\n\n【输出】\n\n具体实现A\n其他操作\n\n\n\n# 4. 伪代码\n\n\n\n遥控器基类声明了一个指向设备对象的引用成员变量。 所有遥控器通过通用设备接口与设备进行交互， 使得同一个遥控器可以支持不同类型的设备。\n\n你可以开发独立于设备类的遥控器类， 只需新建一个遥控器子类即可。 例如， 基础遥控器可能只有两个按钮， 但你可在其基础上扩展新功能， 比如额外的一节电池或一块触摸屏。\n\n客户端代码通过遥控器构造函数将特定种类的遥控器与设备对象连接起来。\n\n// “抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理着一个指向“实\n// 现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。\nclass RemoteControl is\n    protected field device: Device\n    constructor RemoteControl(device: Device) is\n        this.device = device\n    method togglePower() is\n        if (device.isEnabled()) then\n            device.disable()\n        else\n            device.enable()\n    method volumeDown() is\n        device.setVolume(device.getVolume() - 10)\n    method volumeUp() is\n        device.setVolume(device.getVolume() + 10)\n    method channelDown() is\n        device.setChannel(device.getChannel() - 1)\n    method channelUp() is\n        device.setChannel(device.getChannel() + 1)\n\n\n// 你可以独立于设备类的方式从抽象层中扩展类。\nclass AdvancedRemoteControl extends RemoteControl is\n    method mute() is\n        device.setVolume(0)\n\n\n// “实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相\n// 匹配。实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，而\n// 抽象接口则会基于这些操作定义较高层次的操作。\ninterface Device is\n    method isEnabled()\n    method enable()\n    method disable()\n    method getVolume()\n    method setVolume(percent)\n    method getChannel()\n    method setChannel(channel)\n\n\n// 所有设备都遵循相同的接口。\nclass Tv implements Device is\n    // ...\n\nclass Radio implements Device is\n    // ...\n\n\n// 客户端代码中的某个位置。\ntv = new Tv()\nremote = new RemoteControl(tv)\nremote.togglePower()\n\nradio = new Radio()\nremote = new AdvancedRemoteControl(radio)\n\n\n\n# 5. 案例\n\n使用示例： 桥接模式在处理跨平台应用、 支持多种类型的数据库服务器或与多个特定种类 （例如云平台和社交网络等） 的 API 供应商协作时会特别有用。\n\n识别方法： 桥接可以通过一些控制实体及其所依赖的多个不同平台之间的明确区别来进行识别。\n\nJava 中桥接模式应用最经典的代表无疑是日志组件 slf4j 的桥接 jar 包。\n\n假如，你正在开发应用程序所调用的组件当中已经使用了 common-logging，这时你需要 jcl-over-slf4j.jar 把日志信息输出重定向到 slf4j-api，slf4j-api 再去调用 slf4j 实际依赖的日志组件。这个过程称为桥接。下图是官方的 slf4j 桥接策略图：\n\n\n\n\n# 6. 与其他模式的关系\n\n * 桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。\n * 桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 你可以将抽象工厂模式和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。\n * 你可以结合使用生成器模式和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之桥接模式\n\n\n# 1. 意图\n\n桥接模式 (bridge) 是一种结构型设计模式， 可将抽象部分与实现部分分离，使它们都可以独立的变化。\n\n如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的联系。抽象化角色和具体化角色都应该可以被子类扩展。在这种情况下，桥接模式可以灵活地组合不同的抽象化角色和具体化角色，并独立化地扩展。\n\n设计要求实现化角色的任何改变不应当影响客户端，或者说实现化角色的改变对客户端是完全透明的。\n\n\n# 2. 适用场景\n\n * 如果你想要拆分或重组一个具有多重功能的庞杂类（例如能与多个数据库服务器进行交互的类），可以使用桥接模式。\n * 如果你希望在几个独立维度上扩展一个类， 可使用该模式。\n * 如果你需要在运行时切换不同实现方法， 可使用桥接模式。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 抽象部分 （abstraction） 提供高层控制逻辑， 依赖于完成底层实际工作的实现对象。\n 2. 实现部分 （implementation） 为所有具体实现声明通用接口。 抽象部分仅能通过在这里声明的方法与实现对象交互。\n    * 抽象部分可以列出和实现部分一样的方法， 但是抽象部分通常声明一些复杂行为， 这些行为依赖于多种由实现部分声明的原语操作。\n 3. 具体实现 （concrete implementations） 中包括特定于平台的代码。\n 4. 精确抽象 （refined abstraction） 提供控制逻辑的变体。 与其父类一样， 它们通过通用实现接口与不同的实现进行交互。\n 5. 通常情况下， 客户端 （client） 仅关心如何与抽象部分合作。 但是， 客户端需要将抽象对象与一个实现对象连接起来。\n\n\n# 3.2. 结构代码范式\n\n【implementor】定义实现接口。\n\ninterface implementor {\n    // 实现抽象部分需要的某些具体功能\n    public void operationimpl();\n}\n\n\n【abstraction】定义抽象接口。\n\nabstract class abstraction {\n    // 持有一个 implementor 对象，形成聚合关系\n    protected implementor implementor;\n\n    public abstraction(implementor implementor) {\n        this.implementor = implementor;\n    }\n\n    // 可能需要转调实现部分的具体实现\n    public void operation() {\n        implementor.operationimpl();\n    }\n}\n\n\n【concreteimplementor】实现 implementor 中定义的接口。\n\nclass concreteimplementora implements implementor {\n    @override\n    public void operationimpl() {\n        // 真正的实现\n        system.out.println("具体实现a");\n    }\n}\n\nclass concreteimplementorb implements implementor {\n    @override\n    public void operationimpl() {\n        // 真正的实现\n        system.out.println("具体实现b");\n    }\n}\n\n\n【refinedabstraction】扩展 abstraction 类。\n\nclass refinedabstraction extends abstraction {\n\n    public refinedabstraction(implementor implementor) {\n        super(implementor);\n    }\n\n    public void otheroperation() {\n        // 实现一定的功能，可能会使用具体实现部分的实现方法,\n        // 但是本方法更大的可能是使用 abstraction 中定义的方法，\n        // 通过组合使用 abstraction 中定义的方法来完成更多的功能。\n    }\n}\n\n\n【客户端】\n\npublic class bridgepattern {\n    public static void main(string[] args) {\n        implementor implementor = new concreteimplementora();\n        refinedabstraction abstraction = new refinedabstraction(implementor);\n        abstraction.operation();\n        abstraction.otheroperation();\n    }\n}\n\n\n【输出】\n\n具体实现a\n其他操作\n\n\n\n# 4. 伪代码\n\n\n\n遥控器基类声明了一个指向设备对象的引用成员变量。 所有遥控器通过通用设备接口与设备进行交互， 使得同一个遥控器可以支持不同类型的设备。\n\n你可以开发独立于设备类的遥控器类， 只需新建一个遥控器子类即可。 例如， 基础遥控器可能只有两个按钮， 但你可在其基础上扩展新功能， 比如额外的一节电池或一块触摸屏。\n\n客户端代码通过遥控器构造函数将特定种类的遥控器与设备对象连接起来。\n\n// “抽象部分”定义了两个类层次结构中“控制”部分的接口。它管理着一个指向“实\n// 现部分”层次结构中对象的引用，并会将所有真实工作委派给该对象。\nclass remotecontrol is\n    protected field device: device\n    constructor remotecontrol(device: device) is\n        this.device = device\n    method togglepower() is\n        if (device.isenabled()) then\n            device.disable()\n        else\n            device.enable()\n    method volumedown() is\n        device.setvolume(device.getvolume() - 10)\n    method volumeup() is\n        device.setvolume(device.getvolume() + 10)\n    method channeldown() is\n        device.setchannel(device.getchannel() - 1)\n    method channelup() is\n        device.setchannel(device.getchannel() + 1)\n\n\n// 你可以独立于设备类的方式从抽象层中扩展类。\nclass advancedremotecontrol extends remotecontrol is\n    method mute() is\n        device.setvolume(0)\n\n\n// “实现部分”接口声明了在所有具体实现类中通用的方法。它不需要与抽象接口相\n// 匹配。实际上，这两个接口可以完全不一样。通常实现接口只提供原语操作，而\n// 抽象接口则会基于这些操作定义较高层次的操作。\ninterface device is\n    method isenabled()\n    method enable()\n    method disable()\n    method getvolume()\n    method setvolume(percent)\n    method getchannel()\n    method setchannel(channel)\n\n\n// 所有设备都遵循相同的接口。\nclass tv implements device is\n    // ...\n\nclass radio implements device is\n    // ...\n\n\n// 客户端代码中的某个位置。\ntv = new tv()\nremote = new remotecontrol(tv)\nremote.togglepower()\n\nradio = new radio()\nremote = new advancedremotecontrol(radio)\n\n\n\n# 5. 案例\n\n使用示例： 桥接模式在处理跨平台应用、 支持多种类型的数据库服务器或与多个特定种类 （例如云平台和社交网络等） 的 api 供应商协作时会特别有用。\n\n识别方法： 桥接可以通过一些控制实体及其所依赖的多个不同平台之间的明确区别来进行识别。\n\njava 中桥接模式应用最经典的代表无疑是日志组件 slf4j 的桥接 jar 包。\n\n假如，你正在开发应用程序所调用的组件当中已经使用了 common-logging，这时你需要 jcl-over-slf4j.jar 把日志信息输出重定向到 slf4j-api，slf4j-api 再去调用 slf4j 实际依赖的日志组件。这个过程称为桥接。下图是官方的 slf4j 桥接策略图：\n\n\n\n\n# 6. 与其他模式的关系\n\n * 桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。\n * 桥接、 状态模式和策略模式 （在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 你可以将抽象工厂模式和桥接搭配使用。 如果由桥接定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， 抽象工厂可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。\n * 你可以结合使用生成器模式和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之组合模式",frontmatter:{title:"设计模式之组合模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-14T15:33:00.000Z",permalink:"/pages/b18a73/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/09.%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/09.组合模式.md",key:"v-4e6d8200",path:"/pages/b18a73/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:16},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:111},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:340},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:352},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:691},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:2878},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:4858},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:5122},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:5687}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 案例 6. 与其他模式的关系 7. 参考资料",content:'# 设计模式之组合模式\n\n\n# 1. 意图\n\n组合模式 (Component) 是一种结构型设计模式，将对象组合成树形结构以表示“部分-整体”的层次结构。\n\n组合模式使得用户对单个对象和组合对象的使用具有唯一性。\n\n\n# 2. 适用场景\n\n组合模式的适用场景：\n\n * 想要表示对象的部分-整体层次结构。\n * 想要客户端忽略组合对象与单个对象的差异，客户端将统一地使用组合结构中的所有对象。\n\n关于分级数据结构的一个普遍性的例子是你每次使用电脑时所遇到的 文件系统。\n\n文件系统由目录和文件组成。每个目录都可以装内容。目录的内容可以是文件，也 可以是目录。\n\n按照这种方式，计算机的文件系统就是以递归结构来组织的。如果你想要描述这样的数据结构，那么你可以使用组合模式。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 组件 （Component） 接口描述了树中简单项目和复杂项目所共有的操作。\n 2. 叶节点 （Leaf） 是树的基本结构， 它不包含子项目。一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。\n 3. 容器 （Container）——又名 “组合 （Composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。\n 4. 客户端 （Client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。\n\n\n# 3.2. 结构代码范式\n\nComponent : 组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理 Component 的子部件。\n\nabstract class Component {\n    protected String name;\n\n    public Component(String name) {\n        this.name = name;\n    }\n\n    public abstract void Add(Component c);\n    public abstract void Remove(Component c);\n    public abstract void Display(int depth);\n}\n\n\nLeaf : 表示叶节点对象。叶子节点没有子节点。\n\nclass Leaf extends Component {\n\n    public Leaf(String name) {\n        super(name);\n    }\n\n    @Override\n    public void Add(Component c) {\n        System.out.println("Can not add to a leaf");\n    }\n\n    @Override\n    public void Remove(Component c) {\n        System.out.println("Can not remove from a leaf");\n    }\n\n    @Override\n    public void Display(int depth) {\n        String temp = "";\n        for (int i = 0; i < depth; i++)\n            temp += \'-\';\n        System.out.println(temp + name);\n    }\n\n}\n\n\nComposite : 定义枝节点行为，用来存储子部件，在 Component 接口中实现与子部件相关的操作。例如 Add 和 Remove。\n\nclass Composite extends Component {\n\n    private List<Component> children = new ArrayList<Component>();\n\n    public Composite(String name) {\n        super(name);\n    }\n\n    @Override\n    public void Add(Component c) {\n        children.add(c);\n    }\n\n    @Override\n    public void Remove(Component c) {\n        children.remove(c);\n    }\n\n    @Override\n    public void Display(int depth) {\n        String temp = "";\n        for (int i = 0; i < depth; i++)\n            temp += \'-\';\n        System.out.println(temp + name);\n\n        for (Component c : children) {\n            c.Display(depth + 2);\n        }\n    }\n\n}\n\n\nClient : 通过 Component 接口操作结构中的对象。\n\npublic class CompositePattern {\n\n    public static void main(String[] args) {\n        Composite root = new Composite("root");\n        root.Add(new Leaf("Leaf A"));\n        root.Add(new Leaf("Leaf B"));\n\n        Composite compX = new Composite("Composite X");\n        compX.Add(new Leaf("Leaf XA"));\n        compX.Add(new Leaf("Leaf XB"));\n        root.Add(compX);\n\n        Composite compXY = new Composite("Composite XY");\n        compXY.Add(new Leaf("Leaf XYA"));\n        compXY.Add(new Leaf("Leaf XYB"));\n        compX.Add(compXY);\n\n        root.Display(1);\n    }\n\n}\n\n\n\n# 4. 伪代码\n\n在本例中， 我们将借助组合模式帮助你在图形编辑器中实现一系列的几何图形。\n\n\n\n组合图形Compound­Graphic 是一个容器， 它可以由多个包括容器在内的子图形构成。 组合图形与简单图形拥有相同的方法。 但是， 组合图形自身并不完成具体工作， 而是将请求递归地传递给自己的子项目， 然后 “汇总” 结果。\n\n通过所有图形类所共有的接口， 客户端代码可以与所有图形互动。 因此， 客户端不知道与其交互的是简单图形还是组合图形。 客户端可以与非常复杂的对象结构进行交互， 而无需与组成该结构的实体类紧密耦合。\n\n// 组件接口会声明组合中简单和复杂对象的通用操作。\ninterface Graphic is\n    method move(x, y)\n    method draw()\n\n// 叶节点类代表组合的终端对象。叶节点对象中不能包含任何子对象。叶节点对象\n// 通常会完成实际的工作，组合对象则仅会将工作委派给自己的子部件。\nclass Dot implements Graphic is\n    field x, y\n\n    constructor Dot(x, y) { ... }\n\n    method move(x, y) is\n        this.x += x, this.y += y\n\n    method draw() is\n        // 在坐标位置(X,Y)处绘制一个点。\n\n// 所有组件类都可以扩展其他组件。\nclass Circle extends Dot is\n    field radius\n\n    constructor Circle(x, y, radius) { ... }\n\n    method draw() is\n        // 在坐标位置(X,Y)处绘制一个半径为 R 的圆。\n\n// 组合类表示可能包含子项目的复杂组件。组合对象通常会将实际工作委派给子项\n// 目，然后“汇总”结果。\nclass CompoundGraphic implements Graphic is\n    field children: array of Graphic\n\n    // 组合对象可在其项目列表中添加或移除其他组件（简单的或复杂的皆可）。\n    method add(child: Graphic) is\n        // 在子项目数组中添加一个子项目。\n\n    method remove(child: Graphic) is\n        // 从子项目数组中移除一个子项目。\n\n    method move(x, y) is\n        foreach (child in children) do\n            child.move(x, y)\n\n    // 组合会以特定的方式执行其主要逻辑。它会递归遍历所有子项目，并收集和\n    // 汇总其结果。由于组合的子项目也会将调用传递给自己的子项目，以此类推，\n    // 最后组合将会完成整个对象树的遍历工作。\n    method draw() is\n        // 1. 对于每个子部件：\n        //     - 绘制该部件。\n        //     - 更新边框坐标。\n        // 2. 根据边框坐标绘制一个虚线长方形。\n\n\n// 客户端代码会通过基础接口与所有组件进行交互。这样一来，客户端代码便可同\n// 时支持简单叶节点组件和复杂组件。\nclass ImageEditor is\n    field all: CompoundGraphic\n\n    method load() is\n        all = new CompoundGraphic()\n        all.add(new Dot(1, 2))\n        all.add(new Circle(5, 3, 10))\n        // ...\n\n    // 将所需组件组合为复杂的组合组件。\n    method groupSelected(components: array of Graphic) is\n        group = new CompoundGraphic()\n        foreach (component in components) do\n            group.add(component)\n            all.remove(component)\n        all.add(group)\n        // 所有组件都将被绘制。\n        all.draw()\n\n\n\n# 5. 案例\n\n使用实例： 组合模式在 Java 代码中很常见,常用于表示与图形打交道的用户界面组件或代码的层次结构。\n\n下面是一些来自 Java 标准程序库中的组合示例：\n\n * java.awt.Container#add(Component) （几乎广泛存在于 Swing 组件中）\n * javax.faces.component.UIComponent#getChildren() （几乎广泛存在于 JSF UI 组件中）\n\n识别方法： 组合可以通过将同一抽象或接口类型的实例放入树状结构的行为方法来轻松识别。\n\n\n# 6. 与其他模式的关系\n\n * 桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 你可以在创建复杂组合树时使用生成器模式， 因为这可使其构造步骤以递归的方式运行。\n * 责任链模式通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。\n * 你可以使用迭代器模式来遍历组合树。\n * 你可以使用访问者模式对整个组合树执行操作。\n * 你可以使用享元模式实现组合树的共享叶节点以节省内存。\n * 组合和装饰模式的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。\n   * 装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。\n   * 但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。\n * 大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之组合模式\n\n\n# 1. 意图\n\n组合模式 (component) 是一种结构型设计模式，将对象组合成树形结构以表示“部分-整体”的层次结构。\n\n组合模式使得用户对单个对象和组合对象的使用具有唯一性。\n\n\n# 2. 适用场景\n\n组合模式的适用场景：\n\n * 想要表示对象的部分-整体层次结构。\n * 想要客户端忽略组合对象与单个对象的差异，客户端将统一地使用组合结构中的所有对象。\n\n关于分级数据结构的一个普遍性的例子是你每次使用电脑时所遇到的 文件系统。\n\n文件系统由目录和文件组成。每个目录都可以装内容。目录的内容可以是文件，也 可以是目录。\n\n按照这种方式，计算机的文件系统就是以递归结构来组织的。如果你想要描述这样的数据结构，那么你可以使用组合模式。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 组件 （component） 接口描述了树中简单项目和复杂项目所共有的操作。\n 2. 叶节点 （leaf） 是树的基本结构， 它不包含子项目。一般情况下， 叶节点最终会完成大部分的实际工作， 因为它们无法将工作指派给其他部分。\n 3. 容器 （container）——又名 “组合 （composite）”——是包含叶节点或其他容器等子项目的单位。 容器不知道其子项目所属的具体类， 它只通过通用的组件接口与其子项目交互。容器接收到请求后会将工作分配给自己的子项目， 处理中间结果， 然后将最终结果返回给客户端。\n 4. 客户端 （client） 通过组件接口与所有项目交互。 因此， 客户端能以相同方式与树状结构中的简单或复杂项目交互。\n\n\n# 3.2. 结构代码范式\n\ncomponent : 组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理 component 的子部件。\n\nabstract class component {\n    protected string name;\n\n    public component(string name) {\n        this.name = name;\n    }\n\n    public abstract void add(component c);\n    public abstract void remove(component c);\n    public abstract void display(int depth);\n}\n\n\nleaf : 表示叶节点对象。叶子节点没有子节点。\n\nclass leaf extends component {\n\n    public leaf(string name) {\n        super(name);\n    }\n\n    @override\n    public void add(component c) {\n        system.out.println("can not add to a leaf");\n    }\n\n    @override\n    public void remove(component c) {\n        system.out.println("can not remove from a leaf");\n    }\n\n    @override\n    public void display(int depth) {\n        string temp = "";\n        for (int i = 0; i < depth; i++)\n            temp += \'-\';\n        system.out.println(temp + name);\n    }\n\n}\n\n\ncomposite : 定义枝节点行为，用来存储子部件，在 component 接口中实现与子部件相关的操作。例如 add 和 remove。\n\nclass composite extends component {\n\n    private list<component> children = new arraylist<component>();\n\n    public composite(string name) {\n        super(name);\n    }\n\n    @override\n    public void add(component c) {\n        children.add(c);\n    }\n\n    @override\n    public void remove(component c) {\n        children.remove(c);\n    }\n\n    @override\n    public void display(int depth) {\n        string temp = "";\n        for (int i = 0; i < depth; i++)\n            temp += \'-\';\n        system.out.println(temp + name);\n\n        for (component c : children) {\n            c.display(depth + 2);\n        }\n    }\n\n}\n\n\nclient : 通过 component 接口操作结构中的对象。\n\npublic class compositepattern {\n\n    public static void main(string[] args) {\n        composite root = new composite("root");\n        root.add(new leaf("leaf a"));\n        root.add(new leaf("leaf b"));\n\n        composite compx = new composite("composite x");\n        compx.add(new leaf("leaf xa"));\n        compx.add(new leaf("leaf xb"));\n        root.add(compx);\n\n        composite compxy = new composite("composite xy");\n        compxy.add(new leaf("leaf xya"));\n        compxy.add(new leaf("leaf xyb"));\n        compx.add(compxy);\n\n        root.display(1);\n    }\n\n}\n\n\n\n# 4. 伪代码\n\n在本例中， 我们将借助组合模式帮助你在图形编辑器中实现一系列的几何图形。\n\n\n\n组合图形compound­graphic 是一个容器， 它可以由多个包括容器在内的子图形构成。 组合图形与简单图形拥有相同的方法。 但是， 组合图形自身并不完成具体工作， 而是将请求递归地传递给自己的子项目， 然后 “汇总” 结果。\n\n通过所有图形类所共有的接口， 客户端代码可以与所有图形互动。 因此， 客户端不知道与其交互的是简单图形还是组合图形。 客户端可以与非常复杂的对象结构进行交互， 而无需与组成该结构的实体类紧密耦合。\n\n// 组件接口会声明组合中简单和复杂对象的通用操作。\ninterface graphic is\n    method move(x, y)\n    method draw()\n\n// 叶节点类代表组合的终端对象。叶节点对象中不能包含任何子对象。叶节点对象\n// 通常会完成实际的工作，组合对象则仅会将工作委派给自己的子部件。\nclass dot implements graphic is\n    field x, y\n\n    constructor dot(x, y) { ... }\n\n    method move(x, y) is\n        this.x += x, this.y += y\n\n    method draw() is\n        // 在坐标位置(x,y)处绘制一个点。\n\n// 所有组件类都可以扩展其他组件。\nclass circle extends dot is\n    field radius\n\n    constructor circle(x, y, radius) { ... }\n\n    method draw() is\n        // 在坐标位置(x,y)处绘制一个半径为 r 的圆。\n\n// 组合类表示可能包含子项目的复杂组件。组合对象通常会将实际工作委派给子项\n// 目，然后“汇总”结果。\nclass compoundgraphic implements graphic is\n    field children: array of graphic\n\n    // 组合对象可在其项目列表中添加或移除其他组件（简单的或复杂的皆可）。\n    method add(child: graphic) is\n        // 在子项目数组中添加一个子项目。\n\n    method remove(child: graphic) is\n        // 从子项目数组中移除一个子项目。\n\n    method move(x, y) is\n        foreach (child in children) do\n            child.move(x, y)\n\n    // 组合会以特定的方式执行其主要逻辑。它会递归遍历所有子项目，并收集和\n    // 汇总其结果。由于组合的子项目也会将调用传递给自己的子项目，以此类推，\n    // 最后组合将会完成整个对象树的遍历工作。\n    method draw() is\n        // 1. 对于每个子部件：\n        //     - 绘制该部件。\n        //     - 更新边框坐标。\n        // 2. 根据边框坐标绘制一个虚线长方形。\n\n\n// 客户端代码会通过基础接口与所有组件进行交互。这样一来，客户端代码便可同\n// 时支持简单叶节点组件和复杂组件。\nclass imageeditor is\n    field all: compoundgraphic\n\n    method load() is\n        all = new compoundgraphic()\n        all.add(new dot(1, 2))\n        all.add(new circle(5, 3, 10))\n        // ...\n\n    // 将所需组件组合为复杂的组合组件。\n    method groupselected(components: array of graphic) is\n        group = new compoundgraphic()\n        foreach (component in components) do\n            group.add(component)\n            all.remove(component)\n        all.add(group)\n        // 所有组件都将被绘制。\n        all.draw()\n\n\n\n# 5. 案例\n\n使用实例： 组合模式在 java 代码中很常见,常用于表示与图形打交道的用户界面组件或代码的层次结构。\n\n下面是一些来自 java 标准程序库中的组合示例：\n\n * java.awt.container#add(component) （几乎广泛存在于 swing 组件中）\n * javax.faces.component.uicomponent#getchildren() （几乎广泛存在于 jsf ui 组件中）\n\n识别方法： 组合可以通过将同一抽象或接口类型的实例放入树状结构的行为方法来轻松识别。\n\n\n# 6. 与其他模式的关系\n\n * 桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 你可以在创建复杂组合树时使用生成器模式， 因为这可使其构造步骤以递归的方式运行。\n * 责任链模式通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。\n * 你可以使用迭代器模式来遍历组合树。\n * 你可以使用访问者模式对整个组合树执行操作。\n * 你可以使用享元模式实现组合树的共享叶节点以节省内存。\n * 组合和装饰模式的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。\n   * 装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。\n   * 但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。\n * 大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之装饰模式",frontmatter:{title:"设计模式之装饰模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-15T15:41:00.000Z",permalink:"/pages/12897e/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/10.%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/10.装饰模式.md",key:"v-2c19e87c",path:"/pages/12897e/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:16},{level:2,title:"2. 适合场景",slug:"_2-适合场景",normalizedTitle:"2. 适合场景",charIndex:318},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:428},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:440},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:807},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:2806},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:5789},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:6154},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:6835}],headersStr:"1. 意图 2. 适合场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 案例 6. 与其他模式的关系 7. 参考资料",content:'# 设计模式之装饰模式\n\n\n# 1. 意图\n\n装饰模式 (Decorator) 是一种结构型设计模式，动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator 模式相比生成子类更为灵活。\n\n * 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。\n * 装饰对象包含一个真实对象的引用（reference）。\n * 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。\n * 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。\n\n\n# 2. 适合场景\n\n * 如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。\n * 如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 部件 （Component） 声明封装器和被封装对象的公用接口。\n 2. 具体部件 （Concrete Component） 类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。\n 3. 基础装饰 （Base Decorator） 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。\n 4. 具体装饰类 （Concrete Decorators） 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。\n 5. 客户端 （Client） 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。\n\n\n# 3.2. 结构代码范式\n\nComponent : 定义一个对象接口，可以给这些对象动态地添加职责。\n\ninterface Component {\n    public void operation();\n}\n\n\nConcreteComponent : 实现 Component 定义的接口。\n\nclass ConcreteComponent implements Component {\n    @Override\n    public void operation() {\n        System.out.println("初始行为");\n    }\n}\n\n\nDecorator : 装饰抽象类，继承了 Component， 从外类来扩展 Component 类的功能，但对于 Component 来说，是无需知道 Decorator 的存在的。\n\nclass Decorator implements Component {\n    // 持有一个 Component 对象，和 Component 形成聚合关系\n    protected Component component;\n\n    // 传入要进一步修饰的对象\n    public Decorator(Component component) {\n        this.component = component;\n    }\n\n    @Override\n    // 调用要修饰对象的原方法\n    public void operation() {\n        component.operation();\n    }\n}\n\n\nConcreteDecorator : 具体的装饰对象，起到给 Component 添加职责的功能。\n\nclass ConcreteDecoratorA extends Decorator {\n    private String addedState = "新属性1";\n\n    public ConcreteDecoratorA(Component component) {\n        super(component);\n    }\n\n    public void operation() {\n        super.operation();\n        System.out.println("添加属性: " + addedState);\n    }\n}\n\nclass ConcreteDecoratorB extends Decorator {\n    public ConcreteDecoratorB(Component component) {\n        super(component);\n    }\n\n    public void operation() {\n        super.operation();\n        AddedBehavior();\n    }\n\n    public void AddedBehavior() {\n        System.out.println("添加行为");\n    }\n}\n\n\n【客户端】\n\npublic class DecoratorPattern {\n    public static void main(String[] args) {\n        Component component = new ConcreteComponent();\n        component.operation();\n\n        System.out.println("======================================");\n        Decorator decoratorA = new ConcreteDecoratorA(component);\n        decoratorA.operation();\n\n        System.out.println("======================================");\n        Decorator decoratorB = new ConcreteDecoratorB(decoratorA);\n        decoratorB.operation();\n    }\n}\n\n\n【输出】\n\n初始行为\n======================================\n初始行为\n添加属性: 新属性1\n======================================\n初始行为\n添加属性: 新属性1\n添加行为\n\n\n\n# 4. 伪代码\n\n\n\n在本例中， 装饰模式能够对敏感数据进行压缩和加密， 从而将数据从使用数据的代码中独立出来。\n\n程序使用一对装饰来封装数据源对象。 这两个封装器都改变了从磁盘读写数据的方式：\n\n * 当数据即将被写入磁盘前， 装饰对数据进行加密和压缩。 在原始类对改变毫无察觉的情况下， 将加密后的受保护数据写入文件。\n * 当数据刚从磁盘读出后， 同样通过装饰对数据进行解压和解密。 装饰和数据源类实现同一接口， 从而能在客户端代码中相互替换。\n\n// 装饰可以改变组件接口所定义的操作。\ninterface DataSource is\n    method writeData(data)\n    method readData():data\n\n// 具体组件提供操作的默认实现。这些类在程序中可能会有几个变体。\nclass FileDataSource implements DataSource is\n    constructor FileDataSource(filename) { ... }\n\n    method writeData(data) is\n        // 将数据写入文件。\n\n    method readData():data is\n        // 从文件读取数据。\n\n// 装饰基类和其他组件遵循相同的接口。该类的主要任务是定义所有具体装饰的封\n// 装接口。封装的默认实现代码中可能会包含一个保存被封装组件的成员变量，并\n// 且负责对其进行初始化。\nclass DataSourceDecorator implements DataSource is\n    protected field wrappee: DataSource\n\n    constructor DataSourceDecorator(source: DataSource) is\n        wrappee = source\n\n    // 装饰基类会直接将所有工作分派给被封装组件。具体装饰中则可以新增一些\n    // 额外的行为。\n    method writeData(data) is\n        wrappee.writeData(data)\n\n    // 具体装饰可调用其父类的操作实现，而不是直接调用被封装对象。这种方式\n    // 可简化装饰类的扩展工作。\n    method readData():data is\n        return wrappee.readData()\n\n// 具体装饰必须在被封装对象上调用方法，不过也可以自行在结果中添加一些内容。\n// 装饰必须在调用封装对象之前或之后执行额外的行为。\nclass EncryptionDecorator extends DataSourceDecorator is\n    method writeData(data) is\n        // 1. 对传递数据进行加密。\n        // 2. 将加密后数据传递给被封装对象 writeData（写入数据）方法。\n\n    method readData():data is\n        // 1. 通过被封装对象的 readData（读取数据）方法获取数据。\n        // 2. 如果数据被加密就尝试解密。\n        // 3. 返回结果。\n\n// 你可以将对象封装在多层装饰中。\nclass CompressionDecorator extends DataSourceDecorator is\n    method writeData(data) is\n        // 1. 压缩传递数据。\n        // 2. 将压缩后数据传递给被封装对象 writeData（写入数据）方法。\n\n    method readData():data is\n        // 1. 通过被封装对象的 readData（读取数据）方法获取数据。\n        // 2. 如果数据被压缩就尝试解压。\n        // 3. 返回结果。\n\n\n// 选项 1：装饰组件的简单示例\nclass Application is\n    method dumbUsageExample() is\n        source = new FileDataSource("somefile.dat")\n        source.writeData(salaryRecords)\n        // 已将明码数据写入目标文件。\n\n        source = new CompressionDecorator(source)\n        source.writeData(salaryRecords)\n        // 已将压缩数据写入目标文件。\n\n        source = new EncryptionDecorator(source)\n        // 源变量中现在包含：\n        // Encryption > Compression > FileDataSource\n        source.writeData(salaryRecords)\n        // 已将压缩且加密的数据写入目标文件。\n\n\n// 选项 2：客户端使用外部数据源。SalaryManager（工资管理器）对象并不关心\n// 数据如何存储。它们会与提前配置好的数据源进行交互，数据源则是通过程序配\n// 置器获取的。\nclass SalaryManager is\n    field source: DataSource\n\n    constructor SalaryManager(source: DataSource) { ... }\n\n    method load() is\n        return source.readData()\n\n    method save() is\n        source.writeData(salaryRecords)\n    // ...其他有用的方法...\n\n\n// 程序可在运行时根据配置或环境组装不同的装饰堆桟。\nclass ApplicationConfigurator is\n    method configurationExample() is\n        source = new FileDataSource("salary.dat")\n        if (enabledEncryption)\n            source = new EncryptionDecorator(source)\n        if (enabledCompression)\n            source = new CompressionDecorator(source)\n\n        logger = new SalaryManager(source)\n        salary = logger.load()\n    // ...\n\n\n\n# 5. 案例\n\n使用示例： 装饰模式在 Java 代码中可谓是标准配置， 尤其是在与流式加载相关的代码中。\n\nJava 核心程序库中有一些关于装饰的示例：\n\n * java.io.InputStream、 Output­Stream、 Reader 和 Writer 的所有代码都有以自身类型的对象作为参数的构造函数。\n * java.util.Collections； checked­XXX()、 synchronized­XXX() 和 unmodifiable­XXX() 方法。\n * javax.servlet.http.HttpServletRequestWrapper 和 Http­Servlet­Response­Wrapper\n\n识别方法： 装饰可通过以当前类或对象为参数的创建方法或构造函数来识别。\n\n\n# 6. 与其他模式的关系\n\n * 适配器模式可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。\n * 适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。\n * 责任链模式和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。\n   * 责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。\n * 组合模式和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。\n   * 装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。\n   * 但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。\n * 大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。\n * 装饰可让你更改对象的外表， 策略模式则让你能够改变其本质。\n * 装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之装饰模式\n\n\n# 1. 意图\n\n装饰模式 (decorator) 是一种结构型设计模式，动态地给一个对象添加一些额外的职责。就增加功能来说，decorator 模式相比生成子类更为灵活。\n\n * 装饰对象和真实对象有相同的接口。这样客户端对象就能以和真实对象相同的方式和装饰对象交互。\n * 装饰对象包含一个真实对象的引用（reference）。\n * 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。\n * 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来实现对给定类的功能扩展。\n\n\n# 2. 适合场景\n\n * 如果你希望在无需修改代码的情况下即可使用对象， 且希望在运行时为对象新增额外的行为， 可以使用装饰模式。\n * 如果用继承来扩展对象行为的方案难以实现或者根本不可行， 你可以使用该模式。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 部件 （component） 声明封装器和被封装对象的公用接口。\n 2. 具体部件 （concrete component） 类是被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。\n 3. 基础装饰 （base decorator） 类拥有一个指向被封装对象的引用成员变量。 该变量的类型应当被声明为通用部件接口， 这样它就可以引用具体的部件和装饰。 装饰基类会将所有操作委派给被封装的对象。\n 4. 具体装饰类 （concrete decorators） 定义了可动态添加到部件的额外行为。 具体装饰类会重写装饰基类的方法， 并在调用父类方法之前或之后进行额外的行为。\n 5. 客户端 （client） 可以使用多层装饰来封装部件， 只要它能使用通用接口与所有对象互动即可。\n\n\n# 3.2. 结构代码范式\n\ncomponent : 定义一个对象接口，可以给这些对象动态地添加职责。\n\ninterface component {\n    public void operation();\n}\n\n\nconcretecomponent : 实现 component 定义的接口。\n\nclass concretecomponent implements component {\n    @override\n    public void operation() {\n        system.out.println("初始行为");\n    }\n}\n\n\ndecorator : 装饰抽象类，继承了 component， 从外类来扩展 component 类的功能，但对于 component 来说，是无需知道 decorator 的存在的。\n\nclass decorator implements component {\n    // 持有一个 component 对象，和 component 形成聚合关系\n    protected component component;\n\n    // 传入要进一步修饰的对象\n    public decorator(component component) {\n        this.component = component;\n    }\n\n    @override\n    // 调用要修饰对象的原方法\n    public void operation() {\n        component.operation();\n    }\n}\n\n\nconcretedecorator : 具体的装饰对象，起到给 component 添加职责的功能。\n\nclass concretedecoratora extends decorator {\n    private string addedstate = "新属性1";\n\n    public concretedecoratora(component component) {\n        super(component);\n    }\n\n    public void operation() {\n        super.operation();\n        system.out.println("添加属性: " + addedstate);\n    }\n}\n\nclass concretedecoratorb extends decorator {\n    public concretedecoratorb(component component) {\n        super(component);\n    }\n\n    public void operation() {\n        super.operation();\n        addedbehavior();\n    }\n\n    public void addedbehavior() {\n        system.out.println("添加行为");\n    }\n}\n\n\n【客户端】\n\npublic class decoratorpattern {\n    public static void main(string[] args) {\n        component component = new concretecomponent();\n        component.operation();\n\n        system.out.println("======================================");\n        decorator decoratora = new concretedecoratora(component);\n        decoratora.operation();\n\n        system.out.println("======================================");\n        decorator decoratorb = new concretedecoratorb(decoratora);\n        decoratorb.operation();\n    }\n}\n\n\n【输出】\n\n初始行为\n======================================\n初始行为\n添加属性: 新属性1\n======================================\n初始行为\n添加属性: 新属性1\n添加行为\n\n\n\n# 4. 伪代码\n\n\n\n在本例中， 装饰模式能够对敏感数据进行压缩和加密， 从而将数据从使用数据的代码中独立出来。\n\n程序使用一对装饰来封装数据源对象。 这两个封装器都改变了从磁盘读写数据的方式：\n\n * 当数据即将被写入磁盘前， 装饰对数据进行加密和压缩。 在原始类对改变毫无察觉的情况下， 将加密后的受保护数据写入文件。\n * 当数据刚从磁盘读出后， 同样通过装饰对数据进行解压和解密。 装饰和数据源类实现同一接口， 从而能在客户端代码中相互替换。\n\n// 装饰可以改变组件接口所定义的操作。\ninterface datasource is\n    method writedata(data)\n    method readdata():data\n\n// 具体组件提供操作的默认实现。这些类在程序中可能会有几个变体。\nclass filedatasource implements datasource is\n    constructor filedatasource(filename) { ... }\n\n    method writedata(data) is\n        // 将数据写入文件。\n\n    method readdata():data is\n        // 从文件读取数据。\n\n// 装饰基类和其他组件遵循相同的接口。该类的主要任务是定义所有具体装饰的封\n// 装接口。封装的默认实现代码中可能会包含一个保存被封装组件的成员变量，并\n// 且负责对其进行初始化。\nclass datasourcedecorator implements datasource is\n    protected field wrappee: datasource\n\n    constructor datasourcedecorator(source: datasource) is\n        wrappee = source\n\n    // 装饰基类会直接将所有工作分派给被封装组件。具体装饰中则可以新增一些\n    // 额外的行为。\n    method writedata(data) is\n        wrappee.writedata(data)\n\n    // 具体装饰可调用其父类的操作实现，而不是直接调用被封装对象。这种方式\n    // 可简化装饰类的扩展工作。\n    method readdata():data is\n        return wrappee.readdata()\n\n// 具体装饰必须在被封装对象上调用方法，不过也可以自行在结果中添加一些内容。\n// 装饰必须在调用封装对象之前或之后执行额外的行为。\nclass encryptiondecorator extends datasourcedecorator is\n    method writedata(data) is\n        // 1. 对传递数据进行加密。\n        // 2. 将加密后数据传递给被封装对象 writedata（写入数据）方法。\n\n    method readdata():data is\n        // 1. 通过被封装对象的 readdata（读取数据）方法获取数据。\n        // 2. 如果数据被加密就尝试解密。\n        // 3. 返回结果。\n\n// 你可以将对象封装在多层装饰中。\nclass compressiondecorator extends datasourcedecorator is\n    method writedata(data) is\n        // 1. 压缩传递数据。\n        // 2. 将压缩后数据传递给被封装对象 writedata（写入数据）方法。\n\n    method readdata():data is\n        // 1. 通过被封装对象的 readdata（读取数据）方法获取数据。\n        // 2. 如果数据被压缩就尝试解压。\n        // 3. 返回结果。\n\n\n// 选项 1：装饰组件的简单示例\nclass application is\n    method dumbusageexample() is\n        source = new filedatasource("somefile.dat")\n        source.writedata(salaryrecords)\n        // 已将明码数据写入目标文件。\n\n        source = new compressiondecorator(source)\n        source.writedata(salaryrecords)\n        // 已将压缩数据写入目标文件。\n\n        source = new encryptiondecorator(source)\n        // 源变量中现在包含：\n        // encryption > compression > filedatasource\n        source.writedata(salaryrecords)\n        // 已将压缩且加密的数据写入目标文件。\n\n\n// 选项 2：客户端使用外部数据源。salarymanager（工资管理器）对象并不关心\n// 数据如何存储。它们会与提前配置好的数据源进行交互，数据源则是通过程序配\n// 置器获取的。\nclass salarymanager is\n    field source: datasource\n\n    constructor salarymanager(source: datasource) { ... }\n\n    method load() is\n        return source.readdata()\n\n    method save() is\n        source.writedata(salaryrecords)\n    // ...其他有用的方法...\n\n\n// 程序可在运行时根据配置或环境组装不同的装饰堆桟。\nclass applicationconfigurator is\n    method configurationexample() is\n        source = new filedatasource("salary.dat")\n        if (enabledencryption)\n            source = new encryptiondecorator(source)\n        if (enabledcompression)\n            source = new compressiondecorator(source)\n\n        logger = new salarymanager(source)\n        salary = logger.load()\n    // ...\n\n\n\n# 5. 案例\n\n使用示例： 装饰模式在 java 代码中可谓是标准配置， 尤其是在与流式加载相关的代码中。\n\njava 核心程序库中有一些关于装饰的示例：\n\n * java.io.inputstream、 output­stream、 reader 和 writer 的所有代码都有以自身类型的对象作为参数的构造函数。\n * java.util.collections； checked­xxx()、 synchronized­xxx() 和 unmodifiable­xxx() 方法。\n * javax.servlet.http.httpservletrequestwrapper 和 http­servlet­response­wrapper\n\n识别方法： 装饰可通过以当前类或对象为参数的创建方法或构造函数来识别。\n\n\n# 6. 与其他模式的关系\n\n * 适配器模式可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， 装饰还支持递归组合， 适配器则无法实现。\n * 适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。\n * 责任链模式和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。\n   * 责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。\n * 组合模式和装饰的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。\n   * 装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。\n   * 但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。\n * 大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。\n * 装饰可让你更改对象的外表， 策略模式则让你能够改变其本质。\n * 装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之外观模式",frontmatter:{title:"设计模式之外观模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-19T15:15:00.000Z",permalink:"/pages/427347/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/11.%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/11.外观模式.md",key:"v-25c50554",path:"/pages/427347/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:16},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:289},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:376},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:388},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:743},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:1909},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:3083},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:3481},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:3949}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 案例 6. 与其他模式的关系 7. 参考资料",content:'# 设计模式之外观模式\n\n\n# 1. 意图\n\n外观模式 (Facade) 是一种结构型设计模式， 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n * 外观模式为复杂子系统提供了一个简单接口，并不为子系统添加新的功能和行为。\n * 外观模式实现了子系统与客户之间的松耦合关系。\n * 外观模式没有封装子系统的类，只是提供了简单的接口。 如果应用需要，它并不限制客户使用子系统类。因此可以再系统易用性与通用性之间选择。\n * 外观模式注重的是简化接口，它更多的时候是从架构的层次去看整个系统，而并非单个类的层次。\n\n\n# 2. 适用场景\n\n * 如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。\n * 如果需要将子系统组织为多层结构， 可以使用外观。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 外观 （Facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。\n\n 2. 创建附加外观 （Additional Facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。\n\n 3. 复杂子系统 （Complex Subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。\n    \n    子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。\n\n 4. 客户端 （Client） 使用外观代替对子系统对象的直接调用。\n\n\n# 3.2. 结构代码范式\n\nFacade : 了解每个子系统类的功能，负责分发客户端的请求给各个子系统去处理。\n\nclass Class1 {\n    public void op1() {\n        System.out.println("方法1");\n    }\n}\n\nclass Class2 {\n    public void op2() {\n        System.out.println("方法2");\n    }\n}\n\nclass Class3 {\n    public void op3() {\n        System.out.println("方法3");\n    }\n}\n\n\nSubsystem Classes : 实现子系统功能。在不感知 Facade 的情况下，处理 Facade 对象分配的工作，\n\nclass Facade {\n    private Class1 one = new Class1();\n    private Class2 two = new Class2();\n    private Class3 three = new Class3();\n\n    public void op1() {\n        System.out.println("Facade op1()");\n        one.op1();\n    }\n\n    public void op2() {\n        System.out.println("Facade op2()");\n        two.op2();\n    }\n\n    public void op3() {\n        System.out.println("Facade op3()");\n        three.op3();\n    }\n\n    public void Method() {\n        System.out.println("Facade Method()");\n        three.op3();\n        two.op2();\n        one.op1();\n    }\n}\n\n\n【客户端】\n\npublic class FacadePattern {\n    public static void main(String[] args) {\n        Facade facade = new Facade();\n        facade.Method();\n\n        facade.op1();\n    }\n}\n\n\n【输出】\n\nFacade Method()\n方法3\n方法2\n方法1\nFacade op1()\n方法1\n\n\n\n# 4. 伪代码\n\n在本例中， 外观模式简化了客户端与复杂视频转换框架之间的交互。\n\n\n\n你可以创建一个封装所需功能并隐藏其他代码的外观类， 从而无需使全部代码直接与数十个框架类进行交互。 该结构还能将未来框架升级或更换所造成的影响最小化， 因为你只需修改程序中外观方法的实现即可。\n\n// 这里有复杂第三方视频转换框架中的一些类。我们不知晓其中的代码，因此无法\n// 对其进行简化。\n\nclass VideoFile\n// ...\n\nclass OggCompressionCodec\n// ...\n\nclass MPEG4CompressionCodec\n// ...\n\nclass CodecFactory\n// ...\n\nclass BitrateReader\n// ...\n\nclass AudioMixer\n// ...\n\n\n// 为了将框架的复杂性隐藏在一个简单接口背后，我们创建了一个外观类。它是在\n// 功能性和简洁性之间做出的权衡。\nclass VideoConverter is\n    method convert(filename, format):File is\n        file = new VideoFile(filename)\n        sourceCodec = new CodecFactory.extract(file)\n        if (format == "mp4")\n            destinationCodec = new MPEG4CompressionCodec()\n        else\n            destinationCodec = new OggCompressionCodec()\n        buffer = BitrateReader.read(filename, sourceCodec)\n        result = BitrateReader.convert(buffer, destinationCodec)\n        result = (new AudioMixer()).fix(result)\n        return new File(result)\n\n// 应用程序的类并不依赖于复杂框架中成千上万的类。同样，如果你决定更换框架，\n// 那只需重写外观类即可。\nclass Application is\n    method main() is\n        convertor = new VideoConverter()\n        mp4 = convertor.convert("funny-cats-video.ogg", "mp4")\n        mp4.save()\n\n\n\n# 5. 案例\n\n使用示例： 使用 Java 开发的程序中经常会使用外观模式。 它在与复杂程序库和 API 协作时特别有用。\n\n下面是一些核心 Java 程序库中的外观示例：\n\n * javax.faces.context.FacesContext 在底层使用了 Life­Cycle、 View­Handler 和 Navigation­Handler 这几个类， 但绝大多数客户端不知道。\n * javax.faces.context.ExternalContext 在内部使用了 Servlet­Context、 Http­Session、 Http­Servlet­Request、 Http­Servlet­Response 和其他一些类。\n\n识别方法： 外观可以通过使用简单接口， 但将绝大部分工作委派给其他类的类来识别。 通常情况下， 外观管理着其所使用的对象的完整生命周期。\n\n\n# 6. 与其他模式的关系\n\n * 外观模式为现有对象定义了一个新接口， 适配器模式则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。\n * 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂模式来代替外观。\n * 享元模式展示了如何生成大量的小型对象， 外观则展示了如何用一个对象来代表整个子系统。\n * 外观和中介者模式的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。\n   * 外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。\n   * 中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。\n * 外观类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。\n * 外观与代理模式的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之外观模式\n\n\n# 1. 意图\n\n外观模式 (facade) 是一种结构型设计模式， 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n * 外观模式为复杂子系统提供了一个简单接口，并不为子系统添加新的功能和行为。\n * 外观模式实现了子系统与客户之间的松耦合关系。\n * 外观模式没有封装子系统的类，只是提供了简单的接口。 如果应用需要，它并不限制客户使用子系统类。因此可以再系统易用性与通用性之间选择。\n * 外观模式注重的是简化接口，它更多的时候是从架构的层次去看整个系统，而并非单个类的层次。\n\n\n# 2. 适用场景\n\n * 如果你需要一个指向复杂子系统的直接接口， 且该接口的功能有限， 则可以使用外观模式。\n * 如果需要将子系统组织为多层结构， 可以使用外观。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 外观 （facade） 提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。\n\n 2. 创建附加外观 （additional facade） 类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。\n\n 3. 复杂子系统 （complex subsystem） 由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。\n    \n    子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。\n\n 4. 客户端 （client） 使用外观代替对子系统对象的直接调用。\n\n\n# 3.2. 结构代码范式\n\nfacade : 了解每个子系统类的功能，负责分发客户端的请求给各个子系统去处理。\n\nclass class1 {\n    public void op1() {\n        system.out.println("方法1");\n    }\n}\n\nclass class2 {\n    public void op2() {\n        system.out.println("方法2");\n    }\n}\n\nclass class3 {\n    public void op3() {\n        system.out.println("方法3");\n    }\n}\n\n\nsubsystem classes : 实现子系统功能。在不感知 facade 的情况下，处理 facade 对象分配的工作，\n\nclass facade {\n    private class1 one = new class1();\n    private class2 two = new class2();\n    private class3 three = new class3();\n\n    public void op1() {\n        system.out.println("facade op1()");\n        one.op1();\n    }\n\n    public void op2() {\n        system.out.println("facade op2()");\n        two.op2();\n    }\n\n    public void op3() {\n        system.out.println("facade op3()");\n        three.op3();\n    }\n\n    public void method() {\n        system.out.println("facade method()");\n        three.op3();\n        two.op2();\n        one.op1();\n    }\n}\n\n\n【客户端】\n\npublic class facadepattern {\n    public static void main(string[] args) {\n        facade facade = new facade();\n        facade.method();\n\n        facade.op1();\n    }\n}\n\n\n【输出】\n\nfacade method()\n方法3\n方法2\n方法1\nfacade op1()\n方法1\n\n\n\n# 4. 伪代码\n\n在本例中， 外观模式简化了客户端与复杂视频转换框架之间的交互。\n\n\n\n你可以创建一个封装所需功能并隐藏其他代码的外观类， 从而无需使全部代码直接与数十个框架类进行交互。 该结构还能将未来框架升级或更换所造成的影响最小化， 因为你只需修改程序中外观方法的实现即可。\n\n// 这里有复杂第三方视频转换框架中的一些类。我们不知晓其中的代码，因此无法\n// 对其进行简化。\n\nclass videofile\n// ...\n\nclass oggcompressioncodec\n// ...\n\nclass mpeg4compressioncodec\n// ...\n\nclass codecfactory\n// ...\n\nclass bitratereader\n// ...\n\nclass audiomixer\n// ...\n\n\n// 为了将框架的复杂性隐藏在一个简单接口背后，我们创建了一个外观类。它是在\n// 功能性和简洁性之间做出的权衡。\nclass videoconverter is\n    method convert(filename, format):file is\n        file = new videofile(filename)\n        sourcecodec = new codecfactory.extract(file)\n        if (format == "mp4")\n            destinationcodec = new mpeg4compressioncodec()\n        else\n            destinationcodec = new oggcompressioncodec()\n        buffer = bitratereader.read(filename, sourcecodec)\n        result = bitratereader.convert(buffer, destinationcodec)\n        result = (new audiomixer()).fix(result)\n        return new file(result)\n\n// 应用程序的类并不依赖于复杂框架中成千上万的类。同样，如果你决定更换框架，\n// 那只需重写外观类即可。\nclass application is\n    method main() is\n        convertor = new videoconverter()\n        mp4 = convertor.convert("funny-cats-video.ogg", "mp4")\n        mp4.save()\n\n\n\n# 5. 案例\n\n使用示例： 使用 java 开发的程序中经常会使用外观模式。 它在与复杂程序库和 api 协作时特别有用。\n\n下面是一些核心 java 程序库中的外观示例：\n\n * javax.faces.context.facescontext 在底层使用了 life­cycle、 view­handler 和 navigation­handler 这几个类， 但绝大多数客户端不知道。\n * javax.faces.context.externalcontext 在内部使用了 servlet­context、 http­session、 http­servlet­request、 http­servlet­response 和其他一些类。\n\n识别方法： 外观可以通过使用简单接口， 但将绝大部分工作委派给其他类的类来识别。 通常情况下， 外观管理着其所使用的对象的完整生命周期。\n\n\n# 6. 与其他模式的关系\n\n * 外观模式为现有对象定义了一个新接口， 适配器模式则会试图运用已有的接口。 适配器通常只封装一个对象， 外观通常会作用于整个对象子系统上。\n * 当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用抽象工厂模式来代替外观。\n * 享元模式展示了如何生成大量的小型对象， 外观则展示了如何用一个对象来代表整个子系统。\n * 外观和中介者模式的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。\n   * 外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。\n   * 中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。\n * 外观类通常可以转换为单例模式类， 因为在大部分情况下一个外观对象就足够了。\n * 外观与代理模式的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之享元模式",frontmatter:{title:"设计模式之享元模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-19T09:48:00.000Z",permalink:"/pages/265866/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/12.%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/12.享元模式.md",key:"v-6e2d857c",path:"/pages/265866/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:16},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:25},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:36},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:47},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:62},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:77},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:87},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:96},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:111}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 案例 6. 与其他模式的关系 7. 参考资料",content:'# 设计模式之享元模式\n\n * 1. 意图\n * 2. 适用场景\n * 3. 结构\n   * 3.1. 结构说明\n   * 3.2. 结构代码范式\n * 4. 伪代码\n * 5. 案例\n * 6. 与其他模式的关系\n * 7. 参考资料\n\n\n# 1. 意图\n\n享元模式 (Flyweight) 是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。\n\n\n# 2. 适用场景\n\n * 仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。\n 2. 享元 （Flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。\n 3. 情景 （Context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。\n 4. 通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。\n 5. 客户端 （Client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。\n 6. 享元工厂 （Flyweight Factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。\n\n\n# 3.2. 结构代码范式\n\nFlyweight : 它是所有具体享元类的超类或接口，通过这个接口，Flyweight 可以接受并作用于外部状态。\n\nabstract class Flyweight {\n    public abstract void operation(int extrinsicstates);\n}\n\n\nConcreteFlyweight : 是继承 Flyweight 超类或实现 Flyweight 接口，并为内部状态增加存储空间。\n\nclass ConcreteFlyweight extends Flyweight {\n    @Override\n    public void operation(int extrinsicstates) {\n        System.out.println("共享的Flyweight : " + extrinsicstates);\n    }\n}\n\n\nUnsharedConcreteFlyweight : 指那些不需要共享的 Flyweight 子类，因为 Flyweight 接口共享成为可能，但它并不强制共享。\n\nclass UnsharedConcreteFlyweight extends Flyweight {\n    @Override\n    public void operation(int extrinsicstates) {\n        System.out.println("不共享的Flyweight : " + extrinsicstates);\n    }\n}\n\n\nFlywightFactory :是一个享元工厂，用来创建并管理 Flyweight 对象。它主要是用来确保合理地共享 Flyweight ，当用户请求一个 Flyweight 时， FlyweightFactory 对象提供一个已创建的实例或创建一个（如果对象不存在的话）。\n\nclass FlywightFactory {\n    private Hashtable<String, Flyweight> flyweights = new Hashtable<String, Flyweight>();\n\n    public FlywightFactory() {\n        flyweights.put("X", new ConcreteFlyweight());\n        flyweights.put("Y", new ConcreteFlyweight());\n        flyweights.put("Z", new ConcreteFlyweight());\n    }\n\n    public Flyweight getFlyweight(String key) {\n        return ((Flyweight)flyweights.get(key));\n    }\n}\n\n\n客户端\n\npublic class FlyweightPattern {\n    public static void main(String[] args) {\n        int extrinsicstates = 1;\n        FlywightFactory factory = new FlywightFactory();\n\n        Flyweight fx = factory.getFlyweight("X");\n        fx.operation(extrinsicstates);\n\n        Flyweight fy = factory.getFlyweight("Y");\n        fy.operation(++extrinsicstates);\n\n        Flyweight fz = factory.getFlyweight("Z");\n        fz.operation(++extrinsicstates);\n\n        Flyweight uf = new UnsharedConcreteFlyweight();\n        uf.operation(++extrinsicstates);\n    }\n}\n\n\n输出\n\n共享的Flyweight : 1\n共享的Flyweight : 2\n共享的Flyweight : 3\n不共享的Flyweight : 4\n\n\n\n# 4. 伪代码\n\n\n\n在本例中， 享元模式能有效减少在画布上渲染数百万个树状对象时所需的内存。\n\n该模式从主要的 树Tree 类中抽取内在状态， 并将其移动到享元类 树种类Tree­Type 之中。\n\n最初程序需要在多个对象中存储相同数据， 而现在仅需在几个享元对象中保存数据， 然后在作为情景的 树对象中连入享元即可。 客户端代码使用享元工厂创建树对象并封装搜索指定对象的复杂行为， 并能在需要时复用对象。\n\n// 享元类包含一个树的部分状态。这些成员变量保存的数值对于特定树而言是唯一\n// 的。例如，你在这里找不到树的坐标。但这里有很多树木之间所共有的纹理和颜\n// 色。由于这些数据的体积通常非常大，所以如果让每棵树都其进行保存的话将耗\n// 费大量内存。因此，我们可将纹理、颜色和其他重复数据导出到一个单独的对象\n// 中，然后让众多的单个树对象去引用它。\nclass TreeType is\n    field name\n    field color\n    field texture\n    constructor TreeType(name, color, texture) { ... }\n    method draw(canvas, x, y) is\n        // 1. 创建特定类型、颜色和纹理的位图。\n        // 2. 在画布坐标 (X,Y) 处绘制位图。\n\n// 享元工厂决定是否复用已有享元或者创建一个新的对象。\nclass TreeFactory is\n    static field treeTypes: collection of tree types\n    static method getTreeType(name, color, texture) is\n        type = treeTypes.find(name, color, texture)\n        if (type == null)\n            type = new TreeType(name, color, texture)\n            treeTypes.add(type)\n        return type\n\n// 情景对象包含树状态的外在部分。程序中可以创建数十亿个此类对象，因为它们\n// 体积很小：仅有两个整型坐标和一个引用成员变量。\nclass Tree is\n    field x,y\n    field type: TreeType\n    constructor Tree(x, y, type) { ... }\n    method draw(canvas) is\n        type.draw(canvas, this.x, this.y)\n\n// 树（Tree）和森林（Forest）类是享元的客户端。如果不打算继续对树类进行开\n// 发，你可以将它们合并。\nclass Forest is\n    field trees: collection of Trees\n\n    method plantTree(x, y, name, color, texture) is\n        type = TreeFactory.getTreeType(name, color, texture)\n        tree = new Tree(x, y, type)\n        trees.add(tree)\n\n    method draw(canvas) is\n        foreach (tree in trees) do\n            tree.draw(canvas)\n\n\n\n# 5. 案例\n\n使用示例： 享元模式只有一个目的： 将内存消耗最小化。 如果你的程序没有遇到内存容量不足的问题， 则可以暂时忽略该模式。\n\n享元模式在核心 Java 程序库中的示例：\n\n * java.lang.Integer#valueOf(int) （以及 Boolean、 Byte、 Character、 Short、 Long 和 Big­Decimal）\n\n识别方法： 享元可以通过构建方法来识别， 它会返回缓存对象而不是创建新的对象。\n\n\n# 6. 与其他模式的关系\n\n * 你可以使用享元模式实现组合模式树的共享叶节点以节省内存。\n * 享元展示了如何生成大量的小型对象， 外观模式则展示了如何用一个对象来代表整个子系统。\n * 如果你能将对象的所有共享状态简化为一个享元对象， 那么享元就和单例模式类似了。 但这两个模式有两个根本性的不同。\n   1. 只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。\n   2. 单例对象可以是可变的。 享元对象是不可变的。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之享元模式\n\n * 1. 意图\n * 2. 适用场景\n * 3. 结构\n   * 3.1. 结构说明\n   * 3.2. 结构代码范式\n * 4. 伪代码\n * 5. 案例\n * 6. 与其他模式的关系\n * 7. 参考资料\n\n\n# 1. 意图\n\n享元模式 (flyweight) 是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。\n\n\n# 2. 适用场景\n\n * 仅在程序必须支持大量对象且没有足够的内存容量时使用享元模式。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。\n 2. 享元 （flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。\n 3. 情景 （context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。\n 4. 通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。\n 5. 客户端 （client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。\n 6. 享元工厂 （flyweight factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。\n\n\n# 3.2. 结构代码范式\n\nflyweight : 它是所有具体享元类的超类或接口，通过这个接口，flyweight 可以接受并作用于外部状态。\n\nabstract class flyweight {\n    public abstract void operation(int extrinsicstates);\n}\n\n\nconcreteflyweight : 是继承 flyweight 超类或实现 flyweight 接口，并为内部状态增加存储空间。\n\nclass concreteflyweight extends flyweight {\n    @override\n    public void operation(int extrinsicstates) {\n        system.out.println("共享的flyweight : " + extrinsicstates);\n    }\n}\n\n\nunsharedconcreteflyweight : 指那些不需要共享的 flyweight 子类，因为 flyweight 接口共享成为可能，但它并不强制共享。\n\nclass unsharedconcreteflyweight extends flyweight {\n    @override\n    public void operation(int extrinsicstates) {\n        system.out.println("不共享的flyweight : " + extrinsicstates);\n    }\n}\n\n\nflywightfactory :是一个享元工厂，用来创建并管理 flyweight 对象。它主要是用来确保合理地共享 flyweight ，当用户请求一个 flyweight 时， flyweightfactory 对象提供一个已创建的实例或创建一个（如果对象不存在的话）。\n\nclass flywightfactory {\n    private hashtable<string, flyweight> flyweights = new hashtable<string, flyweight>();\n\n    public flywightfactory() {\n        flyweights.put("x", new concreteflyweight());\n        flyweights.put("y", new concreteflyweight());\n        flyweights.put("z", new concreteflyweight());\n    }\n\n    public flyweight getflyweight(string key) {\n        return ((flyweight)flyweights.get(key));\n    }\n}\n\n\n客户端\n\npublic class flyweightpattern {\n    public static void main(string[] args) {\n        int extrinsicstates = 1;\n        flywightfactory factory = new flywightfactory();\n\n        flyweight fx = factory.getflyweight("x");\n        fx.operation(extrinsicstates);\n\n        flyweight fy = factory.getflyweight("y");\n        fy.operation(++extrinsicstates);\n\n        flyweight fz = factory.getflyweight("z");\n        fz.operation(++extrinsicstates);\n\n        flyweight uf = new unsharedconcreteflyweight();\n        uf.operation(++extrinsicstates);\n    }\n}\n\n\n输出\n\n共享的flyweight : 1\n共享的flyweight : 2\n共享的flyweight : 3\n不共享的flyweight : 4\n\n\n\n# 4. 伪代码\n\n\n\n在本例中， 享元模式能有效减少在画布上渲染数百万个树状对象时所需的内存。\n\n该模式从主要的 树tree 类中抽取内在状态， 并将其移动到享元类 树种类tree­type 之中。\n\n最初程序需要在多个对象中存储相同数据， 而现在仅需在几个享元对象中保存数据， 然后在作为情景的 树对象中连入享元即可。 客户端代码使用享元工厂创建树对象并封装搜索指定对象的复杂行为， 并能在需要时复用对象。\n\n// 享元类包含一个树的部分状态。这些成员变量保存的数值对于特定树而言是唯一\n// 的。例如，你在这里找不到树的坐标。但这里有很多树木之间所共有的纹理和颜\n// 色。由于这些数据的体积通常非常大，所以如果让每棵树都其进行保存的话将耗\n// 费大量内存。因此，我们可将纹理、颜色和其他重复数据导出到一个单独的对象\n// 中，然后让众多的单个树对象去引用它。\nclass treetype is\n    field name\n    field color\n    field texture\n    constructor treetype(name, color, texture) { ... }\n    method draw(canvas, x, y) is\n        // 1. 创建特定类型、颜色和纹理的位图。\n        // 2. 在画布坐标 (x,y) 处绘制位图。\n\n// 享元工厂决定是否复用已有享元或者创建一个新的对象。\nclass treefactory is\n    static field treetypes: collection of tree types\n    static method gettreetype(name, color, texture) is\n        type = treetypes.find(name, color, texture)\n        if (type == null)\n            type = new treetype(name, color, texture)\n            treetypes.add(type)\n        return type\n\n// 情景对象包含树状态的外在部分。程序中可以创建数十亿个此类对象，因为它们\n// 体积很小：仅有两个整型坐标和一个引用成员变量。\nclass tree is\n    field x,y\n    field type: treetype\n    constructor tree(x, y, type) { ... }\n    method draw(canvas) is\n        type.draw(canvas, this.x, this.y)\n\n// 树（tree）和森林（forest）类是享元的客户端。如果不打算继续对树类进行开\n// 发，你可以将它们合并。\nclass forest is\n    field trees: collection of trees\n\n    method planttree(x, y, name, color, texture) is\n        type = treefactory.gettreetype(name, color, texture)\n        tree = new tree(x, y, type)\n        trees.add(tree)\n\n    method draw(canvas) is\n        foreach (tree in trees) do\n            tree.draw(canvas)\n\n\n\n# 5. 案例\n\n使用示例： 享元模式只有一个目的： 将内存消耗最小化。 如果你的程序没有遇到内存容量不足的问题， 则可以暂时忽略该模式。\n\n享元模式在核心 java 程序库中的示例：\n\n * java.lang.integer#valueof(int) （以及 boolean、 byte、 character、 short、 long 和 big­decimal）\n\n识别方法： 享元可以通过构建方法来识别， 它会返回缓存对象而不是创建新的对象。\n\n\n# 6. 与其他模式的关系\n\n * 你可以使用享元模式实现组合模式树的共享叶节点以节省内存。\n * 享元展示了如何生成大量的小型对象， 外观模式则展示了如何用一个对象来代表整个子系统。\n * 如果你能将对象的所有共享状态简化为一个享元对象， 那么享元就和单例模式类似了。 但这两个模式有两个根本性的不同。\n   1. 只会有一个单例实体， 但是享元类可以有多个实体， 各实体的内在状态也可以不同。\n   2. 单例对象可以是可变的。 享元对象是不可变的。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之代理模式",frontmatter:{title:"设计模式之代理模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-19T11:38:00.000Z",permalink:"/pages/2937c1/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/13.%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/13.代理模式.md",key:"v-51d6ac9c",path:"/pages/2937c1/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:16},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:187},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:497},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:509},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:785},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:1382},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:3619},{level:3,title:"5.1. 注解+反射+代理消除重复代码",slug:"_5-1-注解-反射-代理消除重复代码",normalizedTitle:"5.1. 注解+反射+代理消除重复代码",charIndex:3952},{level:4,title:"问题版本",slug:"问题版本",normalizedTitle:"问题版本",charIndex:4280},{level:4,title:"优化版本",slug:"优化版本",normalizedTitle:"优化版本",charIndex:6344},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:11181},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:11463}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 案例 5.1. 注解+反射+代理消除重复代码 问题版本 优化版本 6. 与其他模式的关系 7. 参考资料",content:'# 设计模式之代理模式\n\n\n# 1. 意图\n\n代理模式 (Proxy) 是一种结构型设计模式， 为其他对象提供一种代理以控制对这个对象的访问。\n\n * 代理模式介绍了一种访问对象的间接等级。\n * 一个远程代理可以隐藏一个对象在不同地址空间的细节。\n * 一个虚拟代理可以根据需要最优化创建对象的开销。\n * 而安全代理和智能指引都允许访问对象的同时处理其他事务。\n\n\n# 2. 适用场景\n\n * 延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。\n * 访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。\n * 本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。\n * 记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。\n * 智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 服务接口 （Service Interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。\n 2. 服务 （Service） 类提供了一些实用的业务逻辑。\n 3. 代理 （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。\n 4. 客户端 （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。\n\n\n# 3.2. 结构代码范式\n\nSubject : 定义了 RealSubject 和 Proxy 的公共接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy 。\n\nabstract class Subject {\n    public abstract void Request();\n}\n\n\nRealSubject : 定义 Proxy 所代表的真实实体。\n\nclass RealSubject extends Subject {\n    @Override\n    public void Request() {\n        System.out.println("真实的请求");\n    }\n}\n\n\nProxy : 保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。\n\nclass Proxy extends Subject {\n    private RealSubject real;\n\n    @Override\n    public void Request() {\n        if (null == real) {\n            real = new RealSubject();\n        }\n        real.Request();\n    }\n}\n\n\n\n# 4. 伪代码\n\n本例演示如何使用代理模式在第三方腾讯视频 （TencentVideo， 代码示例中记为 TV） 程序库中添加延迟初始化和缓存。\n\n\n\n程序库提供了视频下载类。 但是该类的效率非常低。 如果客户端程序多次请求同一视频， 程序库会反复下载该视频， 而不会将首次下载的文件缓存下来复用。\n\n代理类实现和原下载器相同的接口， 并将所有工作委派给原下载器。 不过， 代理类会保存所有的文件下载记录， 如果程序多次请求同一文件， 它会返回缓存的文件。\n\n// 远程服务接口。\ninterface ThirdPartyTVLib is\n    method listVideos()\n    method getVideoInfo(id)\n    method downloadVideo(id)\n\n// 服务连接器的具体实现。该类的方法可以向腾讯视频请求信息。请求速度取决于\n// 用户和腾讯视频的互联网连接情况。如果同时发送大量请求，即使所请求的信息\n// 一模一样，程序的速度依然会减慢。\nclass ThirdPartyTVClass implements ThirdPartyTVLib is\n    method listVideos() is\n        // 向腾讯视频发送一个 API 请求。\n\n    method getVideoInfo(id) is\n        // 获取某个视频的元数据。\n\n    method downloadVideo(id) is\n        // 从腾讯视频下载一个视频文件。\n\n// 为了节省网络带宽，我们可以将请求结果缓存下来并保存一段时间。但你可能无\n// 法直接将这些代码放入服务类中。比如该类可能是第三方程序库的一部分或其签\n// 名是`final（最终）`。因此我们会在一个实现了服务类接口的新代理类中放入\n// 缓存代码。当代理类接收到真实请求后，才会将其委派给服务对象。\nclass CachedTVClass implements ThirdPartyTVLib is\n    private field service: ThirdPartyTVLib\n    private field listCache, videoCache\n    field needReset\n\n    constructor CachedTVClass(service: ThirdPartyTVLib) is\n        this.service = service\n\n    method listVideos() is\n        if (listCache == null || needReset)\n            listCache = service.listVideos()\n        return listCache\n\n    method getVideoInfo(id) is\n        if (videoCache == null || needReset)\n            videoCache = service.getVideoInfo(id)\n        return videoCache\n\n    method downloadVideo(id) is\n        if (!downloadExists(id) || needReset)\n            service.downloadVideo(id)\n\n// 之前直接与服务对象交互的 GUI 类不需要改变，前提是它仅通过接口与服务对\n// 象交互。我们可以安全地传递一个代理对象来代替真实服务对象，因为它们都实\n// 现了相同的接口。\nclass TVManager is\n    protected field service: ThirdPartyTVLib\n\n    constructor TVManager(service: ThirdPartyTVLib) is\n        this.service = service\n\n    method renderVideoPage(id) is\n        info = service.getVideoInfo(id)\n        // 渲染视频页面。\n\n    method renderListPanel() is\n        list = service.listVideos()\n        // 渲染视频缩略图列表。\n\n    method reactOnUserInput() is\n        renderVideoPage()\n        renderListPanel()\n\n// 程序可在运行时对代理进行配置。\nclass Application is\n    method init() is\n        aTVService = new ThirdPartyTVClass()\n        aTVProxy = new CachedTVClass(aTVService)\n        manager = new TVManager(aTVProxy)\n        manager.reactOnUserInput()\n\n\n\n# 5. 案例\n\n使用示例： 尽管代理模式在绝大多数 Java 程序中并不常见， 但它在一些特殊情况下仍然非常方便。 当你希望在无需修改客户代码的前提下于已有类的对象上增加额外行为时， 该模式是无可替代的。\n\nJava 标准程序库中的一些代理模式的示例：\n\n * java.lang.reflect.Proxy\n * java.rmi.*\n * javax.ejb.EJB （查看评论）\n * javax.inject.Inject （查看评论）\n * javax.persistence.PersistenceContext\n\n识别方法： 代理模式会将所有实际工作委派给一些其他对象。 除非代理是某个服务的子类， 否则每个代理方法最后都应该引用一个服务对象。\n\n\n# 5.1. 注解+反射+代理消除重复代码\n\n假设银行提供了一些 API 接口，对参数的序列化有点特殊，不使用 JSON，而是需要我们把参数依次拼在一起构成一个大字符串。\n\n按照银行提供的 API 文档的顺序，把所有参数构成定长的数据，然后拼接在一起作为整个字符串。因为每一种参数都有固定长度，未达到长度时需要做填充处理：\n\n * 字符串类型的参数不满长度部分需要以下划线右填充，也就是字符串内容靠左；\n * 数字类型的参数不满长度部分以 0 左填充，也就是实际数字靠右；\n * 货币类型的表示需要把金额向下舍入 2 位到分，以分为单位，作为数字类型同样进行 左填充。\n\n对所有参数做 MD5 操作作为签名（为了方便理解，Demo 中不涉及加盐处理）。\n\n# 问题版本\n\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.apache.http.client.fluent.Request;\nimport org.apache.http.entity.ContentType;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\n\npublic class BankService {\n\n    public static String createUser(String name, String identity, String mobile, int age) throws IOException {\n        StringBuilder stringBuilder = new StringBuilder();\n        //字符串靠左，多余的地方_填充\n        stringBuilder.append(String.format("%-10s", name).replace(\' \', \'_\'));\n        //字符串靠左，多余的地方_填充\n        stringBuilder.append(String.format("%-18s", identity).replace(\' \', \'_\'));\n        //数字靠右，多余的地方用0填充\n        stringBuilder.append(String.format("%05d", age));\n        //字符串靠左，多余的地方_填充\n        stringBuilder.append(String.format("%-11s", mobile).replace(\' \', \'_\'));\n        //最后加上MD5作为签名\n        stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));\n        return Request.Post("http://localhost:45678/reflection/bank/createUser")\n                .bodyString(stringBuilder.toString(), ContentType.APPLICATION_JSON)\n                .execute().returnContent().asString();\n    }\n\n    public static String pay(long userId, BigDecimal amount) throws IOException {\n        StringBuilder stringBuilder = new StringBuilder();\n        //数字靠右，多余的地方用0填充\n        stringBuilder.append(String.format("%020d", userId));\n        //金额向下舍入2位到分，以分为单位，作为数字靠右，多余的地方用0填充\n        stringBuilder.append(String.format("%010d", amount.setScale(2, RoundingMode.DOWN).multiply(new BigDecimal("100")).longValue()));\n        //最后加上MD5作为签名\n        stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));\n        return Request.Post("http://localhost:45678/reflection/bank/pay")\n                .bodyString(stringBuilder.toString(), ContentType.APPLICATION_JSON)\n                .execute().returnContent().asString();\n    }\n}\n\n\n在以上的代码版本中，存在以下问题：\n\n * 三种标准数据类型的处理逻辑有重复，稍有不慎就会出现 Bug；\n * 处理流程中字符串拼接、加签和发请求的逻辑，在所有方法重复；\n * 实际方法的入参的参数类型和顺序，不一定和接口要求一致，容易出错；\n * 代码层面针对每一个参数硬编码，无法清晰地进行核对，如果参数达到几十个、上百个，出错的概率极大。\n\n# 优化版本\n\n针对上面代码版本中的问题，可以使用 注解+反射+代理模式 解决重复代码。\n\n【注解一】\n\nimport java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Documented\n@Inherited\npublic @interface BankAPI {\n\n    String desc() default "";\n\n    String url() default "";\n\n}\n\n\n【注解二】\n\nimport java.lang.annotation.*;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\n@Documented\n@Inherited\npublic @interface BankAPIField {\n\n    int order() default -1;\n\n    int length() default -1;\n\n    String type() default "";\n\n}\n\n\n【抽象类】\n\nabstract class AbstractAPI {}\n\n\n【代理类】\n\n@Slf4j\npublic class BetterBankService {\n\n    public static String createUser(String name, String identity, String mobile, int age) throws IOException {\n        CreateUserAPI createUserAPI = new CreateUserAPI();\n        createUserAPI.setName(name);\n        createUserAPI.setIdentity(identity);\n        createUserAPI.setAge(age);\n        createUserAPI.setMobile(mobile);\n        return remoteCall(createUserAPI);\n    }\n\n    public static String pay(long userId, BigDecimal amount) throws IOException {\n        PayAPI payAPI = new PayAPI();\n        payAPI.setUserId(userId);\n        payAPI.setAmount(amount);\n        return remoteCall(payAPI);\n    }\n\n    private static String remoteCall(AbstractAPI api) throws IOException {\n        //从BankAPI注解获取请求地址\n        BankAPI bankAPI = api.getClass().getAnnotation(BankAPI.class);\n        bankAPI.url();\n        StringBuilder stringBuilder = new StringBuilder();\n        Arrays.stream(api.getClass().getDeclaredFields()) //获得所有字段\n            .filter(field -> field.isAnnotationPresent(BankAPIField.class)) //查找标记了注解的字段\n            .sorted(Comparator.comparingInt(a -> a.getAnnotation(BankAPIField.class).order())) //根据注解中的order对字段排序\n            .peek(field -> field.setAccessible(true)) //设置可以访问私有字段\n            .forEach(field -> {\n                //获得注解\n                BankAPIField bankAPIField = field.getAnnotation(BankAPIField.class);\n                Object value = "";\n                try {\n                    //反射获取字段值\n                    value = field.get(api);\n                } catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                }\n                //根据字段类型以正确的填充方式格式化字符串\n                switch (bankAPIField.type()) {\n                    case "S": {\n                        stringBuilder.append(\n                            String.format("%-" + bankAPIField.length() + "s", value.toString()).replace(\' \', \'_\'));\n                        break;\n                    }\n                    case "N": {\n                        stringBuilder.append(\n                            String.format("%" + bankAPIField.length() + "s", value.toString()).replace(\' \', \'0\'));\n                        break;\n                    }\n                    case "M": {\n                        if (!(value instanceof BigDecimal)) {\n                            throw new RuntimeException(\n                                String.format("{} 的 {} 必须是BigDecimal", api, field));\n                        }\n                        stringBuilder.append(String.format("%0" + bankAPIField.length() + "d",\n                            ((BigDecimal) value).setScale(2, RoundingMode.DOWN)\n                                .multiply(new BigDecimal("100"))\n                                .longValue()));\n                        break;\n                    }\n                    default:\n                        break;\n                }\n            });\n        //签名逻辑\n        stringBuilder.append(DigestUtils.md2Hex(stringBuilder.toString()));\n        String param = stringBuilder.toString();\n        long begin = System.currentTimeMillis();\n        //发请求\n        String result = Request.Post("http://localhost:45678/reflection" + bankAPI.url())\n            .bodyString(param, ContentType.APPLICATION_JSON)\n            .execute().returnContent().asString();\n        log.info("调用银行API {} url:{} 参数:{} 耗时:{}ms", bankAPI.desc(), bankAPI.url(), param,\n            System.currentTimeMillis() - begin);\n        return result;\n    }\n\n}\n\n\n【注解修饰的 API 接口一】\n\nimport lombok.Data;\n\n@BankAPI(url = "/bank/createUser", desc = "创建用户接口")\n@Data\npublic class CreateUserAPI extends AbstractAPI {\n\n    @BankAPIField(order = 1, type = "S", length = 10)\n    private String name;\n    @BankAPIField(order = 2, type = "S", length = 18)\n    private String identity;\n    @BankAPIField(order = 4, type = "S", length = 11)\n    private String mobile;\n    @BankAPIField(order = 3, type = "N", length = 5)\n    private int age;\n\n}\n\n\n【注解修饰的 API 接口二】\n\nimport lombok.Data;\n\nimport java.math.BigDecimal;\n\n@BankAPI(url = "/bank/pay", desc = "支付接口")\n@Data\npublic class PayAPI extends AbstractAPI {\n\n    @BankAPIField(order = 1, type = "N", length = 20)\n    private long userId;\n    @BankAPIField(order = 2, type = "M", length = 10)\n    private BigDecimal amount;\n\n}\n\n\n\n# 6. 与其他模式的关系\n\n * 适配器模式能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰模式则能为对象提供加强的接口。\n * 外观模式与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。\n * 装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之代理模式\n\n\n# 1. 意图\n\n代理模式 (proxy) 是一种结构型设计模式， 为其他对象提供一种代理以控制对这个对象的访问。\n\n * 代理模式介绍了一种访问对象的间接等级。\n * 一个远程代理可以隐藏一个对象在不同地址空间的细节。\n * 一个虚拟代理可以根据需要最优化创建对象的开销。\n * 而安全代理和智能指引都允许访问对象的同时处理其他事务。\n\n\n# 2. 适用场景\n\n * 延迟初始化 （虚拟代理）。 如果你有一个偶尔使用的重量级服务对象， 一直保持该对象运行会消耗系统资源时， 可使用代理模式。\n * 访问控制 （保护代理）。 如果你只希望特定客户端使用服务对象， 这里的对象可以是操作系统中非常重要的部分， 而客户端则是各种已启动的程序 （包括恶意程序）， 此时可使用代理模式。\n * 本地执行远程服务 （远程代理）。 适用于服务对象位于远程服务器上的情形。\n * 记录日志请求 （日志记录代理）。 适用于当你需要保存对于服务对象的请求历史记录时。 代理可以在向服务传递请求前进行记录。\n * 智能引用。 可在没有客户端使用某个重量级对象时立即销毁该对象。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 服务接口 （service interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。\n 2. 服务 （service） 类提供了一些实用的业务逻辑。\n 3. 代理 （proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。\n 4. 客户端 （client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。\n\n\n# 3.2. 结构代码范式\n\nsubject : 定义了 realsubject 和 proxy 的公共接口，这样就在任何使用 realsubject 的地方都可以使用 proxy 。\n\nabstract class subject {\n    public abstract void request();\n}\n\n\nrealsubject : 定义 proxy 所代表的真实实体。\n\nclass realsubject extends subject {\n    @override\n    public void request() {\n        system.out.println("真实的请求");\n    }\n}\n\n\nproxy : 保存一个引用使得代理可以访问实体，并提供一个与 subject 的接口相同的接口，这样代理就可以用来替代实体。\n\nclass proxy extends subject {\n    private realsubject real;\n\n    @override\n    public void request() {\n        if (null == real) {\n            real = new realsubject();\n        }\n        real.request();\n    }\n}\n\n\n\n# 4. 伪代码\n\n本例演示如何使用代理模式在第三方腾讯视频 （tencentvideo， 代码示例中记为 tv） 程序库中添加延迟初始化和缓存。\n\n\n\n程序库提供了视频下载类。 但是该类的效率非常低。 如果客户端程序多次请求同一视频， 程序库会反复下载该视频， 而不会将首次下载的文件缓存下来复用。\n\n代理类实现和原下载器相同的接口， 并将所有工作委派给原下载器。 不过， 代理类会保存所有的文件下载记录， 如果程序多次请求同一文件， 它会返回缓存的文件。\n\n// 远程服务接口。\ninterface thirdpartytvlib is\n    method listvideos()\n    method getvideoinfo(id)\n    method downloadvideo(id)\n\n// 服务连接器的具体实现。该类的方法可以向腾讯视频请求信息。请求速度取决于\n// 用户和腾讯视频的互联网连接情况。如果同时发送大量请求，即使所请求的信息\n// 一模一样，程序的速度依然会减慢。\nclass thirdpartytvclass implements thirdpartytvlib is\n    method listvideos() is\n        // 向腾讯视频发送一个 api 请求。\n\n    method getvideoinfo(id) is\n        // 获取某个视频的元数据。\n\n    method downloadvideo(id) is\n        // 从腾讯视频下载一个视频文件。\n\n// 为了节省网络带宽，我们可以将请求结果缓存下来并保存一段时间。但你可能无\n// 法直接将这些代码放入服务类中。比如该类可能是第三方程序库的一部分或其签\n// 名是`final（最终）`。因此我们会在一个实现了服务类接口的新代理类中放入\n// 缓存代码。当代理类接收到真实请求后，才会将其委派给服务对象。\nclass cachedtvclass implements thirdpartytvlib is\n    private field service: thirdpartytvlib\n    private field listcache, videocache\n    field needreset\n\n    constructor cachedtvclass(service: thirdpartytvlib) is\n        this.service = service\n\n    method listvideos() is\n        if (listcache == null || needreset)\n            listcache = service.listvideos()\n        return listcache\n\n    method getvideoinfo(id) is\n        if (videocache == null || needreset)\n            videocache = service.getvideoinfo(id)\n        return videocache\n\n    method downloadvideo(id) is\n        if (!downloadexists(id) || needreset)\n            service.downloadvideo(id)\n\n// 之前直接与服务对象交互的 gui 类不需要改变，前提是它仅通过接口与服务对\n// 象交互。我们可以安全地传递一个代理对象来代替真实服务对象，因为它们都实\n// 现了相同的接口。\nclass tvmanager is\n    protected field service: thirdpartytvlib\n\n    constructor tvmanager(service: thirdpartytvlib) is\n        this.service = service\n\n    method rendervideopage(id) is\n        info = service.getvideoinfo(id)\n        // 渲染视频页面。\n\n    method renderlistpanel() is\n        list = service.listvideos()\n        // 渲染视频缩略图列表。\n\n    method reactonuserinput() is\n        rendervideopage()\n        renderlistpanel()\n\n// 程序可在运行时对代理进行配置。\nclass application is\n    method init() is\n        atvservice = new thirdpartytvclass()\n        atvproxy = new cachedtvclass(atvservice)\n        manager = new tvmanager(atvproxy)\n        manager.reactonuserinput()\n\n\n\n# 5. 案例\n\n使用示例： 尽管代理模式在绝大多数 java 程序中并不常见， 但它在一些特殊情况下仍然非常方便。 当你希望在无需修改客户代码的前提下于已有类的对象上增加额外行为时， 该模式是无可替代的。\n\njava 标准程序库中的一些代理模式的示例：\n\n * java.lang.reflect.proxy\n * java.rmi.*\n * javax.ejb.ejb （查看评论）\n * javax.inject.inject （查看评论）\n * javax.persistence.persistencecontext\n\n识别方法： 代理模式会将所有实际工作委派给一些其他对象。 除非代理是某个服务的子类， 否则每个代理方法最后都应该引用一个服务对象。\n\n\n# 5.1. 注解+反射+代理消除重复代码\n\n假设银行提供了一些 api 接口，对参数的序列化有点特殊，不使用 json，而是需要我们把参数依次拼在一起构成一个大字符串。\n\n按照银行提供的 api 文档的顺序，把所有参数构成定长的数据，然后拼接在一起作为整个字符串。因为每一种参数都有固定长度，未达到长度时需要做填充处理：\n\n * 字符串类型的参数不满长度部分需要以下划线右填充，也就是字符串内容靠左；\n * 数字类型的参数不满长度部分以 0 左填充，也就是实际数字靠右；\n * 货币类型的表示需要把金额向下舍入 2 位到分，以分为单位，作为数字类型同样进行 左填充。\n\n对所有参数做 md5 操作作为签名（为了方便理解，demo 中不涉及加盐处理）。\n\n# 问题版本\n\nimport org.apache.commons.codec.digest.digestutils;\nimport org.apache.http.client.fluent.request;\nimport org.apache.http.entity.contenttype;\n\nimport java.io.ioexception;\nimport java.math.bigdecimal;\nimport java.math.roundingmode;\n\npublic class bankservice {\n\n    public static string createuser(string name, string identity, string mobile, int age) throws ioexception {\n        stringbuilder stringbuilder = new stringbuilder();\n        //字符串靠左，多余的地方_填充\n        stringbuilder.append(string.format("%-10s", name).replace(\' \', \'_\'));\n        //字符串靠左，多余的地方_填充\n        stringbuilder.append(string.format("%-18s", identity).replace(\' \', \'_\'));\n        //数字靠右，多余的地方用0填充\n        stringbuilder.append(string.format("%05d", age));\n        //字符串靠左，多余的地方_填充\n        stringbuilder.append(string.format("%-11s", mobile).replace(\' \', \'_\'));\n        //最后加上md5作为签名\n        stringbuilder.append(digestutils.md2hex(stringbuilder.tostring()));\n        return request.post("http://localhost:45678/reflection/bank/createuser")\n                .bodystring(stringbuilder.tostring(), contenttype.application_json)\n                .execute().returncontent().asstring();\n    }\n\n    public static string pay(long userid, bigdecimal amount) throws ioexception {\n        stringbuilder stringbuilder = new stringbuilder();\n        //数字靠右，多余的地方用0填充\n        stringbuilder.append(string.format("%020d", userid));\n        //金额向下舍入2位到分，以分为单位，作为数字靠右，多余的地方用0填充\n        stringbuilder.append(string.format("%010d", amount.setscale(2, roundingmode.down).multiply(new bigdecimal("100")).longvalue()));\n        //最后加上md5作为签名\n        stringbuilder.append(digestutils.md2hex(stringbuilder.tostring()));\n        return request.post("http://localhost:45678/reflection/bank/pay")\n                .bodystring(stringbuilder.tostring(), contenttype.application_json)\n                .execute().returncontent().asstring();\n    }\n}\n\n\n在以上的代码版本中，存在以下问题：\n\n * 三种标准数据类型的处理逻辑有重复，稍有不慎就会出现 bug；\n * 处理流程中字符串拼接、加签和发请求的逻辑，在所有方法重复；\n * 实际方法的入参的参数类型和顺序，不一定和接口要求一致，容易出错；\n * 代码层面针对每一个参数硬编码，无法清晰地进行核对，如果参数达到几十个、上百个，出错的概率极大。\n\n# 优化版本\n\n针对上面代码版本中的问题，可以使用 注解+反射+代理模式 解决重复代码。\n\n【注解一】\n\nimport java.lang.annotation.*;\n\n@retention(retentionpolicy.runtime)\n@target(elementtype.type)\n@documented\n@inherited\npublic @interface bankapi {\n\n    string desc() default "";\n\n    string url() default "";\n\n}\n\n\n【注解二】\n\nimport java.lang.annotation.*;\n\n@retention(retentionpolicy.runtime)\n@target(elementtype.field)\n@documented\n@inherited\npublic @interface bankapifield {\n\n    int order() default -1;\n\n    int length() default -1;\n\n    string type() default "";\n\n}\n\n\n【抽象类】\n\nabstract class abstractapi {}\n\n\n【代理类】\n\n@slf4j\npublic class betterbankservice {\n\n    public static string createuser(string name, string identity, string mobile, int age) throws ioexception {\n        createuserapi createuserapi = new createuserapi();\n        createuserapi.setname(name);\n        createuserapi.setidentity(identity);\n        createuserapi.setage(age);\n        createuserapi.setmobile(mobile);\n        return remotecall(createuserapi);\n    }\n\n    public static string pay(long userid, bigdecimal amount) throws ioexception {\n        payapi payapi = new payapi();\n        payapi.setuserid(userid);\n        payapi.setamount(amount);\n        return remotecall(payapi);\n    }\n\n    private static string remotecall(abstractapi api) throws ioexception {\n        //从bankapi注解获取请求地址\n        bankapi bankapi = api.getclass().getannotation(bankapi.class);\n        bankapi.url();\n        stringbuilder stringbuilder = new stringbuilder();\n        arrays.stream(api.getclass().getdeclaredfields()) //获得所有字段\n            .filter(field -> field.isannotationpresent(bankapifield.class)) //查找标记了注解的字段\n            .sorted(comparator.comparingint(a -> a.getannotation(bankapifield.class).order())) //根据注解中的order对字段排序\n            .peek(field -> field.setaccessible(true)) //设置可以访问私有字段\n            .foreach(field -> {\n                //获得注解\n                bankapifield bankapifield = field.getannotation(bankapifield.class);\n                object value = "";\n                try {\n                    //反射获取字段值\n                    value = field.get(api);\n                } catch (illegalaccessexception e) {\n                    e.printstacktrace();\n                }\n                //根据字段类型以正确的填充方式格式化字符串\n                switch (bankapifield.type()) {\n                    case "s": {\n                        stringbuilder.append(\n                            string.format("%-" + bankapifield.length() + "s", value.tostring()).replace(\' \', \'_\'));\n                        break;\n                    }\n                    case "n": {\n                        stringbuilder.append(\n                            string.format("%" + bankapifield.length() + "s", value.tostring()).replace(\' \', \'0\'));\n                        break;\n                    }\n                    case "m": {\n                        if (!(value instanceof bigdecimal)) {\n                            throw new runtimeexception(\n                                string.format("{} 的 {} 必须是bigdecimal", api, field));\n                        }\n                        stringbuilder.append(string.format("%0" + bankapifield.length() + "d",\n                            ((bigdecimal) value).setscale(2, roundingmode.down)\n                                .multiply(new bigdecimal("100"))\n                                .longvalue()));\n                        break;\n                    }\n                    default:\n                        break;\n                }\n            });\n        //签名逻辑\n        stringbuilder.append(digestutils.md2hex(stringbuilder.tostring()));\n        string param = stringbuilder.tostring();\n        long begin = system.currenttimemillis();\n        //发请求\n        string result = request.post("http://localhost:45678/reflection" + bankapi.url())\n            .bodystring(param, contenttype.application_json)\n            .execute().returncontent().asstring();\n        log.info("调用银行api {} url:{} 参数:{} 耗时:{}ms", bankapi.desc(), bankapi.url(), param,\n            system.currenttimemillis() - begin);\n        return result;\n    }\n\n}\n\n\n【注解修饰的 api 接口一】\n\nimport lombok.data;\n\n@bankapi(url = "/bank/createuser", desc = "创建用户接口")\n@data\npublic class createuserapi extends abstractapi {\n\n    @bankapifield(order = 1, type = "s", length = 10)\n    private string name;\n    @bankapifield(order = 2, type = "s", length = 18)\n    private string identity;\n    @bankapifield(order = 4, type = "s", length = 11)\n    private string mobile;\n    @bankapifield(order = 3, type = "n", length = 5)\n    private int age;\n\n}\n\n\n【注解修饰的 api 接口二】\n\nimport lombok.data;\n\nimport java.math.bigdecimal;\n\n@bankapi(url = "/bank/pay", desc = "支付接口")\n@data\npublic class payapi extends abstractapi {\n\n    @bankapifield(order = 1, type = "n", length = 20)\n    private long userid;\n    @bankapifield(order = 2, type = "m", length = 10)\n    private bigdecimal amount;\n\n}\n\n\n\n# 6. 与其他模式的关系\n\n * 适配器模式能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰模式则能为对象提供加强的接口。\n * 外观模式与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。 代理与其服务对象遵循同一接口， 使得自己和服务对象可以互换， 在这一点上它与外观不同。\n * 装饰和代理有着相似的结构， 但是其意图却非常不同。 这两个模式的构建都基于组合原则， 也就是说一个对象应该将部分工作委派给另一个对象。 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期， 而装饰的生成则总是由客户端进行控制。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之模板方法模式",frontmatter:{title:"设计模式之模板方法模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-06T09:43:00.000Z",permalink:"/pages/604ebc/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/14.%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/14.模板方法模式.md",key:"v-f82d5ee0",path:"/pages/604ebc/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:18},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:489},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:619},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:631},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:780},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:1918},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:3675},{level:2,title:"6. 案例",slug:"_6-案例",normalizedTitle:"6. 案例",charIndex:5510},{level:3,title:"6.1. 消除 if ... else 和重复代码",slug:"_6-1-消除-if-else-和重复代码",normalizedTitle:"6.1. 消除 if ... else 和重复代码",charIndex:5925},{level:4,title:"问题 1.0 版本",slug:"问题-1-0-版本",normalizedTitle:"问题 1.0 版本",charIndex:6093},{level:4,title:"修正版本",slug:"修正版本",normalizedTitle:"修正版本",charIndex:11575},{level:2,title:"7. 与其他模式的关系",slug:"_7-与其他模式的关系",normalizedTitle:"7. 与其他模式的关系",charIndex:14843},{level:2,title:"8. 参考资料",slug:"_8-参考资料",normalizedTitle:"8. 参考资料",charIndex:15042}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 案例 6. 案例 6.1. 消除 if ... else 和重复代码 问题 1.0 版本 修正版本 7. 与其他模式的关系 8. 参考资料",content:'# 设计模式之模板方法模式\n\n\n# 1. 意图\n\n模板方法模式 (Template Method) 是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n\n模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。，没有关联关系。 因此，在模板方法模式的类结构图中，只有继承关系。\n\n模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。\n\n代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。\n\n在模板方法模式中，首先父类会定义一个算法的框架，即实现算法所必须的所有方法。\n\n * 其中，具有共性的代码放在父类的具体方法中。\n\n * 各个子类特殊性的代码放在子类的具体方法中。但是父类中需要有对应抽象方法声明。\n\n * 钩子方法可以让子类决定是否对算法的不同点进行挂钩。\n\n\n# 2. 适用场景\n\n * 当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。\n * 当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 抽象类 （Abstract­Class） 会声明作为算法步骤的方法， 以及依次调用它们的实际模板方法。 算法步骤可以被声明为 抽象类型， 也可以提供一些默认实现。\n 2. 具体类 （Concrete­Class） 可以重写所有步骤， 但不能重写模板方法自身。\n\n\n# 3.2. 结构代码范式\n\nAbstractClass : 抽象类，定义并实现一个模板方法。这个模板方法定义了算法的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类去实现。顶级逻辑也有可能调用一些具体方法。\n\nabstract class AbstractClass {\n    public abstract void PrimitiveOperation1();\n    public abstract void PrimitiveOperation2();\n\n    public void TemplateMethod() {\n        PrimitiveOperation1();\n        PrimitiveOperation2();\n    }\n}\n\n\nConcreteClass : 实现实现父类所定义的一个或多个抽象方法。\n\nclass ConcreteClassA extends AbstractClass {\n    @Override\n    public void PrimitiveOperation1() {\n        System.out.println("具体A类方法1");\n    }\n\n    @Override\n    public void PrimitiveOperation2() {\n        System.out.println("具体A类方法2");\n    }\n}\n\nclass ConcreteClassB extends AbstractClass {\n    @Override\n    public void PrimitiveOperation1() {\n        System.out.println("具体B类方法1");\n    }\n\n    @Override\n    public void PrimitiveOperation2() {\n        System.out.println("具体B类方法2");\n    }\n}\n\n\n客户端\n\npublic class TemplateMethodPattern {\n    public static void main(String[] args) {\n        AbstractClass objA = new ConcreteClassA();\n        AbstractClass objB = new ConcreteClassB();\n        objA.TemplateMethod();\n        objB.TemplateMethod();\n    }\n}\n\n\n\n# 4. 伪代码\n\n本例中的模板方法模式为一款简单策略游戏中人工智能的不同分支提供 “框架”。\n\n\n\n一款简单游戏的 AI 类。\n\n游戏中所有的种族都有几乎同类的单位和建筑。 因此你可以在不同的种族上复用相同的 AI 结构， 同时还需要具备重写一些细节的能力。 通过这种方式， 你可以重写半兽人的 AI 使其更富攻击性， 也可以让人类侧重防守， 还可以禁止怪物建造建筑。 在游戏中新增种族需要创建新的 AI 子类， 还需要重写 AI 基类中所声明的默认方法。\n\n// 抽象类定义了一个模板方法，其中通常会包含某个由抽象原语操作调用组成的算\n// 法框架。具体子类会实现这些操作，但是不会对模板方法做出修改。\nclass GameAI is\n    // 模板方法定义了某个算法的框架。\n    method turn() is\n        collectResources()\n        buildStructures()\n        buildUnits()\n        attack()\n\n    // 某些步骤可在基类中直接实现。\n    method collectResources() is\n        foreach (s in this.builtStructures) do\n            s.collect()\n\n    // 某些可定义为抽象类型。\n    abstract method buildStructures()\n    abstract method buildUnits()\n\n    // 一个类可包含多个模板方法。\n    method attack() is\n        enemy = closestEnemy()\n        if (enemy == null)\n            sendScouts(map.center)\n        else\n            sendWarriors(enemy.position)\n\n    abstract method sendScouts(position)\n    abstract method sendWarriors(position)\n\n// 具体类必须实现基类中的所有抽象操作，但是它们不能重写模板方法自身。\nclass OrcsAI extends GameAI is\n    method buildStructures() is\n        if (there are some resources) then\n            // 建造农场，接着是谷仓，然后是要塞。\n\n    method buildUnits() is\n        if (there are plenty of resources) then\n            if (there are no scouts)\n                // 建造苦工，将其加入侦查编组。\n            else\n                // 建造兽族步兵，将其加入战士编组。\n\n    // ...\n\n    method sendScouts(position) is\n        if (scouts.length > 0) then\n            // 将侦查编组送到指定位置。\n\n    method sendWarriors(position) is\n        if (warriors.length > 5) then\n            // 将战斗编组送到指定位置。\n\n// 子类可以重写部分默认的操作。\nclass MonstersAI extends GameAI is\n    method collectResources() is\n        // 怪物不会采集资源。\n\n    method buildStructures() is\n        // 怪物不会建造建筑。\n\n    method buildUnits() is\n        // 怪物不会建造单位。\n\n\n\n# 5. 案例\n\n模板方法模式应用场景十分广泛。\n\n在《Head First》的模板方法模式章节里列举了一个十分具有代表性的例子。\n\n现实生活中，茶和咖啡是随处可见的饮料。冲泡一杯茶或冲泡一杯咖啡的过程是怎样的？\n\n我们来整理一下流程。\n\n * 泡茶： 烧开水 ==> 冲泡茶叶 ==> 倒入杯中 ==> 添加柠檬\n * 泡咖啡： 烧开水 ==> 冲泡咖啡 ==> 倒入杯中 ==> 添加糖和牛奶\n\n由以上处理步骤不难发现，准备这两种饮料的处理过程非常相似。我们可以使用模板类方法去限定制作饮料的算法框架。\n\n其中相同的具有共性的步骤（如烧开水、倒入杯中），直接在抽象类中给出具体实现。\n\n而对于有差异性的步骤，则在各自的具体类中给出实现。\n\n【抽象类】\n\nabstract class Beverage {\n\n    // 模板方法，决定了算法骨架。相当于TemplateMethod()方法\n    public void prepareBeverage() {\n        boilWater();\n        brew();\n        pourInCup();\n        if (customWantsCondiments())\n        {\n            addCondiments();\n        }\n    }\n\n    // 共性操作，直接在抽象类中定义\n    public void boilWater() {\n        System.out.println("烧开水");\n    }\n\n    // 共性操作，直接在抽象类中定义\n    public void pourInCup() {\n        System.out.println("倒入杯中");\n    }\n\n    // 钩子方法，决定某些算法步骤是否挂钩在算法中\n    public boolean customWantsCondiments() {\n        return true;\n    }\n\n    // 特殊操作，在子类中具体实现\n    public abstract void brew();\n\n    // 特殊操作，在子类中具体实现\n    public abstract void addCondiments();\n\n}\n\n\n【具体类】\n\nclass Tea extends Beverage {\n\n    @Override\n    public void brew() {\n        System.out.println("冲泡茶叶");\n    }\n\n    @Override\n    public void addCondiments() {\n        System.out.println("添加柠檬");\n    }\n\n}\n\nclass Coffee extends Beverage {\n\n    @Override\n    public void brew() {\n        System.out.println("冲泡咖啡豆");\n    }\n\n    @Override\n    public void addCondiments() {\n        System.out.println("添加糖和牛奶");\n    }\n\n}\n\n\n【客户端】\n\npublic static void main(String[] args) {\n\n    System.out.println("============= 准备茶 =============");\n    Beverage tea = new Tea();\n    tea.prepareBeverage();\n\n    System.out.println("============= 准备咖啡 =============");\n    Beverage coffee = new Coffee();\n    coffee.prepareBeverage();\n\n}\n\n\n输出\n\n============= 准备茶 =============\n烧开水\n冲泡茶叶\n倒入杯中\n添加柠檬\n============= 准备咖啡 =============\n烧开水\n冲泡咖啡豆\n倒入杯中\n添加糖和牛奶\n\n\n\n# 6. 案例\n\n使用示例： 模版方法模式在 Java 框架中很常见。 开发者通常使用它来向框架用户提供通过继承实现的、 对标准功能进行扩展的简单方式。\n\n这里是一些核心 Java 程序库中模版方法的示例：\n\n * java.io.InputStream、 java.io.OutputStream、 java.io.Reader 和 java.io.Writer 的所有非抽象方法。\n * java.util.AbstractList、 java.util.AbstractSet 和 java.util.AbstractMap 的所有非抽象方法。\n * javax.servlet.http.HttpServlet， 所有默认发送 HTTP 405 “方法不允许” 错误响应的 do­XXX()方法。 你可随时对其进行重写。\n\n识别方法： 模版方法可以通过行为方法来识别， 该方法已有一个在基类中定义的 “默认” 行为。\n\n\n# 6.1. 消除 if ... else 和重复代码\n\n假设要开发一个购物车功能，针对不同用户进行不同的处理：\n\n * 普通用户需要收取运费，运费是商品价格的 10%，无商品折扣；\n * VIP 用户同样需要收取商品价格 10% 的快递费，但购买两件以上相同商品时，第三件开始享受一定折扣；\n * 内部用户可以免运费，无商品折扣。\n\n# 问题 1.0 版本\n\n普通用户购物车\n\npublic class NormalUserCart {\n\n    public Cart process(long userId, Map<Long, Integer> items) {\n        Cart cart = new Cart();\n\n        //把Map的购物车转换为Item列表\n        List<Item> itemList = new ArrayList<>();\n        items.entrySet().stream().forEach(entry -> {\n            Item item = new Item();\n            item.setId(entry.getKey());\n            item.setPrice(Db.getItemPrice(entry.getKey()));\n            item.setQuantity(entry.getValue());\n            itemList.add(item);\n        });\n        cart.setItems(itemList);\n\n        //处理运费和商品优惠\n        itemList.stream().forEach(item -> {\n            //运费为商品总价的10%\n            item.setDeliveryPrice(\n                item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())).multiply(new BigDecimal("0.1")));\n            //无优惠\n            item.setCouponPrice(BigDecimal.ZERO);\n        });\n\n        //计算纯商品总价\n        cart.setTotalItemPrice(cart.getItems()\n            .stream()\n            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))\n            .reduce(BigDecimal.ZERO, BigDecimal::add));\n        //计算运费总价\n        cart.setTotalDeliveryPrice(\n            cart.getItems().stream().map(Item::getDeliveryPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        //计算总优惠\n        cart.setTotalDiscount(\n            cart.getItems().stream().map(Item::getCouponPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        //应付总价=商品总价+运费总价-总优惠\n        cart.setPayPrice(cart.getTotalItemPrice().add(cart.getTotalDeliveryPrice()).subtract(cart.getTotalDiscount()));\n        return cart;\n    }\n\n}\n\n\nVIP 用户购物车\n\npublic class VipUserCart {\n\n    public Cart process(long userId, Map<Long, Integer> items) {\n        Cart cart = new Cart();\n\n        List<Item> itemList = new ArrayList<>();\n        items.entrySet().stream().forEach(entry -> {\n            Item item = new Item();\n            item.setId(entry.getKey());\n            item.setPrice(Db.getItemPrice(entry.getKey()));\n            item.setQuantity(entry.getValue());\n            itemList.add(item);\n        });\n        cart.setItems(itemList);\n\n        itemList.stream().forEach(item -> {\n            //运费为商品总价的10%\n            item.setDeliveryPrice(\n                item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())).multiply(new BigDecimal("0.1")));\n            //购买两件以上相同商品，第三件开始享受一定折扣\n            if (item.getQuantity() > 2) {\n                item.setCouponPrice(item.getPrice()\n                    .multiply(BigDecimal.valueOf(100 - Db.getUserCouponPercent(userId)).divide(new BigDecimal("100")))\n                    .multiply(BigDecimal.valueOf(item.getQuantity() - 2)));\n            } else {\n                item.setCouponPrice(BigDecimal.ZERO);\n            }\n        });\n\n        cart.setTotalItemPrice(cart.getItems()\n            .stream()\n            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))\n            .reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setTotalDeliveryPrice(\n            cart.getItems().stream().map(Item::getDeliveryPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setTotalDiscount(\n            cart.getItems().stream().map(Item::getCouponPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setPayPrice(cart.getTotalItemPrice().add(cart.getTotalDeliveryPrice()).subtract(cart.getTotalDiscount()));\n        return cart;\n    }\n\n}\n\n\n内部用户购物车\n\npublic class InternalUserCart {\n\n    public Cart process(long userId, Map<Long, Integer> items) {\n        Cart cart = new Cart();\n\n        List<Item> itemList = new ArrayList<>();\n        items.entrySet().stream().forEach(entry -> {\n            Item item = new Item();\n            item.setId(entry.getKey());\n            item.setPrice(Db.getItemPrice(entry.getKey()));\n            item.setQuantity(entry.getValue());\n            itemList.add(item);\n        });\n        cart.setItems(itemList);\n\n        itemList.stream().forEach(item -> {\n            //免运费\n            item.setDeliveryPrice(BigDecimal.ZERO);\n            //无优惠\n            item.setCouponPrice(BigDecimal.ZERO);\n        });\n\n        cart.setTotalItemPrice(cart.getItems()\n            .stream()\n            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))\n            .reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setTotalDeliveryPrice(\n            cart.getItems().stream().map(Item::getDeliveryPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setTotalDiscount(\n            cart.getItems().stream().map(Item::getCouponPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setPayPrice(cart.getTotalItemPrice().add(cart.getTotalDeliveryPrice()).subtract(cart.getTotalDiscount()));\n        return cart;\n    }\n\n}\n\n\n客户端\n\n@GetMapping("wrong")\npublic Cart wrong(@RequestParam("userId") int userId) {\n    String userCategory = Db.getUserCategory(userId);\n\n    if (userCategory.equals("Normal")) {\n        NormalUserCart normalUserCart = new NormalUserCart();\n        return normalUserCart.process(userId, items);\n    }\n\n    if (userCategory.equals("Vip")) {\n        VipUserCart vipUserCart = new VipUserCart();\n        return vipUserCart.process(userId, items);\n    }\n\n    if (userCategory.equals("Internal")) {\n        InternalUserCart internalUserCart = new InternalUserCart();\n        return internalUserCart.process(userId, items);\n    }\n\n    return null;\n}\n\n\n> 对比一下代码量可以发现，三种购物车 70% 的代码是重复的。原因很简单，虽然不同类型用户计算运费和优惠的方式不同，但整个购物车的初始化、统计总价、总运费、总优惠和支付价格的逻辑都是一样的。\n\n# 修正版本\n\n1.0 版本的问题在于：相同的代码应该只在一处出现。\n\n如果我们熟记抽象类和抽象方法的定义的话，这时或许就会想到，是否可以把重复的逻辑定义在抽象类中，三个购物车只要分别实现不同的那份逻辑呢？\n\n其实，这个模式就是模板方法模式。\n\n> 下面展示基于 工厂模式+模板方法模式 优化重复代码。\n\n【抽象类】\n\npublic abstract class AbstractCart {\n\n    public Cart process(long userId, Map<Long, Integer> items) {\n\n        Cart cart = new Cart();\n\n        List<Item> itemList = new ArrayList<>();\n        items.entrySet().stream().forEach(entry -> {\n            Item item = new Item();\n            item.setId(entry.getKey());\n            item.setPrice(Db.getItemPrice(entry.getKey()));\n            item.setQuantity(entry.getValue());\n            itemList.add(item);\n        });\n        cart.setItems(itemList);\n\n        itemList.stream().forEach(item -> {\n            processCouponPrice(userId, item);\n            processDeliveryPrice(userId, item);\n        });\n\n        cart.setTotalItemPrice(cart.getItems()\n            .stream()\n            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))\n            .reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setTotalDeliveryPrice(\n            cart.getItems().stream().map(Item::getDeliveryPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setTotalDiscount(\n            cart.getItems().stream().map(Item::getCouponPrice).reduce(BigDecimal.ZERO, BigDecimal::add));\n        cart.setPayPrice(cart.getTotalItemPrice().add(cart.getTotalDeliveryPrice()).subtract(cart.getTotalDiscount()));\n        return cart;\n    }\n\n    protected abstract void processCouponPrice(long userId, Item item);\n\n    protected abstract void processDeliveryPrice(long userId, Item item);\n\n}\n\n\n【普通用户购物车】\n\n@Service(value = "NormalUserCart")\npublic class NormalUserCart extends AbstractCart {\n\n    @Override\n    protected void processCouponPrice(long userId, Item item) {\n        item.setCouponPrice(BigDecimal.ZERO);\n    }\n\n    @Override\n    protected void processDeliveryPrice(long userId, Item item) {\n        item.setDeliveryPrice(item.getPrice()\n            .multiply(BigDecimal.valueOf(item.getQuantity()))\n            .multiply(new BigDecimal("0.1")));\n    }\n\n}\n\n\n【VIP 用户购物车】\n\n@Service(value = "VipUserCart")\npublic class VipUserCart extends NormalUserCart {\n\n    @Override\n    protected void processCouponPrice(long userId, Item item) {\n        if (item.getQuantity() > 2) {\n            item.setCouponPrice(item.getPrice()\n                .multiply(BigDecimal.valueOf(100 - Db.getUserCouponPercent(userId)).divide(new BigDecimal("100")))\n                .multiply(BigDecimal.valueOf(item.getQuantity() - 2)));\n        } else {\n            item.setCouponPrice(BigDecimal.ZERO);\n        }\n    }\n\n}\n\n\n【内部用户购物车】\n\n@Service(value = "InternalUserCart")\npublic class InternalUserCart extends AbstractCart {\n\n    @Override\n    protected void processCouponPrice(long userId, Item item) {\n        item.setCouponPrice(BigDecimal.ZERO);\n    }\n\n    @Override\n    protected void processDeliveryPrice(long userId, Item item) {\n        item.setDeliveryPrice(BigDecimal.ZERO);\n    }\n\n}\n\n\n【客户端】\n\n@GetMapping("right")\npublic Cart right(@RequestParam("userId") int userId) {\n    String userCategory = Db.getUserCategory(userId);\n    AbstractCart cart = (AbstractCart) applicationContext.getBean(userCategory + "UserCart");\n    return cart.process(userId, items);\n}\n\n\n\n# 7. 与其他模式的关系\n\n * 工厂方法模式是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。\n * 模板方法基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略模式基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。\n\n\n# 8. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之模板方法模式\n\n\n# 1. 意图\n\n模板方法模式 (template method) 是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n\n模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。，没有关联关系。 因此，在模板方法模式的类结构图中，只有继承关系。\n\n模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。\n\n代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。\n\n在模板方法模式中，首先父类会定义一个算法的框架，即实现算法所必须的所有方法。\n\n * 其中，具有共性的代码放在父类的具体方法中。\n\n * 各个子类特殊性的代码放在子类的具体方法中。但是父类中需要有对应抽象方法声明。\n\n * 钩子方法可以让子类决定是否对算法的不同点进行挂钩。\n\n\n# 2. 适用场景\n\n * 当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。\n * 当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 抽象类 （abstract­class） 会声明作为算法步骤的方法， 以及依次调用它们的实际模板方法。 算法步骤可以被声明为 抽象类型， 也可以提供一些默认实现。\n 2. 具体类 （concrete­class） 可以重写所有步骤， 但不能重写模板方法自身。\n\n\n# 3.2. 结构代码范式\n\nabstractclass : 抽象类，定义并实现一个模板方法。这个模板方法定义了算法的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类去实现。顶级逻辑也有可能调用一些具体方法。\n\nabstract class abstractclass {\n    public abstract void primitiveoperation1();\n    public abstract void primitiveoperation2();\n\n    public void templatemethod() {\n        primitiveoperation1();\n        primitiveoperation2();\n    }\n}\n\n\nconcreteclass : 实现实现父类所定义的一个或多个抽象方法。\n\nclass concreteclassa extends abstractclass {\n    @override\n    public void primitiveoperation1() {\n        system.out.println("具体a类方法1");\n    }\n\n    @override\n    public void primitiveoperation2() {\n        system.out.println("具体a类方法2");\n    }\n}\n\nclass concreteclassb extends abstractclass {\n    @override\n    public void primitiveoperation1() {\n        system.out.println("具体b类方法1");\n    }\n\n    @override\n    public void primitiveoperation2() {\n        system.out.println("具体b类方法2");\n    }\n}\n\n\n客户端\n\npublic class templatemethodpattern {\n    public static void main(string[] args) {\n        abstractclass obja = new concreteclassa();\n        abstractclass objb = new concreteclassb();\n        obja.templatemethod();\n        objb.templatemethod();\n    }\n}\n\n\n\n# 4. 伪代码\n\n本例中的模板方法模式为一款简单策略游戏中人工智能的不同分支提供 “框架”。\n\n\n\n一款简单游戏的 ai 类。\n\n游戏中所有的种族都有几乎同类的单位和建筑。 因此你可以在不同的种族上复用相同的 ai 结构， 同时还需要具备重写一些细节的能力。 通过这种方式， 你可以重写半兽人的 ai 使其更富攻击性， 也可以让人类侧重防守， 还可以禁止怪物建造建筑。 在游戏中新增种族需要创建新的 ai 子类， 还需要重写 ai 基类中所声明的默认方法。\n\n// 抽象类定义了一个模板方法，其中通常会包含某个由抽象原语操作调用组成的算\n// 法框架。具体子类会实现这些操作，但是不会对模板方法做出修改。\nclass gameai is\n    // 模板方法定义了某个算法的框架。\n    method turn() is\n        collectresources()\n        buildstructures()\n        buildunits()\n        attack()\n\n    // 某些步骤可在基类中直接实现。\n    method collectresources() is\n        foreach (s in this.builtstructures) do\n            s.collect()\n\n    // 某些可定义为抽象类型。\n    abstract method buildstructures()\n    abstract method buildunits()\n\n    // 一个类可包含多个模板方法。\n    method attack() is\n        enemy = closestenemy()\n        if (enemy == null)\n            sendscouts(map.center)\n        else\n            sendwarriors(enemy.position)\n\n    abstract method sendscouts(position)\n    abstract method sendwarriors(position)\n\n// 具体类必须实现基类中的所有抽象操作，但是它们不能重写模板方法自身。\nclass orcsai extends gameai is\n    method buildstructures() is\n        if (there are some resources) then\n            // 建造农场，接着是谷仓，然后是要塞。\n\n    method buildunits() is\n        if (there are plenty of resources) then\n            if (there are no scouts)\n                // 建造苦工，将其加入侦查编组。\n            else\n                // 建造兽族步兵，将其加入战士编组。\n\n    // ...\n\n    method sendscouts(position) is\n        if (scouts.length > 0) then\n            // 将侦查编组送到指定位置。\n\n    method sendwarriors(position) is\n        if (warriors.length > 5) then\n            // 将战斗编组送到指定位置。\n\n// 子类可以重写部分默认的操作。\nclass monstersai extends gameai is\n    method collectresources() is\n        // 怪物不会采集资源。\n\n    method buildstructures() is\n        // 怪物不会建造建筑。\n\n    method buildunits() is\n        // 怪物不会建造单位。\n\n\n\n# 5. 案例\n\n模板方法模式应用场景十分广泛。\n\n在《head first》的模板方法模式章节里列举了一个十分具有代表性的例子。\n\n现实生活中，茶和咖啡是随处可见的饮料。冲泡一杯茶或冲泡一杯咖啡的过程是怎样的？\n\n我们来整理一下流程。\n\n * 泡茶： 烧开水 ==> 冲泡茶叶 ==> 倒入杯中 ==> 添加柠檬\n * 泡咖啡： 烧开水 ==> 冲泡咖啡 ==> 倒入杯中 ==> 添加糖和牛奶\n\n由以上处理步骤不难发现，准备这两种饮料的处理过程非常相似。我们可以使用模板类方法去限定制作饮料的算法框架。\n\n其中相同的具有共性的步骤（如烧开水、倒入杯中），直接在抽象类中给出具体实现。\n\n而对于有差异性的步骤，则在各自的具体类中给出实现。\n\n【抽象类】\n\nabstract class beverage {\n\n    // 模板方法，决定了算法骨架。相当于templatemethod()方法\n    public void preparebeverage() {\n        boilwater();\n        brew();\n        pourincup();\n        if (customwantscondiments())\n        {\n            addcondiments();\n        }\n    }\n\n    // 共性操作，直接在抽象类中定义\n    public void boilwater() {\n        system.out.println("烧开水");\n    }\n\n    // 共性操作，直接在抽象类中定义\n    public void pourincup() {\n        system.out.println("倒入杯中");\n    }\n\n    // 钩子方法，决定某些算法步骤是否挂钩在算法中\n    public boolean customwantscondiments() {\n        return true;\n    }\n\n    // 特殊操作，在子类中具体实现\n    public abstract void brew();\n\n    // 特殊操作，在子类中具体实现\n    public abstract void addcondiments();\n\n}\n\n\n【具体类】\n\nclass tea extends beverage {\n\n    @override\n    public void brew() {\n        system.out.println("冲泡茶叶");\n    }\n\n    @override\n    public void addcondiments() {\n        system.out.println("添加柠檬");\n    }\n\n}\n\nclass coffee extends beverage {\n\n    @override\n    public void brew() {\n        system.out.println("冲泡咖啡豆");\n    }\n\n    @override\n    public void addcondiments() {\n        system.out.println("添加糖和牛奶");\n    }\n\n}\n\n\n【客户端】\n\npublic static void main(string[] args) {\n\n    system.out.println("============= 准备茶 =============");\n    beverage tea = new tea();\n    tea.preparebeverage();\n\n    system.out.println("============= 准备咖啡 =============");\n    beverage coffee = new coffee();\n    coffee.preparebeverage();\n\n}\n\n\n输出\n\n============= 准备茶 =============\n烧开水\n冲泡茶叶\n倒入杯中\n添加柠檬\n============= 准备咖啡 =============\n烧开水\n冲泡咖啡豆\n倒入杯中\n添加糖和牛奶\n\n\n\n# 6. 案例\n\n使用示例： 模版方法模式在 java 框架中很常见。 开发者通常使用它来向框架用户提供通过继承实现的、 对标准功能进行扩展的简单方式。\n\n这里是一些核心 java 程序库中模版方法的示例：\n\n * java.io.inputstream、 java.io.outputstream、 java.io.reader 和 java.io.writer 的所有非抽象方法。\n * java.util.abstractlist、 java.util.abstractset 和 java.util.abstractmap 的所有非抽象方法。\n * javax.servlet.http.httpservlet， 所有默认发送 http 405 “方法不允许” 错误响应的 do­xxx()方法。 你可随时对其进行重写。\n\n识别方法： 模版方法可以通过行为方法来识别， 该方法已有一个在基类中定义的 “默认” 行为。\n\n\n# 6.1. 消除 if ... else 和重复代码\n\n假设要开发一个购物车功能，针对不同用户进行不同的处理：\n\n * 普通用户需要收取运费，运费是商品价格的 10%，无商品折扣；\n * vip 用户同样需要收取商品价格 10% 的快递费，但购买两件以上相同商品时，第三件开始享受一定折扣；\n * 内部用户可以免运费，无商品折扣。\n\n# 问题 1.0 版本\n\n普通用户购物车\n\npublic class normalusercart {\n\n    public cart process(long userid, map<long, integer> items) {\n        cart cart = new cart();\n\n        //把map的购物车转换为item列表\n        list<item> itemlist = new arraylist<>();\n        items.entryset().stream().foreach(entry -> {\n            item item = new item();\n            item.setid(entry.getkey());\n            item.setprice(db.getitemprice(entry.getkey()));\n            item.setquantity(entry.getvalue());\n            itemlist.add(item);\n        });\n        cart.setitems(itemlist);\n\n        //处理运费和商品优惠\n        itemlist.stream().foreach(item -> {\n            //运费为商品总价的10%\n            item.setdeliveryprice(\n                item.getprice().multiply(bigdecimal.valueof(item.getquantity())).multiply(new bigdecimal("0.1")));\n            //无优惠\n            item.setcouponprice(bigdecimal.zero);\n        });\n\n        //计算纯商品总价\n        cart.settotalitemprice(cart.getitems()\n            .stream()\n            .map(item -> item.getprice().multiply(bigdecimal.valueof(item.getquantity())))\n            .reduce(bigdecimal.zero, bigdecimal::add));\n        //计算运费总价\n        cart.settotaldeliveryprice(\n            cart.getitems().stream().map(item::getdeliveryprice).reduce(bigdecimal.zero, bigdecimal::add));\n        //计算总优惠\n        cart.settotaldiscount(\n            cart.getitems().stream().map(item::getcouponprice).reduce(bigdecimal.zero, bigdecimal::add));\n        //应付总价=商品总价+运费总价-总优惠\n        cart.setpayprice(cart.gettotalitemprice().add(cart.gettotaldeliveryprice()).subtract(cart.gettotaldiscount()));\n        return cart;\n    }\n\n}\n\n\nvip 用户购物车\n\npublic class vipusercart {\n\n    public cart process(long userid, map<long, integer> items) {\n        cart cart = new cart();\n\n        list<item> itemlist = new arraylist<>();\n        items.entryset().stream().foreach(entry -> {\n            item item = new item();\n            item.setid(entry.getkey());\n            item.setprice(db.getitemprice(entry.getkey()));\n            item.setquantity(entry.getvalue());\n            itemlist.add(item);\n        });\n        cart.setitems(itemlist);\n\n        itemlist.stream().foreach(item -> {\n            //运费为商品总价的10%\n            item.setdeliveryprice(\n                item.getprice().multiply(bigdecimal.valueof(item.getquantity())).multiply(new bigdecimal("0.1")));\n            //购买两件以上相同商品，第三件开始享受一定折扣\n            if (item.getquantity() > 2) {\n                item.setcouponprice(item.getprice()\n                    .multiply(bigdecimal.valueof(100 - db.getusercouponpercent(userid)).divide(new bigdecimal("100")))\n                    .multiply(bigdecimal.valueof(item.getquantity() - 2)));\n            } else {\n                item.setcouponprice(bigdecimal.zero);\n            }\n        });\n\n        cart.settotalitemprice(cart.getitems()\n            .stream()\n            .map(item -> item.getprice().multiply(bigdecimal.valueof(item.getquantity())))\n            .reduce(bigdecimal.zero, bigdecimal::add));\n        cart.settotaldeliveryprice(\n            cart.getitems().stream().map(item::getdeliveryprice).reduce(bigdecimal.zero, bigdecimal::add));\n        cart.settotaldiscount(\n            cart.getitems().stream().map(item::getcouponprice).reduce(bigdecimal.zero, bigdecimal::add));\n        cart.setpayprice(cart.gettotalitemprice().add(cart.gettotaldeliveryprice()).subtract(cart.gettotaldiscount()));\n        return cart;\n    }\n\n}\n\n\n内部用户购物车\n\npublic class internalusercart {\n\n    public cart process(long userid, map<long, integer> items) {\n        cart cart = new cart();\n\n        list<item> itemlist = new arraylist<>();\n        items.entryset().stream().foreach(entry -> {\n            item item = new item();\n            item.setid(entry.getkey());\n            item.setprice(db.getitemprice(entry.getkey()));\n            item.setquantity(entry.getvalue());\n            itemlist.add(item);\n        });\n        cart.setitems(itemlist);\n\n        itemlist.stream().foreach(item -> {\n            //免运费\n            item.setdeliveryprice(bigdecimal.zero);\n            //无优惠\n            item.setcouponprice(bigdecimal.zero);\n        });\n\n        cart.settotalitemprice(cart.getitems()\n            .stream()\n            .map(item -> item.getprice().multiply(bigdecimal.valueof(item.getquantity())))\n            .reduce(bigdecimal.zero, bigdecimal::add));\n        cart.settotaldeliveryprice(\n            cart.getitems().stream().map(item::getdeliveryprice).reduce(bigdecimal.zero, bigdecimal::add));\n        cart.settotaldiscount(\n            cart.getitems().stream().map(item::getcouponprice).reduce(bigdecimal.zero, bigdecimal::add));\n        cart.setpayprice(cart.gettotalitemprice().add(cart.gettotaldeliveryprice()).subtract(cart.gettotaldiscount()));\n        return cart;\n    }\n\n}\n\n\n客户端\n\n@getmapping("wrong")\npublic cart wrong(@requestparam("userid") int userid) {\n    string usercategory = db.getusercategory(userid);\n\n    if (usercategory.equals("normal")) {\n        normalusercart normalusercart = new normalusercart();\n        return normalusercart.process(userid, items);\n    }\n\n    if (usercategory.equals("vip")) {\n        vipusercart vipusercart = new vipusercart();\n        return vipusercart.process(userid, items);\n    }\n\n    if (usercategory.equals("internal")) {\n        internalusercart internalusercart = new internalusercart();\n        return internalusercart.process(userid, items);\n    }\n\n    return null;\n}\n\n\n> 对比一下代码量可以发现，三种购物车 70% 的代码是重复的。原因很简单，虽然不同类型用户计算运费和优惠的方式不同，但整个购物车的初始化、统计总价、总运费、总优惠和支付价格的逻辑都是一样的。\n\n# 修正版本\n\n1.0 版本的问题在于：相同的代码应该只在一处出现。\n\n如果我们熟记抽象类和抽象方法的定义的话，这时或许就会想到，是否可以把重复的逻辑定义在抽象类中，三个购物车只要分别实现不同的那份逻辑呢？\n\n其实，这个模式就是模板方法模式。\n\n> 下面展示基于 工厂模式+模板方法模式 优化重复代码。\n\n【抽象类】\n\npublic abstract class abstractcart {\n\n    public cart process(long userid, map<long, integer> items) {\n\n        cart cart = new cart();\n\n        list<item> itemlist = new arraylist<>();\n        items.entryset().stream().foreach(entry -> {\n            item item = new item();\n            item.setid(entry.getkey());\n            item.setprice(db.getitemprice(entry.getkey()));\n            item.setquantity(entry.getvalue());\n            itemlist.add(item);\n        });\n        cart.setitems(itemlist);\n\n        itemlist.stream().foreach(item -> {\n            processcouponprice(userid, item);\n            processdeliveryprice(userid, item);\n        });\n\n        cart.settotalitemprice(cart.getitems()\n            .stream()\n            .map(item -> item.getprice().multiply(bigdecimal.valueof(item.getquantity())))\n            .reduce(bigdecimal.zero, bigdecimal::add));\n        cart.settotaldeliveryprice(\n            cart.getitems().stream().map(item::getdeliveryprice).reduce(bigdecimal.zero, bigdecimal::add));\n        cart.settotaldiscount(\n            cart.getitems().stream().map(item::getcouponprice).reduce(bigdecimal.zero, bigdecimal::add));\n        cart.setpayprice(cart.gettotalitemprice().add(cart.gettotaldeliveryprice()).subtract(cart.gettotaldiscount()));\n        return cart;\n    }\n\n    protected abstract void processcouponprice(long userid, item item);\n\n    protected abstract void processdeliveryprice(long userid, item item);\n\n}\n\n\n【普通用户购物车】\n\n@service(value = "normalusercart")\npublic class normalusercart extends abstractcart {\n\n    @override\n    protected void processcouponprice(long userid, item item) {\n        item.setcouponprice(bigdecimal.zero);\n    }\n\n    @override\n    protected void processdeliveryprice(long userid, item item) {\n        item.setdeliveryprice(item.getprice()\n            .multiply(bigdecimal.valueof(item.getquantity()))\n            .multiply(new bigdecimal("0.1")));\n    }\n\n}\n\n\n【vip 用户购物车】\n\n@service(value = "vipusercart")\npublic class vipusercart extends normalusercart {\n\n    @override\n    protected void processcouponprice(long userid, item item) {\n        if (item.getquantity() > 2) {\n            item.setcouponprice(item.getprice()\n                .multiply(bigdecimal.valueof(100 - db.getusercouponpercent(userid)).divide(new bigdecimal("100")))\n                .multiply(bigdecimal.valueof(item.getquantity() - 2)));\n        } else {\n            item.setcouponprice(bigdecimal.zero);\n        }\n    }\n\n}\n\n\n【内部用户购物车】\n\n@service(value = "internalusercart")\npublic class internalusercart extends abstractcart {\n\n    @override\n    protected void processcouponprice(long userid, item item) {\n        item.setcouponprice(bigdecimal.zero);\n    }\n\n    @override\n    protected void processdeliveryprice(long userid, item item) {\n        item.setdeliveryprice(bigdecimal.zero);\n    }\n\n}\n\n\n【客户端】\n\n@getmapping("right")\npublic cart right(@requestparam("userid") int userid) {\n    string usercategory = db.getusercategory(userid);\n    abstractcart cart = (abstractcart) applicationcontext.getbean(usercategory + "usercart");\n    return cart.process(userid, items);\n}\n\n\n\n# 7. 与其他模式的关系\n\n * 工厂方法模式是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。\n * 模板方法基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略模式基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。\n\n\n# 8. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之命令模式",frontmatter:{title:"设计模式之命令模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-19T17:20:00.000Z",permalink:"/pages/6389ed/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/15.%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/15.命令模式.md",key:"v-e65aab34",path:"/pages/6389ed/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:16},{level:3,title:"1.1. 命令模式的交互",slug:"_1-1-命令模式的交互",normalizedTitle:"1.1. 命令模式的交互",charIndex:129},{level:3,title:"1.2. 命令模式的要点",slug:"_1-2-命令模式的要点",normalizedTitle:"1.2. 命令模式的要点",charIndex:397},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:698},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:809},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:821},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:1368},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:2490},{level:2,title:"5. 与其他模式的关系",slug:"_5-与其他模式的关系",normalizedTitle:"5. 与其他模式的关系",charIndex:5804},{level:2,title:"6. 案例",slug:"_6-案例",normalizedTitle:"6. 案例",charIndex:6480},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:6766}],headersStr:"1. 意图 1.1. 命令模式的交互 1.2. 命令模式的要点 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 与其他模式的关系 6. 案例 7. 参考资料",content:'# 设计模式之命令模式\n\n\n# 1. 意图\n\n命令模式（Command） 是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。\n\n\n# 1.1. 命令模式的交互\n\n\n\n * Client 创建一个 ConcreteCommand 对象并指定他的 Receiver 对象。\n * 某个 Invoker 对象存储该 ConcreteCommand 对象。\n * 该 Invoker 通过调用 Command 对象的 Execute 操作来提交一个请求。若该命令是可撤销的，ConcreteCommand 就在执行 Execute 操作之前存储当前状态以用于取消该命令。\n * ConcreteCommand 对象对调用它的 Receiver 的一些操作以执行该请求。\n\n\n# 1.2. 命令模式的要点\n\n * 命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。\n * 每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。\n * 命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。\n * 命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。\n * 命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。\n\n\n# 2. 适用场景\n\n * 如果你需要通过操作来参数化对象， 可使用命令模式。\n * 如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。\n * 如果你想要实现操作回滚功能， 可使用命令模式。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 发送者 （Sender）——亦称 “触发者 （Invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。\n\n 2. 命令 （Command） 接口通常仅声明一个执行命令的方法。\n\n 3. 具体命令 （Concrete Commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。\n    \n    接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。\n\n 4. 接收者 （Receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。\n\n 5. 客户端 （Client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。\n\n\n# 3.2. 结构代码范式\n\nCommand : 用来声明执行操作的接口。\n\nabstract class Command {\n    protected Receiver receiver;\n    public Command(Receiver receiver) {\n        this.receiver = receiver;\n    }\n\n    public abstract void Execute();\n}\n\n\nConcreteCommand : 将一个接收者对象绑定一个动作，调用接收者相应的操作，以实现 Execute。\n\nclass ConcreteCommand extends Command {\n    public ConcreteCommand(Receiver receiver) {\n        super(receiver);\n    }\n\n    @Override\n    public void Execute() {\n        receiver.Action();\n    }\n}\n\n\nInvoker : 要求该命令执行这个请求。\n\nclass Invoker {\n    private Command command;\n\n    public Invoker(Command command) {\n        this.command = command;\n    }\n\n    public void ExecuteCommand() {\n        command.Execute();\n    }\n}\n\n\nReceiver : 知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。\n\nclass Receiver {\n    public void Action() {\n        System.out.println("执行请求");\n    }\n}\n\n\nClient : 创建一个具体命令对象并设定它的接受者。\n\npublic class CommandPattern {\n    public static void main(String[] args) {\n        Receiver receiver = new Receiver();\n        Command cmd = new ConcreteCommand(receiver);\n        Invoker invoker = new Invoker(cmd);\n        invoker.ExecuteCommand();\n    }\n}\n\n\n\n# 4. 伪代码\n\n在本例中， 命令模式会记录已执行操作的历史记录， 以在需要时撤销操作。\n\n\n\n有些命令会改变编辑器的状态 （例如剪切和粘贴）， 它们可在执行相关操作前对编辑器的状态进行备份。 命令执行后会和当前点备份的编辑器状态一起被放入命令历史 （命令对象栈）。 此后， 如果用户需要进行回滚操作， 程序可从历史记录中取出最近的命令， 读取相应的编辑器状态备份， 然后进行恢复。\n\n客户端代码 （GUI 元素和命令历史等） 没有和具体命令类相耦合， 因为它通过命令接口来使用命令。 这使得你能在无需修改已有代码的情况下在程序中增加新的命令。\n\n// 命令基类会为所有具体命令定义通用接口。\nabstract class Command is\n    protected field app: Application\n    protected field editor: Editor\n    protected field backup: text\n\n    constructor Command(app: Application, editor: Editor) is\n        this.app = app\n        this.editor = editor\n\n    // 备份编辑器状态。\n    method saveBackup() is\n        backup = editor.text\n\n    // 恢复编辑器状态。\n    method undo() is\n        editor.text = backup\n\n    // 执行方法被声明为抽象以强制所有具体命令提供自己的实现。该方法必须根\n    // 据命令是否更改编辑器的状态返回 true 或 false。\n    abstract method execute()\n\n\n// 这里是具体命令。\nclass CopyCommand extends Command is\n    // 复制命令不会被保存到历史记录中，因为它没有改变编辑器的状态。\n    method execute() is\n        app.clipboard = editor.getSelection()\n        return false\n\nclass CutCommand extends Command is\n    // 剪切命令改变了编辑器的状态，因此它必须被保存到历史记录中。只要方法\n    // 返回 true，它就会被保存。\n    method execute() is\n        saveBackup()\n        app.clipboard = editor.getSelection()\n        editor.deleteSelection()\n        return true\n\nclass PasteCommand extends Command is\n    method execute() is\n        saveBackup()\n        editor.replaceSelection(app.clipboard)\n        return true\n\n// 撤销操作也是一个命令。\nclass UndoCommand extends Command is\n    method execute() is\n        app.undo()\n        return false\n\n\n// 全局命令历史记录就是一个堆桟。\nclass CommandHistory is\n    private field history: array of Command\n\n    // 后进...\n    method push(c: Command) is\n        // 将命令压入历史记录数组的末尾。\n\n    // ...先出\n    method pop():Command is\n        // 从历史记录中取出最近的命令。\n\n\n// 编辑器类包含实际的文本编辑操作。它会担任接收者的角色：最后所有命令都会\n// 将执行工作委派给编辑器的方法。\nclass Editor is\n    field text: string\n\n    method getSelection() is\n        // 返回选中的文字。\n\n    method deleteSelection() is\n        // 删除选中的文字。\n\n    method replaceSelection(text) is\n        // 在当前位置插入剪贴板中的内容。\n\n// 应用程序类会设置对象之间的关系。它会担任发送者的角色：当需要完成某些工\n// 作时，它会创建并执行一个命令对象。\nclass Application is\n    field clipboard: string\n    field editors: array of Editors\n    field activeEditor: Editor\n    field history: CommandHistory\n\n    // 将命令分派给 UI 对象的代码可能会是这样的。\n    method createUI() is\n        // ...\n        copy = function() { executeCommand(\n            new CopyCommand(this, activeEditor)) }\n        copyButton.setCommand(copy)\n        shortcuts.onKeyPress("Ctrl+C", copy)\n\n        cut = function() { executeCommand(\n            new CutCommand(this, activeEditor)) }\n        cutButton.setCommand(cut)\n        shortcuts.onKeyPress("Ctrl+X", cut)\n\n        paste = function() { executeCommand(\n            new PasteCommand(this, activeEditor)) }\n        pasteButton.setCommand(paste)\n        shortcuts.onKeyPress("Ctrl+V", paste)\n\n        undo = function() { executeCommand(\n            new UndoCommand(this, activeEditor)) }\n        undoButton.setCommand(undo)\n        shortcuts.onKeyPress("Ctrl+Z", undo)\n\n    // 执行一个命令并检查它是否需要被添加到历史记录中。\n    method executeCommand(command) is\n        if (command.execute)\n            history.push(command)\n\n    // 从历史记录中取出最近的命令并运行其 undo（撤销）方法。请注意，你并\n    // 不知晓该命令所属的类。但是我们不需要知晓，因为命令自己知道如何撤销\n    // 其动作。\n    method undo() is\n        command = history.pop()\n        if (command != null)\n            command.undo()\n\n\n\n# 5. 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n * 责任链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。 还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。\n * 你可以同时使用命令和备忘录模式来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。\n * 命令和策略模式看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。\n   * 你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。\n   * 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。\n * 原型模式可用于保存命令的历史记录。\n * 你可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作。\n\n\n# 6. 案例\n\n使用示例：命令模式在 Java 代码中很常见。 大部分情况下， 它被用于代替包含行为的参数化 UI 元素的回调函数， 此外还被用于对任务进行排序和记录操作历史记录等。\n\n以下是在核心 Java 程序库中的一些示例：\n\n * java.lang.Runnable 的所有实现\n * javax.swing.Action 的所有实现\n\n识别方法： 命令模式可以通过抽象或接口类型 （发送者） 中的行为方法来识别， 该类型调用另一个不同的抽象或接口类型 （接收者） 实现中的方法， 该实现则是在创建时由命令模式的实现封装。 命令类通常仅限于一些特殊行为。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之命令模式\n\n\n# 1. 意图\n\n命令模式（command） 是一种行为设计模式， 它可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。\n\n\n# 1.1. 命令模式的交互\n\n\n\n * client 创建一个 concretecommand 对象并指定他的 receiver 对象。\n * 某个 invoker 对象存储该 concretecommand 对象。\n * 该 invoker 通过调用 command 对象的 execute 操作来提交一个请求。若该命令是可撤销的，concretecommand 就在执行 execute 操作之前存储当前状态以用于取消该命令。\n * concretecommand 对象对调用它的 receiver 的一些操作以执行该请求。\n\n\n# 1.2. 命令模式的要点\n\n * 命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。\n * 每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。\n * 命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。\n * 命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。\n * 命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。\n\n\n# 2. 适用场景\n\n * 如果你需要通过操作来参数化对象， 可使用命令模式。\n * 如果你想要将操作放入队列中、 操作的执行或者远程执行操作， 可使用命令模式。\n * 如果你想要实现操作回滚功能， 可使用命令模式。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 发送者 （sender）——亦称 “触发者 （invoker）”——类负责对请求进行初始化， 其中必须包含一个成员变量来存储对于命令对象的引用。 发送者触发命令， 而不向接收者直接发送请求。 注意， 发送者并不负责创建命令对象： 它通常会通过构造函数从客户端处获得预先生成的命令。\n\n 2. 命令 （command） 接口通常仅声明一个执行命令的方法。\n\n 3. 具体命令 （concrete commands） 会实现各种类型的请求。 具体命令自身并不完成工作， 而是会将调用委派给一个业务逻辑对象。 但为了简化代码， 这些类可以进行合并。\n    \n    接收对象执行方法所需的参数可以声明为具体命令的成员变量。 你可以将命令对象设为不可变， 仅允许通过构造函数对这些成员变量进行初始化。\n\n 4. 接收者 （receiver） 类包含部分业务逻辑。 几乎任何对象都可以作为接收者。 绝大部分命令只处理如何将请求传递到接收者的细节， 接收者自己会完成实际的工作。\n\n 5. 客户端 （client） 会创建并配置具体命令对象。 客户端必须将包括接收者实体在内的所有请求参数传递给命令的构造函数。 此后， 生成的命令就可以与一个或多个发送者相关联了。\n\n\n# 3.2. 结构代码范式\n\ncommand : 用来声明执行操作的接口。\n\nabstract class command {\n    protected receiver receiver;\n    public command(receiver receiver) {\n        this.receiver = receiver;\n    }\n\n    public abstract void execute();\n}\n\n\nconcretecommand : 将一个接收者对象绑定一个动作，调用接收者相应的操作，以实现 execute。\n\nclass concretecommand extends command {\n    public concretecommand(receiver receiver) {\n        super(receiver);\n    }\n\n    @override\n    public void execute() {\n        receiver.action();\n    }\n}\n\n\ninvoker : 要求该命令执行这个请求。\n\nclass invoker {\n    private command command;\n\n    public invoker(command command) {\n        this.command = command;\n    }\n\n    public void executecommand() {\n        command.execute();\n    }\n}\n\n\nreceiver : 知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。\n\nclass receiver {\n    public void action() {\n        system.out.println("执行请求");\n    }\n}\n\n\nclient : 创建一个具体命令对象并设定它的接受者。\n\npublic class commandpattern {\n    public static void main(string[] args) {\n        receiver receiver = new receiver();\n        command cmd = new concretecommand(receiver);\n        invoker invoker = new invoker(cmd);\n        invoker.executecommand();\n    }\n}\n\n\n\n# 4. 伪代码\n\n在本例中， 命令模式会记录已执行操作的历史记录， 以在需要时撤销操作。\n\n\n\n有些命令会改变编辑器的状态 （例如剪切和粘贴）， 它们可在执行相关操作前对编辑器的状态进行备份。 命令执行后会和当前点备份的编辑器状态一起被放入命令历史 （命令对象栈）。 此后， 如果用户需要进行回滚操作， 程序可从历史记录中取出最近的命令， 读取相应的编辑器状态备份， 然后进行恢复。\n\n客户端代码 （gui 元素和命令历史等） 没有和具体命令类相耦合， 因为它通过命令接口来使用命令。 这使得你能在无需修改已有代码的情况下在程序中增加新的命令。\n\n// 命令基类会为所有具体命令定义通用接口。\nabstract class command is\n    protected field app: application\n    protected field editor: editor\n    protected field backup: text\n\n    constructor command(app: application, editor: editor) is\n        this.app = app\n        this.editor = editor\n\n    // 备份编辑器状态。\n    method savebackup() is\n        backup = editor.text\n\n    // 恢复编辑器状态。\n    method undo() is\n        editor.text = backup\n\n    // 执行方法被声明为抽象以强制所有具体命令提供自己的实现。该方法必须根\n    // 据命令是否更改编辑器的状态返回 true 或 false。\n    abstract method execute()\n\n\n// 这里是具体命令。\nclass copycommand extends command is\n    // 复制命令不会被保存到历史记录中，因为它没有改变编辑器的状态。\n    method execute() is\n        app.clipboard = editor.getselection()\n        return false\n\nclass cutcommand extends command is\n    // 剪切命令改变了编辑器的状态，因此它必须被保存到历史记录中。只要方法\n    // 返回 true，它就会被保存。\n    method execute() is\n        savebackup()\n        app.clipboard = editor.getselection()\n        editor.deleteselection()\n        return true\n\nclass pastecommand extends command is\n    method execute() is\n        savebackup()\n        editor.replaceselection(app.clipboard)\n        return true\n\n// 撤销操作也是一个命令。\nclass undocommand extends command is\n    method execute() is\n        app.undo()\n        return false\n\n\n// 全局命令历史记录就是一个堆桟。\nclass commandhistory is\n    private field history: array of command\n\n    // 后进...\n    method push(c: command) is\n        // 将命令压入历史记录数组的末尾。\n\n    // ...先出\n    method pop():command is\n        // 从历史记录中取出最近的命令。\n\n\n// 编辑器类包含实际的文本编辑操作。它会担任接收者的角色：最后所有命令都会\n// 将执行工作委派给编辑器的方法。\nclass editor is\n    field text: string\n\n    method getselection() is\n        // 返回选中的文字。\n\n    method deleteselection() is\n        // 删除选中的文字。\n\n    method replaceselection(text) is\n        // 在当前位置插入剪贴板中的内容。\n\n// 应用程序类会设置对象之间的关系。它会担任发送者的角色：当需要完成某些工\n// 作时，它会创建并执行一个命令对象。\nclass application is\n    field clipboard: string\n    field editors: array of editors\n    field activeeditor: editor\n    field history: commandhistory\n\n    // 将命令分派给 ui 对象的代码可能会是这样的。\n    method createui() is\n        // ...\n        copy = function() { executecommand(\n            new copycommand(this, activeeditor)) }\n        copybutton.setcommand(copy)\n        shortcuts.onkeypress("ctrl+c", copy)\n\n        cut = function() { executecommand(\n            new cutcommand(this, activeeditor)) }\n        cutbutton.setcommand(cut)\n        shortcuts.onkeypress("ctrl+x", cut)\n\n        paste = function() { executecommand(\n            new pastecommand(this, activeeditor)) }\n        pastebutton.setcommand(paste)\n        shortcuts.onkeypress("ctrl+v", paste)\n\n        undo = function() { executecommand(\n            new undocommand(this, activeeditor)) }\n        undobutton.setcommand(undo)\n        shortcuts.onkeypress("ctrl+z", undo)\n\n    // 执行一个命令并检查它是否需要被添加到历史记录中。\n    method executecommand(command) is\n        if (command.execute)\n            history.push(command)\n\n    // 从历史记录中取出最近的命令并运行其 undo（撤销）方法。请注意，你并\n    // 不知晓该命令所属的类。但是我们不需要知晓，因为命令自己知道如何撤销\n    // 其动作。\n    method undo() is\n        command = history.pop()\n        if (command != null)\n            command.undo()\n\n\n\n# 5. 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n * 责任链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。 还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。\n * 你可以同时使用命令和备忘录模式来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。\n * 命令和策略模式看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。\n   * 你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。\n   * 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。\n * 原型模式可用于保存命令的历史记录。\n * 你可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作。\n\n\n# 6. 案例\n\n使用示例：命令模式在 java 代码中很常见。 大部分情况下， 它被用于代替包含行为的参数化 ui 元素的回调函数， 此外还被用于对任务进行排序和记录操作历史记录等。\n\n以下是在核心 java 程序库中的一些示例：\n\n * java.lang.runnable 的所有实现\n * javax.swing.action 的所有实现\n\n识别方法： 命令模式可以通过抽象或接口类型 （发送者） 中的行为方法来识别， 该类型调用另一个不同的抽象或接口类型 （接收者） 实现中的方法， 该实现则是在创建时由命令模式的实现封装。 命令类通常仅限于一些特殊行为。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之迭代器模式",frontmatter:{title:"设计模式之迭代器模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-19T17:20:00.000Z",permalink:"/pages/d2026d/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/16.%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/16.迭代器模式.md",key:"v-637f7ff4",path:"/pages/d2026d/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:17},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:98},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:240},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:252},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:797},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:3002},{level:2,title:"5. 与其他模式的关系",slug:"_5-与其他模式的关系",normalizedTitle:"5. 与其他模式的关系",charIndex:5822},{level:2,title:"6. 案例",slug:"_6-案例",normalizedTitle:"6. 案例",charIndex:6020},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:6270}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 与其他模式的关系 6. 案例 7. 参考资料",content:'# 设计模式之迭代器模式\n\n\n# 1. 意图\n\n迭代器模式（Iterator） 是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。\n\n\n# 2. 适用场景\n\n * 当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。\n * 使用该模式可以减少程序中重复的遍历代码。\n * 如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 迭代器 （Iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。\n 2. 具体迭代器 （Concrete Iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。\n 3. 集合 （Collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。\n 4. 具体集合 （Concrete Collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。\n 5. 客户端 （Client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。\n    * 客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。\n\n\n# 3.2. 结构代码范式\n\nIterator : 定义访问元素的接口。\n\ninterface Iterator {\n    public Object first();\n    public Object next();\n    public boolean isDone();\n    public Object currentItem();\n}\n\n\nConcreteIterator : 实现 Iterator 接口。记录当前访问的元素在集合中的位置信息。\n\nclass ConcreteIterator implements Iterator {\n    private int current = 0;\n    private ConcreteAggregate aggregate;\n\n    public ConcreteIterator(ConcreteAggregate aggregate) {\n        this.aggregate = aggregate;\n    }\n\n    @Override\n    public Object first() {\n        return aggregate.get(0);\n    }\n\n    @Override\n    public Object next() {\n        current++;\n        if (current < aggregate.size()) {\n            return aggregate.get(current);\n        }\n        return null;\n    }\n\n    @Override\n    public boolean isDone() {\n        return (current >= aggregate.size()) ? true : false;\n    }\n\n    @Override\n    public Object currentItem() {\n        return aggregate.get(current);\n    }\n}\n\n\nAggregate : 定义创建 Iterator 对象的接口。\n\ninterface Aggregate {\n    public Iterator CreateIterator();\n}\n\n\nConcreteAggregate : 实现 Iterator 接口，返回一个合适的 ConcreteIterator 实例。\n\nclass ConcreteAggregate implements Aggregate {\n    private List<Object> items = new ArrayList<Object>();\n\n    @Override\n    public Iterator CreateIterator() {\n        return new ConcreteIterator(this);\n    }\n\n    public int size() {\n        return items.size();\n    }\n\n    public Object get(int index) {\n        return items.get(index);\n    }\n\n    public void set(int index, Object element) {\n        items.set(index, element);\n    }\n\n    public void add(Object element) {\n        items.add(element);\n    }\n}\n\n\n客户端\n\npublic class IteratorPattern {\n    public static void main(String[] args) {\n        ConcreteAggregate aggregate = new ConcreteAggregate();\n        aggregate.add("张三");\n        aggregate.add("李四");\n        aggregate.add("王五");\n        aggregate.add("赵六");\n\n        Iterator iter = new ConcreteIterator(aggregate);\n        Object item = iter.first();\n        System.out.println("第一个人是：" + item);\n        System.out.println("所有人的名单是：");\n        while (!iter.isDone()) {\n            System.out.println(iter.currentItem());\n            iter.next();\n        }\n    }\n}\n\n\n输出\n\n第一个人是：张三\n所有人的名单是：\n张三\n李四\n王五\n赵六\n\n\n\n# 4. 伪代码\n\n在本例中， 迭代器模式用于遍历一个封装了访问微信好友关系功能的特殊集合。 该集合提供使用不同方式遍历档案资料的多个迭代器。\n\n\n\n“好友 （friends）” 迭代器可用于遍历指定档案的好友。 “同事 （colleagues）” 迭代器也提供同样的功能， 但仅包括与目标用户在同一家公司工作的好友。 这两个迭代器都实现了同一个通用接口， 客户端能在不了解认证和发送 REST 请求等实现细节的情况下获取档案。\n\n客户端仅通过接口与集合和迭代器交互， 也就不会同具体类耦合。 如果你决定将应用连接到全新的社交网络， 只需提供新的集合和迭代器类即可， 无需修改现有代码。\n\n// 集合接口必须声明一个用于生成迭代器的工厂方法。如果程序中有不同类型的迭\n// 代器，你也可以声明多个方法。\ninterface SocialNetwork is\n    method createFriendsIterator(profileId):ProfileIterator\n    method createCoworkersIterator(profileId):ProfileIterator\n\n\n// 每个具体集合都与其返回的一组具体迭代器相耦合。但客户并不是这样的，因为\n// 这些方法的签名将会返回迭代器接口。\nclass WeChat implements SocialNetwork is\n    // ...大量的集合代码应该放在这里...\n\n    // 迭代器创建代码。\n    method createFriendsIterator(profileId) is\n        return new WeChatIterator(this, profileId, "friends")\n    method createCoworkersIterator(profileId) is\n        return new WeChatIterator(this, profileId, "coworkers")\n\n\n// 所有迭代器的通用接口。\ninterface ProfileIterator is\n    method getNext():Profile\n    method hasMore():bool\n\n\n// 具体迭代器类。\nclass WeChatIterator implements ProfileIterator is\n    // 迭代器需要一个指向其遍历集合的引用。\n    private field weChat: WeChat\n    private field profileId, type: string\n\n    // 迭代器对象会独立于其他迭代器来对集合进行遍历。因此它必须保存迭代器\n    // 的状态。\n    private field currentPosition\n    private field cache: array of Profile\n\n    constructor WeChatIterator(weChat, profileId, type) is\n        this.weChat = weChat\n        this.profileId = profileId\n        this.type = type\n\n    private method lazyInit() is\n        if (cache == null)\n            cache = weChat.socialGraphRequest(profileId, type)\n\n    // 每个具体迭代器类都会自行实现通用迭代器接口。\n    method getNext() is\n        if (hasMore())\n            currentPosition++\n            return cache[currentPosition]\n\n    method hasMore() is\n        lazyInit()\n        return currentPosition < cache.length\n\n\n// 这里还有一个有用的绝招：你可将迭代器传递给客户端类，无需让其拥有访问整\n// 个集合的权限。这样一来，你就无需将集合暴露给客户端了。\n//\n// 还有另一个好处：你可在运行时将不同的迭代器传递给客户端，从而改变客户端\n// 与集合互动的方式。这一方法可行的原因是客户端代码并没有和具体迭代器类相\n// 耦合。\nclass SocialSpammer is\n    method send(iterator: ProfileIterator, message: string) is\n        while (iterator.hasMore())\n            profile = iterator.getNext()\n            System.sendEmail(profile.getEmail(), message)\n\n\n// 应用程序（Application）类可对集合和迭代器进行配置，然后将其传递给客户\n// 端代码。\nclass Application is\n    field network: SocialNetwork\n    field spammer: SocialSpammer\n\n    method config() is\n        if working with WeChat\n            this.network = new WeChat()\n        if working with LinkedIn\n            this.network = new LinkedIn()\n        this.spammer = new SocialSpammer()\n\n    method sendSpamToFriends(profile) is\n        iterator = network.createFriendsIterator(profile.getId())\n        spammer.send(iterator, "非常重要的消息")\n\n    method sendSpamToCoworkers(profile) is\n        iterator = network.createCoworkersIterator(profile.getId())\n        spammer.send(iterator, "非常重要的消息")\n\n\n\n# 5. 与其他模式的关系\n\n * 你可以使用迭代器模式来遍历组合模式树。\n * 你可以同时使用工厂方法模式和迭代器来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。\n * 你可以同时使用备忘录模式和迭代器来获取当前迭代器的状态， 并且在需要的时候进行回滚。\n * 可以同时使用访问者模式和迭代器来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。\n\n\n# 6. 案例\n\n使用示例： 该模式在 Java 代码中很常见。 许多框架和程序库都会使用它来提供遍历其集合的标准方式。\n\n下面是该模式在核心 Java 程序库中的一些示例：\n\n * java.util.Iterator的所有实现 （还有 java.util.Scanner）。\n * java.util.Enumeration的所有实现\n\n识别方法： 迭代器可以通过导航方法 （例如 next和 previous等） 来轻松识别。 使用迭代器的客户端代码可能没有其所遍历的集合的直接访问权限。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之迭代器模式\n\n\n# 1. 意图\n\n迭代器模式（iterator） 是一种行为设计模式， 让你能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。\n\n\n# 2. 适用场景\n\n * 当集合背后为复杂的数据结构， 且你希望对客户端隐藏其复杂性时 （出于使用便利性或安全性的考虑）， 可以使用迭代器模式。\n * 使用该模式可以减少程序中重复的遍历代码。\n * 如果你希望代码能够遍历不同的甚至是无法预知的数据结构， 可以使用迭代器模式。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 迭代器 （iterator） 接口声明了遍历集合所需的操作： 获取下一个元素、 获取当前位置和重新开始迭代等。\n 2. 具体迭代器 （concrete iterators） 实现遍历集合的一种特定算法。 迭代器对象必须跟踪自身遍历的进度。 这使得多个迭代器可以相互独立地遍历同一集合。\n 3. 集合 （collection） 接口声明一个或多个方法来获取与集合兼容的迭代器。 请注意， 返回方法的类型必须被声明为迭代器接口， 因此具体集合可以返回各种不同种类的迭代器。\n 4. 具体集合 （concrete collections） 会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 你可能会琢磨， 剩下的集合代码在什么地方呢？ 不用担心， 它也会在同一个类中。 只是这些细节对于实际模式来说并不重要， 所以我们将其省略了而已。\n 5. 客户端 （client） 通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。\n    * 客户端通常不会自行创建迭代器， 而是会从集合中获取。 但在特定情况下， 客户端可以直接创建一个迭代器 （例如当客户端需要自定义特殊迭代器时）。\n\n\n# 3.2. 结构代码范式\n\niterator : 定义访问元素的接口。\n\ninterface iterator {\n    public object first();\n    public object next();\n    public boolean isdone();\n    public object currentitem();\n}\n\n\nconcreteiterator : 实现 iterator 接口。记录当前访问的元素在集合中的位置信息。\n\nclass concreteiterator implements iterator {\n    private int current = 0;\n    private concreteaggregate aggregate;\n\n    public concreteiterator(concreteaggregate aggregate) {\n        this.aggregate = aggregate;\n    }\n\n    @override\n    public object first() {\n        return aggregate.get(0);\n    }\n\n    @override\n    public object next() {\n        current++;\n        if (current < aggregate.size()) {\n            return aggregate.get(current);\n        }\n        return null;\n    }\n\n    @override\n    public boolean isdone() {\n        return (current >= aggregate.size()) ? true : false;\n    }\n\n    @override\n    public object currentitem() {\n        return aggregate.get(current);\n    }\n}\n\n\naggregate : 定义创建 iterator 对象的接口。\n\ninterface aggregate {\n    public iterator createiterator();\n}\n\n\nconcreteaggregate : 实现 iterator 接口，返回一个合适的 concreteiterator 实例。\n\nclass concreteaggregate implements aggregate {\n    private list<object> items = new arraylist<object>();\n\n    @override\n    public iterator createiterator() {\n        return new concreteiterator(this);\n    }\n\n    public int size() {\n        return items.size();\n    }\n\n    public object get(int index) {\n        return items.get(index);\n    }\n\n    public void set(int index, object element) {\n        items.set(index, element);\n    }\n\n    public void add(object element) {\n        items.add(element);\n    }\n}\n\n\n客户端\n\npublic class iteratorpattern {\n    public static void main(string[] args) {\n        concreteaggregate aggregate = new concreteaggregate();\n        aggregate.add("张三");\n        aggregate.add("李四");\n        aggregate.add("王五");\n        aggregate.add("赵六");\n\n        iterator iter = new concreteiterator(aggregate);\n        object item = iter.first();\n        system.out.println("第一个人是：" + item);\n        system.out.println("所有人的名单是：");\n        while (!iter.isdone()) {\n            system.out.println(iter.currentitem());\n            iter.next();\n        }\n    }\n}\n\n\n输出\n\n第一个人是：张三\n所有人的名单是：\n张三\n李四\n王五\n赵六\n\n\n\n# 4. 伪代码\n\n在本例中， 迭代器模式用于遍历一个封装了访问微信好友关系功能的特殊集合。 该集合提供使用不同方式遍历档案资料的多个迭代器。\n\n\n\n“好友 （friends）” 迭代器可用于遍历指定档案的好友。 “同事 （colleagues）” 迭代器也提供同样的功能， 但仅包括与目标用户在同一家公司工作的好友。 这两个迭代器都实现了同一个通用接口， 客户端能在不了解认证和发送 rest 请求等实现细节的情况下获取档案。\n\n客户端仅通过接口与集合和迭代器交互， 也就不会同具体类耦合。 如果你决定将应用连接到全新的社交网络， 只需提供新的集合和迭代器类即可， 无需修改现有代码。\n\n// 集合接口必须声明一个用于生成迭代器的工厂方法。如果程序中有不同类型的迭\n// 代器，你也可以声明多个方法。\ninterface socialnetwork is\n    method createfriendsiterator(profileid):profileiterator\n    method createcoworkersiterator(profileid):profileiterator\n\n\n// 每个具体集合都与其返回的一组具体迭代器相耦合。但客户并不是这样的，因为\n// 这些方法的签名将会返回迭代器接口。\nclass wechat implements socialnetwork is\n    // ...大量的集合代码应该放在这里...\n\n    // 迭代器创建代码。\n    method createfriendsiterator(profileid) is\n        return new wechatiterator(this, profileid, "friends")\n    method createcoworkersiterator(profileid) is\n        return new wechatiterator(this, profileid, "coworkers")\n\n\n// 所有迭代器的通用接口。\ninterface profileiterator is\n    method getnext():profile\n    method hasmore():bool\n\n\n// 具体迭代器类。\nclass wechatiterator implements profileiterator is\n    // 迭代器需要一个指向其遍历集合的引用。\n    private field wechat: wechat\n    private field profileid, type: string\n\n    // 迭代器对象会独立于其他迭代器来对集合进行遍历。因此它必须保存迭代器\n    // 的状态。\n    private field currentposition\n    private field cache: array of profile\n\n    constructor wechatiterator(wechat, profileid, type) is\n        this.wechat = wechat\n        this.profileid = profileid\n        this.type = type\n\n    private method lazyinit() is\n        if (cache == null)\n            cache = wechat.socialgraphrequest(profileid, type)\n\n    // 每个具体迭代器类都会自行实现通用迭代器接口。\n    method getnext() is\n        if (hasmore())\n            currentposition++\n            return cache[currentposition]\n\n    method hasmore() is\n        lazyinit()\n        return currentposition < cache.length\n\n\n// 这里还有一个有用的绝招：你可将迭代器传递给客户端类，无需让其拥有访问整\n// 个集合的权限。这样一来，你就无需将集合暴露给客户端了。\n//\n// 还有另一个好处：你可在运行时将不同的迭代器传递给客户端，从而改变客户端\n// 与集合互动的方式。这一方法可行的原因是客户端代码并没有和具体迭代器类相\n// 耦合。\nclass socialspammer is\n    method send(iterator: profileiterator, message: string) is\n        while (iterator.hasmore())\n            profile = iterator.getnext()\n            system.sendemail(profile.getemail(), message)\n\n\n// 应用程序（application）类可对集合和迭代器进行配置，然后将其传递给客户\n// 端代码。\nclass application is\n    field network: socialnetwork\n    field spammer: socialspammer\n\n    method config() is\n        if working with wechat\n            this.network = new wechat()\n        if working with linkedin\n            this.network = new linkedin()\n        this.spammer = new socialspammer()\n\n    method sendspamtofriends(profile) is\n        iterator = network.createfriendsiterator(profile.getid())\n        spammer.send(iterator, "非常重要的消息")\n\n    method sendspamtocoworkers(profile) is\n        iterator = network.createcoworkersiterator(profile.getid())\n        spammer.send(iterator, "非常重要的消息")\n\n\n\n# 5. 与其他模式的关系\n\n * 你可以使用迭代器模式来遍历组合模式树。\n * 你可以同时使用工厂方法模式和迭代器来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。\n * 你可以同时使用备忘录模式和迭代器来获取当前迭代器的状态， 并且在需要的时候进行回滚。\n * 可以同时使用访问者模式和迭代器来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。\n\n\n# 6. 案例\n\n使用示例： 该模式在 java 代码中很常见。 许多框架和程序库都会使用它来提供遍历其集合的标准方式。\n\n下面是该模式在核心 java 程序库中的一些示例：\n\n * java.util.iterator的所有实现 （还有 java.util.scanner）。\n * java.util.enumeration的所有实现\n\n识别方法： 迭代器可以通过导航方法 （例如 next和 previous等） 来轻松识别。 使用迭代器的客户端代码可能没有其所遍历的集合的直接访问权限。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之观察者模式",frontmatter:{title:"设计模式之观察者模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-20T16:09:00.000Z",permalink:"/pages/87fbaa/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/17.%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/17.观察者模式.md",key:"v-07d9254f",path:"/pages/87fbaa/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:17},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:96},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:212},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:224},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:716},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:3343},{level:2,title:"5. 与其他模式的关系",slug:"_5-与其他模式的关系",normalizedTitle:"5. 与其他模式的关系",charIndex:5650},{level:2,title:"6. 案例",slug:"_6-案例",normalizedTitle:"6. 案例",charIndex:6301},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:6710}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 与其他模式的关系 6. 案例 7. 参考资料",content:'# 设计模式之观察者模式\n\n\n# 1. 意图\n\n观察者模式（Observer）是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。\n\n\n# 2. 适用场景\n\n * 当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。\n * 当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 发布者 （Publisher） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。\n 2. 当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。\n 3. 订阅者 （Subscriber） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 update更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。\n 4. 具体订阅者 （Concrete Subscribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。\n 5. 订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。\n 6. 客户端 （Client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。\n\n\n# 3.2. 结构代码范式\n\nSubject : 主题类，保存所有订阅此主题的观察者，观察者的 数量是任意的。定义 添加观察者 (Attach) 和 删除观察者 (Detach) 的接口。\n\nabstract class Subject {\n    protected String name;\n    protected String state;\n    protected List<Observer> observers = new ArrayList<Observer>();\n\n    public abstract String getState();\n    public abstract void setState(String state);\n    public abstract void Notify();\n\n    public Subject(String name) {\n        this.name = name;\n    }\n\n    public void Attach(Observer observer) {\n        observers.add(observer);\n    }\n\n    public void Detach(Observer observer) {\n        observers.remove(observer);\n    }\n}\n\n\nObserver : 观察者类，定义更新接口 (Update)，当收到 Subject 的通知时，Observer 需要同步更新信息。\n\nabstract class Observer {\n    protected String name;\n    protected Subject subject;\n    public Observer(String name, Subject subject) {\n        this.name = name;\n        this.subject = subject;\n    }\n    public abstract void Update();\n}\n\n\nConcreteSubject : 具体主题类，存储对于这个主题感兴趣的所有观察者。当内部状态发生变化时，应通知所有登记的观察者(Notify)。\n\nclass ConcreteSubject extends Subject {\n    public ConcreteSubject(String name) {\n        super(name);\n    }\n\n    @Override\n    public String getState() {\n        return state;\n    }\n\n    @Override\n    public void setState(String state) {\n        this.state = state;\n    }\n\n    @Override\n    public void Notify() {\n        System.out.println("======= " + this.name + "主题发布新消息 =======");\n        for (Observer observer : observers) {\n            observer.Update();\n        }\n    }\n}\n\n\nConcreteObserver : 具体观察者类，实现 Observer 的更新接口 (Update)，以便和 Subject 同步状态信息。\n\nclass ConcreteObserver extends Observer {\n    private String state;\n    public ConcreteObserver(String name, Subject subject) {\n        super(name, subject);\n    }\n\n    @Override\n    public void Update() {\n        state = subject.getState();\n        System.out.println(this.name + "收到当前状态：" + state);\n    }\n}\n\n\n客户端\n\npublic class ObserverPattern {\n    public static void main(String[] args) {\n        ConcreteSubject subject = new ConcreteSubject("天气");\n        ConcreteObserver observer1 = new ConcreteObserver("张三", subject);\n        ConcreteObserver observer2 = new ConcreteObserver("李四", subject);\n        ConcreteObserver observer3 = new ConcreteObserver("王五", subject);\n\n        subject.Attach(observer1);\n        subject.Attach(observer2);\n        subject.Attach(observer3);\n        subject.setState("今天下雨");\n        subject.Notify();\n\n        subject.Detach(observer2);\n        subject.setState("明天天晴");\n        subject.Notify();\n    }\n}\n\n\n输出\n\n======= 天气主题发布新消息 =======\n张三收到当前状态：今天下雨\n李四收到当前状态：今天下雨\n王五收到当前状态：今天下雨\n======= 天气主题发布新消息 =======\n张三收到当前状态：明天天晴\n王五收到当前状态：明天天晴\n\n\n\n# 4. 伪代码\n\n在本例中， 观察者模式允许文本编辑器对象将自身的状态改变通知给其他服务对象。\n\n\n\n订阅者列表是动态生成的： 对象可在运行时根据程序需要开始或停止监听通知。\n\n在本实现中， 编辑器类自身并不维护订阅列表。 它将工作委派给专门从事此工作的一个特殊帮手对象。 你还可将该对象升级为中心化的事件分发器， 允许任何对象成为发布者。\n\n只要发布者通过同样的接口与所有订阅者进行交互， 那么在程序中新增订阅者时就无需修改已有发布者类的代码。\n\n// 发布者基类包含订阅管理代码和通知方法。\nclass EventManager is\n    private field listeners: hash map of event types and listeners\n\n    method subscribe(eventType, listener) is\n        listeners.add(eventType, listener)\n\n    method unsubscribe(eventType, listener) is\n        listeners.remove(eventType, listener)\n\n    method notify(eventType, data) is\n        foreach (listener in listeners.of(eventType)) do\n            listener.update(data)\n\n// 具体发布者包含一些订阅者感兴趣的实际业务逻辑。我们可以从发布者基类中扩\n// 展出该类，但在实际情况下并不总能做到，因为具体发布者可能已经是子类了。\n// 在这种情况下，你可用组合来修补订阅逻辑，就像我们在这里做的一样。\nclass Editor is\n    public field events: EventManager\n    private field file: File\n\n    constructor Editor() is\n        events = new EventManager()\n\n    // 业务逻辑的方法可将变化通知给订阅者。\n    method openFile(path) is\n        this.file = new File(path)\n        events.notify("open", file.name)\n\n    method saveFile() is\n        file.write()\n        events.notify("save", file.name)\n\n    // ...\n\n\n// 这里是订阅者接口。如果你的编程语言支持函数类型，则可用一组函数来代替整\n// 个订阅者的层次结构。\ninterface EventListener is\n    method update(filename)\n\n// 具体订阅者会对其注册的发布者所发出的更新消息做出响应。\nclass LoggingListener implements EventListener is\n    private field log: File\n    private field message\n\n    constructor LoggingListener(log_filename, message) is\n        this.log = new File(log_filename)\n        this.message = message\n\n    method update(filename) is\n        log.write(replace(\'%s\',filename,message))\n\nclass EmailAlertsListener implements EventListener is\n    private field email: string\n\n    constructor EmailAlertsListener(email, message) is\n        this.email = email\n        this.message = message\n\n    method update(filename) is\n        system.email(email, replace(\'%s\',filename,message))\n\n\n// 应用程序可在运行时配置发布者和订阅者。\nclass Application is\n    method config() is\n        editor = new Editor()\n\n        logger = new LoggingListener(\n            "/path/to/log.txt",\n            "有人打开了文件：%s");\n        editor.events.subscribe("open", logger)\n\n        emailAlerts = new EmailAlertsListener(\n            "admin@example.com",\n            "有人更改了文件：%s")\n        editor.events.subscribe("save", emailAlerts)\n\n\n\n# 5. 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n * 中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。\n   * 中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。\n   * 有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。\n   * 当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。\n   * 假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。\n\n\n# 6. 案例\n\n使用示例： 观察者模式在 Java 代码中很常见， 特别是在 GUI 组件中。 它提供了在不与其他对象所属类耦合的情况下对其事件做出反应的方式。\n\n这里是核心 Java 程序库中该模式的一些示例：\n\n * java.util.Observer/ java.util.Observable （极少在真实世界中使用）\n * java.util.EventListener的所有实现 （几乎广泛存在于 Swing 组件中）\n * javax.servlet.http.HttpSessionBindingListener\n * javax.servlet.http.HttpSessionAttributeListener\n * javax.faces.event.PhaseListener\n\n识别方法： 该模式可以通过将对象存储在列表中的订阅方法， 和对于面向该列表中对象的更新方法的调用来识别。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之观察者模式\n\n\n# 1. 意图\n\n观察者模式（observer）是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。\n\n\n# 2. 适用场景\n\n * 当一个对象状态的改变需要改变其他对象， 或实际对象是事先未知的或动态变化的时， 可使用观察者模式。\n * 当应用中的一些对象必须观察其他对象时， 可使用该模式。 但仅能在有限时间内或特定情况下使用。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 发布者 （publisher） 会向其他对象发送值得关注的事件。 事件会在发布者自身状态改变或执行特定行为后发生。 发布者中包含一个允许新订阅者加入和当前订阅者离开列表的订阅构架。\n 2. 当新事件发生时， 发送者会遍历订阅列表并调用每个订阅者对象的通知方法。 该方法是在订阅者接口中声明的。\n 3. 订阅者 （subscriber） 接口声明了通知接口。 在绝大多数情况下， 该接口仅包含一个 update更新方法。 该方法可以拥有多个参数， 使发布者能在更新时传递事件的详细信息。\n 4. 具体订阅者 （concrete subscribers） 可以执行一些操作来回应发布者的通知。 所有具体订阅者类都实现了同样的接口， 因此发布者不需要与具体类相耦合。\n 5. 订阅者通常需要一些上下文信息来正确地处理更新。 因此， 发布者通常会将一些上下文数据作为通知方法的参数进行传递。 发布者也可将自身作为参数进行传递， 使订阅者直接获取所需的数据。\n 6. 客户端 （client） 会分别创建发布者和订阅者对象， 然后为订阅者注册发布者更新。\n\n\n# 3.2. 结构代码范式\n\nsubject : 主题类，保存所有订阅此主题的观察者，观察者的 数量是任意的。定义 添加观察者 (attach) 和 删除观察者 (detach) 的接口。\n\nabstract class subject {\n    protected string name;\n    protected string state;\n    protected list<observer> observers = new arraylist<observer>();\n\n    public abstract string getstate();\n    public abstract void setstate(string state);\n    public abstract void notify();\n\n    public subject(string name) {\n        this.name = name;\n    }\n\n    public void attach(observer observer) {\n        observers.add(observer);\n    }\n\n    public void detach(observer observer) {\n        observers.remove(observer);\n    }\n}\n\n\nobserver : 观察者类，定义更新接口 (update)，当收到 subject 的通知时，observer 需要同步更新信息。\n\nabstract class observer {\n    protected string name;\n    protected subject subject;\n    public observer(string name, subject subject) {\n        this.name = name;\n        this.subject = subject;\n    }\n    public abstract void update();\n}\n\n\nconcretesubject : 具体主题类，存储对于这个主题感兴趣的所有观察者。当内部状态发生变化时，应通知所有登记的观察者(notify)。\n\nclass concretesubject extends subject {\n    public concretesubject(string name) {\n        super(name);\n    }\n\n    @override\n    public string getstate() {\n        return state;\n    }\n\n    @override\n    public void setstate(string state) {\n        this.state = state;\n    }\n\n    @override\n    public void notify() {\n        system.out.println("======= " + this.name + "主题发布新消息 =======");\n        for (observer observer : observers) {\n            observer.update();\n        }\n    }\n}\n\n\nconcreteobserver : 具体观察者类，实现 observer 的更新接口 (update)，以便和 subject 同步状态信息。\n\nclass concreteobserver extends observer {\n    private string state;\n    public concreteobserver(string name, subject subject) {\n        super(name, subject);\n    }\n\n    @override\n    public void update() {\n        state = subject.getstate();\n        system.out.println(this.name + "收到当前状态：" + state);\n    }\n}\n\n\n客户端\n\npublic class observerpattern {\n    public static void main(string[] args) {\n        concretesubject subject = new concretesubject("天气");\n        concreteobserver observer1 = new concreteobserver("张三", subject);\n        concreteobserver observer2 = new concreteobserver("李四", subject);\n        concreteobserver observer3 = new concreteobserver("王五", subject);\n\n        subject.attach(observer1);\n        subject.attach(observer2);\n        subject.attach(observer3);\n        subject.setstate("今天下雨");\n        subject.notify();\n\n        subject.detach(observer2);\n        subject.setstate("明天天晴");\n        subject.notify();\n    }\n}\n\n\n输出\n\n======= 天气主题发布新消息 =======\n张三收到当前状态：今天下雨\n李四收到当前状态：今天下雨\n王五收到当前状态：今天下雨\n======= 天气主题发布新消息 =======\n张三收到当前状态：明天天晴\n王五收到当前状态：明天天晴\n\n\n\n# 4. 伪代码\n\n在本例中， 观察者模式允许文本编辑器对象将自身的状态改变通知给其他服务对象。\n\n\n\n订阅者列表是动态生成的： 对象可在运行时根据程序需要开始或停止监听通知。\n\n在本实现中， 编辑器类自身并不维护订阅列表。 它将工作委派给专门从事此工作的一个特殊帮手对象。 你还可将该对象升级为中心化的事件分发器， 允许任何对象成为发布者。\n\n只要发布者通过同样的接口与所有订阅者进行交互， 那么在程序中新增订阅者时就无需修改已有发布者类的代码。\n\n// 发布者基类包含订阅管理代码和通知方法。\nclass eventmanager is\n    private field listeners: hash map of event types and listeners\n\n    method subscribe(eventtype, listener) is\n        listeners.add(eventtype, listener)\n\n    method unsubscribe(eventtype, listener) is\n        listeners.remove(eventtype, listener)\n\n    method notify(eventtype, data) is\n        foreach (listener in listeners.of(eventtype)) do\n            listener.update(data)\n\n// 具体发布者包含一些订阅者感兴趣的实际业务逻辑。我们可以从发布者基类中扩\n// 展出该类，但在实际情况下并不总能做到，因为具体发布者可能已经是子类了。\n// 在这种情况下，你可用组合来修补订阅逻辑，就像我们在这里做的一样。\nclass editor is\n    public field events: eventmanager\n    private field file: file\n\n    constructor editor() is\n        events = new eventmanager()\n\n    // 业务逻辑的方法可将变化通知给订阅者。\n    method openfile(path) is\n        this.file = new file(path)\n        events.notify("open", file.name)\n\n    method savefile() is\n        file.write()\n        events.notify("save", file.name)\n\n    // ...\n\n\n// 这里是订阅者接口。如果你的编程语言支持函数类型，则可用一组函数来代替整\n// 个订阅者的层次结构。\ninterface eventlistener is\n    method update(filename)\n\n// 具体订阅者会对其注册的发布者所发出的更新消息做出响应。\nclass logginglistener implements eventlistener is\n    private field log: file\n    private field message\n\n    constructor logginglistener(log_filename, message) is\n        this.log = new file(log_filename)\n        this.message = message\n\n    method update(filename) is\n        log.write(replace(\'%s\',filename,message))\n\nclass emailalertslistener implements eventlistener is\n    private field email: string\n\n    constructor emailalertslistener(email, message) is\n        this.email = email\n        this.message = message\n\n    method update(filename) is\n        system.email(email, replace(\'%s\',filename,message))\n\n\n// 应用程序可在运行时配置发布者和订阅者。\nclass application is\n    method config() is\n        editor = new editor()\n\n        logger = new logginglistener(\n            "/path/to/log.txt",\n            "有人打开了文件：%s");\n        editor.events.subscribe("open", logger)\n\n        emailalerts = new emailalertslistener(\n            "admin@example.com",\n            "有人更改了文件：%s")\n        editor.events.subscribe("save", emailalerts)\n\n\n\n# 5. 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n * 中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。\n   * 中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。\n   * 有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。\n   * 当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。\n   * 假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。\n\n\n# 6. 案例\n\n使用示例： 观察者模式在 java 代码中很常见， 特别是在 gui 组件中。 它提供了在不与其他对象所属类耦合的情况下对其事件做出反应的方式。\n\n这里是核心 java 程序库中该模式的一些示例：\n\n * java.util.observer/ java.util.observable （极少在真实世界中使用）\n * java.util.eventlistener的所有实现 （几乎广泛存在于 swing 组件中）\n * javax.servlet.http.httpsessionbindinglistener\n * javax.servlet.http.httpsessionattributelistener\n * javax.faces.event.phaselistener\n\n识别方法： 该模式可以通过将对象存储在列表中的订阅方法， 和对于面向该列表中对象的更新方法的调用来识别。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之解释器模式",frontmatter:{title:"设计模式之解释器模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-20T18:44:00.000Z",permalink:"/pages/1e0eff/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/18.%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/18.解释器模式.md",key:"v-cc527b5a",path:"/pages/1e0eff/",headers:[{level:2,title:"1. 简介",slug:"_1-简介",normalizedTitle:"1. 简介",charIndex:17},{level:2,title:"2. 实例",slug:"_2-实例",normalizedTitle:"2. 实例",charIndex:1842},{level:2,title:"3. 场景",slug:"_3-场景",normalizedTitle:"3. 场景",charIndex:1852},{level:2,title:"4. 参考资料",slug:"_4-参考资料",normalizedTitle:"4. 参考资料",charIndex:1862}],headersStr:"1. 简介 2. 实例 3. 场景 4. 参考资料",content:'# 设计模式之解释器模式\n\n\n# 1. 简介\n\n解释器模式 (Interpreter) 定义一个语言，定义它的文法的一种表示。并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n\n解释器模式是一种行为型模式。\n\n\n\nContext : 包含解释器之外的一些全局信息。\n\n\nclass Context {\n    private String input;\n    private String output;\n\n    public void setInput(String input) {\n        this.input = input;\n    }\n\n    public String getInput() {\n        return this.input;\n    }\n\n    public void setOutput(String output) {\n        this.output = output;\n    }\n\n    public String getOutput() {\n        return this.output;\n    }\n}\n\n\nAbstractExpression : 声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。\n\nabstract class AbstractExpression {\n    public abstract void Interpret(Context context);\n}\n\n\nTerminalExpression : 实现与文法中的终结符相关联的解释操作。实现抽象表达式中所要求的接口，主要是一个 Interprete()方法。\n\n文法中的每一个终结符都有一个具体终结表达式与之对应。\n\nclass TerminalExpression extends AbstractExpression {\n    @Override\n    public void Interpret(Context context) {\n        context.setOutput("终端" + context.getInput());\n        System.out.println(context.getInput() + "经过终端解释器解释为：" + context.getOutput());\n    }\n}\n\n\nNonterminalExpression : 实现与文法中的非终结符相关联的解释操作。对文法中的每一条规则 R1，R2......Rn 都需要一个具体的非终结符表达式类。通过实现抽象表达式的 Interpret 方法实现解释操作。\n\nclass NonterminalExpression extends AbstractExpression {\n    @Override\n    public void Interpret(Context context) {\n        context.setOutput("非终端" + context.getInput());\n        System.out.println(context.getInput() + "经过非终端解释器解释为：" + context.getOutput());\n    }\n}\n\n\n客户端\n\npublic class InterpreterPattern {\n    public static void main(String[] args) {\n        Context context = new Context();\n        context.setInput("ABC");\n\n        AbstractExpression expression1 = new TerminalExpression();\n        expression1.Interpret(context);\n\n        AbstractExpression expression2 = new NonterminalExpression();\n        expression2.Interpret(context);\n    }\n}\n\n\n输出\n\nABC经过终端解释器解释为：终端ABC\nABC经过非终端解释器解释为：非终端ABC\n\n\n\n# 2. 实例\n\n\n# 3. 场景\n\n\n# 4. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》',normalizedContent:'# 设计模式之解释器模式\n\n\n# 1. 简介\n\n解释器模式 (interpreter) 定义一个语言，定义它的文法的一种表示。并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n\n解释器模式是一种行为型模式。\n\n\n\ncontext : 包含解释器之外的一些全局信息。\n\n\nclass context {\n    private string input;\n    private string output;\n\n    public void setinput(string input) {\n        this.input = input;\n    }\n\n    public string getinput() {\n        return this.input;\n    }\n\n    public void setoutput(string output) {\n        this.output = output;\n    }\n\n    public string getoutput() {\n        return this.output;\n    }\n}\n\n\nabstractexpression : 声明一个抽象的解释操作，这个接口为抽象语法树中所有的节点所共享。\n\nabstract class abstractexpression {\n    public abstract void interpret(context context);\n}\n\n\nterminalexpression : 实现与文法中的终结符相关联的解释操作。实现抽象表达式中所要求的接口，主要是一个 interprete()方法。\n\n文法中的每一个终结符都有一个具体终结表达式与之对应。\n\nclass terminalexpression extends abstractexpression {\n    @override\n    public void interpret(context context) {\n        context.setoutput("终端" + context.getinput());\n        system.out.println(context.getinput() + "经过终端解释器解释为：" + context.getoutput());\n    }\n}\n\n\nnonterminalexpression : 实现与文法中的非终结符相关联的解释操作。对文法中的每一条规则 r1，r2......rn 都需要一个具体的非终结符表达式类。通过实现抽象表达式的 interpret 方法实现解释操作。\n\nclass nonterminalexpression extends abstractexpression {\n    @override\n    public void interpret(context context) {\n        context.setoutput("非终端" + context.getinput());\n        system.out.println(context.getinput() + "经过非终端解释器解释为：" + context.getoutput());\n    }\n}\n\n\n客户端\n\npublic class interpreterpattern {\n    public static void main(string[] args) {\n        context context = new context();\n        context.setinput("abc");\n\n        abstractexpression expression1 = new terminalexpression();\n        expression1.interpret(context);\n\n        abstractexpression expression2 = new nonterminalexpression();\n        expression2.interpret(context);\n    }\n}\n\n\n输出\n\nabc经过终端解释器解释为：终端abc\nabc经过非终端解释器解释为：非终端abc\n\n\n\n# 2. 实例\n\n\n# 3. 场景\n\n\n# 4. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之中介者模式",frontmatter:{title:"设计模式之中介者模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-22T13:34:00.000Z",permalink:"/pages/b5886f/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19.%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/19.中介者模式.md",key:"v-04ae6228",path:"/pages/b5886f/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:17},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:111},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:255},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:267},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:733},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:3077},{level:2,title:"5. 与其他模式的关系",slug:"_5-与其他模式的关系",normalizedTitle:"5. 与其他模式的关系",charIndex:5142},{level:2,title:"6. 案例",slug:"_6-案例",normalizedTitle:"6. 案例",charIndex:5955},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:6321}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 与其他模式的关系 6. 案例 7. 参考资料",content:'# 设计模式之中介者模式\n\n\n# 1. 意图\n\n中介者模式（Mediator） 是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。\n\n\n# 2. 适用场景\n\n * 当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。\n * 当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。\n * 如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 组件 （Component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。\n 2. 中介者 （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。\n 3. 具体中介者 （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。\n 4. 组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。\n    * 对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。\n\n\n# 3.2. 结构代码范式\n\nMediator : 为 Colleague 对象定义一个交流接口。\n\nabstract class Mediator {\n    public abstract void Send(String message, Colleague colleague);\n}\n\n\nConcreteMediator : 实现 Mediator 中的交流接口。 这个类中需要了解并维护所有的 colleague 对象。\n\nclass ConcreteMediator extends Mediator {\n    private ConcreteColleague1 colleague1;\n    private ConcreteColleague2 colleague2;\n\n    public void setColleague1(ConcreteColleague1 colleague1) {\n        this.colleague1 = colleague1;\n    }\n\n    public void setColleague2(ConcreteColleague2 colleague2) {\n        this.colleague2 = colleague2;\n    }\n\n    @Override\n    public void Send(String message, Colleague colleague) {\n        if (colleague == colleague1) {\n            colleague2.Notify(message);\n        } else if (colleague == colleague2){\n            colleague1.Notify(message);\n        } else {\n            System.out.println("Error!");\n        }\n    }\n}\n\n\nColleague 组 : 每个 Colleague 对象应该知道它的 Mediator 对象，但不知道其他同事对象。它只能联系 Mediator 对象。\n\nabstract class Colleague {\n    protected Mediator mediator;\n\n    public Colleague(Mediator mediator) {\n        this.mediator = mediator;\n    }\n\n    public void Send(String message) {\n        mediator.Send(message, this);\n    }\n\n    public abstract void Notify(String message);\n}\n\nclass ConcreteColleague1 extends Colleague {\n    public ConcreteColleague1(Mediator mediator) {\n        super(mediator);\n    }\n\n    @Override\n    public void Notify(String message) {\n        System.out.println("同事1得到信息：" + message);\n    }\n}\n\nclass ConcreteColleague2 extends Colleague {\n    public ConcreteColleague2(Mediator mediator) {\n        super(mediator);\n    }\n\n    @Override\n    public void Notify(String message) {\n        System.out.println("同事2得到信息：" + message);\n    }\n}\n\n\n客户端\n\npublic class MediatorPattern {\n    public static void main(String[] args) {\n        ConcreteMediator mediator = new ConcreteMediator();\n        ConcreteColleague1 colleague1 = new ConcreteColleague1(mediator);\n        ConcreteColleague2 colleague2 = new ConcreteColleague2(mediator);\n\n        mediator.setColleague1(colleague1);\n        mediator.setColleague2(colleague2);\n\n        colleague1.Send("How are you?");\n        colleague2.Send("Fine, thank you. And you?");\n        colleague1.Send("I\'m fine. Thankes.");\n    }\n}\n\n\n输出\n\n同事2得到信息：How are you?\n同事1得到信息：Fine, thank you. And you?\n同事2得到信息：I\'m fine. Thankes.\n\n\n\n# 4. 伪代码\n\n在本例中， 中介者模式可帮助你减少各种 UI 类 （按钮、 复选框和文本标签） 之间的相互依赖关系。\n\n\n\n用户触发的元素不会直接与其他元素交流， 即使看上去它们应该这样做。 相反， 元素只需让中介者知晓事件即可， 并能在发出通知时同时传递任何上下文信息。\n\n本例中的中介者是整个认证对话框。 对话框知道具体元素应如何进行合作并促进它们的间接交流。 当接收到事件通知后， 对话框会确定负责处理事件的元素并据此重定向请求。\n\n// 中介者接口声明了一个能让组件将各种事件通知给中介者的方法。中介者可对这\n// 些事件做出响应并将执行工作传递给其他组件。\ninterface Mediator is\n    method notify(sender: Component, event: string)\n\n\n// 具体中介者类可解开各组件之间相互交叉的连接关系并将其转移到中介者中。\nclass AuthenticationDialog implements Mediator is\n    private field title: string\n    private field loginOrRegisterChkBx: Checkbox\n    private field loginUsername, loginPassword: Textbox\n    private field registrationUsername, registrationPassword,\n                  registrationEmail: Textbox\n    private field okBtn, cancelBtn: Button\n\n    constructor AuthenticationDialog() is\n        // 创建所有组件对象并将当前中介者传递给其构造函数以建立连接。\n\n    // 当组件中有事件发生时，它会通知中介者。中介者接收到通知后可自行处理，\n    // 也可将请求传递给另一个组件。\n    method notify(sender, event) is\n        if (sender == loginOrRegisterChkBx and event == "check")\n            if (loginOrRegisterChkBx.checked)\n                title = "登录"\n                // 1. 显示登录表单组件。\n                // 2. 隐藏注册表单组件。\n            else\n                title = "注册"\n                // 1. 显示注册表单组件。\n                // 2. 隐藏登录表单组件。\n\n        if (sender == okBtn && event == "click")\n            if (loginOrRegister.checked)\n                // 尝试找到使用登录信息的用户。\n                if (!found)\n                    // 在登录字段上方显示错误信息。\n            else\n                // 1. 使用注册字段中的数据创建用户账号。\n                // 2. 完成用户登录工作。 …\n\n\n// 组件会使用中介者接口与中介者进行交互。因此只需将它们与不同的中介者连接\n// 起来，你就能在其他情境中使用这些组件了。\nclass Component is\n    field dialog: Mediator\n\n    constructor Component(dialog) is\n        this.dialog = dialog\n\n    method click() is\n        dialog.notify(this, "click")\n\n    method keypress() is\n        dialog.notify(this, "keypress")\n\n// 具体组件之间无法进行交流。它们只有一个交流渠道，那就是向中介者发送通知。\nclass Button extends Component is\n    // ...\n\nclass Textbox extends Component is\n    // ...\n\nclass Checkbox extends Component is\n    method check() is\n        dialog.notify(this, "check")\n    // ...\n\n\n\n# 5. 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n * 外观模式和中介者的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。\n   * 外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。\n   * 中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。\n * 中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。\n   * 中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。\n   * 有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。\n   * 当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。\n   * 假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。\n\n\n# 6. 案例\n\n使用示例： 中介者模式在 Java 代码中最常用于帮助程序 GUI 组件之间的通信。 在 MVC 模式中， 控制器是中介者的同义词。\n\n下面是核心 Java 程序库中该模式的一些示例：\n\n * java.util.Timer （所有 schedule­XXX()方法）\n * java.util.concurrent.Executor#execute()\n * java.util.concurrent.ExecutorService （ invoke­XXX()和 submit­()方法）\n * java.util.concurrent.ScheduledExecutorService （所有 schedule­XXX()方法）\n * java.lang.reflect.Method#invoke()\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之中介者模式\n\n\n# 1. 意图\n\n中介者模式（mediator） 是一种行为设计模式， 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。\n\n\n# 2. 适用场景\n\n * 当一些对象和其他对象紧密耦合以致难以对其进行修改时， 可使用中介者模式。\n * 当组件因过于依赖其他组件而无法在不同应用中复用时， 可使用中介者模式。\n * 如果为了能在不同情景下复用一些基本行为， 导致你需要被迫创建大量组件子类时， 可使用中介者模式。\n\n\n# 3. 结构\n\n\n\n\n# 3.1. 结构说明\n\n 1. 组件 （component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。\n 2. 中介者 （mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。\n 3. 具体中介者 （concrete mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。\n 4. 组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。\n    * 对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。\n\n\n# 3.2. 结构代码范式\n\nmediator : 为 colleague 对象定义一个交流接口。\n\nabstract class mediator {\n    public abstract void send(string message, colleague colleague);\n}\n\n\nconcretemediator : 实现 mediator 中的交流接口。 这个类中需要了解并维护所有的 colleague 对象。\n\nclass concretemediator extends mediator {\n    private concretecolleague1 colleague1;\n    private concretecolleague2 colleague2;\n\n    public void setcolleague1(concretecolleague1 colleague1) {\n        this.colleague1 = colleague1;\n    }\n\n    public void setcolleague2(concretecolleague2 colleague2) {\n        this.colleague2 = colleague2;\n    }\n\n    @override\n    public void send(string message, colleague colleague) {\n        if (colleague == colleague1) {\n            colleague2.notify(message);\n        } else if (colleague == colleague2){\n            colleague1.notify(message);\n        } else {\n            system.out.println("error!");\n        }\n    }\n}\n\n\ncolleague 组 : 每个 colleague 对象应该知道它的 mediator 对象，但不知道其他同事对象。它只能联系 mediator 对象。\n\nabstract class colleague {\n    protected mediator mediator;\n\n    public colleague(mediator mediator) {\n        this.mediator = mediator;\n    }\n\n    public void send(string message) {\n        mediator.send(message, this);\n    }\n\n    public abstract void notify(string message);\n}\n\nclass concretecolleague1 extends colleague {\n    public concretecolleague1(mediator mediator) {\n        super(mediator);\n    }\n\n    @override\n    public void notify(string message) {\n        system.out.println("同事1得到信息：" + message);\n    }\n}\n\nclass concretecolleague2 extends colleague {\n    public concretecolleague2(mediator mediator) {\n        super(mediator);\n    }\n\n    @override\n    public void notify(string message) {\n        system.out.println("同事2得到信息：" + message);\n    }\n}\n\n\n客户端\n\npublic class mediatorpattern {\n    public static void main(string[] args) {\n        concretemediator mediator = new concretemediator();\n        concretecolleague1 colleague1 = new concretecolleague1(mediator);\n        concretecolleague2 colleague2 = new concretecolleague2(mediator);\n\n        mediator.setcolleague1(colleague1);\n        mediator.setcolleague2(colleague2);\n\n        colleague1.send("how are you?");\n        colleague2.send("fine, thank you. and you?");\n        colleague1.send("i\'m fine. thankes.");\n    }\n}\n\n\n输出\n\n同事2得到信息：how are you?\n同事1得到信息：fine, thank you. and you?\n同事2得到信息：i\'m fine. thankes.\n\n\n\n# 4. 伪代码\n\n在本例中， 中介者模式可帮助你减少各种 ui 类 （按钮、 复选框和文本标签） 之间的相互依赖关系。\n\n\n\n用户触发的元素不会直接与其他元素交流， 即使看上去它们应该这样做。 相反， 元素只需让中介者知晓事件即可， 并能在发出通知时同时传递任何上下文信息。\n\n本例中的中介者是整个认证对话框。 对话框知道具体元素应如何进行合作并促进它们的间接交流。 当接收到事件通知后， 对话框会确定负责处理事件的元素并据此重定向请求。\n\n// 中介者接口声明了一个能让组件将各种事件通知给中介者的方法。中介者可对这\n// 些事件做出响应并将执行工作传递给其他组件。\ninterface mediator is\n    method notify(sender: component, event: string)\n\n\n// 具体中介者类可解开各组件之间相互交叉的连接关系并将其转移到中介者中。\nclass authenticationdialog implements mediator is\n    private field title: string\n    private field loginorregisterchkbx: checkbox\n    private field loginusername, loginpassword: textbox\n    private field registrationusername, registrationpassword,\n                  registrationemail: textbox\n    private field okbtn, cancelbtn: button\n\n    constructor authenticationdialog() is\n        // 创建所有组件对象并将当前中介者传递给其构造函数以建立连接。\n\n    // 当组件中有事件发生时，它会通知中介者。中介者接收到通知后可自行处理，\n    // 也可将请求传递给另一个组件。\n    method notify(sender, event) is\n        if (sender == loginorregisterchkbx and event == "check")\n            if (loginorregisterchkbx.checked)\n                title = "登录"\n                // 1. 显示登录表单组件。\n                // 2. 隐藏注册表单组件。\n            else\n                title = "注册"\n                // 1. 显示注册表单组件。\n                // 2. 隐藏登录表单组件。\n\n        if (sender == okbtn && event == "click")\n            if (loginorregister.checked)\n                // 尝试找到使用登录信息的用户。\n                if (!found)\n                    // 在登录字段上方显示错误信息。\n            else\n                // 1. 使用注册字段中的数据创建用户账号。\n                // 2. 完成用户登录工作。 …\n\n\n// 组件会使用中介者接口与中介者进行交互。因此只需将它们与不同的中介者连接\n// 起来，你就能在其他情境中使用这些组件了。\nclass component is\n    field dialog: mediator\n\n    constructor component(dialog) is\n        this.dialog = dialog\n\n    method click() is\n        dialog.notify(this, "click")\n\n    method keypress() is\n        dialog.notify(this, "keypress")\n\n// 具体组件之间无法进行交流。它们只有一个交流渠道，那就是向中介者发送通知。\nclass button extends component is\n    // ...\n\nclass textbox extends component is\n    // ...\n\nclass checkbox extends component is\n    method check() is\n        dialog.notify(this, "check")\n    // ...\n\n\n\n# 5. 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n * 外观模式和中介者的职责类似： 它们都尝试在大量紧密耦合的类中组织起合作。\n   * 外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。 子系统本身不会意识到外观的存在。 子系统中的对象可以直接进行交流。\n   * 中介者将系统中组件的沟通行为中心化。 各组件只知道中介者对象， 无法直接相互交流。\n * 中介者和观察者之间的区别往往很难记住。 在大部分情况下， 你可以使用其中一种模式， 而有时可以同时使用。 让我们来看看如何做到这一点。\n   * 中介者的主要目标是消除一系列系统组件之间的相互依赖。 这些组件将依赖于同一个中介者对象。 观察者的目标是在对象之间建立动态的单向连接， 使得部分对象可作为其他对象的附属发挥作用。\n   * 有一种流行的中介者模式实现方式依赖于观察者。 中介者对象担当发布者的角色， 其他组件则作为订阅者， 可以订阅中介者的事件或取消订阅。 当中介者以这种方式实现时， 它可能看上去与观察者非常相似。\n   * 当你感到疑惑时， 记住可以采用其他方式来实现中介者。 例如， 你可永久性地将所有组件链接到同一个中介者对象。 这种实现方式和观察者并不相同， 但这仍是一种中介者模式。\n   * 假设有一个程序， 其所有的组件都变成了发布者， 它们之间可以相互建立动态连接。 这样程序中就没有中心化的中介者对象， 而只有一些分布式的观察者。\n\n\n# 6. 案例\n\n使用示例： 中介者模式在 java 代码中最常用于帮助程序 gui 组件之间的通信。 在 mvc 模式中， 控制器是中介者的同义词。\n\n下面是核心 java 程序库中该模式的一些示例：\n\n * java.util.timer （所有 schedule­xxx()方法）\n * java.util.concurrent.executor#execute()\n * java.util.concurrent.executorservice （ invoke­xxx()和 submit­()方法）\n * java.util.concurrent.scheduledexecutorservice （所有 schedule­xxx()方法）\n * java.lang.reflect.method#invoke()\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之职责链模式",frontmatter:{title:"设计模式之职责链模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-22T14:34:00.000Z",permalink:"/pages/a92964/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/20.%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/20.职责链模式.md",key:"v-1a6137e8",path:"/pages/a92964/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:17},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:202},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:331},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:341},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:814},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:2560},{level:2,title:"5. 与其他模式的关系",slug:"_5-与其他模式的关系",normalizedTitle:"5. 与其他模式的关系",charIndex:4754},{level:2,title:"6. 案例",slug:"_6-案例",normalizedTitle:"6. 案例",charIndex:5330},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:5603}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 与其他模式的关系 6. 案例 7. 参考资料",content:'# 设计模式之职责链模式\n\n\n# 1. 意图\n\n职责链模式（Chain Of Responsibility） 是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。\n\n使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。 将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n\n# 2. 适用场景\n\n * 当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。\n * 当必须按顺序执行多个处理者时， 可以使用该模式。\n * 如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。\n\n\n# 3. 结构\n\n\n# 3.1. 结构说明\n\n\n\n 1. 处理者 （Handler） 声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。\n\n 2. 基础处理者 （Base Handler） 是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。\n    \n    通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。\n\n 3. 具体处理者 （Concrete Handlers） 包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。\n    \n    处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。\n\n 4. 客户端 （Client） 可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的任意一个处理者， 而非必须是第一个处理者。\n\n\n# 3.2. 结构代码范式\n\nHandler : 定义一个处理请求的接口。（可选的）实现设置后继者的方法。\n\nabstract class Handler {\n    protected Handler successor;\n    public void SetSuccesssor(Handler successor) {\n        this.successor = successor;\n    }\n\n    public abstract void HandlerRequest(int request);\n}\n\n\nConcreteHandler : 处理它所负责的请求，可以访问它的后继者，如果可处理该请求，就处理之，否则就将请求转发给它的后继者。\n\nclass ConcreteHandler1 extends Handler {\n    @Override\n    public void HandlerRequest(int request) {\n        if (request >= 0 && request < 10) {\n            System.out.println("ConcreteHandler1 处理请求 " + request);\n        } else if (null != successor) {\n            successor.HandlerRequest(request);\n        }\n    }\n}\n\nclass ConcreteHandler2 extends Handler {\n    @Override\n    public void HandlerRequest(int request) {\n        if (request >= 10 && request < 20) {\n            System.out.println("ConcreteHandler2 处理请求 " + request);\n        } else if (null != successor) {\n            successor.HandlerRequest(request);\n        }\n    }\n}\n\nclass ConcreteHandler3 extends Handler {\n    @Override\n    public void HandlerRequest(int request) {\n        if (request >= 20 && request < 30) {\n            System.out.println("ConcreteHandler3 处理请求 " + request);\n        } else if (null != successor) {\n            successor.HandlerRequest(request);\n        }\n    }\n}\n\n\nClient : 需要设置一个职责链的各环节对象串联起来。\n\npublic class ChainOfResponsibilityPattern {\n    public static void main(String[] args) {\n        Handler h1 = new ConcreteHandler1();\n        Handler h2 = new ConcreteHandler2();\n        Handler h3 = new ConcreteHandler3();\n        h1.SetSuccesssor(h2);\n        h2.SetSuccesssor(h3);\n\n        int[] requests = {2, 29, 9, 15, 4, 19};\n        for (int i : requests) {\n            h1.HandlerRequest(i);\n        }\n    }\n}\n\n\n\n# 4. 伪代码\n\n在本例中， 责任链模式负责为活动的 GUI 元素显示上下文帮助信息。\n\n\n\n应用程序的 GUI 　通常为对象树结构。 例如， 负责渲染程序主窗口的 对话框类就是对象树的根节点。 对话框包含 面板 ， 而面板可能包含其他面板， 或是 按钮和 文本框等下层元素。\n\n只要给一个简单的组件指定帮助文本， 它就可显示简短的上下文提示。 但更复杂的组件可自定义上下文帮助文本的显示方式， 例如显示手册摘录内容或在浏览器中打开一个网页。\n\n\n\n当用户将鼠标指针移动到某个元素并按下 F1键时， 程序检测到指针下的组件并对其发送帮助请求。 该请求不断向上传递到该元素所有的容器， 直至某个元素能够显示帮助信息。\n\n// 处理者接口声明了一个创建处理者链的方法。还声明了一个执行请求的方法。\ninterface ComponentWithContextualHelp is\n    method showHelp()\n\n\n// 简单组件的基础类。\nabstract class Component implements ComponentWithContextualHelp is\n    field tooltipText: string\n\n    // 组件容器在处理者链中作为“下一个”链接。\n    protected field container: Container\n\n    // 如果组件设定了帮助文字，那它将会显示提示信息。如果组件没有帮助文字\n    // 且其容器存在，那它会将调用传递给容器。\n    method showHelp() is\n        if (tooltipText != null)\n            // 显示提示信息。\n        else\n            container.showHelp()\n\n\n// 容器可以将简单组件和其他容器作为其子项目。链关系将在这里建立。该类将从\n// 其父类处继承 showHelp（显示帮助）的行为。\nabstract class Container extends Component is\n    protected field children: array of Component\n\n    method add(child) is\n        children.add(child)\n        child.container = this\n\n\n// 原始组件应该能够使用帮助操作的默认实现...\nclass Button extends Component is\n    // ...\n\n// 但复杂组件可能会对默认实现进行重写。如果无法以新的方式来提供帮助文字，\n// 那组件总是还能调用基础实现的（参见 Component 类）。\nclass Panel extends Container is\n    field modalHelpText: string\n\n    method showHelp() is\n        if (modalHelpText != null)\n            // 显示包含帮助文字的模态窗口。\n        else\n            super.showHelp()\n\n// ...同上...\nclass Dialog extends Container is\n    field wikiPageURL: string\n\n    method showHelp() is\n        if (wikiPageURL != null)\n            // 打开百科帮助页面。\n        else\n            super.showHelp()\n\n\n// 客户端代码。\nclass Application is\n    // 每个程序都能以不同方式对链进行配置。\n    method createUI() is\n        dialog = new Dialog("预算报告")\n        dialog.wikiPageURL = "http://..."\n        panel = new Panel(0, 0, 400, 800)\n        panel.modalHelpText = "本面板用于..."\n        ok = new Button(250, 760, 50, 20, "确认")\n        ok.tooltipText = "这是一个确认按钮..."\n        cancel = new Button(320, 760, 50, 20, "取消")\n        // ...\n        panel.add(ok)\n        panel.add(cancel)\n        dialog.add(panel)\n\n    // 想象这里会发生什么。\n    method onF1KeyPress() is\n        component = this.getComponentAtMouseCoords()\n        component.showHelp()\n\n\n\n# 5. 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   \n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n\n * 责任链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。\n\n * 责任链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。\n   \n   还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。\n\n * 责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。\n   \n   责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。\n\n\n# 6. 案例\n\n使用示例： 责任链模式在 Java 程序中并不常见， 因为它仅在代码与对象链打交道时才能发挥作用。\n\n该模式最流行的使用案例之一是在 GUI 类中将事件向上传递给父组件。 另一个值得注意的使用案例是依次访问过滤器。\n\n下面是该模式在核心 Java 程序库中的一些示例：\n\n * javax.servlet.Filter#doFilter()\n * java.util.logging.Logger#log()\n\n识别方法： 该模式可通过一组对象的行为方法间接调用其他对象的相同方法来识别， 而且所有对象都会遵循相同的接口。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之职责链模式\n\n\n# 1. 意图\n\n职责链模式（chain of responsibility） 是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。\n\n使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。 将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。\n\n\n# 2. 适用场景\n\n * 当程序需要使用不同方式处理不同种类请求， 而且请求类型和顺序预先未知时， 可以使用责任链模式。\n * 当必须按顺序执行多个处理者时， 可以使用该模式。\n * 如果所需处理者及其顺序必须在运行时进行改变， 可以使用责任链模式。\n\n\n# 3. 结构\n\n\n# 3.1. 结构说明\n\n\n\n 1. 处理者 （handler） 声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。\n\n 2. 基础处理者 （base handler） 是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。\n    \n    通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。\n\n 3. 具体处理者 （concrete handlers） 包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。\n    \n    处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。\n\n 4. 客户端 （client） 可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的任意一个处理者， 而非必须是第一个处理者。\n\n\n# 3.2. 结构代码范式\n\nhandler : 定义一个处理请求的接口。（可选的）实现设置后继者的方法。\n\nabstract class handler {\n    protected handler successor;\n    public void setsuccesssor(handler successor) {\n        this.successor = successor;\n    }\n\n    public abstract void handlerrequest(int request);\n}\n\n\nconcretehandler : 处理它所负责的请求，可以访问它的后继者，如果可处理该请求，就处理之，否则就将请求转发给它的后继者。\n\nclass concretehandler1 extends handler {\n    @override\n    public void handlerrequest(int request) {\n        if (request >= 0 && request < 10) {\n            system.out.println("concretehandler1 处理请求 " + request);\n        } else if (null != successor) {\n            successor.handlerrequest(request);\n        }\n    }\n}\n\nclass concretehandler2 extends handler {\n    @override\n    public void handlerrequest(int request) {\n        if (request >= 10 && request < 20) {\n            system.out.println("concretehandler2 处理请求 " + request);\n        } else if (null != successor) {\n            successor.handlerrequest(request);\n        }\n    }\n}\n\nclass concretehandler3 extends handler {\n    @override\n    public void handlerrequest(int request) {\n        if (request >= 20 && request < 30) {\n            system.out.println("concretehandler3 处理请求 " + request);\n        } else if (null != successor) {\n            successor.handlerrequest(request);\n        }\n    }\n}\n\n\nclient : 需要设置一个职责链的各环节对象串联起来。\n\npublic class chainofresponsibilitypattern {\n    public static void main(string[] args) {\n        handler h1 = new concretehandler1();\n        handler h2 = new concretehandler2();\n        handler h3 = new concretehandler3();\n        h1.setsuccesssor(h2);\n        h2.setsuccesssor(h3);\n\n        int[] requests = {2, 29, 9, 15, 4, 19};\n        for (int i : requests) {\n            h1.handlerrequest(i);\n        }\n    }\n}\n\n\n\n# 4. 伪代码\n\n在本例中， 责任链模式负责为活动的 gui 元素显示上下文帮助信息。\n\n\n\n应用程序的 gui 　通常为对象树结构。 例如， 负责渲染程序主窗口的 对话框类就是对象树的根节点。 对话框包含 面板 ， 而面板可能包含其他面板， 或是 按钮和 文本框等下层元素。\n\n只要给一个简单的组件指定帮助文本， 它就可显示简短的上下文提示。 但更复杂的组件可自定义上下文帮助文本的显示方式， 例如显示手册摘录内容或在浏览器中打开一个网页。\n\n\n\n当用户将鼠标指针移动到某个元素并按下 f1键时， 程序检测到指针下的组件并对其发送帮助请求。 该请求不断向上传递到该元素所有的容器， 直至某个元素能够显示帮助信息。\n\n// 处理者接口声明了一个创建处理者链的方法。还声明了一个执行请求的方法。\ninterface componentwithcontextualhelp is\n    method showhelp()\n\n\n// 简单组件的基础类。\nabstract class component implements componentwithcontextualhelp is\n    field tooltiptext: string\n\n    // 组件容器在处理者链中作为“下一个”链接。\n    protected field container: container\n\n    // 如果组件设定了帮助文字，那它将会显示提示信息。如果组件没有帮助文字\n    // 且其容器存在，那它会将调用传递给容器。\n    method showhelp() is\n        if (tooltiptext != null)\n            // 显示提示信息。\n        else\n            container.showhelp()\n\n\n// 容器可以将简单组件和其他容器作为其子项目。链关系将在这里建立。该类将从\n// 其父类处继承 showhelp（显示帮助）的行为。\nabstract class container extends component is\n    protected field children: array of component\n\n    method add(child) is\n        children.add(child)\n        child.container = this\n\n\n// 原始组件应该能够使用帮助操作的默认实现...\nclass button extends component is\n    // ...\n\n// 但复杂组件可能会对默认实现进行重写。如果无法以新的方式来提供帮助文字，\n// 那组件总是还能调用基础实现的（参见 component 类）。\nclass panel extends container is\n    field modalhelptext: string\n\n    method showhelp() is\n        if (modalhelptext != null)\n            // 显示包含帮助文字的模态窗口。\n        else\n            super.showhelp()\n\n// ...同上...\nclass dialog extends container is\n    field wikipageurl: string\n\n    method showhelp() is\n        if (wikipageurl != null)\n            // 打开百科帮助页面。\n        else\n            super.showhelp()\n\n\n// 客户端代码。\nclass application is\n    // 每个程序都能以不同方式对链进行配置。\n    method createui() is\n        dialog = new dialog("预算报告")\n        dialog.wikipageurl = "http://..."\n        panel = new panel(0, 0, 400, 800)\n        panel.modalhelptext = "本面板用于..."\n        ok = new button(250, 760, 50, 20, "确认")\n        ok.tooltiptext = "这是一个确认按钮..."\n        cancel = new button(320, 760, 50, 20, "取消")\n        // ...\n        panel.add(ok)\n        panel.add(cancel)\n        dialog.add(panel)\n\n    // 想象这里会发生什么。\n    method onf1keypress() is\n        component = this.getcomponentatmousecoords()\n        component.showhelp()\n\n\n\n# 5. 与其他模式的关系\n\n * 责任链模式、 命令模式、 中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式：\n   \n   * 责任链按照顺序将请求动态传递给一系列的潜在接收者， 直至其中一名接收者对请求进行处理。\n   * 命令在发送者和请求者之间建立单向连接。\n   * 中介者清除了发送者和请求者之间的直接连接， 强制它们通过一个中介对象进行间接沟通。\n   * 观察者允许接收者动态地订阅或取消接收请求。\n\n * 责任链通常和组合模式结合使用。 在这种情况下， 叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。\n\n * 责任链的管理者可使用命令模式实现。 在这种情况下， 你可以对由请求代表的同一个上下文对象执行许多不同的操作。\n   \n   还有另外一种实现方式， 那就是请求自身就是一个命令对象。 在这种情况下， 你可以对由一系列不同上下文连接而成的链执行相同的操作。\n\n * 责任链和装饰模式的类结构非常相似。 两者都依赖递归组合将需要执行的操作传递给一系列对象。 但是， 两者有几点重要的不同之处。\n   \n   责任链的管理者可以相互独立地执行一切操作， 还可以随时停止传递请求。 另一方面， 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 此外， 装饰无法中断请求的传递。\n\n\n# 6. 案例\n\n使用示例： 责任链模式在 java 程序中并不常见， 因为它仅在代码与对象链打交道时才能发挥作用。\n\n该模式最流行的使用案例之一是在 gui 类中将事件向上传递给父组件。 另一个值得注意的使用案例是依次访问过滤器。\n\n下面是该模式在核心 java 程序库中的一些示例：\n\n * javax.servlet.filter#dofilter()\n * java.util.logging.logger#log()\n\n识别方法： 该模式可通过一组对象的行为方法间接调用其他对象的相同方法来识别， 而且所有对象都会遵循相同的接口。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之备忘录模式",frontmatter:{title:"设计模式之备忘录模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-22T15:26:00.000Z",permalink:"/pages/e3cd5d/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/21.%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/21.备忘录模式.md",key:"v-ca584e06",path:"/pages/e3cd5d/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:17},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:84},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:179},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:189},{level:4,title:"基于嵌套类的实现",slug:"基于嵌套类的实现",normalizedTitle:"基于嵌套类的实现",charIndex:202},{level:4,title:"基于中间接口的实现",slug:"基于中间接口的实现",normalizedTitle:"基于中间接口的实现",charIndex:628},{level:4,title:"封装更加严格的实现",slug:"封装更加严格的实现",normalizedTitle:"封装更加严格的实现",charIndex:848},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:1145},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:2696},{level:2,title:"5. 与其他模式的关系",slug:"_5-与其他模式的关系",normalizedTitle:"5. 与其他模式的关系",charIndex:4360},{level:2,title:"6. 案例",slug:"_6-案例",normalizedTitle:"6. 案例",charIndex:4582},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:4808}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 基于嵌套类的实现 基于中间接口的实现 封装更加严格的实现 3.2. 结构代码范式 4. 伪代码 5. 与其他模式的关系 6. 案例 7. 参考资料",content:'# 设计模式之备忘录模式\n\n\n# 1. 意图\n\n备忘录模式（Memento） 是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。\n\n\n# 2. 适用场景\n\n * 当你需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。\n * 当直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。\n\n\n# 3. 结构\n\n\n# 3.1. 结构说明\n\n# 基于嵌套类的实现\n\n\n\n 1. 原发器 （Originator） 类可以生成自身状态的快照， 也可以在需要时通过快照恢复自身状态。\n\n 2. 备忘录 （Memento） 是原发器状态快照的值对象 （value object）。 通常做法是将备忘录设为不可变的， 并通过构造函数一次性传递数据。\n\n 3. 负责人 （Caretaker） 仅知道 “何时” 和 “为何” 捕捉原发器的状态， 以及何时恢复状态。\n    \n    负责人通过保存备忘录栈来记录原发器的历史状态。 当原发器需要回溯历史状态时， 负责人将从栈中获取最顶部的备忘录， 并将其传递给原发器的恢复 （restoration） 方法。\n\n 4. 在该实现方法中， 备忘录类将被嵌套在原发器中。 这样原发器就可访问备忘录的成员变量和方法， 即使这些方法被声明为私有。 另一方面， 负责人对于备忘录的成员变量和方法的访问权限非常有限： 它们只能在栈中保存备忘录， 而不能修改其状态。\n\n# 基于中间接口的实现\n\n另外一种实现方法适用于不支持嵌套类的编程语言 （没错， 我说的就是 PHP）。\n\n\n\n 1. 在没有嵌套类的情况下， 你可以规定负责人仅可通过明确声明的中间接口与备忘录互动， 该接口仅声明与备忘录元数据相关的方法， 限制其对备忘录成员变量的直接访问权限。\n 2. 另一方面， 原发器可以直接与备忘录对象进行交互， 访问备忘录类中声明的成员变量和方法。 这种方式的缺点在于你需要将备忘录的所有成员变量声明为公有。\n\n# 封装更加严格的实现\n\n如果你不想让其他类有任何机会通过备忘录来访问原发器的状态， 那么还有另一种可用的实现方式。\n\n\n\n 1. 这种实现方式允许存在多种不同类型的原发器和备忘录。 每种原发器都和其相应的备忘录类进行交互。 原发器和备忘录都不会将其状态暴露给其他类。\n 2. 负责人此时被明确禁止修改存储在备忘录中的状态。 但负责人类将独立于原发器， 因为此时恢复方法被定义在了备忘录类中。\n 3. 每个备忘录将与创建了自身的原发器连接。 原发器会将自己及状态传递给备忘录的构造函数。 由于这些类之间的紧密联系， 只要原发器定义了合适的设置器 （setter）， 备忘录就能恢复其状态。\n\n\n# 3.2. 结构代码范式\n\nMemento : 负责存储 Originator 对象的内部状态，并可以防止 Originator 以外的其他对象访问 Memento。\n\nMemento 有两个接口，Caretaker 只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。 Originator 可以看到一个宽接口，允许它访问返回到先前状态所需的所有数据。\n\nclass Memento {\n    private String state;\n    public Memento(String state) {\n        this.state = state;\n    }\n\n    public String GetState() {\n        return state;\n    }\n}\n\n\nOriginator : 负责创建一个备忘录 Memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。\n\nOriginator 可根据需要决定 Memento 存储 Originator 的哪些内部状态。\n\nclass Originator {\n    private String state;\n\n    public void SetState(String state) {\n        this.state = state;\n    }\n    public String GetState() {\n        return state;\n    }\n\n    public Memento CreateMemento() {\n        return (new Memento(state));\n    }\n\n    public void SetMemento(Memento memento) {\n        state = memento.GetState();\n    }\n\n    public void Show() {\n        System.out.println("State = " + state);\n    }\n}\n\n\nCaretaker : 负责保存好备忘录 Memento，不能对备忘录的内容进行操作或检查。\n\nclass Caretaker {\n    private Memento memento;\n\n    public void SetMemento(Memento memento) {\n        this.memento = memento;\n    }\n    public Memento GetMemento() {\n        return memento;\n    }\n}\n\n\n客户端\n\npublic class MementoPattern {\n    public static void main(String[] args) {\n        Originator o = new Originator();\n        o.SetState("ON");\n        o.Show();\n\n        Caretaker c = new Caretaker();\n        c.SetMemento(o.CreateMemento());\n\n        o.SetState("OFF");\n        o.Show();\n\n        o.SetMemento(c.GetMemento());\n        o.Show();\n    }\n}\n\n\n输出\n\nState = ON\nState = OFF\nState = ON\n\n\n\n# 4. 伪代码\n\n本例结合使用了命令模式与备忘录模式， 可保存复杂文字编辑器的状态快照， 并能在需要时从快照中恢复之前的状态。\n\n\n\n命令 （command） 对象将作为负责人， 它们会在执行与命令相关的操作前获取编辑器的备忘录。 当用户试图撤销最近的命令时， 编辑器可以使用保存在命令中的备忘录来将自身回滚到之前的状态。\n\n备忘录类没有声明任何公有的成员变量、 获取器 （getter） 和设置器， 因此没有对象可以修改其内容。 备忘录与创建自己的编辑器相连接， 这使得备忘录能够通过编辑器对象的设置器传递数据， 恢复与其相连接的编辑器的状态。 由于备忘录与特定的编辑器对象相连接， 程序可以使用中心化的撤销栈实现对多个独立编辑器窗口的支持。\n\n// 原发器中包含了一些可能会随时间变化的重要数据。它还定义了在备忘录中保存\n// 自身状态的方法，以及从备忘录中恢复状态的方法。\nclass Editor is\n    private field text, curX, curY, selectionWidth\n\n    method setText(text) is\n        this.text = text\n\n    method setCursor(x, y) is\n        this.curX = curX\n        this.curY = curY\n\n    method setSelectionWidth(width) is\n        this.selectionWidth = width\n\n    // 在备忘录中保存当前的状态。\n    method createSnapshot():Snapshot is\n        // 备忘录是不可变的对象；因此原发器会将自身状态作为参数传递给备忘\n        // 录的构造函数。\n        return new Snapshot(this, text, curX, curY, selectionWidth)\n\n// 备忘录类保存有编辑器的过往状态。\nclass Snapshot is\n    private field editor: Editor\n    private field text, curX, curY, selectionWidth\n\n    constructor Snapshot(editor, text, curX, curY, selectionWidth) is\n        this.editor = editor\n        this.text = text\n        this.curX = curX\n        this.curY = curY\n        this.selectionWidth = selectionWidth\n\n    // 在某一时刻，编辑器之前的状态可以使用备忘录对象来恢复。\n    method restore() is\n        editor.setText(text)\n        editor.setCursor(curX, curY)\n        editor.setSelectionWidth(selectionWidth)\n\n// 命令对象可作为负责人。在这种情况下，命令会在修改原发器状态之前获取一个\n// 备忘录。当需要撤销时，它会从备忘录中恢复原发器的状态。\nclass Command is\n    private field backup: Snapshot\n\n    method makeBackup() is\n        backup = editor.createSnapshot()\n\n    method undo() is\n        if (backup != null)\n            backup.restore()\n    // ...\n\n\n\n# 5. 与其他模式的关系\n\n * 你可以同时使用命令模式和备忘录模式来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。\n * 你可以同时使用备忘录和迭代器模式来获取当前迭代器的状态， 并且在需要的时候进行回滚。\n * 有时候原型模式可以作为备忘录的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。\n\n\n# 6. 案例\n\n使用示例： 备忘录的基本原则可通过序列化来实现， 这在 Java 语言中很常见。 尽管备忘录不是生成对象状态快照的唯一或最有效方法， 但它能在保护原始对象的结构不暴露给其他对象的情况下保存对象状态的备份。\n\n下面是核心 Java 程序库中该模式的一些示例：\n\n * 所有 java.io.Serializable 的实现都可以模拟备忘录。\n * 所有 javax.faces.component.StateHolder 的实现。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之备忘录模式\n\n\n# 1. 意图\n\n备忘录模式（memento） 是一种行为设计模式， 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。\n\n\n# 2. 适用场景\n\n * 当你需要创建对象状态快照来恢复其之前的状态时， 可以使用备忘录模式。\n * 当直接访问对象的成员变量、 获取器或设置器将导致封装被突破时， 可以使用该模式。\n\n\n# 3. 结构\n\n\n# 3.1. 结构说明\n\n# 基于嵌套类的实现\n\n\n\n 1. 原发器 （originator） 类可以生成自身状态的快照， 也可以在需要时通过快照恢复自身状态。\n\n 2. 备忘录 （memento） 是原发器状态快照的值对象 （value object）。 通常做法是将备忘录设为不可变的， 并通过构造函数一次性传递数据。\n\n 3. 负责人 （caretaker） 仅知道 “何时” 和 “为何” 捕捉原发器的状态， 以及何时恢复状态。\n    \n    负责人通过保存备忘录栈来记录原发器的历史状态。 当原发器需要回溯历史状态时， 负责人将从栈中获取最顶部的备忘录， 并将其传递给原发器的恢复 （restoration） 方法。\n\n 4. 在该实现方法中， 备忘录类将被嵌套在原发器中。 这样原发器就可访问备忘录的成员变量和方法， 即使这些方法被声明为私有。 另一方面， 负责人对于备忘录的成员变量和方法的访问权限非常有限： 它们只能在栈中保存备忘录， 而不能修改其状态。\n\n# 基于中间接口的实现\n\n另外一种实现方法适用于不支持嵌套类的编程语言 （没错， 我说的就是 php）。\n\n\n\n 1. 在没有嵌套类的情况下， 你可以规定负责人仅可通过明确声明的中间接口与备忘录互动， 该接口仅声明与备忘录元数据相关的方法， 限制其对备忘录成员变量的直接访问权限。\n 2. 另一方面， 原发器可以直接与备忘录对象进行交互， 访问备忘录类中声明的成员变量和方法。 这种方式的缺点在于你需要将备忘录的所有成员变量声明为公有。\n\n# 封装更加严格的实现\n\n如果你不想让其他类有任何机会通过备忘录来访问原发器的状态， 那么还有另一种可用的实现方式。\n\n\n\n 1. 这种实现方式允许存在多种不同类型的原发器和备忘录。 每种原发器都和其相应的备忘录类进行交互。 原发器和备忘录都不会将其状态暴露给其他类。\n 2. 负责人此时被明确禁止修改存储在备忘录中的状态。 但负责人类将独立于原发器， 因为此时恢复方法被定义在了备忘录类中。\n 3. 每个备忘录将与创建了自身的原发器连接。 原发器会将自己及状态传递给备忘录的构造函数。 由于这些类之间的紧密联系， 只要原发器定义了合适的设置器 （setter）， 备忘录就能恢复其状态。\n\n\n# 3.2. 结构代码范式\n\nmemento : 负责存储 originator 对象的内部状态，并可以防止 originator 以外的其他对象访问 memento。\n\nmemento 有两个接口，caretaker 只能看到备忘录的窄接口，它只能将备忘录传递给其他对象。 originator 可以看到一个宽接口，允许它访问返回到先前状态所需的所有数据。\n\nclass memento {\n    private string state;\n    public memento(string state) {\n        this.state = state;\n    }\n\n    public string getstate() {\n        return state;\n    }\n}\n\n\noriginator : 负责创建一个备忘录 memento，用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态。\n\noriginator 可根据需要决定 memento 存储 originator 的哪些内部状态。\n\nclass originator {\n    private string state;\n\n    public void setstate(string state) {\n        this.state = state;\n    }\n    public string getstate() {\n        return state;\n    }\n\n    public memento creatememento() {\n        return (new memento(state));\n    }\n\n    public void setmemento(memento memento) {\n        state = memento.getstate();\n    }\n\n    public void show() {\n        system.out.println("state = " + state);\n    }\n}\n\n\ncaretaker : 负责保存好备忘录 memento，不能对备忘录的内容进行操作或检查。\n\nclass caretaker {\n    private memento memento;\n\n    public void setmemento(memento memento) {\n        this.memento = memento;\n    }\n    public memento getmemento() {\n        return memento;\n    }\n}\n\n\n客户端\n\npublic class mementopattern {\n    public static void main(string[] args) {\n        originator o = new originator();\n        o.setstate("on");\n        o.show();\n\n        caretaker c = new caretaker();\n        c.setmemento(o.creatememento());\n\n        o.setstate("off");\n        o.show();\n\n        o.setmemento(c.getmemento());\n        o.show();\n    }\n}\n\n\n输出\n\nstate = on\nstate = off\nstate = on\n\n\n\n# 4. 伪代码\n\n本例结合使用了命令模式与备忘录模式， 可保存复杂文字编辑器的状态快照， 并能在需要时从快照中恢复之前的状态。\n\n\n\n命令 （command） 对象将作为负责人， 它们会在执行与命令相关的操作前获取编辑器的备忘录。 当用户试图撤销最近的命令时， 编辑器可以使用保存在命令中的备忘录来将自身回滚到之前的状态。\n\n备忘录类没有声明任何公有的成员变量、 获取器 （getter） 和设置器， 因此没有对象可以修改其内容。 备忘录与创建自己的编辑器相连接， 这使得备忘录能够通过编辑器对象的设置器传递数据， 恢复与其相连接的编辑器的状态。 由于备忘录与特定的编辑器对象相连接， 程序可以使用中心化的撤销栈实现对多个独立编辑器窗口的支持。\n\n// 原发器中包含了一些可能会随时间变化的重要数据。它还定义了在备忘录中保存\n// 自身状态的方法，以及从备忘录中恢复状态的方法。\nclass editor is\n    private field text, curx, cury, selectionwidth\n\n    method settext(text) is\n        this.text = text\n\n    method setcursor(x, y) is\n        this.curx = curx\n        this.cury = cury\n\n    method setselectionwidth(width) is\n        this.selectionwidth = width\n\n    // 在备忘录中保存当前的状态。\n    method createsnapshot():snapshot is\n        // 备忘录是不可变的对象；因此原发器会将自身状态作为参数传递给备忘\n        // 录的构造函数。\n        return new snapshot(this, text, curx, cury, selectionwidth)\n\n// 备忘录类保存有编辑器的过往状态。\nclass snapshot is\n    private field editor: editor\n    private field text, curx, cury, selectionwidth\n\n    constructor snapshot(editor, text, curx, cury, selectionwidth) is\n        this.editor = editor\n        this.text = text\n        this.curx = curx\n        this.cury = cury\n        this.selectionwidth = selectionwidth\n\n    // 在某一时刻，编辑器之前的状态可以使用备忘录对象来恢复。\n    method restore() is\n        editor.settext(text)\n        editor.setcursor(curx, cury)\n        editor.setselectionwidth(selectionwidth)\n\n// 命令对象可作为负责人。在这种情况下，命令会在修改原发器状态之前获取一个\n// 备忘录。当需要撤销时，它会从备忘录中恢复原发器的状态。\nclass command is\n    private field backup: snapshot\n\n    method makebackup() is\n        backup = editor.createsnapshot()\n\n    method undo() is\n        if (backup != null)\n            backup.restore()\n    // ...\n\n\n\n# 5. 与其他模式的关系\n\n * 你可以同时使用命令模式和备忘录模式来实现 “撤销”。 在这种情况下， 命令用于对目标对象执行各种不同的操作， 备忘录用来保存一条命令执行前该对象的状态。\n * 你可以同时使用备忘录和迭代器模式来获取当前迭代器的状态， 并且在需要的时候进行回滚。\n * 有时候原型模式可以作为备忘录的一个简化版本， 其条件是你需要在历史记录中存储的对象的状态比较简单， 不需要链接其他外部资源， 或者链接可以方便地重建。\n\n\n# 6. 案例\n\n使用示例： 备忘录的基本原则可通过序列化来实现， 这在 java 语言中很常见。 尽管备忘录不是生成对象状态快照的唯一或最有效方法， 但它能在保护原始对象的结构不暴露给其他对象的情况下保存对象状态的备份。\n\n下面是核心 java 程序库中该模式的一些示例：\n\n * 所有 java.io.serializable 的实现都可以模拟备忘录。\n * 所有 javax.faces.component.stateholder 的实现。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之策略模式",frontmatter:{title:"设计模式之策略模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-22T16:14:00.000Z",permalink:"/pages/e5bb92/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/22.%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/22.策略模式.md",key:"v-f0251290",path:"/pages/e5bb92/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:16},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:98},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:285},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:295},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:598},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:1941},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:3415},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:3830},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:4475}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 案例 6. 与其他模式的关系 7. 参考资料",content:'# 设计模式之策略模式\n\n\n# 1. 意图\n\n策略模式（Strategy） 是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。\n\n\n# 2. 适用场景\n\n * 当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。\n * 当你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。\n * 如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。\n * 当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。\n\n\n# 3. 结构\n\n\n# 3.1. 结构说明\n\n\n\n 1. 上下文 （Context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。\n 2. 策略 （Strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。\n 3. 具体策略 （Concrete Strategies） 实现了上下文所用算法的各种不同变体。\n 4. 当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。\n 5. 客户端 （Client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。\n\n\n# 3.2. 结构代码范式\n\nStrategy : 定义所有算法的公共接口(AlgorithmInterface)。Context 使用这个接口去调用 ConcreteStrategy 定义的具体算法。\n\nabstract class Strategy {\n    public abstract void AlgorithmInterface();\n}\n\n\nConcreteStrategy : 实现 Strategy 中的算法接口(AlgorithmInterface)。\n\nclass ConcreteStrategyA extends Strategy {\n    @Override\n    public void AlgorithmInterface() {\n        System.out.println("算法A");\n    }\n}\n\nclass ConcreteStrategyB extends Strategy {\n    @Override\n    public void AlgorithmInterface() {\n        System.out.println("算法B");\n    }\n}\n\nclass ConcreteStrategyC extends Strategy {\n    @Override\n    public void AlgorithmInterface() {\n        System.out.println("算法C");\n    }\n}\n\n\nContext : 用一个 ConcreteStrategy 来配置。维护一个对 Strategy 对象的引用。\n\nclass Context {\n    Strategy strategy;\n    public Context(Strategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void ContextInterface() {\n        strategy.AlgorithmInterface();\n    }\n}\n\n\n客户端\n\npublic class StrategyPattern {\n    public static void main(String[] args) {\n        Context context1 = new Context(new ConcreteStrategyA());\n        context1.ContextInterface();\n\n        Context context2 = new Context(new ConcreteStrategyB());\n        context2.ContextInterface();\n\n        Context context3 = new Context(new ConcreteStrategyC());\n        context3.ContextInterface();\n    }\n}\n\n\n输出\n\n算法A\n算法B\n算法C\n\n\n\n# 4. 伪代码\n\n在本例中， 上下文使用了多个策略来执行不同的计算操作。\n\n// 策略接口声明了某个算法各个不同版本间所共有的操作。上下文会使用该接口来\n// 调用有具体策略定义的算法。\ninterface Strategy is\n    method execute(a, b)\n\n// 具体策略会在遵循策略基础接口的情况下实现算法。该接口实现了它们在上下文\n// 中的互换性。\nclass ConcreteStrategyAdd implements Strategy is\n    method execute(a, b) is\n        return a + b\n\nclass ConcreteStrategySubtract implements Strategy is\n    method execute(a, b) is\n        return a - b\n\nclass ConcreteStrategyMultiply implements Strategy is\n    method execute(a, b) is\n        return a * b\n\n// 上下文定义了客户端关注的接口。\nclass Context is\n    // 上下文会维护指向某个策略对象的引用。上下文不知晓策略的具体类。上下\n    // 文必须通过策略接口来与所有策略进行交互。\n    private strategy: Strategy\n\n    // 上下文通常会通过构造函数来接收策略对象，同时还提供设置器以便在运行\n    // 时切换策略。\n    method setStrategy(Strategy strategy) is\n        this.strategy = strategy\n\n    // 上下文会将一些工作委派给策略对象，而不是自行实现不同版本的算法。\n    method executeStrategy(int a, int b) is\n        return strategy.execute(a, b)\n\n\n// 客户端代码会选择具体策略并将其传递给上下文。客户端必须知晓策略之间的差\n// 异，才能做出正确的选择。\nclass ExampleApplication is\n    method main() is\n\n        创建上下文对象。\n\n        读取第一个数。\n        读取最后一个数。\n        从用户输入中读取期望进行的行为。\n\n        if (action == addition) then\n            context.setStrategy(new ConcreteStrategyAdd())\n\n        if (action == subtraction) then\n            context.setStrategy(new ConcreteStrategySubtract())\n\n        if (action == multiplication) then\n            context.setStrategy(new ConcreteStrategyMultiply())\n\n        result = context.executeStrategy(First number, Second number)\n\n        打印结果。\n\n\n\n# 5. 案例\n\n使用示例： 策略模式在 Java 代码中很常见。 它经常在各种框架中使用， 能在不扩展类的情况下向用户提供改变其行为的方式。\n\nJava 8 开始支持 lambda 方法， 它可作为一种替代策略模式的简单方式。\n\n这里有一些核心 Java 程序库中策略模式的示例：\n\n * 对 java.util.Comparator#compare() 的调用来自 Collections#sort().\n * javax.servlet.http.HttpServlet： service­()方法， 还有所有接受 Http­Servlet­Request和 Http­Servlet­Response对象作为参数的 do­XXX()方法。\n * javax.servlet.Filter#doFilter()\n\n识别方法： 策略模式可以通过允许嵌套对象完成实际工作的方法以及允许将该对象替换为不同对象的设置器来识别。\n\n\n# 6. 与其他模式的关系\n\n * 桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 命令模式和策略看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。\n   * 你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。\n   * 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。\n * 装饰模式可让你更改对象的外表， 策略则让你能够改变其本质。\n * 模板方法模式基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。\n * 状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之策略模式\n\n\n# 1. 意图\n\n策略模式（strategy） 是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。\n\n\n# 2. 适用场景\n\n * 当你想使用对象中各种不同的算法变体， 并希望能在运行时切换算法时， 可使用策略模式。\n * 当你有许多仅在执行某些行为时略有不同的相似类时， 可使用策略模式。\n * 如果算法在上下文的逻辑中不是特别重要， 使用该模式能将类的业务逻辑与其算法实现细节隔离开来。\n * 当类中使用了复杂条件运算符以在同一算法的不同变体中切换时， 可使用该模式。\n\n\n# 3. 结构\n\n\n# 3.1. 结构说明\n\n\n\n 1. 上下文 （context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。\n 2. 策略 （strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。\n 3. 具体策略 （concrete strategies） 实现了上下文所用算法的各种不同变体。\n 4. 当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。\n 5. 客户端 （client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。\n\n\n# 3.2. 结构代码范式\n\nstrategy : 定义所有算法的公共接口(algorithminterface)。context 使用这个接口去调用 concretestrategy 定义的具体算法。\n\nabstract class strategy {\n    public abstract void algorithminterface();\n}\n\n\nconcretestrategy : 实现 strategy 中的算法接口(algorithminterface)。\n\nclass concretestrategya extends strategy {\n    @override\n    public void algorithminterface() {\n        system.out.println("算法a");\n    }\n}\n\nclass concretestrategyb extends strategy {\n    @override\n    public void algorithminterface() {\n        system.out.println("算法b");\n    }\n}\n\nclass concretestrategyc extends strategy {\n    @override\n    public void algorithminterface() {\n        system.out.println("算法c");\n    }\n}\n\n\ncontext : 用一个 concretestrategy 来配置。维护一个对 strategy 对象的引用。\n\nclass context {\n    strategy strategy;\n    public context(strategy strategy) {\n        this.strategy = strategy;\n    }\n\n    public void contextinterface() {\n        strategy.algorithminterface();\n    }\n}\n\n\n客户端\n\npublic class strategypattern {\n    public static void main(string[] args) {\n        context context1 = new context(new concretestrategya());\n        context1.contextinterface();\n\n        context context2 = new context(new concretestrategyb());\n        context2.contextinterface();\n\n        context context3 = new context(new concretestrategyc());\n        context3.contextinterface();\n    }\n}\n\n\n输出\n\n算法a\n算法b\n算法c\n\n\n\n# 4. 伪代码\n\n在本例中， 上下文使用了多个策略来执行不同的计算操作。\n\n// 策略接口声明了某个算法各个不同版本间所共有的操作。上下文会使用该接口来\n// 调用有具体策略定义的算法。\ninterface strategy is\n    method execute(a, b)\n\n// 具体策略会在遵循策略基础接口的情况下实现算法。该接口实现了它们在上下文\n// 中的互换性。\nclass concretestrategyadd implements strategy is\n    method execute(a, b) is\n        return a + b\n\nclass concretestrategysubtract implements strategy is\n    method execute(a, b) is\n        return a - b\n\nclass concretestrategymultiply implements strategy is\n    method execute(a, b) is\n        return a * b\n\n// 上下文定义了客户端关注的接口。\nclass context is\n    // 上下文会维护指向某个策略对象的引用。上下文不知晓策略的具体类。上下\n    // 文必须通过策略接口来与所有策略进行交互。\n    private strategy: strategy\n\n    // 上下文通常会通过构造函数来接收策略对象，同时还提供设置器以便在运行\n    // 时切换策略。\n    method setstrategy(strategy strategy) is\n        this.strategy = strategy\n\n    // 上下文会将一些工作委派给策略对象，而不是自行实现不同版本的算法。\n    method executestrategy(int a, int b) is\n        return strategy.execute(a, b)\n\n\n// 客户端代码会选择具体策略并将其传递给上下文。客户端必须知晓策略之间的差\n// 异，才能做出正确的选择。\nclass exampleapplication is\n    method main() is\n\n        创建上下文对象。\n\n        读取第一个数。\n        读取最后一个数。\n        从用户输入中读取期望进行的行为。\n\n        if (action == addition) then\n            context.setstrategy(new concretestrategyadd())\n\n        if (action == subtraction) then\n            context.setstrategy(new concretestrategysubtract())\n\n        if (action == multiplication) then\n            context.setstrategy(new concretestrategymultiply())\n\n        result = context.executestrategy(first number, second number)\n\n        打印结果。\n\n\n\n# 5. 案例\n\n使用示例： 策略模式在 java 代码中很常见。 它经常在各种框架中使用， 能在不扩展类的情况下向用户提供改变其行为的方式。\n\njava 8 开始支持 lambda 方法， 它可作为一种替代策略模式的简单方式。\n\n这里有一些核心 java 程序库中策略模式的示例：\n\n * 对 java.util.comparator#compare() 的调用来自 collections#sort().\n * javax.servlet.http.httpservlet： service­()方法， 还有所有接受 http­servlet­request和 http­servlet­response对象作为参数的 do­xxx()方法。\n * javax.servlet.filter#dofilter()\n\n识别方法： 策略模式可以通过允许嵌套对象完成实际工作的方法以及允许将该对象替换为不同对象的设置器来识别。\n\n\n# 6. 与其他模式的关系\n\n * 桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 命令模式和策略看上去很像， 因为两者都能通过某些行为来参数化对象。 但是， 它们的意图有非常大的不同。\n   * 你可以使用命令来将任何操作转换为对象。 操作的参数将成为对象的成员变量。 你可以通过转换来延迟操作的执行、 将操作放入队列、 保存历史命令或者向远程服务发送命令等。\n   * 另一方面， 策略通常可用于描述完成某件事的不同方式， 让你能够在同一个上下文类中切换算法。\n * 装饰模式可让你更改对象的外表， 策略则让你能够改变其本质。\n * 模板方法模式基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。\n * 状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之访问者模式",frontmatter:{title:"设计模式之访问者模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-22T18:25:00.000Z",permalink:"/pages/6e8ebc/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/23.%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/23.访问者模式.md",key:"v-0f7af49e",path:"/pages/6e8ebc/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:17},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:73},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:208},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:218},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:644},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:3227},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:4999},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:5365},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:5511}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 案例 6. 与其他模式的关系 7. 参考资料",content:'# 设计模式之访问者模式\n\n\n# 1. 意图\n\n访问者模式（Visitor） 是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。\n\n\n# 2. 适用场景\n\n * 如果你需要对一个复杂对象结构 （例如对象树） 中的所有元素执行某些操作， 可使用访问者模式。\n * 可使用访问者模式来清理辅助行为的业务逻辑。\n * 当某个行为仅在类层次结构中的一些类中有意义， 而在其他类中没有意义时， 可使用该模式。\n\n\n# 3. 结构\n\n\n# 3.1. 结构说明\n\n\n\n 1. 访问者 （Visitor） 接口声明了一系列以对象结构的具体元素为参数的访问者方法。 如果编程语言支持重载， 这些方法的名称可以是相同的， 但是其参数一定是不同的。\n 2. 具体访问者 （Concrete Visitor） 会为不同的具体元素类实现相同行为的几个不同版本。\n 3. 元素 （Element） 接口声明了一个方法来 “接收” 访问者。 该方法必须有一个参数被声明为访问者接口类型。\n 4. 具体元素 （Concrete Element） 必须实现接收方法。 该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。 请注意， 即使元素基类实现了该方法， 所有子类都必须对其进行重写并调用访问者对象中的合适方法。\n 5. 客户端 （Client） 通常会作为集合或其他复杂对象 （例如一个组合树） 的代表。 客户端通常不知晓所有的具体元素类， 因为它们会通过抽象接口与集合中的对象进行交互。\n\n\n# 3.2. 结构代码范式\n\nVisitor : 为该对象结构中 ConcreteElement 的每一个类声明一个 Visit 操作。\n\nabstract class Visitor {\n    public abstract void VisitConcreteElementA(ConcreteElementA elementA);\n    public abstract void VisitConcreteElementB(ConcreteElementB elementB);\n}\n\n\nConcreteVisitor : 实现每个由 Visitor 声明的操作。每个操作实现算法的一部分，而该算法片段乃是对应于结构中对象的类。\n\nclass ConcreteVisitor1 extends Visitor {\n    @Override\n    public void VisitConcreteElementA(ConcreteElementA elementA) {\n        System.out.println(this.getClass().getName() + " 访问 " + elementA.getClass().getName());\n    }\n\n    @Override\n    public void VisitConcreteElementB(ConcreteElementB elementB) {\n        System.out.println(this.getClass().getName() + " 访问 " + elementB.getClass().getName());\n    }\n}\n\nclass ConcreteVisitor2 extends Visitor {\n    @Override\n    public void VisitConcreteElementA(ConcreteElementA elementA) {\n        System.out.println(this.getClass().getName() + " 访问 " + elementA.getClass().getName());\n    }\n\n    @Override\n    public void VisitConcreteElementB(ConcreteElementB elementB) {\n        System.out.println(this.getClass().getName() + " 访问 " + elementB.getClass().getName());\n    }\n}\n\n\nElement : 定义一个 Accpet 操作，它以一个访问者为参数。\n\nabstract class Element {\n    public abstract void Accept(Visitor visitor);\n}\n\n\nConcreteElement : 实现 Element 声明的 Accept 操作。\n\nclass ConcreteElementA extends Element {\n    @Override\n    public void Accept(Visitor visitor) {\n        visitor.VisitConcreteElementA(this);\n    }\n}\n\nclass ConcreteElementB extends Element {\n    @Override\n    public void Accept(Visitor visitor) {\n        visitor.VisitConcreteElementB(this);\n    }\n}\n\n\nObjectStructure : 可以枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素。\n\nclass ObjectStructure {\n    private List<Element> elements = new ArrayList<Element>();\n\n    public void Attach(Element element) {\n        elements.add(element);\n    }\n\n    public void Detach(Element element) {\n        elements.remove(element);\n    }\n\n    public void Accept(Visitor visitor) {\n        for (Element elem : elements) {\n            elem.Accept(visitor);\n        }\n    }\n}\n\n\n客户端\n\npublic class VisitorPattern {\n    public static void main(String[] args) {\n        ObjectStructure o = new ObjectStructure();\n        o.Attach(new ConcreteElementA());\n        o.Attach(new ConcreteElementB());\n\n        ConcreteVisitor1 v1 = new ConcreteVisitor1();\n        ConcreteVisitor2 v2 = new ConcreteVisitor2();\n\n        o.Accept(v1);\n        o.Accept(v2);\n    }\n}\n\n\n输出\n\nConcreteVisitor1 访问 ConcreteElementA\nConcreteVisitor1 访问 ConcreteElementB\nConcreteVisitor2 访问 ConcreteElementA\nConcreteVisitor2 访问 ConcreteElementB\n\n\n\n# 4. 伪代码\n\n在本例中， 访问者模式为几何图像层次结构添加了对于 XML 文件导出功能的支持。\n\n\n\n// 元素接口声明了一个`accept（接收）`方法，它会将访问者基础接口作为一个参\n// 数。\ninterface Shape is\n    method move(x, y)\n    method draw()\n    method accept(v: Visitor)\n\n// 每个具体元素类都必须以特定方式实现`accept`方法，使其能调用相应元素类的\n// 访问者方法。\nclass Dot implements Shape is\n    // ...\n\n    // 注意我们正在调用的`visitDot（访问点）`方法与当前类的名称相匹配。\n    // 这样我们能让访问者知晓与其交互的元素类。\n    method accept(v: Visitor) is\n        v.visitDot(this)\n\nclass Circle implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitCircle(this)\n\nclass Rectangle implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitRectangle(this)\n\nclass CompoundShape implements Shape is\n    // ...\n    method accept(v: Visitor) is\n        v.visitCompoundShape(this)\n\n\n// 访问者接口声明了一组与元素类对应的访问方法。访问方法的签名能让访问者准\n// 确辨别出与其交互的元素所属的类。\ninterface Visitor is\n    method visitDot(d: Dot)\n    method visitCircle(c: Circle)\n    method visitRectangle(r: Rectangle)\n    method visitCompoundShape(cs: CompoundShape)\n\n// 具体访问者实现了同一算法的多个版本，而且该算法能与所有具体类进行交互。\n//\n// 访问者模式在复杂对象结构（例如组合树）上使用时能发挥最大作用。在这种情\n// 况下，它可以存储算法的一些中间状态，并同时在结构中的不同对象上执行访问\n// 者方法。这可能会非常有帮助。\nclass XMLExportVisitor implements Visitor is\n    method visitDot(d: Dot) is\n        // 导出点（dot）的 ID 和中心坐标。\n\n    method visitCircle(c: Circle) is\n        // 导出圆（circle）的 ID 、中心坐标和半径。\n\n    method visitRectangle(r: Rectangle) is\n        // 导出长方形（rectangle）的 ID 、左上角坐标、宽和长。\n\n    method visitCompoundShape(cs: CompoundShape) is\n        // 导出图形（shape）的 ID 和其子项目的 ID 列表。\n\n\n// 客户端代码可在不知晓具体类的情况下在一组元素上运行访问者操作。“接收”操\n// 作会将调用定位到访问者对象的相应操作上。\nclass Application is\n    field allShapes: array of Shapes\n\n    method export() is\n        exportVisitor = new XMLExportVisitor()\n\n        foreach (shape in allShapes) do\n            shape.accept(exportVisitor)\n\n\n\n# 5. 案例\n\n使用示例： 访问者不是常用的设计模式， 因为它不仅复杂， 应用范围也比较狭窄。\n\n这里是 Java 程序库代码中该模式的一些示例：\n\n * javax.lang.model.element.AnnotationValue 和 Annotation­Value­Visitor\n * javax.lang.model.element.Element 和 Element­Visitor\n * javax.lang.model.type.TypeMirror 和 Type­Visitor\n * java.nio.file.FileVisitor 和 Simple­File­Visitor\n * javax.faces.component.visit.VisitContext 和 Visit­Callback\n\n\n# 6. 与其他模式的关系\n\n * 你可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作。\n * 你可以使用访问者对整个组合模式树执行操作。\n * 可以同时使用访问者和迭代器模式来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之访问者模式\n\n\n# 1. 意图\n\n访问者模式（visitor） 是一种行为设计模式， 它能将算法与其所作用的对象隔离开来。\n\n\n# 2. 适用场景\n\n * 如果你需要对一个复杂对象结构 （例如对象树） 中的所有元素执行某些操作， 可使用访问者模式。\n * 可使用访问者模式来清理辅助行为的业务逻辑。\n * 当某个行为仅在类层次结构中的一些类中有意义， 而在其他类中没有意义时， 可使用该模式。\n\n\n# 3. 结构\n\n\n# 3.1. 结构说明\n\n\n\n 1. 访问者 （visitor） 接口声明了一系列以对象结构的具体元素为参数的访问者方法。 如果编程语言支持重载， 这些方法的名称可以是相同的， 但是其参数一定是不同的。\n 2. 具体访问者 （concrete visitor） 会为不同的具体元素类实现相同行为的几个不同版本。\n 3. 元素 （element） 接口声明了一个方法来 “接收” 访问者。 该方法必须有一个参数被声明为访问者接口类型。\n 4. 具体元素 （concrete element） 必须实现接收方法。 该方法的目的是根据当前元素类将其调用重定向到相应访问者的方法。 请注意， 即使元素基类实现了该方法， 所有子类都必须对其进行重写并调用访问者对象中的合适方法。\n 5. 客户端 （client） 通常会作为集合或其他复杂对象 （例如一个组合树） 的代表。 客户端通常不知晓所有的具体元素类， 因为它们会通过抽象接口与集合中的对象进行交互。\n\n\n# 3.2. 结构代码范式\n\nvisitor : 为该对象结构中 concreteelement 的每一个类声明一个 visit 操作。\n\nabstract class visitor {\n    public abstract void visitconcreteelementa(concreteelementa elementa);\n    public abstract void visitconcreteelementb(concreteelementb elementb);\n}\n\n\nconcretevisitor : 实现每个由 visitor 声明的操作。每个操作实现算法的一部分，而该算法片段乃是对应于结构中对象的类。\n\nclass concretevisitor1 extends visitor {\n    @override\n    public void visitconcreteelementa(concreteelementa elementa) {\n        system.out.println(this.getclass().getname() + " 访问 " + elementa.getclass().getname());\n    }\n\n    @override\n    public void visitconcreteelementb(concreteelementb elementb) {\n        system.out.println(this.getclass().getname() + " 访问 " + elementb.getclass().getname());\n    }\n}\n\nclass concretevisitor2 extends visitor {\n    @override\n    public void visitconcreteelementa(concreteelementa elementa) {\n        system.out.println(this.getclass().getname() + " 访问 " + elementa.getclass().getname());\n    }\n\n    @override\n    public void visitconcreteelementb(concreteelementb elementb) {\n        system.out.println(this.getclass().getname() + " 访问 " + elementb.getclass().getname());\n    }\n}\n\n\nelement : 定义一个 accpet 操作，它以一个访问者为参数。\n\nabstract class element {\n    public abstract void accept(visitor visitor);\n}\n\n\nconcreteelement : 实现 element 声明的 accept 操作。\n\nclass concreteelementa extends element {\n    @override\n    public void accept(visitor visitor) {\n        visitor.visitconcreteelementa(this);\n    }\n}\n\nclass concreteelementb extends element {\n    @override\n    public void accept(visitor visitor) {\n        visitor.visitconcreteelementb(this);\n    }\n}\n\n\nobjectstructure : 可以枚举它的元素，可以提供一个高层的接口以允许访问者访问它的元素。\n\nclass objectstructure {\n    private list<element> elements = new arraylist<element>();\n\n    public void attach(element element) {\n        elements.add(element);\n    }\n\n    public void detach(element element) {\n        elements.remove(element);\n    }\n\n    public void accept(visitor visitor) {\n        for (element elem : elements) {\n            elem.accept(visitor);\n        }\n    }\n}\n\n\n客户端\n\npublic class visitorpattern {\n    public static void main(string[] args) {\n        objectstructure o = new objectstructure();\n        o.attach(new concreteelementa());\n        o.attach(new concreteelementb());\n\n        concretevisitor1 v1 = new concretevisitor1();\n        concretevisitor2 v2 = new concretevisitor2();\n\n        o.accept(v1);\n        o.accept(v2);\n    }\n}\n\n\n输出\n\nconcretevisitor1 访问 concreteelementa\nconcretevisitor1 访问 concreteelementb\nconcretevisitor2 访问 concreteelementa\nconcretevisitor2 访问 concreteelementb\n\n\n\n# 4. 伪代码\n\n在本例中， 访问者模式为几何图像层次结构添加了对于 xml 文件导出功能的支持。\n\n\n\n// 元素接口声明了一个`accept（接收）`方法，它会将访问者基础接口作为一个参\n// 数。\ninterface shape is\n    method move(x, y)\n    method draw()\n    method accept(v: visitor)\n\n// 每个具体元素类都必须以特定方式实现`accept`方法，使其能调用相应元素类的\n// 访问者方法。\nclass dot implements shape is\n    // ...\n\n    // 注意我们正在调用的`visitdot（访问点）`方法与当前类的名称相匹配。\n    // 这样我们能让访问者知晓与其交互的元素类。\n    method accept(v: visitor) is\n        v.visitdot(this)\n\nclass circle implements shape is\n    // ...\n    method accept(v: visitor) is\n        v.visitcircle(this)\n\nclass rectangle implements shape is\n    // ...\n    method accept(v: visitor) is\n        v.visitrectangle(this)\n\nclass compoundshape implements shape is\n    // ...\n    method accept(v: visitor) is\n        v.visitcompoundshape(this)\n\n\n// 访问者接口声明了一组与元素类对应的访问方法。访问方法的签名能让访问者准\n// 确辨别出与其交互的元素所属的类。\ninterface visitor is\n    method visitdot(d: dot)\n    method visitcircle(c: circle)\n    method visitrectangle(r: rectangle)\n    method visitcompoundshape(cs: compoundshape)\n\n// 具体访问者实现了同一算法的多个版本，而且该算法能与所有具体类进行交互。\n//\n// 访问者模式在复杂对象结构（例如组合树）上使用时能发挥最大作用。在这种情\n// 况下，它可以存储算法的一些中间状态，并同时在结构中的不同对象上执行访问\n// 者方法。这可能会非常有帮助。\nclass xmlexportvisitor implements visitor is\n    method visitdot(d: dot) is\n        // 导出点（dot）的 id 和中心坐标。\n\n    method visitcircle(c: circle) is\n        // 导出圆（circle）的 id 、中心坐标和半径。\n\n    method visitrectangle(r: rectangle) is\n        // 导出长方形（rectangle）的 id 、左上角坐标、宽和长。\n\n    method visitcompoundshape(cs: compoundshape) is\n        // 导出图形（shape）的 id 和其子项目的 id 列表。\n\n\n// 客户端代码可在不知晓具体类的情况下在一组元素上运行访问者操作。“接收”操\n// 作会将调用定位到访问者对象的相应操作上。\nclass application is\n    field allshapes: array of shapes\n\n    method export() is\n        exportvisitor = new xmlexportvisitor()\n\n        foreach (shape in allshapes) do\n            shape.accept(exportvisitor)\n\n\n\n# 5. 案例\n\n使用示例： 访问者不是常用的设计模式， 因为它不仅复杂， 应用范围也比较狭窄。\n\n这里是 java 程序库代码中该模式的一些示例：\n\n * javax.lang.model.element.annotationvalue 和 annotation­value­visitor\n * javax.lang.model.element.element 和 element­visitor\n * javax.lang.model.type.typemirror 和 type­visitor\n * java.nio.file.filevisitor 和 simple­file­visitor\n * javax.faces.component.visit.visitcontext 和 visit­callback\n\n\n# 6. 与其他模式的关系\n\n * 你可以将访问者模式视为命令模式的加强版本， 其对象可对不同类的多种对象执行操作。\n * 你可以使用访问者对整个组合模式树执行操作。\n * 可以同时使用访问者和迭代器模式来遍历复杂数据结构， 并对其中的元素执行所需操作， 即使这些元素所属的类完全不同。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式之状态模式",frontmatter:{title:"设计模式之状态模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2015-01-23T10:29:00.000Z",permalink:"/pages/6420d5/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/24.%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.html",relativePath:"03.设计/02.设计模式/24.状态模式.md",key:"v-1457855d",path:"/pages/6420d5/",headers:[{level:2,title:"1. 意图",slug:"_1-意图",normalizedTitle:"1. 意图",charIndex:16},{level:2,title:"2. 适用场景",slug:"_2-适用场景",normalizedTitle:"2. 适用场景",charIndex:93},{level:2,title:"3. 结构",slug:"_3-结构",normalizedTitle:"3. 结构",charIndex:260},{level:3,title:"3.1. 结构说明",slug:"_3-1-结构说明",normalizedTitle:"3.1. 结构说明",charIndex:270},{level:3,title:"3.2. 结构代码范式",slug:"_3-2-结构代码范式",normalizedTitle:"3.2. 结构代码范式",charIndex:656},{level:2,title:"4. 伪代码",slug:"_4-伪代码",normalizedTitle:"4. 伪代码",charIndex:1796},{level:2,title:"5. 案例",slug:"_5-案例",normalizedTitle:"5. 案例",charIndex:4765},{level:2,title:"6. 与其他模式的关系",slug:"_6-与其他模式的关系",normalizedTitle:"6. 与其他模式的关系",charIndex:4986},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:5275}],headersStr:"1. 意图 2. 适用场景 3. 结构 3.1. 结构说明 3.2. 结构代码范式 4. 伪代码 5. 案例 6. 与其他模式的关系 7. 参考资料",content:'# 设计模式之状态模式\n\n\n# 1. 意图\n\n状态模式（State） 是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。\n\n\n# 2. 适用场景\n\n * 如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。\n * 如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。\n * 当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。\n\n\n# 3. 结构\n\n\n# 3.1. 结构说明\n\n\n\n 1. 上下文 （Context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。\n 2. 状态 （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。\n 3. 具体状态 （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。\n    * 状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。\n 4. 上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。\n\n\n# 3.2. 结构代码范式\n\nState : 定义一个接口以封装与 Context 的一个特定状态相关的行为。\n\nabstract class State {\n    public abstract void Handle(Context context);\n}\n\n\nConcreteState : 每一个子类实现一个与 Context 的一个状态相关的行为。\n\nclass ConcreteStateA extends State {\n    @Override\n    public void Handle(Context context) {\n        context.SetState(new ConcreteStateB());\n    }\n}\n\nclass ConcreteStateB extends State {\n    @Override\n    public void Handle(Context context) {\n        context.SetState(new ConcreteStateA());\n    }\n}\n\n\nContext : 维护一个 ConcreteState 子类的实例，这个实例定义当前的状态。\n\nclass Context {\n    private State state;\n    public Context(State state) {\n        this.state = state;\n    }\n\n    public void SetState(State state) {\n        this.state = state;\n        System.out.println("当前状态：" + state.getClass().getName());\n    }\n    public State GetState() {\n        return state;\n    }\n\n    public void Request() {\n        state.Handle(this);\n    }\n}\n\n\n\n客户端\n\npublic class StatePattern {\n    public static void main(String[] args) {\n        Context c = new Context(new ConcreteStateA());\n        c.Request();\n        c.Request();\n    }\n}\n\n\n输出\n\n当前状态：ConcreteStateB\n当前状态：ConcreteStateA\n\n\n\n# 4. 伪代码\n\n在本例中， 状态模式将根据当前回放状态， 让媒体播放器中的相同控件完成不同的行为。\n\n\n\n播放器的主要对象总是会连接到一个负责播放器绝大部分工作的状态对象中。 部分操作会更换播放器当前的状态对象， 以此改变播放器对于用户互动所作出的反应。\n\n// 音频播放器（Audio­Player）类即为上下文。它还会维护指向状态类实例的引用，\n// 该状态类则用于表示音频播放器当前的状态。\nclass AudioPlayer is\n    field state: State\n    field UI, volume, playlist, currentSong\n\n    constructor AudioPlayer() is\n        this.state = new ReadyState(this)\n\n        // 上下文会将处理用户输入的工作委派给状态对象。由于每个状态都以不\n        // 同的方式处理输入，其结果自然将依赖于当前所处的状态。\n        UI = new UserInterface()\n        UI.lockButton.onClick(this.clickLock)\n        UI.playButton.onClick(this.clickPlay)\n        UI.nextButton.onClick(this.clickNext)\n        UI.prevButton.onClick(this.clickPrevious)\n\n    // 其他对象必须能切换音频播放器当前所处的状态。\n    method changeState(state: State) is\n        this.state = state\n\n    // UI 方法会将执行工作委派给当前状态。\n    method clickLock() is\n        state.clickLock()\n    method clickPlay() is\n        state.clickPlay()\n    method clickNext() is\n        state.clickNext()\n    method clickPrevious() is\n        state.clickPrevious()\n\n    // 状态可调用上下文的一些服务方法。\n    method startPlayback() is\n        // ...\n    method stopPlayback() is\n        // ...\n    method nextSong() is\n        // ...\n    method previousSong() is\n        // ...\n    method fastForward(time) is\n        // ...\n    method rewind(time) is\n        // ...\n\n\n// 所有具体状态类都必须实现状态基类声明的方法，并提供反向引用指向与状态相\n// 关的上下文对象。状态可使用反向引用将上下文转换为另一个状态。\nabstract class State is\n    protected field player: AudioPlayer\n\n    // 上下文将自身传递给状态构造函数。这可帮助状态在需要时获取一些有用的\n    // 上下文数据。\n    constructor State(player) is\n        this.player = player\n\n    abstract method clickLock()\n    abstract method clickPlay()\n    abstract method clickNext()\n    abstract method clickPrevious()\n\n\n// 具体状态会实现与上下文状态相关的多种行为。\nclass LockedState extends State is\n\n    // 当你解锁一个锁定的播放器时，它可能处于两种状态之一。\n    method clickLock() is\n        if (player.playing)\n            player.changeState(new PlayingState(player))\n        else\n            player.changeState(new ReadyState(player))\n\n    method clickPlay() is\n        // 已锁定，什么也不做。\n\n    method clickNext() is\n        // 已锁定，什么也不做。\n\n    method clickPrevious() is\n        // 已锁定，什么也不做。\n\n\n// 它们还可在上下文中触发状态转换。\nclass ReadyState extends State is\n    method clickLock() is\n        player.changeState(new LockedState(player))\n\n    method clickPlay() is\n        player.startPlayback()\n        player.changeState(new PlayingState(player))\n\n    method clickNext() is\n        player.nextSong()\n\n    method clickPrevious() is\n        player.previousSong()\n\n\nclass PlayingState extends State is\n    method clickLock() is\n        player.changeState(new LockedState(player))\n\n    method clickPlay() is\n        player.stopPlayback()\n        player.changeState(new ReadyState(player))\n\n    method clickNext() is\n        if (event.doubleclick)\n            player.nextSong()\n        else\n            player.fastForward(5)\n\n    method clickPrevious() is\n        if (event.doubleclick)\n            player.previous()\n        else\n            player.rewind(5)\n\n\n\n# 5. 案例\n\n使用示例： 在 Java 语言中， 状态模式通常被用于将基于 switch语句的大型状态机转换为对象。\n\n这里是核心 Java 程序库中一些状态模式的示例：\n\n * javax.faces.lifecycle.LifeCycle#execute() （由 Faces­Servlet控制： 行为依赖于当前 JSF 生命周期的阶段 （状态））\n\n识别方法： 状态模式可通过受外部控制且能根据对象状态改变行为的方法来识别。\n\n\n# 6. 与其他模式的关系\n\n * 桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程',normalizedContent:'# 设计模式之状态模式\n\n\n# 1. 意图\n\n状态模式（state） 是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。\n\n\n# 2. 适用场景\n\n * 如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。\n * 如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。\n * 当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。\n\n\n# 3. 结构\n\n\n# 3.1. 结构说明\n\n\n\n 1. 上下文 （context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。\n 2. 状态 （state） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。\n 3. 具体状态 （concrete states） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。\n    * 状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。\n 4. 上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。\n\n\n# 3.2. 结构代码范式\n\nstate : 定义一个接口以封装与 context 的一个特定状态相关的行为。\n\nabstract class state {\n    public abstract void handle(context context);\n}\n\n\nconcretestate : 每一个子类实现一个与 context 的一个状态相关的行为。\n\nclass concretestatea extends state {\n    @override\n    public void handle(context context) {\n        context.setstate(new concretestateb());\n    }\n}\n\nclass concretestateb extends state {\n    @override\n    public void handle(context context) {\n        context.setstate(new concretestatea());\n    }\n}\n\n\ncontext : 维护一个 concretestate 子类的实例，这个实例定义当前的状态。\n\nclass context {\n    private state state;\n    public context(state state) {\n        this.state = state;\n    }\n\n    public void setstate(state state) {\n        this.state = state;\n        system.out.println("当前状态：" + state.getclass().getname());\n    }\n    public state getstate() {\n        return state;\n    }\n\n    public void request() {\n        state.handle(this);\n    }\n}\n\n\n\n客户端\n\npublic class statepattern {\n    public static void main(string[] args) {\n        context c = new context(new concretestatea());\n        c.request();\n        c.request();\n    }\n}\n\n\n输出\n\n当前状态：concretestateb\n当前状态：concretestatea\n\n\n\n# 4. 伪代码\n\n在本例中， 状态模式将根据当前回放状态， 让媒体播放器中的相同控件完成不同的行为。\n\n\n\n播放器的主要对象总是会连接到一个负责播放器绝大部分工作的状态对象中。 部分操作会更换播放器当前的状态对象， 以此改变播放器对于用户互动所作出的反应。\n\n// 音频播放器（audio­player）类即为上下文。它还会维护指向状态类实例的引用，\n// 该状态类则用于表示音频播放器当前的状态。\nclass audioplayer is\n    field state: state\n    field ui, volume, playlist, currentsong\n\n    constructor audioplayer() is\n        this.state = new readystate(this)\n\n        // 上下文会将处理用户输入的工作委派给状态对象。由于每个状态都以不\n        // 同的方式处理输入，其结果自然将依赖于当前所处的状态。\n        ui = new userinterface()\n        ui.lockbutton.onclick(this.clicklock)\n        ui.playbutton.onclick(this.clickplay)\n        ui.nextbutton.onclick(this.clicknext)\n        ui.prevbutton.onclick(this.clickprevious)\n\n    // 其他对象必须能切换音频播放器当前所处的状态。\n    method changestate(state: state) is\n        this.state = state\n\n    // ui 方法会将执行工作委派给当前状态。\n    method clicklock() is\n        state.clicklock()\n    method clickplay() is\n        state.clickplay()\n    method clicknext() is\n        state.clicknext()\n    method clickprevious() is\n        state.clickprevious()\n\n    // 状态可调用上下文的一些服务方法。\n    method startplayback() is\n        // ...\n    method stopplayback() is\n        // ...\n    method nextsong() is\n        // ...\n    method previoussong() is\n        // ...\n    method fastforward(time) is\n        // ...\n    method rewind(time) is\n        // ...\n\n\n// 所有具体状态类都必须实现状态基类声明的方法，并提供反向引用指向与状态相\n// 关的上下文对象。状态可使用反向引用将上下文转换为另一个状态。\nabstract class state is\n    protected field player: audioplayer\n\n    // 上下文将自身传递给状态构造函数。这可帮助状态在需要时获取一些有用的\n    // 上下文数据。\n    constructor state(player) is\n        this.player = player\n\n    abstract method clicklock()\n    abstract method clickplay()\n    abstract method clicknext()\n    abstract method clickprevious()\n\n\n// 具体状态会实现与上下文状态相关的多种行为。\nclass lockedstate extends state is\n\n    // 当你解锁一个锁定的播放器时，它可能处于两种状态之一。\n    method clicklock() is\n        if (player.playing)\n            player.changestate(new playingstate(player))\n        else\n            player.changestate(new readystate(player))\n\n    method clickplay() is\n        // 已锁定，什么也不做。\n\n    method clicknext() is\n        // 已锁定，什么也不做。\n\n    method clickprevious() is\n        // 已锁定，什么也不做。\n\n\n// 它们还可在上下文中触发状态转换。\nclass readystate extends state is\n    method clicklock() is\n        player.changestate(new lockedstate(player))\n\n    method clickplay() is\n        player.startplayback()\n        player.changestate(new playingstate(player))\n\n    method clicknext() is\n        player.nextsong()\n\n    method clickprevious() is\n        player.previoussong()\n\n\nclass playingstate extends state is\n    method clicklock() is\n        player.changestate(new lockedstate(player))\n\n    method clickplay() is\n        player.stopplayback()\n        player.changestate(new readystate(player))\n\n    method clicknext() is\n        if (event.doubleclick)\n            player.nextsong()\n        else\n            player.fastforward(5)\n\n    method clickprevious() is\n        if (event.doubleclick)\n            player.previous()\n        else\n            player.rewind(5)\n\n\n\n# 5. 案例\n\n使用示例： 在 java 语言中， 状态模式通常被用于将基于 switch语句的大型状态机转换为对象。\n\n这里是核心 java 程序库中一些状态模式的示例：\n\n * javax.faces.lifecycle.lifecycle#execute() （由 faces­servlet控制： 行为依赖于当前 jsf 生命周期的阶段 （状态））\n\n识别方法： 状态模式可通过受外部控制且能根据对象状态改变行为的方法来识别。\n\n\n# 6. 与其他模式的关系\n\n * 桥接模式、 状态模式和策略模式 （在某种程度上包括适配器模式） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。\n * 状态可被视为策略的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但状态模式没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"面向对象原则",frontmatter:{title:"面向对象原则",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2021-05-19T09:49:05.000Z",permalink:"/pages/b3c94e/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/25.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%88%99.html",relativePath:"03.设计/02.设计模式/25.面向对象原则.md",key:"v-3f96c8d8",path:"/pages/b3c94e/",headers:[{level:2,title:"1. 单一职责原则",slug:"_1-单一职责原则",normalizedTitle:"1. 单一职责原则",charIndex:17},{level:2,title:"2. 开放-封闭原则",slug:"_2-开放-封闭原则",normalizedTitle:"2. 开放-封闭原则",charIndex:110},{level:2,title:"3. 里氏替换原则",slug:"_3-里氏替换原则",normalizedTitle:"3. 里氏替换原则",charIndex:205},{level:2,title:"4. 依赖倒置原则",slug:"_4-依赖倒置原则",normalizedTitle:"4. 依赖倒置原则",charIndex:268},{level:2,title:"5. 接口隔离原则",slug:"_5-接口隔离原则",normalizedTitle:"5. 接口隔离原则",charIndex:426},{level:2,title:"6. 迪米特原则",slug:"_6-迪米特原则",normalizedTitle:"6. 迪米特原则",charIndex:562},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:724}],headersStr:"1. 单一职责原则 2. 开放-封闭原则 3. 里氏替换原则 4. 依赖倒置原则 5. 接口隔离原则 6. 迪米特原则 7. 参考资料",content:"# 面向对象设计六大原则\n\n\n# 1. 单一职责原则\n\n单一职责原则（Single Responsibility Principle），应该有且仅有一个原因引起类的变更。\n\n简单点说，一个类，最好只负责一件事。\n\n\n# 2. 开放-封闭原则\n\n开放-封闭原则（Open Close Principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。\n\n对于扩展是开放的；对于更改是封闭的。\n\n\n# 3. 里氏替换原则\n\n里氏替换原则（Liskov Substitution Principle），子类可以替换父类。\n\n\n# 4. 依赖倒置原则\n\n依赖倒置原则（Dependency Inversion Principle），抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。\n\n关键点：\n\n * 高层模块不应该依赖低层模块，两者都应该依赖其抽象\n * 抽象不应该依赖细节\n * 细节应该依赖抽象\n\n\n# 5. 接口隔离原则\n\n接口隔离原则（Interface Segregation Principle）使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。\n\n * 客户端不应依赖它不需要的接口\n * 类间的依赖关系应该建立在最小的接口上\n\n\n# 6. 迪米特原则\n\n迪米特原则（Least Knowledge Principle）又称最少知识原则，一个软件实体应当尽可能少地与其他实体发生相互作用。\n\n一个类应该对自己需要调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。\n\n\n# 7. 参考资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》",normalizedContent:"# 面向对象设计六大原则\n\n\n# 1. 单一职责原则\n\n单一职责原则（single responsibility principle），应该有且仅有一个原因引起类的变更。\n\n简单点说，一个类，最好只负责一件事。\n\n\n# 2. 开放-封闭原则\n\n开放-封闭原则（open close principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。\n\n对于扩展是开放的；对于更改是封闭的。\n\n\n# 3. 里氏替换原则\n\n里氏替换原则（liskov substitution principle），子类可以替换父类。\n\n\n# 4. 依赖倒置原则\n\n依赖倒置原则（dependency inversion principle），抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。\n\n关键点：\n\n * 高层模块不应该依赖低层模块，两者都应该依赖其抽象\n * 抽象不应该依赖细节\n * 细节应该依赖抽象\n\n\n# 5. 接口隔离原则\n\n接口隔离原则（interface segregation principle）使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。\n\n * 客户端不应依赖它不需要的接口\n * 类间的依赖关系应该建立在最小的接口上\n\n\n# 6. 迪米特原则\n\n迪米特原则（least knowledge principle）又称最少知识原则，一个软件实体应当尽可能少地与其他实体发生相互作用。\n\n一个类应该对自己需要调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。\n\n\n# 7. 参考资料\n\n * 《head first 设计模式》\n * 《大话设计模式》",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"设计模式",frontmatter:{title:"设计模式",categories:["设计","设计模式"],tags:["设计","设计模式"],date:"2020-08-10T10:59:18.000Z",permalink:"/pages/4b9193/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/02.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",relativePath:"03.设计/02.设计模式/README.md",key:"v-0893d5c3",path:"/pages/4b9193/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:37},{level:3,title:"创建型模式",slug:"创建型模式",normalizedTitle:"创建型模式",charIndex:55},{level:3,title:"结构型模式",slug:"结构型模式",normalizedTitle:"结构型模式",charIndex:247},{level:3,title:"行为型模式",slug:"行为型模式",normalizedTitle:"行为型模式",charIndex:429},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:701},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:755}],headersStr:"📖 内容 创建型模式 结构型模式 行为型模式 📚 资料 🚪 传送",content:"# 设计模式\n\n> 设计模式是软件设计中常见问题的典型解决方案。\n\n\n# 📖 内容\n\n面向对象原则\n\n\n# 创建型模式\n\n> 创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。\n\n * 简单工厂模式 (Simple Factory)\n * 工厂方法模式 (Factory Method)\n * 抽象工厂模式 (Abstract Factory)\n * 建造者模式 (Builder)\n * 原型模式 (Prototype)\n * 单例模式 (Singleton)\n\n\n# 结构型模式\n\n> 结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。\n\n * 适配器模式 (Adapter)\n * 桥接模式 (Bridge)\n * 组合模式 (Composite)\n * 装饰模式 (Decorator)\n * 外观模式 (Facade)\n * 享元模式 (Flyweight)\n * 代理模式 (Proxy)\n\n\n# 行为型模式\n\n> 行为模式负责对象间的高效沟通和职责委派。\n\n * 模板方法模式 (Template Method)\n * 命令模式 (Command)\n * 迭代器模式 (Iterator)\n * 观察者模式 (Observer)\n * 解释器模式 (Interpreter)\n * 中介者模式 (Mediator)\n * 职责链模式 (Chain of Responsibility)\n * 备忘录模式 (Memento)\n * 策略模式 (Strategy)\n * 访问者模式 (Visitor)\n * 状态模式 (State)\n\n\n# 📚 资料\n\n * 《Head First 设计模式》\n * 《大话设计模式》\n * 设计模式教程\n\n\n# 🚪 传送\n\n◾ 🏠 DESIGN 首页 ◾ 🎯 我的博客 ◾",normalizedContent:"# 设计模式\n\n> 设计模式是软件设计中常见问题的典型解决方案。\n\n\n# 📖 内容\n\n面向对象原则\n\n\n# 创建型模式\n\n> 创建型模式提供了创建对象的机制， 能够提升已有代码的灵活性和可复用性。\n\n * 简单工厂模式 (simple factory)\n * 工厂方法模式 (factory method)\n * 抽象工厂模式 (abstract factory)\n * 建造者模式 (builder)\n * 原型模式 (prototype)\n * 单例模式 (singleton)\n\n\n# 结构型模式\n\n> 结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。\n\n * 适配器模式 (adapter)\n * 桥接模式 (bridge)\n * 组合模式 (composite)\n * 装饰模式 (decorator)\n * 外观模式 (facade)\n * 享元模式 (flyweight)\n * 代理模式 (proxy)\n\n\n# 行为型模式\n\n> 行为模式负责对象间的高效沟通和职责委派。\n\n * 模板方法模式 (template method)\n * 命令模式 (command)\n * 迭代器模式 (iterator)\n * 观察者模式 (observer)\n * 解释器模式 (interpreter)\n * 中介者模式 (mediator)\n * 职责链模式 (chain of responsibility)\n * 备忘录模式 (memento)\n * 策略模式 (strategy)\n * 访问者模式 (visitor)\n * 状态模式 (state)\n\n\n# 📚 资料\n\n * 《head first 设计模式》\n * 《大话设计模式》\n * 设计模式教程\n\n\n# 🚪 传送\n\n◾ 🏠 design 首页 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"代码的坏味道和重构",frontmatter:{title:"代码的坏味道和重构",categories:["设计","重构"],tags:["设计","重构","代码的坏味道"],date:"2018-10-13T22:48:00.000Z",permalink:"/pages/89848c/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/03.%E9%87%8D%E6%9E%84/01.%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%93%E5%92%8C%E9%87%8D%E6%9E%84.html",relativePath:"03.设计/03.重构/01.代码的坏味道和重构.md",key:"v-79c78335",path:"/pages/89848c/",headers:[{level:2,title:"1. 症与药",slug:"_1-症与药",normalizedTitle:"1. 症与药",charIndex:105},{level:3,title:"1.1. 对代码的坏味道的思考",slug:"_1-1-对代码的坏味道的思考",normalizedTitle:"1.1. 对代码的坏味道的思考",charIndex:116},{level:3,title:"1.2. 重构的原则",slug:"_1-2-重构的原则",normalizedTitle:"1.2. 重构的原则",charIndex:735},{level:4,title:"1.2.1. 何谓重构(What)",slug:"_1-2-1-何谓重构-what",normalizedTitle:"1.2.1. 何谓重构(what)",charIndex:792},{level:4,title:"1.2.2. 为何重构(Why)",slug:"_1-2-2-为何重构-why",normalizedTitle:"1.2.2. 为何重构(why)",charIndex:998},{level:4,title:"1.2.3. 何时重构(When)",slug:"_1-2-3-何时重构-when",normalizedTitle:"1.2.3. 何时重构(when)",charIndex:1113},{level:4,title:"1.2.4. 如何重构(How)",slug:"_1-2-4-如何重构-how",normalizedTitle:"1.2.4. 如何重构(how)",charIndex:2251},{level:2,title:"2. 代码的坏味道",slug:"_2-代码的坏味道",normalizedTitle:"2. 代码的坏味道",charIndex:2719},{level:3,title:"2.1. 代码坏味道之代码臃肿",slug:"_2-1-代码坏味道之代码臃肿",normalizedTitle:"2.1. 代码坏味道之代码臃肿",charIndex:2827},{level:3,title:"2.2. 代码坏味道之滥用面向对象",slug:"_2-2-代码坏味道之滥用面向对象",normalizedTitle:"2.2. 代码坏味道之滥用面向对象",charIndex:3002},{level:3,title:"2.3. 代码坏味道之变革的障碍",slug:"_2-3-代码坏味道之变革的障碍",normalizedTitle:"2.3. 代码坏味道之变革的障碍",charIndex:3133},{level:3,title:"2.4. 代码坏味道之非必要的",slug:"_2-4-代码坏味道之非必要的",normalizedTitle:"2.4. 代码坏味道之非必要的",charIndex:3263},{level:3,title:"2.5. 代码坏味道之耦合",slug:"_2-5-代码坏味道之耦合",normalizedTitle:"2.5. 代码坏味道之耦合",charIndex:3390},{level:2,title:"3. 扩展阅读",slug:"_3-扩展阅读",normalizedTitle:"3. 扩展阅读",charIndex:3489},{level:2,title:"4. 参考资料",slug:"_4-参考资料",normalizedTitle:"4. 参考资料",charIndex:3586}],headersStr:"1. 症与药 1.1. 对代码的坏味道的思考 1.2. 重构的原则 1.2.1. 何谓重构(What) 1.2.2. 为何重构(Why) 1.2.3. 何时重构(When) 1.2.4. 如何重构(How) 2. 代码的坏味道 2.1. 代码坏味道之代码臃肿 2.2. 代码坏味道之滥用面向对象 2.3. 代码坏味道之变革的障碍 2.4. 代码坏味道之非必要的 2.5. 代码坏味道之耦合 3. 扩展阅读 4. 参考资料",content:"第一次读《重构:改善既有代码的设计》时，我曾整理过一个简单的笔记。最近，因为参与一个重构项目，再一次温习了《重构:改善既有代码的设计》。过程中，萌发了认真总结、整理重构方法的冲动，于是有了这系列文字。\n\n\n# 1. 症与药\n\n\n# 1.1. 对代码的坏味道的思考\n\n“有病要早治，不要放弃治疗”。多么朴素的道理 ，人人都懂。\n\n病，就是不健康。\n\n人有病，可以通过打针、吃药、做手术来进行治疗。\n\n如果把代码的坏味道（代码质量问题）比作病症，那么重构就是治疗代码的坏味道的药。\n\n个人认为，在重构这件事上，也可以应用治病的道理：\n\n * 防患于未然。 —— 春秋战国时期的一代名医扁鹊，曾经有个很著名的医学主张：防患于未然。 我觉得这个道理应用于软件代码的重构亦然。编程前要有合理的设计、编程时要有良好的编程风格，尽量减少问题。从这个层面上说，了解代码的坏味道，不仅仅是为了发现问题、解决问题。更重要的作用是：指导我们在编程过程中有意识的去规避这些问题。\n\n * 小病不医，易得大病。 —— 刘备说过：“勿以善小而不为，勿以恶小而为之”。发现问题就及时修改，代码质量自然容易进入良性循环；反之，亦然。要重视积累的力量，别总以为代码出现点小问题，那都不是事儿。\n\n * 对症下药。 —— 程序出现了问题，要分析出问题的根本，有针对性的制定合理的重构方案。大家都知道吃错药的后果，同样的，瞎改还不如不改。\n\n * 忌猛药 —— 医病用猛药容易产生副作用。换一句俗语：步子大了容易扯着蛋。重构如果大刀阔斧的干，那你就要有随时可能扑街的心理准备。推倒重来不是重构，而是重写。重构应该是循序渐进，步步为营的过程。当你发现重写代码比重构代码更简单，往往说明你早就该重构了。\n\n\n# 1.2. 重构的原则\n\n前面把代码质量问题比作病症，而把重构比作药。这里，我们再进一步讨论一下重构的原则。\n\n# 1.2.1. 何谓重构(What)\n\n重构（Refactoring） 的常见定义是：不改变软件系统外部行为的前提下，改善它的内部结构。\n\n个人觉得这个定义有点生涩。不妨理解为：重构是给代码治病的行为。而代码有病是指代码的质量（可靠性、安全性、可复用性、可维护性）和性能有问题。\n\n重构的目的是为了提高代码的质量和性能。\n\n注：功能不全或者不正确，那是残疾代码。就像治病治不了残疾，重构也解决不了功能问题。\n\n# 1.2.2. 为何重构(Why)\n\n翻翻书，上网搜一下，谈到重构的理由大体相同：\n\n * 重构改进软件设计\n * 重构使软件更容易理解\n * 重构帮助找到 bug\n * 重构提高编程速度\n\n总之就是，重构可以提高代码质量。\n\n# 1.2.3. 何时重构(When)\n\n关于何时重构，我先引用一下 重构并非难在如何做，而是难在何时开始做 一文的观点。\n\n> 对于一个高速发展的公司来说，停止业务开发，专门来做重构项目，从来就不是一个可接受的选项，“边开飞机边换引擎”才是这种公司想要的。\n\n我们不妨来衡量一下重构的成本和收益。\n\n * 重构的成本\n   \n   重构是有成本的，费时费力（时间、人力）不说，还有可能会使本来正常运行的程序出错。所以，很多人都抱着“不求有功，但求无过”的心理得过且过。\n   \n   还有一种成本：重构使用较新且较为复杂的技术，学习曲线不平滑，团队成员技术切换困难，短期内开发效率可能不升反降。\n   \n   但是，如果一直放任代码腐朽下去，技术债务会越来越沉重。当代码最终快要跑不动时，架构师们往往还是不得不使用激进的手段来治疗代码的顽疾。但是，这个过程通常都是非常痛苦的，而且有着很高的失败风险。\n\n * 重构的收益\n   \n   重构的收益是提高代码的质量和性能，并提高未来的开发效率。但是，应当看到，重构往往并不能在短期内带来实际的效益，或者很难直观看出效益。而对于一个企业来说，没有什么比效益更重要。换句话说，没有实际效益的事，通常也没有价值。很多领导，尤其是非技术方向的领导，并不关心你应用了什么新技术，让代码变得多么优雅等等。\n\n * 重构的合适时机\n   \n   从以上来看，重构实在是个吃力不讨好的事情。\n   \n   于是，很多人屈服于万恶的 KPI 和要命的 deadline，一边吐槽着以前的代码是垃圾，一边自己也在造垃圾。\n   \n   但是，重构本应该是个渐进式的过程，不是只有伤筋动骨的改造才叫重构。如果非要等到代码已经烂到病入膏肓，再使用激进方式来重构，那必然是困难重重，风险极高。\n   \n   《重构》书中提到的重构时机应该在添加功能、修复功能、审查代码时，不建议专门抽出时间专门做重构项目。\n   \n   我认为，其思想就是指：重构应该是在开发过程中实时的、渐进的演化过程。\n\n * 重构的不恰当时机\n   \n   但是，这里我也要强调一下：不是所有软件开发过程都一定要重构。\n   \n   较能凸显重构价值的场景是：代码规模较大、生命周期还较长、承担了较多责任、有一个较大（且较不稳定，人员流动频繁）团队在其上工作的单一代码库。\n   \n   与之相反，有一些场景的重构价值就很小：\n   \n   * 代码库生命周期快要走到尾声，开发逐渐减少，以维护为主。\n   * 代码库当前版本马上要发布了，这时重构无疑是给自己找麻烦。\n   * 重构代价过于沉重：重构后功能的正确性、稳定性难以保障；技术过于超前，团队成员技术迁移难度太大。\n\n# 1.2.4. 如何重构(How)\n\n重构行为在我看来，也是可以分层级的。由高到低，越高层级难度越大：\n\n * 系统架构、集群架构、框架、服务、数据库：这个层面的重构属于战略级重构。现代软件往往业务复杂、庞大。使用微服务、数据迁移来拆分业务，降低业务复杂度成为了主流。但是，这些技术的测试、部署复杂，技术难度很高。\n * 组件、模块、接口：这个层面的重构属于战术级重构。组件、模块、框架的重构，主要是针对代码的设计问题。解决的是代码的整体结构问题。需要对框架、设计模式、分布式、并发等等有足够的了解。\n * 类、接口、函数、字段等：这个层面的重构属于战法级重构。《重构》一书提到了 代码的坏味道 以及相关的重构方法。这些都是对类、接口、函数、字段级别代码的重构手段。由于这一级别的重构方法较为简单，所以可操作性较强。具体细节可以阅读《代码的坏味道》篇章。\n\n前两种层级的重构已经涉及到架构层面，影响较大，难度较高，如果功力不够不要轻易变动。由于这两个层级涉及领域较广，这里不做论述。\n\n此处为分割线。下面是代码的坏味道系列。。。\n\n\n# 2. 代码的坏味道\n\n《重构:改善既有代码的设计》中介绍了 22 种代码的坏味道以及重构手法。这些坏味道可以进一步归类。我总觉得将事物分类有助于理解和记忆。所以本系列将坏味道按照特性分类，然后逐一讲解。\n\n\n\n\n# 2.1. 代码坏味道之代码臃肿\n\n> 代码臃肿(Bloated)这组坏味道意味着：代码中的类、函数、字段没有经过合理的组织，只是简单的堆砌起来。这一类型的问题通常在代码的初期并不明显，但是随着代码规模的增长而逐渐积累（特别是当没有人努力去根除它们时）。\n\n * 过长函数\n * 过大的类\n * 基本类型偏执\n * 过长参数列\n * 数据泥团\n\n\n# 2.2. 代码坏味道之滥用面向对象\n\n> 滥用面向对象(Object-Orientation Abusers)这组坏味道意味着：代码部分或完全地违背了面向对象编程原则。\n\n * switch 声明\n * 临时字段\n * 被拒绝的馈赠\n * 异曲同工的类\n\n\n# 2.3. 代码坏味道之变革的障碍\n\n> 变革的障碍(Change Preventers)这组坏味道意味着：当你需要改变一处代码时，却发现不得不改变其他的地方。这使得程序开发变得复杂、代价高昂。\n\n * 发散式变化\n * 霰弹式修改\n * 平行继承体系\n\n\n# 2.4. 代码坏味道之非必要的\n\n> 非必要的(Dispensables)这组坏味道意味着：这样的代码可有可无，它的存在反而影响整体代码的整洁和可读性。\n\n * 过多的注释\n * 重复代码\n * 冗余类\n * 纯稚的数据类\n * 夸夸其谈未来性\n\n\n# 2.5. 代码坏味道之耦合\n\n> 耦合(Couplers)这组坏味道意味着：不同类之间过度耦合。\n\n * 依恋情结\n * 狎昵关系\n * 过度耦合的消息链\n * 中间人\n * 不完美的库类\n\n\n# 3. 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 4. 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring",normalizedContent:"第一次读《重构:改善既有代码的设计》时，我曾整理过一个简单的笔记。最近，因为参与一个重构项目，再一次温习了《重构:改善既有代码的设计》。过程中，萌发了认真总结、整理重构方法的冲动，于是有了这系列文字。\n\n\n# 1. 症与药\n\n\n# 1.1. 对代码的坏味道的思考\n\n“有病要早治，不要放弃治疗”。多么朴素的道理 ，人人都懂。\n\n病，就是不健康。\n\n人有病，可以通过打针、吃药、做手术来进行治疗。\n\n如果把代码的坏味道（代码质量问题）比作病症，那么重构就是治疗代码的坏味道的药。\n\n个人认为，在重构这件事上，也可以应用治病的道理：\n\n * 防患于未然。 —— 春秋战国时期的一代名医扁鹊，曾经有个很著名的医学主张：防患于未然。 我觉得这个道理应用于软件代码的重构亦然。编程前要有合理的设计、编程时要有良好的编程风格，尽量减少问题。从这个层面上说，了解代码的坏味道，不仅仅是为了发现问题、解决问题。更重要的作用是：指导我们在编程过程中有意识的去规避这些问题。\n\n * 小病不医，易得大病。 —— 刘备说过：“勿以善小而不为，勿以恶小而为之”。发现问题就及时修改，代码质量自然容易进入良性循环；反之，亦然。要重视积累的力量，别总以为代码出现点小问题，那都不是事儿。\n\n * 对症下药。 —— 程序出现了问题，要分析出问题的根本，有针对性的制定合理的重构方案。大家都知道吃错药的后果，同样的，瞎改还不如不改。\n\n * 忌猛药 —— 医病用猛药容易产生副作用。换一句俗语：步子大了容易扯着蛋。重构如果大刀阔斧的干，那你就要有随时可能扑街的心理准备。推倒重来不是重构，而是重写。重构应该是循序渐进，步步为营的过程。当你发现重写代码比重构代码更简单，往往说明你早就该重构了。\n\n\n# 1.2. 重构的原则\n\n前面把代码质量问题比作病症，而把重构比作药。这里，我们再进一步讨论一下重构的原则。\n\n# 1.2.1. 何谓重构(what)\n\n重构（refactoring） 的常见定义是：不改变软件系统外部行为的前提下，改善它的内部结构。\n\n个人觉得这个定义有点生涩。不妨理解为：重构是给代码治病的行为。而代码有病是指代码的质量（可靠性、安全性、可复用性、可维护性）和性能有问题。\n\n重构的目的是为了提高代码的质量和性能。\n\n注：功能不全或者不正确，那是残疾代码。就像治病治不了残疾，重构也解决不了功能问题。\n\n# 1.2.2. 为何重构(why)\n\n翻翻书，上网搜一下，谈到重构的理由大体相同：\n\n * 重构改进软件设计\n * 重构使软件更容易理解\n * 重构帮助找到 bug\n * 重构提高编程速度\n\n总之就是，重构可以提高代码质量。\n\n# 1.2.3. 何时重构(when)\n\n关于何时重构，我先引用一下 重构并非难在如何做，而是难在何时开始做 一文的观点。\n\n> 对于一个高速发展的公司来说，停止业务开发，专门来做重构项目，从来就不是一个可接受的选项，“边开飞机边换引擎”才是这种公司想要的。\n\n我们不妨来衡量一下重构的成本和收益。\n\n * 重构的成本\n   \n   重构是有成本的，费时费力（时间、人力）不说，还有可能会使本来正常运行的程序出错。所以，很多人都抱着“不求有功，但求无过”的心理得过且过。\n   \n   还有一种成本：重构使用较新且较为复杂的技术，学习曲线不平滑，团队成员技术切换困难，短期内开发效率可能不升反降。\n   \n   但是，如果一直放任代码腐朽下去，技术债务会越来越沉重。当代码最终快要跑不动时，架构师们往往还是不得不使用激进的手段来治疗代码的顽疾。但是，这个过程通常都是非常痛苦的，而且有着很高的失败风险。\n\n * 重构的收益\n   \n   重构的收益是提高代码的质量和性能，并提高未来的开发效率。但是，应当看到，重构往往并不能在短期内带来实际的效益，或者很难直观看出效益。而对于一个企业来说，没有什么比效益更重要。换句话说，没有实际效益的事，通常也没有价值。很多领导，尤其是非技术方向的领导，并不关心你应用了什么新技术，让代码变得多么优雅等等。\n\n * 重构的合适时机\n   \n   从以上来看，重构实在是个吃力不讨好的事情。\n   \n   于是，很多人屈服于万恶的 kpi 和要命的 deadline，一边吐槽着以前的代码是垃圾，一边自己也在造垃圾。\n   \n   但是，重构本应该是个渐进式的过程，不是只有伤筋动骨的改造才叫重构。如果非要等到代码已经烂到病入膏肓，再使用激进方式来重构，那必然是困难重重，风险极高。\n   \n   《重构》书中提到的重构时机应该在添加功能、修复功能、审查代码时，不建议专门抽出时间专门做重构项目。\n   \n   我认为，其思想就是指：重构应该是在开发过程中实时的、渐进的演化过程。\n\n * 重构的不恰当时机\n   \n   但是，这里我也要强调一下：不是所有软件开发过程都一定要重构。\n   \n   较能凸显重构价值的场景是：代码规模较大、生命周期还较长、承担了较多责任、有一个较大（且较不稳定，人员流动频繁）团队在其上工作的单一代码库。\n   \n   与之相反，有一些场景的重构价值就很小：\n   \n   * 代码库生命周期快要走到尾声，开发逐渐减少，以维护为主。\n   * 代码库当前版本马上要发布了，这时重构无疑是给自己找麻烦。\n   * 重构代价过于沉重：重构后功能的正确性、稳定性难以保障；技术过于超前，团队成员技术迁移难度太大。\n\n# 1.2.4. 如何重构(how)\n\n重构行为在我看来，也是可以分层级的。由高到低，越高层级难度越大：\n\n * 系统架构、集群架构、框架、服务、数据库：这个层面的重构属于战略级重构。现代软件往往业务复杂、庞大。使用微服务、数据迁移来拆分业务，降低业务复杂度成为了主流。但是，这些技术的测试、部署复杂，技术难度很高。\n * 组件、模块、接口：这个层面的重构属于战术级重构。组件、模块、框架的重构，主要是针对代码的设计问题。解决的是代码的整体结构问题。需要对框架、设计模式、分布式、并发等等有足够的了解。\n * 类、接口、函数、字段等：这个层面的重构属于战法级重构。《重构》一书提到了 代码的坏味道 以及相关的重构方法。这些都是对类、接口、函数、字段级别代码的重构手段。由于这一级别的重构方法较为简单，所以可操作性较强。具体细节可以阅读《代码的坏味道》篇章。\n\n前两种层级的重构已经涉及到架构层面，影响较大，难度较高，如果功力不够不要轻易变动。由于这两个层级涉及领域较广，这里不做论述。\n\n此处为分割线。下面是代码的坏味道系列。。。\n\n\n# 2. 代码的坏味道\n\n《重构:改善既有代码的设计》中介绍了 22 种代码的坏味道以及重构手法。这些坏味道可以进一步归类。我总觉得将事物分类有助于理解和记忆。所以本系列将坏味道按照特性分类，然后逐一讲解。\n\n\n\n\n# 2.1. 代码坏味道之代码臃肿\n\n> 代码臃肿(bloated)这组坏味道意味着：代码中的类、函数、字段没有经过合理的组织，只是简单的堆砌起来。这一类型的问题通常在代码的初期并不明显，但是随着代码规模的增长而逐渐积累（特别是当没有人努力去根除它们时）。\n\n * 过长函数\n * 过大的类\n * 基本类型偏执\n * 过长参数列\n * 数据泥团\n\n\n# 2.2. 代码坏味道之滥用面向对象\n\n> 滥用面向对象(object-orientation abusers)这组坏味道意味着：代码部分或完全地违背了面向对象编程原则。\n\n * switch 声明\n * 临时字段\n * 被拒绝的馈赠\n * 异曲同工的类\n\n\n# 2.3. 代码坏味道之变革的障碍\n\n> 变革的障碍(change preventers)这组坏味道意味着：当你需要改变一处代码时，却发现不得不改变其他的地方。这使得程序开发变得复杂、代价高昂。\n\n * 发散式变化\n * 霰弹式修改\n * 平行继承体系\n\n\n# 2.4. 代码坏味道之非必要的\n\n> 非必要的(dispensables)这组坏味道意味着：这样的代码可有可无，它的存在反而影响整体代码的整洁和可读性。\n\n * 过多的注释\n * 重复代码\n * 冗余类\n * 纯稚的数据类\n * 夸夸其谈未来性\n\n\n# 2.5. 代码坏味道之耦合\n\n> 耦合(couplers)这组坏味道意味着：不同类之间过度耦合。\n\n * 依恋情结\n * 狎昵关系\n * 过度耦合的消息链\n * 中间人\n * 不完美的库类\n\n\n# 3. 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 4. 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"代码坏味道之代码臃肿",frontmatter:{title:"代码坏味道之代码臃肿",categories:["设计","重构"],tags:["设计","重构","代码的坏味道"],date:"2018-10-13T22:48:00.000Z",permalink:"/pages/82f4c8/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/03.%E9%87%8D%E6%9E%84/02.%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E4%BB%A3%E7%A0%81%E8%87%83%E8%82%BF.html",relativePath:"03.设计/03.重构/02.代码坏味道之代码臃肿.md",key:"v-c5ef3042",path:"/pages/82f4c8/",headers:[{level:2,title:"1. 基本类型偏执",slug:"_1-基本类型偏执",normalizedTitle:"1. 基本类型偏执",charIndex:176},{level:3,title:"1.1. 问题原因",slug:"_1-1-问题原因",normalizedTitle:"1.1. 问题原因",charIndex:348},{level:3,title:"1.2. 解决方法",slug:"_1-2-解决方法",normalizedTitle:"1.2. 解决方法",charIndex:501},{level:3,title:"1.3. 收益",slug:"_1-3-收益",normalizedTitle:"1.3. 收益",charIndex:1132},{level:3,title:"1.4. 重构方法说明",slug:"_1-4-重构方法说明",normalizedTitle:"1.4. 重构方法说明",charIndex:1261},{level:4,title:"1.4.1. 以类取代类型码(Replace Type Code with Class)",slug:"_1-4-1-以类取代类型码-replace-type-code-with-class",normalizedTitle:"1.4.1. 以类取代类型码(replace type code with class)",charIndex:1276},{level:4,title:"1.4.2. 引入参数对象(Introduce Parameter Object)",slug:"_1-4-2-引入参数对象-introduce-parameter-object",normalizedTitle:"1.4.2. 引入参数对象(introduce parameter object)",charIndex:1378},{level:4,title:"1.4.3. 保持对象完整(Preserve Whole Object)",slug:"_1-4-3-保持对象完整-preserve-whole-object",normalizedTitle:"1.4.3. 保持对象完整(preserve whole object)",charIndex:1467},{level:4,title:"1.4.4. 以子类取代类型码(Replace Type Code with Subclass)",slug:"_1-4-4-以子类取代类型码-replace-type-code-with-subclass",normalizedTitle:"1.4.4. 以子类取代类型码(replace type code with subclass)",charIndex:1736},{level:4,title:"1.4.5. 以状态/策略模式取代类型码(Replace Type Code with State/Strategy)",slug:"_1-4-5-以状态-策略模式取代类型码-replace-type-code-with-state-strategy",normalizedTitle:"1.4.5. 以状态/策略模式取代类型码(replace type code with state/strategy)",charIndex:1836},{level:4,title:"1.4.6. 以对象取代数组(Replace Array with Object)",slug:"_1-4-6-以对象取代数组-replace-array-with-object",normalizedTitle:"1.4.6. 以对象取代数组(replace array with object)",charIndex:1955},{level:2,title:"2. 数据泥团",slug:"_2-数据泥团",normalizedTitle:"2. 数据泥团",charIndex:2216},{level:3,title:"2.1. 问题原因",slug:"_2-1-问题原因",normalizedTitle:"2.1. 问题原因",charIndex:2312},{level:3,title:"2.2. 解决方法",slug:"_2-2-解决方法",normalizedTitle:"2.2. 解决方法",charIndex:2443},{level:3,title:"2.3. 收益",slug:"_2-3-收益",normalizedTitle:"2.3. 收益",charIndex:2698},{level:3,title:"2.4. 何时忽略",slug:"_2-4-何时忽略",normalizedTitle:"2.4. 何时忽略",charIndex:2768},{level:3,title:"2.5. 重构方法说明",slug:"_2-5-重构方法说明",normalizedTitle:"2.5. 重构方法说明",charIndex:2851},{level:4,title:"2.5.1. 提炼类(Extract Class)",slug:"_2-5-1-提炼类-extract-class",normalizedTitle:"2.5.1. 提炼类(extract class)",charIndex:2866},{level:4,title:"2.5.2. 引入参数对象(Introduce Parameter Object)",slug:"_2-5-2-引入参数对象-introduce-parameter-object",normalizedTitle:"2.5.2. 引入参数对象(introduce parameter object)",charIndex:2947},{level:4,title:"2.5.3. 保持对象完整(Preserve Whole Object)",slug:"_2-5-3-保持对象完整-preserve-whole-object",normalizedTitle:"2.5.3. 保持对象完整(preserve whole object)",charIndex:3036},{level:2,title:"3. 过大的类",slug:"_3-过大的类",normalizedTitle:"3. 过大的类",charIndex:3306},{level:3,title:"3.1. 问题原因",slug:"_3-1-问题原因",normalizedTitle:"3.1. 问题原因",charIndex:3364},{level:3,title:"3.2. 解决方法",slug:"_3-2-解决方法",normalizedTitle:"3.2. 解决方法",charIndex:3445},{level:3,title:"3.3. 收益",slug:"_3-3-收益",normalizedTitle:"3.3. 收益",charIndex:3797},{level:3,title:"3.4. 重构方法说明",slug:"_3-4-重构方法说明",normalizedTitle:"3.4. 重构方法说明",charIndex:3873},{level:4,title:"3.4.1. 提炼类(Extract Class)",slug:"_3-4-1-提炼类-extract-class",normalizedTitle:"3.4.1. 提炼类(extract class)",charIndex:3888},{level:4,title:"3.4.2. 提炼子类(Extract Subclass)",slug:"_3-4-2-提炼子类-extract-subclass",normalizedTitle:"3.4.2. 提炼子类(extract subclass)",charIndex:3969},{level:4,title:"3.4.3. 提炼接口(Extract Interface)",slug:"_3-4-3-提炼接口-extract-interface",normalizedTitle:"3.4.3. 提炼接口(extract interface)",charIndex:4057},{level:4,title:"3.4.4. 复制被监视数据(Duplicate Observed Data)",slug:"_3-4-4-复制被监视数据-duplicate-observed-data",normalizedTitle:"3.4.4. 复制被监视数据(duplicate observed data)",charIndex:4157},{level:2,title:"4. 过长函数",slug:"_4-过长函数",normalizedTitle:"4. 过长函数",charIndex:4288},{level:3,title:"4.1. 问题的原因",slug:"_4-1-问题的原因",normalizedTitle:"4.1. 问题的原因",charIndex:4395},{level:3,title:"4.2. 解决函数",slug:"_4-2-解决函数",normalizedTitle:"4.2. 解决函数",charIndex:4605},{level:3,title:"4.3. 收益",slug:"_4-3-收益",normalizedTitle:"4.3. 收益",charIndex:5172},{level:3,title:"4.4. 性能",slug:"_4-4-性能",normalizedTitle:"4.4. 性能",charIndex:5268},{level:3,title:"4.5. 重构方法说明",slug:"_4-5-重构方法说明",normalizedTitle:"4.5. 重构方法说明",charIndex:5385},{level:4,title:"4.5.1. 提炼函数(Extract Method)",slug:"_4-5-1-提炼函数-extract-method",normalizedTitle:"4.5.1. 提炼函数(extract method)",charIndex:5400},{level:4,title:"4.5.2. 以查询取代临时变量(Replace Temp with Query)",slug:"_4-5-2-以查询取代临时变量-replace-temp-with-query",normalizedTitle:"4.5.2. 以查询取代临时变量(replace temp with query)",charIndex:5843},{level:4,title:"4.5.3. 引入参数对象(Introduce Parameter Object)",slug:"_4-5-3-引入参数对象-introduce-parameter-object",normalizedTitle:"4.5.3. 引入参数对象(introduce parameter object)",charIndex:6345},{level:4,title:"4.5.4. 保持对象完整(Preserve Whole Object)",slug:"_4-5-4-保持对象完整-preserve-whole-object",normalizedTitle:"4.5.4. 保持对象完整(preserve whole object)",charIndex:6434},{level:4,title:"4.5.5. 以函数对象取代函数(Replace Method with Method Object)",slug:"_4-5-5-以函数对象取代函数-replace-method-with-method-object",normalizedTitle:"4.5.5. 以函数对象取代函数(replace method with method object)",charIndex:6703},{level:4,title:"4.5.6. 分解条件表达式(Decompose Conditional)",slug:"_4-5-6-分解条件表达式-decompose-conditional",normalizedTitle:"4.5.6. 分解条件表达式(decompose conditional)",charIndex:7466},{level:2,title:"5. 过长参数列",slug:"_5-过长参数列",normalizedTitle:"5. 过长参数列",charIndex:7821},{level:3,title:"5.1. 问题原因",slug:"_5-1-问题原因",normalizedTitle:"5.1. 问题原因",charIndex:7888},{level:3,title:"5.2. 解决方案",slug:"_5-2-解决方案",normalizedTitle:"5.2. 解决方案",charIndex:8148},{level:3,title:"5.3. 收益",slug:"_5-3-收益",normalizedTitle:"5.3. 收益",charIndex:8421},{level:3,title:"5.4. 何时忽略",slug:"_5-4-何时忽略",normalizedTitle:"5.4. 何时忽略",charIndex:8473},{level:3,title:"5.5. 重构方法说明",slug:"_5-5-重构方法说明",normalizedTitle:"5.5. 重构方法说明",charIndex:8606},{level:4,title:"5.5.1. 以函数取代参数(Replace Parameter with Methods)",slug:"_5-5-1-以函数取代参数-replace-parameter-with-methods",normalizedTitle:"5.5.1. 以函数取代参数(replace parameter with methods)",charIndex:8621},{level:4,title:"5.5.2. 保持对象完整(Preserve Whole Object)",slug:"_5-5-2-保持对象完整-preserve-whole-object",normalizedTitle:"5.5.2. 保持对象完整(preserve whole object)",charIndex:9038},{level:4,title:"5.5.3. 引入参数对象(Introduce Parameter Object)",slug:"_5-5-3-引入参数对象-introduce-parameter-object",normalizedTitle:"5.5.3. 引入参数对象(introduce parameter object)",charIndex:9307},{level:2,title:"6. 扩展阅读",slug:"_6-扩展阅读",normalizedTitle:"6. 扩展阅读",charIndex:9397},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:9494}],headersStr:"1. 基本类型偏执 1.1. 问题原因 1.2. 解决方法 1.3. 收益 1.4. 重构方法说明 1.4.1. 以类取代类型码(Replace Type Code with Class) 1.4.2. 引入参数对象(Introduce Parameter Object) 1.4.3. 保持对象完整(Preserve Whole Object) 1.4.4. 以子类取代类型码(Replace Type Code with Subclass) 1.4.5. 以状态/策略模式取代类型码(Replace Type Code with State/Strategy) 1.4.6. 以对象取代数组(Replace Array with Object) 2. 数据泥团 2.1. 问题原因 2.2. 解决方法 2.3. 收益 2.4. 何时忽略 2.5. 重构方法说明 2.5.1. 提炼类(Extract Class) 2.5.2. 引入参数对象(Introduce Parameter Object) 2.5.3. 保持对象完整(Preserve Whole Object) 3. 过大的类 3.1. 问题原因 3.2. 解决方法 3.3. 收益 3.4. 重构方法说明 3.4.1. 提炼类(Extract Class) 3.4.2. 提炼子类(Extract Subclass) 3.4.3. 提炼接口(Extract Interface) 3.4.4. 复制被监视数据(Duplicate Observed Data) 4. 过长函数 4.1. 问题的原因 4.2. 解决函数 4.3. 收益 4.4. 性能 4.5. 重构方法说明 4.5.1. 提炼函数(Extract Method) 4.5.2. 以查询取代临时变量(Replace Temp with Query) 4.5.3. 引入参数对象(Introduce Parameter Object) 4.5.4. 保持对象完整(Preserve Whole Object) 4.5.5. 以函数对象取代函数(Replace Method with Method Object) 4.5.6. 分解条件表达式(Decompose Conditional) 5. 过长参数列 5.1. 问题原因 5.2. 解决方案 5.3. 收益 5.4. 何时忽略 5.5. 重构方法说明 5.5.1. 以函数取代参数(Replace Parameter with Methods) 5.5.2. 保持对象完整(Preserve Whole Object) 5.5.3. 引入参数对象(Introduce Parameter Object) 6. 扩展阅读 7. 参考资料",content:'> 翻译自：https://sourcemaking.com/refactoring/smells/bloaters\n> \n> 代码臃肿(Bloated)这组坏味道意味着：代码中的类、函数、字段没有经过合理的组织，只是简单的堆砌起来。这一类型的问题通常在代码的初期并不明显，但是随着代码规模的增长而逐渐积累（特别是当没有人努力去根除它们时）。\n\n\n# 1. 基本类型偏执\n\n> 基本类型偏执(Primitive Obsession)\n> \n>  * 使用基本类型而不是小对象来实现简单任务（例如货币、范围、电话号码字符串等）。\n>  * 使用常量编码信息（例如一个用于引用管理员权限的常量USER_ADMIN_ROLE = 1 ）。\n>  * 使用字符串常量作为字段名在数组中使用。\n\n\n\n\n# 1.1. 问题原因\n\n类似其他大部分坏味道，基本类型偏执诞生于类初建的时候。一开始，可能只是不多的字段，随着表示的特性越来越多，基本数据类型字段也越来越多。\n\n基本类型常常被用于表示模型的类型。你有一组数字或字符串用来表示某个实体。\n\n还有一个场景：在模拟场景，大量的字符串常量被用于数组的索引。\n\n\n# 1.2. 解决方法\n\n\n\n大多数编程语言都支持基本数据类型和结构类型（类、结构体等）。结构类型允许程序员将基本数据类型组织起来，以代表某一事物的模型。\n\n基本数据类型可以看成是机构类型的积木块。当基本数据类型数量成规模后，将它们有组织地结合起来，可以更方便的管理这些数据。\n\n * 如果你有大量的基本数据类型字段，就有可能将其中部分存在逻辑联系的字段组织起来，形成一个类。更进一步的是，将与这些数据有关联的方法也一并移入类中。为了实现这个目标，可以尝试 以类取代类型码(Replace Type Code with Class) 。\n * 如果基本数据类型字段的值是用于方法的参数，可以使用 引入参数对象(Introduce Parameter Object) 或 保持对象完整(Preserve Whole Object) 。\n * 如果想要替换的数据值是类型码，而它并不影响行为，则可以运用 以类取代类型码(Replace Type Code with Class) 将它替换掉。如果你有与类型码相关的条件表达式，可运用 以子类取代类型码(Replace Type Code with Subclass) 或 以状态/策略模式取代类型码(Replace Type Code with State/Strategy) 加以处理。\n * 如果你发现自己正从数组中挑选数据，可运用 以对象取代数组(Replace Array with Object) 。\n\n\n# 1.3. 收益\n\n * 多亏了使用对象替代基本数据类型，使得代码变得更加灵活。\n * 代码变得更加易读和更加有组织。特殊数据可以集中进行操作，而不像之前那样分散。不用再猜测这些陌生的常量的意义以及它们为什么在数组中。\n * 更容易发现重复代码。\n\n\n\n\n# 1.4. 重构方法说明\n\n# 1.4.1. 以类取代类型码(Replace Type Code with Class)\n\n问题\n\n类之中有一个数值类型码，但它并不影响类的行为。\n\n\n\n解决\n\n以一个新的类替换该数值类型码。\n\n\n\n# 1.4.2. 引入参数对象(Introduce Parameter Object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n# 1.4.3. 保持对象完整(Preserve Whole Object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daysTempRange.getLow();\nint high = daysTempRange.getHigh();\nboolean withinPlan = plan.withinRange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinPlan = plan.withinRange(daysTempRange);\n\n\n# 1.4.4. 以子类取代类型码(Replace Type Code with Subclass)\n\n问题\n\n你有一个不可变的类型码，它会影响类的行为。\n\n\n\n解决\n\n以子类取代这个类型码。\n\n\n\n# 1.4.5. 以状态/策略模式取代类型码(Replace Type Code with State/Strategy)\n\n问题\n\n你有一个类型码，它会影响类的行为，但你无法通过继承消除它。\n\n\n\n解决\n\n以状态对象取代类型码。\n\n\n\n# 1.4.6. 以对象取代数组(Replace Array with Object)\n\n问题\n\n你有一个数组，其中的元素各自代表不同的东西。\n\nString[] row = new String[3];\nrow[0] = "Liverpool";\nrow[1] = "15";\n\n\n解决\n\n以对象替换数组。对于数组中的每个元素，以一个字段来表示。\n\nPerformance row = new Performance();\nrow.setName("Liverpool");\nrow.setWins("15");\n\n\n\n# 2. 数据泥团\n\n> 数据泥团(Data Clumps)\n> \n> 有时，代码的不同部分包含相同的变量组（例如用于连接到数据库的参数）。这些绑在一起出现的数据应该拥有自己的对象。\n\n\n\n\n# 2.1. 问题原因\n\n通常，数据泥团的出现时因为糟糕的编程结构或“复制-粘贴式编程”。\n\n有一个判断是否是数据泥团的好办法：删掉众多数据中的一项。这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是个明确的信号：你应该为它们产生一个新的对象。\n\n\n# 2.2. 解决方法\n\n * 首先找出这些数据以字段形式出现的地方，运用 提炼类(Extract Class) 将它们提炼到一个独立对象中。\n * 如果数据泥团在函数的参数列中出现，运用 引入参数对象(Introduce Parameter Object) 将它们组织成一个类。\n * 如果数据泥团的部分数据出现在其他函数中，考虑运用 保持对象完整(Preserve Whole Object) 将整个数据对象传入到函数中。\n * 检视一下使用这些字段的代码，也许，将它们移入一个数据类是个不错的主意。\n\n\n# 2.3. 收益\n\n * 提高代码易读性和组织性。对于特殊数据的操作，可以集中进行处理，而不像以前那样分散。\n * 减少代码量。\n\n\n\n\n# 2.4. 何时忽略\n\n * 有时为了对象中的部分数据而将整个对象作为参数传递给函数，可能会产生让两个类之间不收欢迎的依赖关系，这中情况下可以不传递整个对象。\n\n\n# 2.5. 重构方法说明\n\n# 2.5.1. 提炼类(Extract Class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 2.5.2. 引入参数对象(Introduce Parameter Object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n# 2.5.3. 保持对象完整(Preserve Whole Object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daysTempRange.getLow();\nint high = daysTempRange.getHigh();\nboolean withinPlan = plan.withinRange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinPlan = plan.withinRange(daysTempRange);\n\n\n\n# 3. 过大的类\n\n> 过大的类(Large Class)\n> \n> 一个类含有过多字段、函数、代码行。\n\n\n\n\n# 3.1. 问题原因\n\n类通常一开始很小，但是随着程序的增长而逐渐膨胀。\n\n类似于过长函数，程序员通常觉得在一个现存类中添加新特性比创建一个新的类要容易。\n\n\n# 3.2. 解决方法\n\n设计模式中有一条重要原则：职责单一原则。一个类应该只赋予它一个职责。如果它所承担的职责太多，就该考虑为它减减负。\n\n\n\n * 如果过大类中的部分行为可以提炼到一个独立的组件中，可以使用 提炼类(Extract Class)。\n * 如果过大类中的部分行为可以用不同方式实现或使用于特殊场景，可以使用 提炼子类(Extract Subclass)。\n * 如果有必要为客户端提供一组操作和行为，可以使用 提炼接口(Extract Interface)。\n * 如果你的过大类是个 GUI 类，可能需要把数据和行为移到一个独立的领域对象去。你可能需要两边各保留一些重复数据，并保持两边同步。 复制被监视数据(Duplicate Observed Data) 可以告诉你怎么做。\n\n\n# 3.3. 收益\n\n * 重构过大的类可以使程序员不必记住一个类中大量的属性。\n * 在大多数情况下，分割过大的类可以避免代码和功能的重复。\n\n\n\n\n# 3.4. 重构方法说明\n\n# 3.4.1. 提炼类(Extract Class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 3.4.2. 提炼子类(Extract Subclass)\n\n问题\n\n一个类中有些特性仅用于特定场景。\n\n\n\n解决\n\n创建一个子类，并将用于特殊场景的特性置入其中。\n\n\n\n# 3.4.3. 提炼接口(Extract Interface)\n\n问题\n\n多个客户端使用一个类部分相同的函数。另一个场景是两个类中的部分函数相同。\n\n\n\n解决\n\n移动相同的部分函数到接口中。\n\n\n\n# 3.4.4. 复制被监视数据(Duplicate Observed Data)\n\n问题\n\n如果存储在类中的数据是负责 GUI 的。\n\n\n\n解决\n\n一个比较好的方法是将负责 GUI 的数据放入一个独立的类，以确保 GUI 数据与域类之间的连接和同步。\n\n\n\n\n# 4. 过长函数\n\n> 过长函数(Long Method)\n> \n> 一个函数含有太多行代码。一般来说，任何函数超过 10 行时，你就可以考虑是不是过长了。 函数中的代码行数原则上不要超过 100 行。\n\n\n\n\n# 4.1. 问题的原因\n\n通常情况下，创建一个新函数的难度要大于添加功能到一个已存在的函数。大部分人都觉得：“我就添加这么两行代码，为此新建一个函数实在是小题大做了。”于是，张三加两行，李四加两行，王五加两行。。。函数日益庞大，最终烂的像一锅浆糊，再也没人能完全看懂了。于是大家就更不敢轻易动这个函数了，只能恶性循环的往其中添加代码。所以，如果你看到一个超过 200 行的函数，通常都是多个程序员东拼西凑出来的。\n\n\n# 4.2. 解决函数\n\n一个很好的技巧是：寻找注释。添加注释，一般有这么几个原因：代码逻辑较为晦涩或复杂；这段代码功能相对独立；特殊处理。 如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。如果函数有一个描述恰当的名字，就不需要去看内部代码究竟是如何实现的。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中。\n\n\n\n * 为了给一个函数瘦身，可以使用 提炼函数(Extract Method)。\n * 如果局部变量和参数干扰提炼函数，可以使用 以查询取代临时变量(Replace Temp with Query)，引入参数对象(Introduce Parameter Object) 或 保持对象完整(Preserve Whole Object) 。\n * 如果前面两条没有帮助，可以通过 以函数对象取代函数(Replace Method with Method Object) 尝试移动整个函数到一个独立的对象中。\n * 条件表达式和循环常常也是提炼的信号。对于条件表达式，可以使用 分解条件表达式(Decompose Conditional) 。至于循环，应该使用 提炼函数(Extract Method) 将循环和其内的代码提炼到独立函数中。\n\n\n# 4.3. 收益\n\n * 在所有类型的面向对象代码中，函数比较短小精悍的类往往生命周期较长。一个函数越长，就越不容易理解和维护。\n * 此外，过长函数中往往含有难以发现的重复代码。\n\n\n\n\n# 4.4. 性能\n\n是否像许多人说的那样，增加函数的数量会影响性能？在几乎绝大多数情况下，这种影响是可以忽略不计，所以不用担心。 此外，现在有了清晰和易读的代码，在需要的时候，你将更容易找到真正有效的函数来重组代码和提高性能。\n\n\n# 4.5. 重构方法说明\n\n# 4.5.1. 提炼函数(Extract Method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printOwing() {\n  printBanner();\n\n  //print details\n  System.out.println("name: " + name);\n  System.out.println("amount: " + getOutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printOwing() {\n  printBanner();\n  printDetails(getOutstanding());\n}\n\nvoid printDetails(double outstanding) {\n  System.out.println("name: " + name);\n  System.out.println("amount: " + outstanding);\n}\n\n\n# 4.5.2. 以查询取代临时变量(Replace Temp with Query)\n\n问题\n\n将表达式的结果放在局部变量中，然后在代码中使用。\n\ndouble calculateTotal() {\n  double basePrice = quantity * itemPrice;\n  if (basePrice > 1000) {\n    return basePrice * 0.95;\n  }\n  else {\n    return basePrice * 0.98;\n  }\n}\n\n\n解决\n\n将整个表达式移动到一个独立的函数中并返回结果。使用查询函数来替代使用变量。如果需要，可以在其他函数中合并新函数。\n\ndouble calculateTotal() {\n  if (basePrice() > 1000) {\n    return basePrice() * 0.95;\n  }\n  else {\n    return basePrice() * 0.98;\n  }\n}\ndouble basePrice() {\n  return quantity * itemPrice;\n}\n\n\n# 4.5.3. 引入参数对象(Introduce Parameter Object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n# 4.5.4. 保持对象完整(Preserve Whole Object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daysTempRange.getLow();\nint high = daysTempRange.getHigh();\nboolean withinPlan = plan.withinRange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinPlan = plan.withinRange(daysTempRange);\n\n\n# 4.5.5. 以函数对象取代函数(Replace Method with Method Object)\n\n问题\n\n你有一个过长函数，它的局部变量交织在一起，以致于你无法应用提炼函数(Extract Method) 。\n\nclass Order {\n  //...\n  public double price() {\n    double primaryBasePrice;\n    double secondaryBasePrice;\n    double tertiaryBasePrice;\n    // long computation.\n    //...\n  }\n}\n\n\n解决\n\n将函数移到一个独立的类中，使得局部变量成了这个类的字段。然后，你可以将函数分割成这个类中的多个函数。\n\nclass Order {\n  //...\n  public double price() {\n    return new PriceCalculator(this).compute();\n  }\n}\n\nclass PriceCalculator {\n  private double primaryBasePrice;\n  private double secondaryBasePrice;\n  private double tertiaryBasePrice;\n\n  public PriceCalculator(Order order) {\n    // copy relevant information from order object.\n    //...\n  }\n\n  public double compute() {\n    // long computation.\n    //...\n  }\n}\n\n\n# 4.5.6. 分解条件表达式(Decompose Conditional)\n\n问题\n\n你有复杂的条件表达式。\n\nif (date.before(SUMMER_START) || date.after(SUMMER_END)) {\n  charge = quantity * winterRate + winterServiceCharge;\n}\nelse {\n  charge = quantity * summerRate;\n}\n\n\n解决\n\n根据条件分支将整个条件表达式分解成几个函数。\n\nif (notSummer(date)) {\n  charge = winterCharge(quantity);\n}\nelse {\n  charge = summerCharge(quantity);\n}\n\n\n\n# 5. 过长参数列\n\n> 过长参数列(Long Parameter List)\n> \n> 一个函数有超过 3、4 个入参。\n\n\n\n\n# 5.1. 问题原因\n\n过长参数列可能是将多个算法并到一个函数中时发生的。函数中的入参可以用来控制最终选用哪个算法去执行。\n\n过长参数列也可能是解耦类之间依赖关系时的副产品。例如，用于创建函数中所需的特定对象的代码已从函数移动到调用函数的代码处，但创建的对象是作为参数传递到函数中。因此，原始类不再知道对象之间的关系，并且依赖性也已经减少。但是如果创建的这些对象，每一个都将需要它自己的参数，这意味着过长参数列。\n\n太长的参数列难以理解，太多参数会造成前后不一致、不易使用，而且一旦需要更多数据，就不得不修改它。\n\n\n# 5.2. 解决方案\n\n\n\n * 如果向已有的对象发出一条请求就可以取代一个参数，那么你应该使用 以函数取代参数(Replace Parameter with Methods) 。在这里，，“已有的对象”可能是函数所属类里的一个字段，也可能是另一个参数。\n * 你还可以运用 保持对象完整(Preserve Whole Object) 将来自同一对象的一堆数据收集起来，并以该对象替换它们。\n * 如果某些数据缺乏合理的对象归属，可使用 引入参数对象(Introduce Parameter Object) 为它们制造出一个“参数对象”。\n\n\n# 5.3. 收益\n\n * 更易读，更简短的代码。\n * 重构可能会暴露出之前未注意到的重复代码。\n\n\n# 5.4. 何时忽略\n\n * 这里有一个重要的例外：有时候你明显不想造成"被调用对象"与"较大对象"间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情理。但是请注意其所引发的代价。如果参数列太长或变化太频繁，就需要重新考虑自己的依赖结构了。\n\n\n# 5.5. 重构方法说明\n\n# 5.5.1. 以函数取代参数(Replace Parameter with Methods)\n\n问题\n\n对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。\n\nint basePrice = quantity * itemPrice;\ndouble seasonDiscount = this.getSeasonalDiscount();\ndouble fees = this.getFees();\ndouble finalPrice = discountedPrice(basePrice, seasonDiscount, fees);\n\n\n解决\n\n让参数接受者去除该项参数，并直接调用前一个函数。\n\nint basePrice = quantity * itemPrice;\ndouble finalPrice = discountedPrice(basePrice);\n\n\n# 5.5.2. 保持对象完整(Preserve Whole Object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daysTempRange.getLow();\nint high = daysTempRange.getHigh();\nboolean withinPlan = plan.withinRange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinPlan = plan.withinRange(daysTempRange);\n\n\n# 5.5.3. 引入参数对象(Introduce Parameter Object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n\n# 6. 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 7. 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',normalizedContent:'> 翻译自：https://sourcemaking.com/refactoring/smells/bloaters\n> \n> 代码臃肿(bloated)这组坏味道意味着：代码中的类、函数、字段没有经过合理的组织，只是简单的堆砌起来。这一类型的问题通常在代码的初期并不明显，但是随着代码规模的增长而逐渐积累（特别是当没有人努力去根除它们时）。\n\n\n# 1. 基本类型偏执\n\n> 基本类型偏执(primitive obsession)\n> \n>  * 使用基本类型而不是小对象来实现简单任务（例如货币、范围、电话号码字符串等）。\n>  * 使用常量编码信息（例如一个用于引用管理员权限的常量user_admin_role = 1 ）。\n>  * 使用字符串常量作为字段名在数组中使用。\n\n\n\n\n# 1.1. 问题原因\n\n类似其他大部分坏味道，基本类型偏执诞生于类初建的时候。一开始，可能只是不多的字段，随着表示的特性越来越多，基本数据类型字段也越来越多。\n\n基本类型常常被用于表示模型的类型。你有一组数字或字符串用来表示某个实体。\n\n还有一个场景：在模拟场景，大量的字符串常量被用于数组的索引。\n\n\n# 1.2. 解决方法\n\n\n\n大多数编程语言都支持基本数据类型和结构类型（类、结构体等）。结构类型允许程序员将基本数据类型组织起来，以代表某一事物的模型。\n\n基本数据类型可以看成是机构类型的积木块。当基本数据类型数量成规模后，将它们有组织地结合起来，可以更方便的管理这些数据。\n\n * 如果你有大量的基本数据类型字段，就有可能将其中部分存在逻辑联系的字段组织起来，形成一个类。更进一步的是，将与这些数据有关联的方法也一并移入类中。为了实现这个目标，可以尝试 以类取代类型码(replace type code with class) 。\n * 如果基本数据类型字段的值是用于方法的参数，可以使用 引入参数对象(introduce parameter object) 或 保持对象完整(preserve whole object) 。\n * 如果想要替换的数据值是类型码，而它并不影响行为，则可以运用 以类取代类型码(replace type code with class) 将它替换掉。如果你有与类型码相关的条件表达式，可运用 以子类取代类型码(replace type code with subclass) 或 以状态/策略模式取代类型码(replace type code with state/strategy) 加以处理。\n * 如果你发现自己正从数组中挑选数据，可运用 以对象取代数组(replace array with object) 。\n\n\n# 1.3. 收益\n\n * 多亏了使用对象替代基本数据类型，使得代码变得更加灵活。\n * 代码变得更加易读和更加有组织。特殊数据可以集中进行操作，而不像之前那样分散。不用再猜测这些陌生的常量的意义以及它们为什么在数组中。\n * 更容易发现重复代码。\n\n\n\n\n# 1.4. 重构方法说明\n\n# 1.4.1. 以类取代类型码(replace type code with class)\n\n问题\n\n类之中有一个数值类型码，但它并不影响类的行为。\n\n\n\n解决\n\n以一个新的类替换该数值类型码。\n\n\n\n# 1.4.2. 引入参数对象(introduce parameter object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n# 1.4.3. 保持对象完整(preserve whole object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daystemprange.getlow();\nint high = daystemprange.gethigh();\nboolean withinplan = plan.withinrange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinplan = plan.withinrange(daystemprange);\n\n\n# 1.4.4. 以子类取代类型码(replace type code with subclass)\n\n问题\n\n你有一个不可变的类型码，它会影响类的行为。\n\n\n\n解决\n\n以子类取代这个类型码。\n\n\n\n# 1.4.5. 以状态/策略模式取代类型码(replace type code with state/strategy)\n\n问题\n\n你有一个类型码，它会影响类的行为，但你无法通过继承消除它。\n\n\n\n解决\n\n以状态对象取代类型码。\n\n\n\n# 1.4.6. 以对象取代数组(replace array with object)\n\n问题\n\n你有一个数组，其中的元素各自代表不同的东西。\n\nstring[] row = new string[3];\nrow[0] = "liverpool";\nrow[1] = "15";\n\n\n解决\n\n以对象替换数组。对于数组中的每个元素，以一个字段来表示。\n\nperformance row = new performance();\nrow.setname("liverpool");\nrow.setwins("15");\n\n\n\n# 2. 数据泥团\n\n> 数据泥团(data clumps)\n> \n> 有时，代码的不同部分包含相同的变量组（例如用于连接到数据库的参数）。这些绑在一起出现的数据应该拥有自己的对象。\n\n\n\n\n# 2.1. 问题原因\n\n通常，数据泥团的出现时因为糟糕的编程结构或“复制-粘贴式编程”。\n\n有一个判断是否是数据泥团的好办法：删掉众多数据中的一项。这么做，其他数据有没有因而失去意义？如果它们不再有意义，这就是个明确的信号：你应该为它们产生一个新的对象。\n\n\n# 2.2. 解决方法\n\n * 首先找出这些数据以字段形式出现的地方，运用 提炼类(extract class) 将它们提炼到一个独立对象中。\n * 如果数据泥团在函数的参数列中出现，运用 引入参数对象(introduce parameter object) 将它们组织成一个类。\n * 如果数据泥团的部分数据出现在其他函数中，考虑运用 保持对象完整(preserve whole object) 将整个数据对象传入到函数中。\n * 检视一下使用这些字段的代码，也许，将它们移入一个数据类是个不错的主意。\n\n\n# 2.3. 收益\n\n * 提高代码易读性和组织性。对于特殊数据的操作，可以集中进行处理，而不像以前那样分散。\n * 减少代码量。\n\n\n\n\n# 2.4. 何时忽略\n\n * 有时为了对象中的部分数据而将整个对象作为参数传递给函数，可能会产生让两个类之间不收欢迎的依赖关系，这中情况下可以不传递整个对象。\n\n\n# 2.5. 重构方法说明\n\n# 2.5.1. 提炼类(extract class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 2.5.2. 引入参数对象(introduce parameter object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n# 2.5.3. 保持对象完整(preserve whole object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daystemprange.getlow();\nint high = daystemprange.gethigh();\nboolean withinplan = plan.withinrange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinplan = plan.withinrange(daystemprange);\n\n\n\n# 3. 过大的类\n\n> 过大的类(large class)\n> \n> 一个类含有过多字段、函数、代码行。\n\n\n\n\n# 3.1. 问题原因\n\n类通常一开始很小，但是随着程序的增长而逐渐膨胀。\n\n类似于过长函数，程序员通常觉得在一个现存类中添加新特性比创建一个新的类要容易。\n\n\n# 3.2. 解决方法\n\n设计模式中有一条重要原则：职责单一原则。一个类应该只赋予它一个职责。如果它所承担的职责太多，就该考虑为它减减负。\n\n\n\n * 如果过大类中的部分行为可以提炼到一个独立的组件中，可以使用 提炼类(extract class)。\n * 如果过大类中的部分行为可以用不同方式实现或使用于特殊场景，可以使用 提炼子类(extract subclass)。\n * 如果有必要为客户端提供一组操作和行为，可以使用 提炼接口(extract interface)。\n * 如果你的过大类是个 gui 类，可能需要把数据和行为移到一个独立的领域对象去。你可能需要两边各保留一些重复数据，并保持两边同步。 复制被监视数据(duplicate observed data) 可以告诉你怎么做。\n\n\n# 3.3. 收益\n\n * 重构过大的类可以使程序员不必记住一个类中大量的属性。\n * 在大多数情况下，分割过大的类可以避免代码和功能的重复。\n\n\n\n\n# 3.4. 重构方法说明\n\n# 3.4.1. 提炼类(extract class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 3.4.2. 提炼子类(extract subclass)\n\n问题\n\n一个类中有些特性仅用于特定场景。\n\n\n\n解决\n\n创建一个子类，并将用于特殊场景的特性置入其中。\n\n\n\n# 3.4.3. 提炼接口(extract interface)\n\n问题\n\n多个客户端使用一个类部分相同的函数。另一个场景是两个类中的部分函数相同。\n\n\n\n解决\n\n移动相同的部分函数到接口中。\n\n\n\n# 3.4.4. 复制被监视数据(duplicate observed data)\n\n问题\n\n如果存储在类中的数据是负责 gui 的。\n\n\n\n解决\n\n一个比较好的方法是将负责 gui 的数据放入一个独立的类，以确保 gui 数据与域类之间的连接和同步。\n\n\n\n\n# 4. 过长函数\n\n> 过长函数(long method)\n> \n> 一个函数含有太多行代码。一般来说，任何函数超过 10 行时，你就可以考虑是不是过长了。 函数中的代码行数原则上不要超过 100 行。\n\n\n\n\n# 4.1. 问题的原因\n\n通常情况下，创建一个新函数的难度要大于添加功能到一个已存在的函数。大部分人都觉得：“我就添加这么两行代码，为此新建一个函数实在是小题大做了。”于是，张三加两行，李四加两行，王五加两行。。。函数日益庞大，最终烂的像一锅浆糊，再也没人能完全看懂了。于是大家就更不敢轻易动这个函数了，只能恶性循环的往其中添加代码。所以，如果你看到一个超过 200 行的函数，通常都是多个程序员东拼西凑出来的。\n\n\n# 4.2. 解决函数\n\n一个很好的技巧是：寻找注释。添加注释，一般有这么几个原因：代码逻辑较为晦涩或复杂；这段代码功能相对独立；特殊处理。 如果代码前方有一行注释，就是在提醒你：可以将这段代码替换成一个函数，而且可以在注释的基础上给这个函数命名。如果函数有一个描述恰当的名字，就不需要去看内部代码究竟是如何实现的。就算只有一行代码，如果它需要以注释来说明，那也值得将它提炼到独立函数中。\n\n\n\n * 为了给一个函数瘦身，可以使用 提炼函数(extract method)。\n * 如果局部变量和参数干扰提炼函数，可以使用 以查询取代临时变量(replace temp with query)，引入参数对象(introduce parameter object) 或 保持对象完整(preserve whole object) 。\n * 如果前面两条没有帮助，可以通过 以函数对象取代函数(replace method with method object) 尝试移动整个函数到一个独立的对象中。\n * 条件表达式和循环常常也是提炼的信号。对于条件表达式，可以使用 分解条件表达式(decompose conditional) 。至于循环，应该使用 提炼函数(extract method) 将循环和其内的代码提炼到独立函数中。\n\n\n# 4.3. 收益\n\n * 在所有类型的面向对象代码中，函数比较短小精悍的类往往生命周期较长。一个函数越长，就越不容易理解和维护。\n * 此外，过长函数中往往含有难以发现的重复代码。\n\n\n\n\n# 4.4. 性能\n\n是否像许多人说的那样，增加函数的数量会影响性能？在几乎绝大多数情况下，这种影响是可以忽略不计，所以不用担心。 此外，现在有了清晰和易读的代码，在需要的时候，你将更容易找到真正有效的函数来重组代码和提高性能。\n\n\n# 4.5. 重构方法说明\n\n# 4.5.1. 提炼函数(extract method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printowing() {\n  printbanner();\n\n  //print details\n  system.out.println("name: " + name);\n  system.out.println("amount: " + getoutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printowing() {\n  printbanner();\n  printdetails(getoutstanding());\n}\n\nvoid printdetails(double outstanding) {\n  system.out.println("name: " + name);\n  system.out.println("amount: " + outstanding);\n}\n\n\n# 4.5.2. 以查询取代临时变量(replace temp with query)\n\n问题\n\n将表达式的结果放在局部变量中，然后在代码中使用。\n\ndouble calculatetotal() {\n  double baseprice = quantity * itemprice;\n  if (baseprice > 1000) {\n    return baseprice * 0.95;\n  }\n  else {\n    return baseprice * 0.98;\n  }\n}\n\n\n解决\n\n将整个表达式移动到一个独立的函数中并返回结果。使用查询函数来替代使用变量。如果需要，可以在其他函数中合并新函数。\n\ndouble calculatetotal() {\n  if (baseprice() > 1000) {\n    return baseprice() * 0.95;\n  }\n  else {\n    return baseprice() * 0.98;\n  }\n}\ndouble baseprice() {\n  return quantity * itemprice;\n}\n\n\n# 4.5.3. 引入参数对象(introduce parameter object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n# 4.5.4. 保持对象完整(preserve whole object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daystemprange.getlow();\nint high = daystemprange.gethigh();\nboolean withinplan = plan.withinrange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinplan = plan.withinrange(daystemprange);\n\n\n# 4.5.5. 以函数对象取代函数(replace method with method object)\n\n问题\n\n你有一个过长函数，它的局部变量交织在一起，以致于你无法应用提炼函数(extract method) 。\n\nclass order {\n  //...\n  public double price() {\n    double primarybaseprice;\n    double secondarybaseprice;\n    double tertiarybaseprice;\n    // long computation.\n    //...\n  }\n}\n\n\n解决\n\n将函数移到一个独立的类中，使得局部变量成了这个类的字段。然后，你可以将函数分割成这个类中的多个函数。\n\nclass order {\n  //...\n  public double price() {\n    return new pricecalculator(this).compute();\n  }\n}\n\nclass pricecalculator {\n  private double primarybaseprice;\n  private double secondarybaseprice;\n  private double tertiarybaseprice;\n\n  public pricecalculator(order order) {\n    // copy relevant information from order object.\n    //...\n  }\n\n  public double compute() {\n    // long computation.\n    //...\n  }\n}\n\n\n# 4.5.6. 分解条件表达式(decompose conditional)\n\n问题\n\n你有复杂的条件表达式。\n\nif (date.before(summer_start) || date.after(summer_end)) {\n  charge = quantity * winterrate + winterservicecharge;\n}\nelse {\n  charge = quantity * summerrate;\n}\n\n\n解决\n\n根据条件分支将整个条件表达式分解成几个函数。\n\nif (notsummer(date)) {\n  charge = wintercharge(quantity);\n}\nelse {\n  charge = summercharge(quantity);\n}\n\n\n\n# 5. 过长参数列\n\n> 过长参数列(long parameter list)\n> \n> 一个函数有超过 3、4 个入参。\n\n\n\n\n# 5.1. 问题原因\n\n过长参数列可能是将多个算法并到一个函数中时发生的。函数中的入参可以用来控制最终选用哪个算法去执行。\n\n过长参数列也可能是解耦类之间依赖关系时的副产品。例如，用于创建函数中所需的特定对象的代码已从函数移动到调用函数的代码处，但创建的对象是作为参数传递到函数中。因此，原始类不再知道对象之间的关系，并且依赖性也已经减少。但是如果创建的这些对象，每一个都将需要它自己的参数，这意味着过长参数列。\n\n太长的参数列难以理解，太多参数会造成前后不一致、不易使用，而且一旦需要更多数据，就不得不修改它。\n\n\n# 5.2. 解决方案\n\n\n\n * 如果向已有的对象发出一条请求就可以取代一个参数，那么你应该使用 以函数取代参数(replace parameter with methods) 。在这里，，“已有的对象”可能是函数所属类里的一个字段，也可能是另一个参数。\n * 你还可以运用 保持对象完整(preserve whole object) 将来自同一对象的一堆数据收集起来，并以该对象替换它们。\n * 如果某些数据缺乏合理的对象归属，可使用 引入参数对象(introduce parameter object) 为它们制造出一个“参数对象”。\n\n\n# 5.3. 收益\n\n * 更易读，更简短的代码。\n * 重构可能会暴露出之前未注意到的重复代码。\n\n\n# 5.4. 何时忽略\n\n * 这里有一个重要的例外：有时候你明显不想造成"被调用对象"与"较大对象"间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情理。但是请注意其所引发的代价。如果参数列太长或变化太频繁，就需要重新考虑自己的依赖结构了。\n\n\n# 5.5. 重构方法说明\n\n# 5.5.1. 以函数取代参数(replace parameter with methods)\n\n问题\n\n对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。\n\nint baseprice = quantity * itemprice;\ndouble seasondiscount = this.getseasonaldiscount();\ndouble fees = this.getfees();\ndouble finalprice = discountedprice(baseprice, seasondiscount, fees);\n\n\n解决\n\n让参数接受者去除该项参数，并直接调用前一个函数。\n\nint baseprice = quantity * itemprice;\ndouble finalprice = discountedprice(baseprice);\n\n\n# 5.5.2. 保持对象完整(preserve whole object)\n\n问题\n\n你从某个对象中取出若干值，将它们作为某一次函数调用时的参数。\n\nint low = daystemprange.getlow();\nint high = daystemprange.gethigh();\nboolean withinplan = plan.withinrange(low, high);\n\n\n解决\n\n改为传递整个对象。\n\nboolean withinplan = plan.withinrange(daystemprange);\n\n\n# 5.5.3. 引入参数对象(introduce parameter object)\n\n问题\n\n某些参数总是很自然地同时出现。\n\n\n\n解决\n\n以一个对象来取代这些参数。\n\n\n\n\n# 6. 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 7. 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"代码坏味道之滥用面向对象",frontmatter:{title:"代码坏味道之滥用面向对象",categories:["设计","重构"],tags:["设计","重构"],date:"2018-10-13T22:48:00.000Z",permalink:"/pages/9ae679/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/03.%E9%87%8D%E6%9E%84/03.%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E6%BB%A5%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"03.设计/03.重构/03.代码坏味道之滥用面向对象.md",key:"v-ce0e8fd4",path:"/pages/9ae679/",headers:[{level:2,title:"1. Switch 声明",slug:"_1-switch-声明",normalizedTitle:"1. switch 声明",charIndex:134},{level:3,title:"1.1. 问题原因",slug:"_1-1-问题原因",normalizedTitle:"1.1. 问题原因",charIndex:218},{level:3,title:"1.2. 解决方法",slug:"_1-2-解决方法",normalizedTitle:"1.2. 解决方法",charIndex:430},{level:3,title:"1.3. 收益",slug:"_1-3-收益",normalizedTitle:"1.3. 收益",charIndex:960},{level:3,title:"1.4. 何时忽略",slug:"_1-4-何时忽略",normalizedTitle:"1.4. 何时忽略",charIndex:987},{level:3,title:"1.5. 重构方法说明",slug:"_1-5-重构方法说明",normalizedTitle:"1.5. 重构方法说明",charIndex:1125},{level:4,title:"1.5.1. 提炼函数(Extract Method)",slug:"_1-5-1-提炼函数-extract-method",normalizedTitle:"1.5.1. 提炼函数(extract method)",charIndex:1140},{level:4,title:"1.5.2. 搬移函数(Move Method)",slug:"_1-5-2-搬移函数-move-method",normalizedTitle:"1.5.2. 搬移函数(move method)",charIndex:1583},{level:4,title:"1.5.3. 以子类取代类型码(Replace Type Code with Subclass)",slug:"_1-5-3-以子类取代类型码-replace-type-code-with-subclass",normalizedTitle:"1.5.3. 以子类取代类型码(replace type code with subclass)",charIndex:1720},{level:4,title:"1.5.4. 以状态/策略模式取代类型码(Replace Type Code with State/Strategy)",slug:"_1-5-4-以状态-策略模式取代类型码-replace-type-code-with-state-strategy",normalizedTitle:"1.5.4. 以状态/策略模式取代类型码(replace type code with state/strategy)",charIndex:1820},{level:4,title:"1.5.5. 以多态取代条件表达式(Replace Conditional with Polymorphism)",slug:"_1-5-5-以多态取代条件表达式-replace-conditional-with-polymorphism",normalizedTitle:"1.5.5. 以多态取代条件表达式(replace conditional with polymorphism)",charIndex:1939},{level:4,title:"1.5.6. 以明确函数取代参数(Replace Parameter with Explicit Methods)",slug:"_1-5-6-以明确函数取代参数-replace-parameter-with-explicit-methods",normalizedTitle:"1.5.6. 以明确函数取代参数(replace parameter with explicit methods)",charIndex:2878},{level:4,title:"1.5.7. 引入 Null 对象(Introduce Null Object)",slug:"_1-5-7-引入-null-对象-introduce-null-object",normalizedTitle:"1.5.7. 引入 null 对象(introduce null object)",charIndex:3296},{level:2,title:"2. 临时字段",slug:"_2-临时字段",normalizedTitle:"2. 临时字段",charIndex:3808},{level:3,title:"2.1. 问题原因",slug:"_2-1-问题原因",normalizedTitle:"2.1. 问题原因",charIndex:3877},{level:3,title:"2.2. 解决方法",slug:"_2-2-解决方法",normalizedTitle:"2.2. 解决方法",charIndex:4110},{level:3,title:"2.3. 收益",slug:"_2-3-收益",normalizedTitle:"2.3. 收益",charIndex:4319},{level:3,title:"2.4. 重构方法说明",slug:"_2-4-重构方法说明",normalizedTitle:"2.4. 重构方法说明",charIndex:4351},{level:4,title:"2.4.1. 提炼类(Extract Class)",slug:"_2-4-1-提炼类-extract-class",normalizedTitle:"2.4.1. 提炼类(extract class)",charIndex:4366},{level:4,title:"2.4.2. 以函数对象取代函数(Replace Method with Method Object)",slug:"_2-4-2-以函数对象取代函数-replace-method-with-method-object",normalizedTitle:"2.4.2. 以函数对象取代函数(replace method with method object)",charIndex:4447},{level:4,title:"2.4.3. 引入 Null 对象(Introduce Null Object)",slug:"_2-4-3-引入-null-对象-introduce-null-object",normalizedTitle:"2.4.3. 引入 null 对象(introduce null object)",charIndex:5210},{level:2,title:"3. 异曲同工的类",slug:"_3-异曲同工的类",normalizedTitle:"3. 异曲同工的类",charIndex:5722},{level:3,title:"3.1. 问题原因",slug:"_3-1-问题原因",normalizedTitle:"3.1. 问题原因",charIndex:5822},{level:3,title:"3.2. 解决方法",slug:"_3-2-解决方法",normalizedTitle:"3.2. 解决方法",charIndex:5876},{level:3,title:"3.3. 收益",slug:"_3-3-收益",normalizedTitle:"3.3. 收益",charIndex:6147},{level:3,title:"3.4. 何时忽略",slug:"_3-4-何时忽略",normalizedTitle:"3.4. 何时忽略",charIndex:6216},{level:3,title:"3.5. 重构方法说明",slug:"_3-5-重构方法说明",normalizedTitle:"3.5. 重构方法说明",charIndex:6286},{level:4,title:"3.5.1. 函数改名(Rename Method)",slug:"_3-5-1-函数改名-rename-method",normalizedTitle:"3.5.1. 函数改名(rename method)",charIndex:6301},{level:4,title:"3.5.2. 搬移函数(Move Method)",slug:"_3-5-2-搬移函数-move-method",normalizedTitle:"3.5.2. 搬移函数(move method)",charIndex:6464},{level:4,title:"3.5.3. 添加参数(Add Parameter)",slug:"_3-5-3-添加参数-add-parameter",normalizedTitle:"3.5.3. 添加参数(add parameter)",charIndex:6601},{level:4,title:"3.5.4. 令函数携带参数(Parameterize Method)",slug:"_3-5-4-令函数携带参数-parameterize-method",normalizedTitle:"3.5.4. 令函数携带参数(parameterize method)",charIndex:6797},{level:4,title:"3.5.5. 提炼超类(Extract Superclass)",slug:"_3-5-5-提炼超类-extract-superclass",normalizedTitle:"3.5.5. 提炼超类(extract superclass)",charIndex:6897},{level:2,title:"4. 被拒绝的馈赠",slug:"_4-被拒绝的馈赠",normalizedTitle:"4. 被拒绝的馈赠",charIndex:6980},{level:3,title:"4.1. 问题原因",slug:"_4-1-问题原因",normalizedTitle:"4.1. 问题原因",charIndex:7062},{level:3,title:"4.2. 解决方法",slug:"_4-2-解决方法",normalizedTitle:"4.2. 解决方法",charIndex:7116},{level:3,title:"4.3. 收益",slug:"_4-3-收益",normalizedTitle:"4.3. 收益",charIndex:7319},{level:3,title:"4.4. 重构方法说明",slug:"_4-4-重构方法说明",normalizedTitle:"4.4. 重构方法说明",charIndex:7351},{level:4,title:"4.4.1. 以委托取代继承(Replace Inheritance with Delegation)",slug:"_4-4-1-以委托取代继承-replace-inheritance-with-delegation",normalizedTitle:"4.4.1. 以委托取代继承(replace inheritance with delegation)",charIndex:7366},{level:4,title:"4.4.2. 提炼超类(Extract Superclass)",slug:"_4-4-2-提炼超类-extract-superclass",normalizedTitle:"4.4.2. 提炼超类(extract superclass)",charIndex:7530},{level:2,title:"5. 扩展阅读",slug:"_5-扩展阅读",normalizedTitle:"5. 扩展阅读",charIndex:7613},{level:2,title:"6. 参考资料",slug:"_6-参考资料",normalizedTitle:"6. 参考资料",charIndex:7710}],headersStr:"1. Switch 声明 1.1. 问题原因 1.2. 解决方法 1.3. 收益 1.4. 何时忽略 1.5. 重构方法说明 1.5.1. 提炼函数(Extract Method) 1.5.2. 搬移函数(Move Method) 1.5.3. 以子类取代类型码(Replace Type Code with Subclass) 1.5.4. 以状态/策略模式取代类型码(Replace Type Code with State/Strategy) 1.5.5. 以多态取代条件表达式(Replace Conditional with Polymorphism) 1.5.6. 以明确函数取代参数(Replace Parameter with Explicit Methods) 1.5.7. 引入 Null 对象(Introduce Null Object) 2. 临时字段 2.1. 问题原因 2.2. 解决方法 2.3. 收益 2.4. 重构方法说明 2.4.1. 提炼类(Extract Class) 2.4.2. 以函数对象取代函数(Replace Method with Method Object) 2.4.3. 引入 Null 对象(Introduce Null Object) 3. 异曲同工的类 3.1. 问题原因 3.2. 解决方法 3.3. 收益 3.4. 何时忽略 3.5. 重构方法说明 3.5.1. 函数改名(Rename Method) 3.5.2. 搬移函数(Move Method) 3.5.3. 添加参数(Add Parameter) 3.5.4. 令函数携带参数(Parameterize Method) 3.5.5. 提炼超类(Extract Superclass) 4. 被拒绝的馈赠 4.1. 问题原因 4.2. 解决方法 4.3. 收益 4.4. 重构方法说明 4.4.1. 以委托取代继承(Replace Inheritance with Delegation) 4.4.2. 提炼超类(Extract Superclass) 5. 扩展阅读 6. 参考资料",content:'> 翻译自：https://sourcemaking.com/refactoring/smells/oo-abusers\n> \n> 滥用面向对象(Object-Orientation Abusers)这组坏味道意味着：代码部分或完全地违背了面向对象编程原则。\n\n\n# 1. Switch 声明\n\n> Switch 声明(Switch Statements)\n> \n> 你有一个复杂的 switch 语句或 if 序列语句。\n\n\n\n\n# 1.1. 问题原因\n\n面向对象程序的一个最明显特征就是：少用 switch 和 case 语句。从本质上说，switch 语句的问题在于重复（if 序列也同样如此）。你常会发现 switch 语句散布于不同地点。如果要为它添加一个新的 case 子句，就必须找到所有 switch 语句并修改它们。面向对象中的多态概念可为此带来优雅的解决办法。\n\n大多数时候，一看到 switch 语句，就应该考虑以多态来替换它。\n\n\n# 1.2. 解决方法\n\n * 问题是多态该出现在哪？switch 语句常常根据类型码进行选择，你要的是“与该类型码相关的函数或类”，所以应该运用 提炼函数(Extract Method) 将 switch 语句提炼到一个独立函数中，再以 搬移函数(Move Method) 将它搬移到需要多态性的那个类里。\n * 如果你的 switch 是基于类型码来识别分支，这时可以运用 以子类取代类型码(Replace Type Code with Subclass) 或 以状态/策略模式取代类型码(Replace Type Code with State/Strategy) 。\n * 一旦完成这样的继承结构后，就可以运用 以多态取代条件表达式(Replace Conditional with Polymorphism) 了。\n * 如果条件分支并不多并且它们使用不同参数调用相同的函数，多态就没必要了。在这种情况下，你可以运用 以明确函数取代参数(Replace Parameter with Explicit Methods) 。\n * 如果你的选择条件之一是 null，可以运用 引入 Null 对象(Introduce Null Object) 。\n\n\n# 1.3. 收益\n\n * 提升代码组织性。\n\n\n\n\n# 1.4. 何时忽略\n\n * 如果一个 switch 操作只是执行简单的行为，就没有重构的必要了。\n * switch 常被工厂设计模式族（工厂方法模式(Factory Method)和抽象工厂模式(Abstract Factory)）所使用，这种情况下也没必要重构。\n\n\n# 1.5. 重构方法说明\n\n# 1.5.1. 提炼函数(Extract Method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printOwing() {\n  printBanner();\n\n  //print details\n  System.out.println("name: " + name);\n  System.out.println("amount: " + getOutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printOwing() {\n  printBanner();\n  printDetails(getOutstanding());\n}\n\nvoid printDetails(double outstanding) {\n  System.out.println("name: " + name);\n  System.out.println("amount: " + outstanding);\n}\n\n\n# 1.5.2. 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 1.5.3. 以子类取代类型码(Replace Type Code with Subclass)\n\n问题\n\n你有一个不可变的类型码，它会影响类的行为。\n\n\n\n解决\n\n以子类取代这个类型码。\n\n\n\n# 1.5.4. 以状态/策略模式取代类型码(Replace Type Code with State/Strategy)\n\n问题\n\n你有一个类型码，它会影响类的行为，但你无法通过继承消除它。\n\n\n\n解决\n\n以状态对象取代类型码。\n\n\n\n# 1.5.5. 以多态取代条件表达式(Replace Conditional with Polymorphism)\n\n问题\n\n你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。\n\nclass Bird {\n  //...\n  double getSpeed() {\n    switch (type) {\n      case EUROPEAN:\n        return getBaseSpeed();\n      case AFRICAN:\n        return getBaseSpeed() - getLoadFactor() * numberOfCoconuts;\n      case NORWEGIAN_BLUE:\n        return (isNailed) ? 0 : getBaseSpeed(voltage);\n    }\n    throw new RuntimeException("Should be unreachable");\n  }\n}\n\n\n解决\n\n将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。\n\nabstract class Bird {\n  //...\n  abstract double getSpeed();\n}\n\nclass European extends Bird {\n  double getSpeed() {\n    return getBaseSpeed();\n  }\n}\nclass African extends Bird {\n  double getSpeed() {\n    return getBaseSpeed() - getLoadFactor() * numberOfCoconuts;\n  }\n}\nclass NorwegianBlue extends Bird {\n  double getSpeed() {\n    return (isNailed) ? 0 : getBaseSpeed(voltage);\n  }\n}\n\n// Somewhere in client code\nspeed = bird.getSpeed();\n\n\n# 1.5.6. 以明确函数取代参数(Replace Parameter with Explicit Methods)\n\n问题\n\n你有一个函数，其中完全取决于参数值而采取不同的行为。\n\nvoid setValue(String name, int value) {\n  if (name.equals("height")) {\n    height = value;\n    return;\n  }\n  if (name.equals("width")) {\n    width = value;\n    return;\n  }\n  Assert.shouldNeverReachHere();\n}\n\n\n解决\n\n针对该参数的每一个可能值，建立一个独立函数。\n\nvoid setHeight(int arg) {\n  height = arg;\n}\nvoid setWidth(int arg) {\n  width = arg;\n}\n\n\n# 1.5.7. 引入 Null 对象(Introduce Null Object)\n\n问题\n\n你需要再三检查某对象是否为 null。\n\nif (customer == null) {\n  plan = BillingPlan.basic();\n}\nelse {\n  plan = customer.getPlan();\n}\n\n\n解决\n\n将 null 值替换为 null 对象。\n\nclass NullCustomer extends Customer {\n  Plan getPlan() {\n    return new NullPlan();\n  }\n  // Some other NULL functionality.\n}\n\n// Replace null values with Null-object.\ncustomer = (order.customer != null) ? order.customer : new NullCustomer();\n\n// Use Null-object as if it\'s normal subclass.\nplan = customer.getPlan();\n\n\n\n# 2. 临时字段\n\n> 临时字段(Temporary Field)的值只在特定环境下有意义，离开这个环境，它们就什么也不是了。\n\n\n\n\n# 2.1. 问题原因\n\n有时你会看到这样的对象：其内某个实例变量仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。在变量未被使用的情况下猜测当初设置目的，会让你发疯。 通常，临时字段是在某一算法需要大量输入时而创建。因此，为了避免函数有过多参数，程序员决定在类中创建这些数据的临时字段。这些临时字段仅仅在算法中使用，其他时候却毫无用处。 这种代码不好理解。你期望查看对象字段的数据，但是出于某种原因，它们总是为空。\n\n\n# 2.2. 解决方法\n\n * 可以通过 提炼类(Extract Class) 将临时字段和操作它们的所有代码提炼到一个单独的类中。此外，你可以运用 以函数对象取代函数(Replace Method with Method Object) 来实现同样的目的。\n * 引入 Null 对象(Introduce Null Object) 在“变量不合法”的情况下创建一个 null 对象，从而避免写出条件表达式。\n\n\n\n\n# 2.3. 收益\n\n * 更好的代码清晰度和组织性。\n\n\n\n\n# 2.4. 重构方法说明\n\n# 2.4.1. 提炼类(Extract Class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 2.4.2. 以函数对象取代函数(Replace Method with Method Object)\n\n问题\n\n你有一个过长函数，它的局部变量交织在一起，以致于你无法应用提炼函数(Extract Method) 。\n\nclass Order {\n  //...\n  public double price() {\n    double primaryBasePrice;\n    double secondaryBasePrice;\n    double tertiaryBasePrice;\n    // long computation.\n    //...\n  }\n}\n\n\n解决\n\n将函数移到一个独立的类中，使得局部变量成了这个类的字段。然后，你可以将函数分割成这个类中的多个函数。\n\nclass Order {\n  //...\n  public double price() {\n    return new PriceCalculator(this).compute();\n  }\n}\n\nclass PriceCalculator {\n  private double primaryBasePrice;\n  private double secondaryBasePrice;\n  private double tertiaryBasePrice;\n\n  public PriceCalculator(Order order) {\n    // copy relevant information from order object.\n    //...\n  }\n\n  public double compute() {\n    // long computation.\n    //...\n  }\n}\n\n\n# 2.4.3. 引入 Null 对象(Introduce Null Object)\n\n问题\n\n你需要再三检查某对象是否为 null。\n\nif (customer == null) {\n  plan = BillingPlan.basic();\n}\nelse {\n  plan = customer.getPlan();\n}\n\n\n解决\n\n将 null 值替换为 null 对象。\n\nclass NullCustomer extends Customer {\n  Plan getPlan() {\n    return new NullPlan();\n  }\n  // Some other NULL functionality.\n}\n\n// Replace null values with Null-object.\ncustomer = (order.customer != null) ? order.customer : new NullCustomer();\n\n// Use Null-object as if it\'s normal subclass.\nplan = customer.getPlan();\n\n\n\n# 3. 异曲同工的类\n\n> 异曲同工的类(Alternative Classes with Different Interfaces)\n> \n> 两个类中有着不同的函数，却在做着同一件事。\n\n\n\n\n# 3.1. 问题原因\n\n这种情况往往是因为：创建这个类的程序员并不知道已经有实现这个功能的类存在了。\n\n\n# 3.2. 解决方法\n\n * 如果两个函数做同一件事，却有着不同的签名，请运用 函数改名(Rename Method) 根据它们的用途重新命名。\n * 运用 搬移函数(Move Method) 、 添加参数(Add Parameter) 和 令函数携带参数(Parameterize Method) 来使得方法的名称和实现一致。\n * 如果两个类仅有部分功能是重复的，尝试运用 提炼超类(Extract Superclass) 。这种情况下，已存在的类就成了超类。\n * 当最终选择并运用某种方法来重构后，也许你就能删除其中一个类了。\n\n\n# 3.3. 收益\n\n * 消除了不必要的重复代码，为代码瘦身了。\n * 代码更易读（不再需要猜测为什么要有两个功能相同的类）。\n\n\n\n\n# 3.4. 何时忽略\n\n * 有时合并类是不可能的，或者是如此困难以至于没有意义。例如：两个功能相似的类存在于不同的 lib 库中。\n\n\n# 3.5. 重构方法说明\n\n# 3.5.1. 函数改名(Rename Method)\n\n问题\n\n函数的名称未能恰当的揭示函数的用途。\n\nclass Person {\n  public String getsnm();\n}\n\n\n解决\n\n修改函数名。\n\nclass Person {\n  public String getSecondName();\n}\n\n\n# 3.5.2. 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 3.5.3. 添加参数(Add Parameter)\n\n问题 某个函数需要从调用端得到更多信息。\n\nclass Customer {\n  public Contact getContact();\n}\n\n\n解决 为此函数添加一个对象函数，让改对象带进函数所需信息。\n\nclass Customer {\n  public Contact getContact(Date date);\n}\n\n\n# 3.5.4. 令函数携带参数(Parameterize Method)\n\n问题\n\n若干函数做了类似的工作，但在函数本体中却包含了不同的值。\n\n解决\n\n建立单一函数，以参数表达哪些不同的值。\n\n\n\n# 3.5.5. 提炼超类(Extract Superclass)\n\n问题\n\n两个类有相似特性。\n\n\n\n解决\n\n为这两个类建立一个超类，将相同特性移至超类。\n\n\n\n\n# 4. 被拒绝的馈赠\n\n> 被拒绝的馈赠(Refused Bequest)\n> \n> 子类仅仅使用父类中的部分方法和属性。其他来自父类的馈赠成为了累赘。\n\n\n\n\n# 4.1. 问题原因\n\n有些人仅仅是想重用超类中的部分代码而创建了子类。但实际上超类和子类完全不同。\n\n\n# 4.2. 解决方法\n\n * 如果继承没有意义并且子类和父类之间确实没有共同点，可以运用 以委托取代继承(Replace Inheritance with Delegation) 消除继承。\n * 如果继承是适当的，则去除子类中不需要的字段和方法。运用 提炼超类(Extract Superclass) 将所有超类中对于子类有用的字段和函数提取出来，置入一个新的超类中，然后让两个类都继承自它。\n\n\n\n\n# 4.3. 收益\n\n * 提高代码的清晰度和组织性。\n\n\n\n\n# 4.4. 重构方法说明\n\n# 4.4.1. 以委托取代继承(Replace Inheritance with Delegation)\n\n问题\n\n某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。\n\n\n\n解决\n\n 1. 在子类中新建一个字段用以保存超类；\n 2. 调整子类函数，令它改而委托超类；\n 3. 然后去掉两者之间的继承关系。\n\n\n\n# 4.4.2. 提炼超类(Extract Superclass)\n\n问题\n\n两个类有相似特性。\n\n\n\n解决\n\n为这两个类建立一个超类，将相同特性移至超类。\n\n\n\n\n# 5. 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 6. 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',normalizedContent:'> 翻译自：https://sourcemaking.com/refactoring/smells/oo-abusers\n> \n> 滥用面向对象(object-orientation abusers)这组坏味道意味着：代码部分或完全地违背了面向对象编程原则。\n\n\n# 1. switch 声明\n\n> switch 声明(switch statements)\n> \n> 你有一个复杂的 switch 语句或 if 序列语句。\n\n\n\n\n# 1.1. 问题原因\n\n面向对象程序的一个最明显特征就是：少用 switch 和 case 语句。从本质上说，switch 语句的问题在于重复（if 序列也同样如此）。你常会发现 switch 语句散布于不同地点。如果要为它添加一个新的 case 子句，就必须找到所有 switch 语句并修改它们。面向对象中的多态概念可为此带来优雅的解决办法。\n\n大多数时候，一看到 switch 语句，就应该考虑以多态来替换它。\n\n\n# 1.2. 解决方法\n\n * 问题是多态该出现在哪？switch 语句常常根据类型码进行选择，你要的是“与该类型码相关的函数或类”，所以应该运用 提炼函数(extract method) 将 switch 语句提炼到一个独立函数中，再以 搬移函数(move method) 将它搬移到需要多态性的那个类里。\n * 如果你的 switch 是基于类型码来识别分支，这时可以运用 以子类取代类型码(replace type code with subclass) 或 以状态/策略模式取代类型码(replace type code with state/strategy) 。\n * 一旦完成这样的继承结构后，就可以运用 以多态取代条件表达式(replace conditional with polymorphism) 了。\n * 如果条件分支并不多并且它们使用不同参数调用相同的函数，多态就没必要了。在这种情况下，你可以运用 以明确函数取代参数(replace parameter with explicit methods) 。\n * 如果你的选择条件之一是 null，可以运用 引入 null 对象(introduce null object) 。\n\n\n# 1.3. 收益\n\n * 提升代码组织性。\n\n\n\n\n# 1.4. 何时忽略\n\n * 如果一个 switch 操作只是执行简单的行为，就没有重构的必要了。\n * switch 常被工厂设计模式族（工厂方法模式(factory method)和抽象工厂模式(abstract factory)）所使用，这种情况下也没必要重构。\n\n\n# 1.5. 重构方法说明\n\n# 1.5.1. 提炼函数(extract method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printowing() {\n  printbanner();\n\n  //print details\n  system.out.println("name: " + name);\n  system.out.println("amount: " + getoutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printowing() {\n  printbanner();\n  printdetails(getoutstanding());\n}\n\nvoid printdetails(double outstanding) {\n  system.out.println("name: " + name);\n  system.out.println("amount: " + outstanding);\n}\n\n\n# 1.5.2. 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 1.5.3. 以子类取代类型码(replace type code with subclass)\n\n问题\n\n你有一个不可变的类型码，它会影响类的行为。\n\n\n\n解决\n\n以子类取代这个类型码。\n\n\n\n# 1.5.4. 以状态/策略模式取代类型码(replace type code with state/strategy)\n\n问题\n\n你有一个类型码，它会影响类的行为，但你无法通过继承消除它。\n\n\n\n解决\n\n以状态对象取代类型码。\n\n\n\n# 1.5.5. 以多态取代条件表达式(replace conditional with polymorphism)\n\n问题\n\n你手上有个条件表达式，它根据对象类型的不同而选择不同的行为。\n\nclass bird {\n  //...\n  double getspeed() {\n    switch (type) {\n      case european:\n        return getbasespeed();\n      case african:\n        return getbasespeed() - getloadfactor() * numberofcoconuts;\n      case norwegian_blue:\n        return (isnailed) ? 0 : getbasespeed(voltage);\n    }\n    throw new runtimeexception("should be unreachable");\n  }\n}\n\n\n解决\n\n将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数。\n\nabstract class bird {\n  //...\n  abstract double getspeed();\n}\n\nclass european extends bird {\n  double getspeed() {\n    return getbasespeed();\n  }\n}\nclass african extends bird {\n  double getspeed() {\n    return getbasespeed() - getloadfactor() * numberofcoconuts;\n  }\n}\nclass norwegianblue extends bird {\n  double getspeed() {\n    return (isnailed) ? 0 : getbasespeed(voltage);\n  }\n}\n\n// somewhere in client code\nspeed = bird.getspeed();\n\n\n# 1.5.6. 以明确函数取代参数(replace parameter with explicit methods)\n\n问题\n\n你有一个函数，其中完全取决于参数值而采取不同的行为。\n\nvoid setvalue(string name, int value) {\n  if (name.equals("height")) {\n    height = value;\n    return;\n  }\n  if (name.equals("width")) {\n    width = value;\n    return;\n  }\n  assert.shouldneverreachhere();\n}\n\n\n解决\n\n针对该参数的每一个可能值，建立一个独立函数。\n\nvoid setheight(int arg) {\n  height = arg;\n}\nvoid setwidth(int arg) {\n  width = arg;\n}\n\n\n# 1.5.7. 引入 null 对象(introduce null object)\n\n问题\n\n你需要再三检查某对象是否为 null。\n\nif (customer == null) {\n  plan = billingplan.basic();\n}\nelse {\n  plan = customer.getplan();\n}\n\n\n解决\n\n将 null 值替换为 null 对象。\n\nclass nullcustomer extends customer {\n  plan getplan() {\n    return new nullplan();\n  }\n  // some other null functionality.\n}\n\n// replace null values with null-object.\ncustomer = (order.customer != null) ? order.customer : new nullcustomer();\n\n// use null-object as if it\'s normal subclass.\nplan = customer.getplan();\n\n\n\n# 2. 临时字段\n\n> 临时字段(temporary field)的值只在特定环境下有意义，离开这个环境，它们就什么也不是了。\n\n\n\n\n# 2.1. 问题原因\n\n有时你会看到这样的对象：其内某个实例变量仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有变量。在变量未被使用的情况下猜测当初设置目的，会让你发疯。 通常，临时字段是在某一算法需要大量输入时而创建。因此，为了避免函数有过多参数，程序员决定在类中创建这些数据的临时字段。这些临时字段仅仅在算法中使用，其他时候却毫无用处。 这种代码不好理解。你期望查看对象字段的数据，但是出于某种原因，它们总是为空。\n\n\n# 2.2. 解决方法\n\n * 可以通过 提炼类(extract class) 将临时字段和操作它们的所有代码提炼到一个单独的类中。此外，你可以运用 以函数对象取代函数(replace method with method object) 来实现同样的目的。\n * 引入 null 对象(introduce null object) 在“变量不合法”的情况下创建一个 null 对象，从而避免写出条件表达式。\n\n\n\n\n# 2.3. 收益\n\n * 更好的代码清晰度和组织性。\n\n\n\n\n# 2.4. 重构方法说明\n\n# 2.4.1. 提炼类(extract class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 2.4.2. 以函数对象取代函数(replace method with method object)\n\n问题\n\n你有一个过长函数，它的局部变量交织在一起，以致于你无法应用提炼函数(extract method) 。\n\nclass order {\n  //...\n  public double price() {\n    double primarybaseprice;\n    double secondarybaseprice;\n    double tertiarybaseprice;\n    // long computation.\n    //...\n  }\n}\n\n\n解决\n\n将函数移到一个独立的类中，使得局部变量成了这个类的字段。然后，你可以将函数分割成这个类中的多个函数。\n\nclass order {\n  //...\n  public double price() {\n    return new pricecalculator(this).compute();\n  }\n}\n\nclass pricecalculator {\n  private double primarybaseprice;\n  private double secondarybaseprice;\n  private double tertiarybaseprice;\n\n  public pricecalculator(order order) {\n    // copy relevant information from order object.\n    //...\n  }\n\n  public double compute() {\n    // long computation.\n    //...\n  }\n}\n\n\n# 2.4.3. 引入 null 对象(introduce null object)\n\n问题\n\n你需要再三检查某对象是否为 null。\n\nif (customer == null) {\n  plan = billingplan.basic();\n}\nelse {\n  plan = customer.getplan();\n}\n\n\n解决\n\n将 null 值替换为 null 对象。\n\nclass nullcustomer extends customer {\n  plan getplan() {\n    return new nullplan();\n  }\n  // some other null functionality.\n}\n\n// replace null values with null-object.\ncustomer = (order.customer != null) ? order.customer : new nullcustomer();\n\n// use null-object as if it\'s normal subclass.\nplan = customer.getplan();\n\n\n\n# 3. 异曲同工的类\n\n> 异曲同工的类(alternative classes with different interfaces)\n> \n> 两个类中有着不同的函数，却在做着同一件事。\n\n\n\n\n# 3.1. 问题原因\n\n这种情况往往是因为：创建这个类的程序员并不知道已经有实现这个功能的类存在了。\n\n\n# 3.2. 解决方法\n\n * 如果两个函数做同一件事，却有着不同的签名，请运用 函数改名(rename method) 根据它们的用途重新命名。\n * 运用 搬移函数(move method) 、 添加参数(add parameter) 和 令函数携带参数(parameterize method) 来使得方法的名称和实现一致。\n * 如果两个类仅有部分功能是重复的，尝试运用 提炼超类(extract superclass) 。这种情况下，已存在的类就成了超类。\n * 当最终选择并运用某种方法来重构后，也许你就能删除其中一个类了。\n\n\n# 3.3. 收益\n\n * 消除了不必要的重复代码，为代码瘦身了。\n * 代码更易读（不再需要猜测为什么要有两个功能相同的类）。\n\n\n\n\n# 3.4. 何时忽略\n\n * 有时合并类是不可能的，或者是如此困难以至于没有意义。例如：两个功能相似的类存在于不同的 lib 库中。\n\n\n# 3.5. 重构方法说明\n\n# 3.5.1. 函数改名(rename method)\n\n问题\n\n函数的名称未能恰当的揭示函数的用途。\n\nclass person {\n  public string getsnm();\n}\n\n\n解决\n\n修改函数名。\n\nclass person {\n  public string getsecondname();\n}\n\n\n# 3.5.2. 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 3.5.3. 添加参数(add parameter)\n\n问题 某个函数需要从调用端得到更多信息。\n\nclass customer {\n  public contact getcontact();\n}\n\n\n解决 为此函数添加一个对象函数，让改对象带进函数所需信息。\n\nclass customer {\n  public contact getcontact(date date);\n}\n\n\n# 3.5.4. 令函数携带参数(parameterize method)\n\n问题\n\n若干函数做了类似的工作，但在函数本体中却包含了不同的值。\n\n解决\n\n建立单一函数，以参数表达哪些不同的值。\n\n\n\n# 3.5.5. 提炼超类(extract superclass)\n\n问题\n\n两个类有相似特性。\n\n\n\n解决\n\n为这两个类建立一个超类，将相同特性移至超类。\n\n\n\n\n# 4. 被拒绝的馈赠\n\n> 被拒绝的馈赠(refused bequest)\n> \n> 子类仅仅使用父类中的部分方法和属性。其他来自父类的馈赠成为了累赘。\n\n\n\n\n# 4.1. 问题原因\n\n有些人仅仅是想重用超类中的部分代码而创建了子类。但实际上超类和子类完全不同。\n\n\n# 4.2. 解决方法\n\n * 如果继承没有意义并且子类和父类之间确实没有共同点，可以运用 以委托取代继承(replace inheritance with delegation) 消除继承。\n * 如果继承是适当的，则去除子类中不需要的字段和方法。运用 提炼超类(extract superclass) 将所有超类中对于子类有用的字段和函数提取出来，置入一个新的超类中，然后让两个类都继承自它。\n\n\n\n\n# 4.3. 收益\n\n * 提高代码的清晰度和组织性。\n\n\n\n\n# 4.4. 重构方法说明\n\n# 4.4.1. 以委托取代继承(replace inheritance with delegation)\n\n问题\n\n某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。\n\n\n\n解决\n\n 1. 在子类中新建一个字段用以保存超类；\n 2. 调整子类函数，令它改而委托超类；\n 3. 然后去掉两者之间的继承关系。\n\n\n\n# 4.4.2. 提炼超类(extract superclass)\n\n问题\n\n两个类有相似特性。\n\n\n\n解决\n\n为这两个类建立一个超类，将相同特性移至超类。\n\n\n\n\n# 5. 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 6. 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"代码坏味道之变革的障碍",frontmatter:{title:"代码坏味道之变革的障碍",categories:["设计","重构"],tags:["设计","重构","代码的坏味道"],date:"2018-10-13T22:48:00.000Z",permalink:"/pages/76e1cc/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/03.%E9%87%8D%E6%9E%84/04.%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E5%8F%98%E9%9D%A9%E7%9A%84%E9%9A%9C%E7%A2%8D.html",relativePath:"03.设计/03.重构/04.代码坏味道之变革的障碍.md",key:"v-38d3c9ce",path:"/pages/76e1cc/",headers:[{level:2,title:"1. 发散式变化",slug:"_1-发散式变化",normalizedTitle:"1. 发散式变化",charIndex:154},{level:3,title:"1.1. 特征",slug:"_1-1-特征",normalizedTitle:"1.1. 特征",charIndex:310},{level:3,title:"1.2. 问题原因",slug:"_1-2-问题原因",normalizedTitle:"1.2. 问题原因",charIndex:399},{level:3,title:"1.3. 解决办法",slug:"_1-3-解决办法",normalizedTitle:"1.3. 解决办法",charIndex:448},{level:3,title:"1.4. 收益",slug:"_1-4-收益",normalizedTitle:"1.4. 收益",charIndex:496},{level:3,title:"1.5. 重构方法说明",slug:"_1-5-重构方法说明",normalizedTitle:"1.5. 重构方法说明",charIndex:531},{level:4,title:"1.5.1. 提炼类(Extract Class)",slug:"_1-5-1-提炼类-extract-class",normalizedTitle:"1.5.1. 提炼类(extract class)",charIndex:546},{level:2,title:"2. 平行继承体系",slug:"_2-平行继承体系",normalizedTitle:"2. 平行继承体系",charIndex:628},{level:3,title:"2.1. 特征",slug:"_2-1-特征",normalizedTitle:"2.1. 特征",charIndex:720},{level:3,title:"2.2. 问题原因",slug:"_2-2-问题原因",normalizedTitle:"2.2. 问题原因",charIndex:800},{level:3,title:"2.3. 解决方法",slug:"_2-3-解决方法",normalizedTitle:"2.3. 解决方法",charIndex:852},{level:3,title:"2.4. 收益",slug:"_2-4-收益",normalizedTitle:"2.4. 收益",charIndex:960},{level:3,title:"2.5. 何时忽略",slug:"_2-5-何时忽略",normalizedTitle:"2.5. 何时忽略",charIndex:994},{level:3,title:"2.6. 重构方法说明",slug:"_2-6-重构方法说明",normalizedTitle:"2.6. 重构方法说明",charIndex:1081},{level:4,title:"2.6.1. 搬移函数(Move Method)",slug:"_2-6-1-搬移函数-move-method",normalizedTitle:"2.6.1. 搬移函数(move method)",charIndex:1096},{level:4,title:"2.6.2. 搬移字段(Move Field)",slug:"_2-6-2-搬移字段-move-field",normalizedTitle:"2.6.2. 搬移字段(move field)",charIndex:1233},{level:2,title:"3. 霰弹式修改",slug:"_3-霰弹式修改",normalizedTitle:"3. 霰弹式修改",charIndex:1337},{level:3,title:"3.1. 特征",slug:"_3-1-特征",normalizedTitle:"3.1. 特征",charIndex:1493},{level:3,title:"3.2. 问题原因",slug:"_3-2-问题原因",normalizedTitle:"3.2. 问题原因",charIndex:1530},{level:3,title:"3.3. 解决方法",slug:"_3-3-解决方法",normalizedTitle:"3.3. 解决方法",charIndex:1562},{level:3,title:"3.4. 收益",slug:"_3-4-收益",normalizedTitle:"3.4. 收益",charIndex:1715},{level:3,title:"3.5. 重构方法说明",slug:"_3-5-重构方法说明",normalizedTitle:"3.5. 重构方法说明",charIndex:1759},{level:4,title:"3.5.1. 搬移函数(Move Method)",slug:"_3-5-1-搬移函数-move-method",normalizedTitle:"3.5.1. 搬移函数(move method)",charIndex:1774},{level:4,title:"3.5.2. 搬移字段(Move Field)",slug:"_3-5-2-搬移字段-move-field",normalizedTitle:"3.5.2. 搬移字段(move field)",charIndex:1911},{level:4,title:"3.5.3. 将类内联化(Inline Class)",slug:"_3-5-3-将类内联化-inline-class",normalizedTitle:"3.5.3. 将类内联化(inline class)",charIndex:2014},{level:2,title:"4. 扩展阅读",slug:"_4-扩展阅读",normalizedTitle:"4. 扩展阅读",charIndex:2097},{level:2,title:"5. 参考资料",slug:"_5-参考资料",normalizedTitle:"5. 参考资料",charIndex:2194}],headersStr:"1. 发散式变化 1.1. 特征 1.2. 问题原因 1.3. 解决办法 1.4. 收益 1.5. 重构方法说明 1.5.1. 提炼类(Extract Class) 2. 平行继承体系 2.1. 特征 2.2. 问题原因 2.3. 解决方法 2.4. 收益 2.5. 何时忽略 2.6. 重构方法说明 2.6.1. 搬移函数(Move Method) 2.6.2. 搬移字段(Move Field) 3. 霰弹式修改 3.1. 特征 3.2. 问题原因 3.3. 解决方法 3.4. 收益 3.5. 重构方法说明 3.5.1. 搬移函数(Move Method) 3.5.2. 搬移字段(Move Field) 3.5.3. 将类内联化(Inline Class) 4. 扩展阅读 5. 参考资料",content:"> 翻译自：https://sourcemaking.com/refactoring/smells/change-preventers\n> \n> 变革的障碍(Change Preventers)这组坏味道意味着：当你需要改变一处代码时，却发现不得不改变其他的地方。这使得程序开发变得复杂、代价高昂。\n\n\n# 1. 发散式变化\n\n> 发散式变化(Divergent Change) 类似于 霰弹式修改(Shotgun Surgery) ，但实际上完全不同。发散式变化(Divergent Change) 是指一个类受多种变化的影响。霰弹式修改(Shotgun Surgery) 是指多种变化引发多个类相应的修改。\n\n\n# 1.1. 特征\n\n你发现你想要修改一个函数，却必须要同时修改许多不相关的函数。例如，当你想要添加一个新的产品类型时，你需要同步修改对产品进行查找、显示、排序的函数。\n\n\n\n\n# 1.2. 问题原因\n\n通常，这种发散式修改是由于编程结构不合理或者“复制-粘贴式编程”。\n\n\n# 1.3. 解决办法\n\n * 运用 提炼类(Extract Class) 拆分类的行为。\n\n\n# 1.4. 收益\n\n * 提高代码组织结构\n * 减少重复代码\n\n\n# 1.5. 重构方法说明\n\n# 1.5.1. 提炼类(Extract Class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n\n# 2. 平行继承体系\n\n> 平行继承体系(Parallel Inheritance Hierarchies) 其实是 霰弹式修改(Shotgun Surgery) 的特殊情况。\n\n\n# 2.1. 特征\n\n每当你为某个类添加一个子类，必须同时为另一个类相应添加一个子类。这种情况的典型特征是：某个继承体系的类名前缀或类名后缀完全相同。\n\n\n\n\n# 2.2. 问题原因\n\n起初的继承体系很小，随着不断添加新类，继承体系越来越大，也越来越难修改。\n\n\n# 2.3. 解决方法\n\n * 一般策略是：让一个继承体系的实例引用另一个继承体系的实例。如果再接再厉运用 搬移函数(Move Method) 和 搬移字段(Move Field)，就可以消除引用端的继承体系。\n\n\n# 2.4. 收益\n\n * 更好的代码组织\n * 减少重复代码\n\n\n# 2.5. 何时忽略\n\n * 有时具有并行类层次结构只是一种为了避免程序体系结构更混乱的方法。如果你发现尝试消除平行继承体系导致代码更加丑陋，那么你应该回滚你的修改。\n\n\n# 2.6. 重构方法说明\n\n# 2.6.1. 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 2.6.2. 搬移字段(Move Field)\n\n问题\n\n在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。\n\n\n\n解决\n\n在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。\n\n\n\n\n# 3. 霰弹式修改\n\n> 霰弹式修改(Shotgun Surgery) 类似于 发散式变化(Divergent Change) ，但实际上完全不同。发散式变化(Divergent Change) 是指一个类受多种变化的影响。霰弹式修改(Shotgun Surgery) 是指多种变化引发多个类相应的修改。\n\n\n# 3.1. 特征\n\n任何修改都需要在许多不同类上做小幅度修改。\n\n\n\n\n# 3.2. 问题原因\n\n一个单一的职责被拆分成大量的类。\n\n\n# 3.3. 解决方法\n\n * 运用搬移函数(Move Method) 和 搬移字段(Move Field) 来搬移不同类中相同的行为到一个独立类中。如果没有适合存放搬移函数或字段的类，就创建一个新类。\n * 通常，可以运用 将类内联化(Inline Class) 将一些列相关行为放进同一个类。\n\n\n\n\n# 3.4. 收益\n\n * 更好的代码组织\n * 减少重复代码\n * 更易维护\n\n\n\n\n# 3.5. 重构方法说明\n\n# 3.5.1. 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 3.5.2. 搬移字段(Move Field)\n\n问题\n\n在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。\n\n\n\n解决\n\n在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。\n\n\n\n# 3.5.3. 将类内联化(Inline Class)\n\n问题\n\n某个类没有做太多事情。\n\n\n\n解决\n\n将这个类的所有特性搬移到另一个类中，然后移除原类。\n\n\n\n\n# 4. 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 5. 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring",normalizedContent:"> 翻译自：https://sourcemaking.com/refactoring/smells/change-preventers\n> \n> 变革的障碍(change preventers)这组坏味道意味着：当你需要改变一处代码时，却发现不得不改变其他的地方。这使得程序开发变得复杂、代价高昂。\n\n\n# 1. 发散式变化\n\n> 发散式变化(divergent change) 类似于 霰弹式修改(shotgun surgery) ，但实际上完全不同。发散式变化(divergent change) 是指一个类受多种变化的影响。霰弹式修改(shotgun surgery) 是指多种变化引发多个类相应的修改。\n\n\n# 1.1. 特征\n\n你发现你想要修改一个函数，却必须要同时修改许多不相关的函数。例如，当你想要添加一个新的产品类型时，你需要同步修改对产品进行查找、显示、排序的函数。\n\n\n\n\n# 1.2. 问题原因\n\n通常，这种发散式修改是由于编程结构不合理或者“复制-粘贴式编程”。\n\n\n# 1.3. 解决办法\n\n * 运用 提炼类(extract class) 拆分类的行为。\n\n\n# 1.4. 收益\n\n * 提高代码组织结构\n * 减少重复代码\n\n\n# 1.5. 重构方法说明\n\n# 1.5.1. 提炼类(extract class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n\n# 2. 平行继承体系\n\n> 平行继承体系(parallel inheritance hierarchies) 其实是 霰弹式修改(shotgun surgery) 的特殊情况。\n\n\n# 2.1. 特征\n\n每当你为某个类添加一个子类，必须同时为另一个类相应添加一个子类。这种情况的典型特征是：某个继承体系的类名前缀或类名后缀完全相同。\n\n\n\n\n# 2.2. 问题原因\n\n起初的继承体系很小，随着不断添加新类，继承体系越来越大，也越来越难修改。\n\n\n# 2.3. 解决方法\n\n * 一般策略是：让一个继承体系的实例引用另一个继承体系的实例。如果再接再厉运用 搬移函数(move method) 和 搬移字段(move field)，就可以消除引用端的继承体系。\n\n\n# 2.4. 收益\n\n * 更好的代码组织\n * 减少重复代码\n\n\n# 2.5. 何时忽略\n\n * 有时具有并行类层次结构只是一种为了避免程序体系结构更混乱的方法。如果你发现尝试消除平行继承体系导致代码更加丑陋，那么你应该回滚你的修改。\n\n\n# 2.6. 重构方法说明\n\n# 2.6.1. 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 2.6.2. 搬移字段(move field)\n\n问题\n\n在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。\n\n\n\n解决\n\n在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。\n\n\n\n\n# 3. 霰弹式修改\n\n> 霰弹式修改(shotgun surgery) 类似于 发散式变化(divergent change) ，但实际上完全不同。发散式变化(divergent change) 是指一个类受多种变化的影响。霰弹式修改(shotgun surgery) 是指多种变化引发多个类相应的修改。\n\n\n# 3.1. 特征\n\n任何修改都需要在许多不同类上做小幅度修改。\n\n\n\n\n# 3.2. 问题原因\n\n一个单一的职责被拆分成大量的类。\n\n\n# 3.3. 解决方法\n\n * 运用搬移函数(move method) 和 搬移字段(move field) 来搬移不同类中相同的行为到一个独立类中。如果没有适合存放搬移函数或字段的类，就创建一个新类。\n * 通常，可以运用 将类内联化(inline class) 将一些列相关行为放进同一个类。\n\n\n\n\n# 3.4. 收益\n\n * 更好的代码组织\n * 减少重复代码\n * 更易维护\n\n\n\n\n# 3.5. 重构方法说明\n\n# 3.5.1. 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 3.5.2. 搬移字段(move field)\n\n问题\n\n在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。\n\n\n\n解决\n\n在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。\n\n\n\n# 3.5.3. 将类内联化(inline class)\n\n问题\n\n某个类没有做太多事情。\n\n\n\n解决\n\n将这个类的所有特性搬移到另一个类中，然后移除原类。\n\n\n\n\n# 4. 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 5. 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"代码坏味道之非必要的",frontmatter:{title:"代码坏味道之非必要的",categories:["设计","重构"],tags:["设计","重构","代码的坏味道"],date:"2018-10-13T22:48:00.000Z",permalink:"/pages/dff53d/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/03.%E9%87%8D%E6%9E%84/05.%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E9%9D%9E%E5%BF%85%E8%A6%81%E7%9A%84.html",relativePath:"03.设计/03.重构/05.代码坏味道之非必要的.md",key:"v-5d9b4816",path:"/pages/dff53d/",headers:[{level:2,title:"1. 冗余类",slug:"_1-冗余类",normalizedTitle:"1. 冗余类",charIndex:130},{level:3,title:"1.1. 问题原因",slug:"_1-1-问题原因",normalizedTitle:"1.1. 问题原因",charIndex:203},{level:3,title:"1.2. 解决方法",slug:"_1-2-解决方法",normalizedTitle:"1.2. 解决方法",charIndex:291},{level:3,title:"1.3. 收益",slug:"_1-3-收益",normalizedTitle:"1.3. 收益",charIndex:392},{level:3,title:"1.4. 何时忽略",slug:"_1-4-何时忽略",normalizedTitle:"1.4. 何时忽略",charIndex:422},{level:3,title:"1.5. 重构方法说明",slug:"_1-5-重构方法说明",normalizedTitle:"1.5. 重构方法说明",charIndex:488},{level:4,title:"1.5.1. 将类内联化(Inline Class)",slug:"_1-5-1-将类内联化-inline-class",normalizedTitle:"1.5.1. 将类内联化(inline class)",charIndex:503},{level:4,title:"1.5.2. 折叠继承体系(Collapse Hierarchy)",slug:"_1-5-2-折叠继承体系-collapse-hierarchy",normalizedTitle:"1.5.2. 折叠继承体系(collapse hierarchy)",charIndex:585},{level:2,title:"2. 夸夸其谈未来性",slug:"_2-夸夸其谈未来性",normalizedTitle:"2. 夸夸其谈未来性",charIndex:660},{level:3,title:"2.1. 问题原因",slug:"_2-1-问题原因",normalizedTitle:"2.1. 问题原因",charIndex:736},{level:3,title:"2.2. 解决方法",slug:"_2-2-解决方法",normalizedTitle:"2.2. 解决方法",charIndex:796},{level:3,title:"2.3. 收益",slug:"_2-3-收益",normalizedTitle:"2.3. 收益",charIndex:999},{level:3,title:"2.4. 何时忽略",slug:"_2-4-何时忽略",normalizedTitle:"2.4. 何时忽略",charIndex:1031},{level:3,title:"2.5. 重构方法说明",slug:"_2-5-重构方法说明",normalizedTitle:"2.5. 重构方法说明",charIndex:1161},{level:4,title:"2.5.1. 折叠继承体系(Collapse Hierarchy)",slug:"_2-5-1-折叠继承体系-collapse-hierarchy",normalizedTitle:"2.5.1. 折叠继承体系(collapse hierarchy)",charIndex:1176},{level:4,title:"2.5.2. 将类内联化(Inline Class)",slug:"_2-5-2-将类内联化-inline-class",normalizedTitle:"2.5.2. 将类内联化(inline class)",charIndex:1250},{level:4,title:"2.5.3. 内联函数(Inline Method)",slug:"_2-5-3-内联函数-inline-method",normalizedTitle:"2.5.3. 内联函数(inline method)",charIndex:1332},{level:4,title:"2.5.4. 移除参数(Remove Parameter)",slug:"_2-5-4-移除参数-remove-parameter",normalizedTitle:"2.5.4. 移除参数(remove parameter)",charIndex:1708},{level:2,title:"3. 纯稚的数据类",slug:"_3-纯稚的数据类",normalizedTitle:"3. 纯稚的数据类",charIndex:1778},{level:3,title:"3.1. 问题原因",slug:"_3-1-问题原因",normalizedTitle:"3.1. 问题原因",charIndex:1902},{level:3,title:"3.2. 解决方法",slug:"_3-2-解决方法",normalizedTitle:"3.2. 解决方法",charIndex:1998},{level:3,title:"3.3. 收益",slug:"_3-3-收益",normalizedTitle:"3.3. 收益",charIndex:2407},{level:3,title:"3.4. 重构方法说明",slug:"_3-4-重构方法说明",normalizedTitle:"3.4. 重构方法说明",charIndex:2486},{level:4,title:"3.4.1. 封装字段(Encapsulated Field)",slug:"_3-4-1-封装字段-encapsulated-field",normalizedTitle:"3.4.1. 封装字段(encapsulated field)",charIndex:2501},{level:4,title:"3.4.2. 封装集合(Encapsulated Collection)",slug:"_3-4-2-封装集合-encapsulated-collection",normalizedTitle:"3.4.2. 封装集合(encapsulated collection)",charIndex:2779},{level:4,title:"3.4.3. 搬移函数(Move Method)",slug:"_3-4-3-搬移函数-move-method",normalizedTitle:"3.4.3. 搬移函数(move method)",charIndex:2884},{level:4,title:"3.4.4. 提炼函数(Extract Method)",slug:"_3-4-4-提炼函数-extract-method",normalizedTitle:"3.4.4. 提炼函数(extract method)",charIndex:3021},{level:4,title:"3.4.5. 移除设置函数(Remove Setting Method)",slug:"_3-4-5-移除设置函数-remove-setting-method",normalizedTitle:"3.4.5. 移除设置函数(remove setting method)",charIndex:3464},{level:4,title:"3.4.6. 隐藏函数(Hide Method)",slug:"_3-4-6-隐藏函数-hide-method",normalizedTitle:"3.4.6. 隐藏函数(hide method)",charIndex:3560},{level:2,title:"4. 过多的注释",slug:"_4-过多的注释",normalizedTitle:"4. 过多的注释",charIndex:3641},{level:3,title:"4.1. 问题原因",slug:"_4-1-问题原因",normalizedTitle:"4.1. 问题原因",charIndex:3732},{level:3,title:"4.2. 解决方法",slug:"_4-2-解决方法",normalizedTitle:"4.2. 解决方法",charIndex:3871},{level:3,title:"4.3. 收益",slug:"_4-3-收益",normalizedTitle:"4.3. 收益",charIndex:4123},{level:3,title:"4.4. 何时忽略",slug:"_4-4-何时忽略",normalizedTitle:"4.4. 何时忽略",charIndex:4151},{level:3,title:"4.5. 重构方法说明",slug:"_4-5-重构方法说明",normalizedTitle:"4.5. 重构方法说明",charIndex:4233},{level:4,title:"4.5.1. 提炼变量(Extract Variable)",slug:"_4-5-1-提炼变量-extract-variable",normalizedTitle:"4.5.1. 提炼变量(extract variable)",charIndex:4248},{level:4,title:"4.5.2. 提炼函数(Extract Method)",slug:"_4-5-2-提炼函数-extract-method",normalizedTitle:"4.5.2. 提炼函数(extract method)",charIndex:4822},{level:4,title:"4.5.3. 函数改名(Rename Method)",slug:"_4-5-3-函数改名-rename-method",normalizedTitle:"4.5.3. 函数改名(rename method)",charIndex:5265},{level:4,title:"4.5.4. 引入断言(Introduce Assertion)",slug:"_4-5-4-引入断言-introduce-assertion",normalizedTitle:"4.5.4. 引入断言(introduce assertion)",charIndex:5428},{level:2,title:"5. 重复代码",slug:"_5-重复代码",normalizedTitle:"5. 重复代码",charIndex:6004},{level:3,title:"5.1. 问题原因",slug:"_5-1-问题原因",normalizedTitle:"5.1. 问题原因",charIndex:6077},{level:3,title:"5.2. 解决方法",slug:"_5-2-解决方法",normalizedTitle:"5.2. 解决方法",charIndex:6303},{level:3,title:"5.3. 收益",slug:"_5-3-收益",normalizedTitle:"5.3. 收益",charIndex:7134},{level:3,title:"5.4. 重构方法说明",slug:"_5-4-重构方法说明",normalizedTitle:"5.4. 重构方法说明",charIndex:7188},{level:4,title:"5.4.1. 提炼函数(Extract Method)",slug:"_5-4-1-提炼函数-extract-method",normalizedTitle:"5.4.1. 提炼函数(extract method)",charIndex:7203},{level:4,title:"5.4.2. 函数上移(Pull Up Method)",slug:"_5-4-2-函数上移-pull-up-method",normalizedTitle:"5.4.2. 函数上移(pull up method)",charIndex:7646},{level:4,title:"5.4.3. 构造函数本体上移(Pull Up Constructor Body)",slug:"_5-4-3-构造函数本体上移-pull-up-constructor-body",normalizedTitle:"5.4.3. 构造函数本体上移(pull up constructor body)",charIndex:7723},{level:4,title:"5.4.4. 塑造模板函数(Form Template Method)",slug:"_5-4-4-塑造模板函数-form-template-method",normalizedTitle:"5.4.4. 塑造模板函数(form template method)",charIndex:8149},{level:4,title:"5.4.5. 替换算法(Substitute Algorithm)",slug:"_5-4-5-替换算法-substitute-algorithm",normalizedTitle:"5.4.5. 替换算法(substitute algorithm)",charIndex:8330},{level:4,title:"5.4.6. 提炼超类(Extract Superclass)",slug:"_5-4-6-提炼超类-extract-superclass",normalizedTitle:"5.4.6. 提炼超类(extract superclass)",charIndex:8949},{level:4,title:"5.4.7. 提炼类(Extract Class)",slug:"_5-4-7-提炼类-extract-class",normalizedTitle:"5.4.7. 提炼类(extract class)",charIndex:9031},{level:4,title:"5.4.8. 合并条件表达式(Consolidate Conditional Expression)",slug:"_5-4-8-合并条件表达式-consolidate-conditional-expression",normalizedTitle:"5.4.8. 合并条件表达式(consolidate conditional expression)",charIndex:9112},{level:4,title:"5.4.9. 合并重复的条件片段(Consolidate Duplicate Conditional Fragments)",slug:"_5-4-9-合并重复的条件片段-consolidate-duplicate-conditional-fragments",normalizedTitle:"5.4.9. 合并重复的条件片段(consolidate duplicate conditional fragments)",charIndex:9559},{level:2,title:"6. 扩展阅读",slug:"_6-扩展阅读",normalizedTitle:"6. 扩展阅读",charIndex:9873},{level:2,title:"7. 参考资料",slug:"_7-参考资料",normalizedTitle:"7. 参考资料",charIndex:9970}],headersStr:"1. 冗余类 1.1. 问题原因 1.2. 解决方法 1.3. 收益 1.4. 何时忽略 1.5. 重构方法说明 1.5.1. 将类内联化(Inline Class) 1.5.2. 折叠继承体系(Collapse Hierarchy) 2. 夸夸其谈未来性 2.1. 问题原因 2.2. 解决方法 2.3. 收益 2.4. 何时忽略 2.5. 重构方法说明 2.5.1. 折叠继承体系(Collapse Hierarchy) 2.5.2. 将类内联化(Inline Class) 2.5.3. 内联函数(Inline Method) 2.5.4. 移除参数(Remove Parameter) 3. 纯稚的数据类 3.1. 问题原因 3.2. 解决方法 3.3. 收益 3.4. 重构方法说明 3.4.1. 封装字段(Encapsulated Field) 3.4.2. 封装集合(Encapsulated Collection) 3.4.3. 搬移函数(Move Method) 3.4.4. 提炼函数(Extract Method) 3.4.5. 移除设置函数(Remove Setting Method) 3.4.6. 隐藏函数(Hide Method) 4. 过多的注释 4.1. 问题原因 4.2. 解决方法 4.3. 收益 4.4. 何时忽略 4.5. 重构方法说明 4.5.1. 提炼变量(Extract Variable) 4.5.2. 提炼函数(Extract Method) 4.5.3. 函数改名(Rename Method) 4.5.4. 引入断言(Introduce Assertion) 5. 重复代码 5.1. 问题原因 5.2. 解决方法 5.3. 收益 5.4. 重构方法说明 5.4.1. 提炼函数(Extract Method) 5.4.2. 函数上移(Pull Up Method) 5.4.3. 构造函数本体上移(Pull Up Constructor Body) 5.4.4. 塑造模板函数(Form Template Method) 5.4.5. 替换算法(Substitute Algorithm) 5.4.6. 提炼超类(Extract Superclass) 5.4.7. 提炼类(Extract Class) 5.4.8. 合并条件表达式(Consolidate Conditional Expression) 5.4.9. 合并重复的条件片段(Consolidate Duplicate Conditional Fragments) 6. 扩展阅读 7. 参考资料",content:'> 翻译自：https://sourcemaking.com/refactoring/smells/dispensables\n> \n> 非必要的(Dispensables)这组坏味道意味着：这样的代码可有可无，它的存在反而影响整体代码的整洁和可读性。\n\n\n# 1. 冗余类\n\n> 冗余类(Lazy Class)\n> \n> 理解和维护总是费时费力的。如果一个类不值得你花费精力，它就应该被删除。\n\n\n\n\n# 1.1. 问题原因\n\n也许一个类的初始设计是一个功能完全的类，然而随着代码的变迁，变得没什么用了。 又或者类起初的设计是为了支持未来的功能扩展，然而却一直未派上用场。\n\n\n# 1.2. 解决方法\n\n * 没什么用的类可以运用 将类内联化(Inline Class) 来干掉。\n\n\n\n * 如果子类用处不大，试试 折叠继承体系(Collapse Hierarchy) 。\n\n\n# 1.3. 收益\n\n * 减少代码量\n * 易于维护\n\n\n# 1.4. 何时忽略\n\n * 有时，创建冗余类是为了描述未来开发的意图。在这种情况下，尝试在代码中保持清晰和简单之间的平衡。\n\n\n# 1.5. 重构方法说明\n\n# 1.5.1. 将类内联化(Inline Class)\n\n问题\n\n某个类没有做太多事情。\n\n\n\n解决\n\n将这个类的所有特性搬移到另一个类中，然后移除原类。\n\n\n\n# 1.5.2. 折叠继承体系(Collapse Hierarchy)\n\n问题\n\n超类和子类之间无太大区别。\n\n\n\n解决\n\n将它们合为一体。\n\n\n\n\n# 2. 夸夸其谈未来性\n\n> 夸夸其谈未来性(Speculative Generality)\n> \n> 存在未被使用的类、函数、字段或参数。\n\n\n\n\n# 2.1. 问题原因\n\n有时，代码仅仅为了支持未来的特性而产生，然而却一直未实现。结果，代码变得难以理解和维护。\n\n\n# 2.2. 解决方法\n\n * 如果你的某个抽象类其实没有太大作用，请运用 折叠继承体系(Collapse Hierarch) 。\n\n\n\n * 不必要的委托可运用 将类内联化(Inline Class) 消除。\n * 无用的函数可运用 内联函数(Inline Method) 消除。\n * 函数中有无用的参数应该运用 移除参数(Remove Parameter) 消除。\n * 无用字段可以直接删除。\n\n\n# 2.3. 收益\n\n * 减少代码量。\n * 更易维护。\n\n\n# 2.4. 何时忽略\n\n * 如果你在一个框架上工作，创建框架本身没有使用的功能是非常合理的，只要框架的用户需要这个功能。\n * 删除元素之前，请确保它们不在单元测试中使用。如果测试需要从类中获取某些内部信息或执行特殊的测试相关操作，就会发生这种情况。\n\n\n# 2.5. 重构方法说明\n\n# 2.5.1. 折叠继承体系(Collapse Hierarchy)\n\n问题\n\n超类和子类之间无太大区别。\n\n\n\n解决\n\n将它们合为一体。\n\n\n\n# 2.5.2. 将类内联化(Inline Class)\n\n问题\n\n某个类没有做太多事情。\n\n\n\n解决\n\n将这个类的所有特性搬移到另一个类中，然后移除原类。\n\n\n\n# 2.5.3. 内联函数(Inline Method)\n\n问题\n\n一个函数的本体比函数名更清楚易懂。\n\nclass PizzaDelivery {\n  //...\n  int getRating() {\n    return moreThanFiveLateDeliveries() ? 2 : 1;\n  }\n  boolean moreThanFiveLateDeliveries() {\n    return numberOfLateDeliveries > 5;\n  }\n}\n\n\n解决\n\n在函数调用点插入函数本体，然后移除该函数。\n\nclass PizzaDelivery {\n  //...\n  int getRating() {\n    return numberOfLateDeliveries > 5 ? 2 : 1;\n  }\n}\n\n\n# 2.5.4. 移除参数(Remove Parameter)\n\n问题\n\n函数本体不再需要某个参数。\n\n\n\n解决\n\n将该参数去除。\n\n\n\n\n# 3. 纯稚的数据类\n\n> 纯稚的数据类(Data Class) 指的是只包含字段和访问它们的 getter 和 setter 函数的类。这些仅仅是供其他类使用的数据容器。这些类不包含任何附加功能，并且不能对自己拥有的数据进行独立操作。\n\n\n\n\n# 3.1. 问题原因\n\n当一个新创建的类只包含几个公共字段（甚至可能几个 getters / setters）是很正常的。但是对象的真正力量在于它们可以包含作用于数据的行为类型或操作。\n\n\n# 3.2. 解决方法\n\n * 如果一个类有公共字段，你应该运用 封装字段(Encapsulated Field) 来隐藏字段的直接访问方式。\n * 如果这些类含容器类的字段，你应该检查它们是不是得到了恰当的封装；如果没有，就运用 封装集合(Encapsulated Collection) 把它们封装起来。\n * 找出这些 getter/setter 函数被其他类运用的地点。尝试以 搬移函数(Move Method) 把那些调用行为搬移到 纯稚的数据类(Data Class) 来。如果无法搬移这个函数，就运用 提炼函数(Extract Method) 产生一个可搬移的函数。\n\n\n\n * 在类已经充满了深思熟虑的函数之后，你可能想要摆脱旧的数据访问方法，以提供适应面较广的类数据访问接口。为此，可以运用 移除设置函数(Remove Setting Method) 和 隐藏函数(Hide Method) 。\n\n\n# 3.3. 收益\n\n * 提高代码的可读性和组织性。特定数据的操作现在被集中在一个地方，而不是在分散在代码各处。\n * 帮助你发现客户端代码的重复处。\n\n\n# 3.4. 重构方法说明\n\n# 3.4.1. 封装字段(Encapsulated Field)\n\n问题\n\n你的类中存在 public 字段。\n\nclass Person {\n  public String name;\n}\n\n\n解决\n\n将它声明为 private，并提供相应的访问函数。\n\nclass Person {\n  private String name;\n\n  public String getName() {\n    return name;\n  }\n  public void setName(String arg) {\n    name = arg;\n  }\n}\n\n\n# 3.4.2. 封装集合(Encapsulated Collection)\n\n问题\n\n有个函数返回一个集合。\n\n\n\n解决\n\n让该函数返回该集合的一个只读副本，并在这个类中提供添加、移除集合元素的函数。\n\n\n\n# 3.4.3. 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 3.4.4. 提炼函数(Extract Method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printOwing() {\n  printBanner();\n\n  //print details\n  System.out.println("name: " + name);\n  System.out.println("amount: " + getOutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printOwing() {\n  printBanner();\n  printDetails(getOutstanding());\n}\n\nvoid printDetails(double outstanding) {\n  System.out.println("name: " + name);\n  System.out.println("amount: " + outstanding);\n}\n\n\n# 3.4.5. 移除设置函数(Remove Setting Method)\n\n问题\n\n类中的某个字段应该在对象创建时被设值，然后就不再改变。\n\n\n\n解决\n\n去掉该字段的所有设值函数。\n\n\n\n# 3.4.6. 隐藏函数(Hide Method)\n\n问题\n\n有一个函数，从来没有被其他任何类用到。\n\n\n\n解决\n\n将这个函数修改为 private。\n\n\n\n\n# 4. 过多的注释\n\n> 过多的注释(Comments)\n> \n> 注释本身并不是坏事。但是常常有这样的情况：一段代码中出现长长的注释，而它之所以存在，是因为代码很糟糕。\n\n\n\n\n# 4.1. 问题原因\n\n注释的作者意识到自己的代码不直观或不明显，所以想使用注释来说明自己的意图。这种情况下，注释就像是烂代码的除臭剂。\n\n> 最好的注释是为函数或类起一个恰当的名字。\n\n如果你觉得一个代码片段没有注释就无法理解，请先尝试重构，试着让所有注释都变得多余。\n\n\n# 4.2. 解决方法\n\n * 如果一个注释是为了解释一个复杂的表达式，可以运用 提炼变量(Extract Variable) 将表达式切分为易理解的子表达式。\n * 如果你需要通过注释来解释一段代码做了什么，请试试 提炼函数(Extract Method) 。\n * 如果函数已经被提炼，但仍需要注释函数做了什么，试试运用 函数改名(Rename Method) 来为函数起一个可以自解释的名字。\n * 如果需要对系统某状态进行断言，请运用 引入断言(Introduce Assertion) 。\n\n\n# 4.3. 收益\n\n * 代码变得更直观和明显。\n\n\n# 4.4. 何时忽略\n\n注释有时候很有用：\n\n * 当解释为什么某事物要以特殊方式实现时。\n * 当解释某种复杂算法时。\n * 当你实在不知可以做些什么时。\n\n\n# 4.5. 重构方法说明\n\n# 4.5.1. 提炼变量(Extract Variable)\n\n问题\n\n你有个难以理解的表达式。\n\nvoid renderBanner() {\n  if ((platform.toUpperCase().indexOf("MAC") > -1) &&\n       (browser.toUpperCase().indexOf("IE") > -1) &&\n        wasInitialized() && resize > 0 )\n  {\n    // do something\n  }\n}\n\n\n解决\n\n将表达式的结果或它的子表达式的结果用不言自明的变量来替代。\n\nvoid renderBanner() {\n  final boolean isMacOs = platform.toUpperCase().indexOf("MAC") > -1;\n  final boolean isIE = browser.toUpperCase().indexOf("IE") > -1;\n  final boolean wasResized = resize > 0;\n\n  if (isMacOs && isIE && wasInitialized() && wasResized) {\n    // do something\n  }\n}\n\n\n# 4.5.2. 提炼函数(Extract Method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printOwing() {\n  printBanner();\n\n  //print details\n  System.out.println("name: " + name);\n  System.out.println("amount: " + getOutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printOwing() {\n  printBanner();\n  printDetails(getOutstanding());\n}\n\nvoid printDetails(double outstanding) {\n  System.out.println("name: " + name);\n  System.out.println("amount: " + outstanding);\n}\n\n\n# 4.5.3. 函数改名(Rename Method)\n\n问题\n\n函数的名称未能恰当的揭示函数的用途。\n\nclass Person {\n  public String getsnm();\n}\n\n\n解决\n\n修改函数名。\n\nclass Person {\n  public String getSecondName();\n}\n\n\n# 4.5.4. 引入断言(Introduce Assertion)\n\n问题\n\n某一段代码需要对程序状态做出某种假设。\n\ndouble getExpenseLimit() {\n  // should have either expense limit or a primary project\n  return (expenseLimit != NULL_EXPENSE) ?\n    expenseLimit:\n    primaryProject.getMemberExpenseLimit();\n}\n\n\n解决\n\n以断言明确表现这种假设。\n\ndouble getExpenseLimit() {\n  Assert.isTrue(expenseLimit != NULL_EXPENSE || primaryProject != null);\n\n  return (expenseLimit != NULL_EXPENSE) ?\n    expenseLimit:\n    primaryProject.getMemberExpenseLimit();\n}\n\n\n注：请不要滥用断言。不要使用它来检查”应该为真“的条件，只能使用它来检查“一定必须为真”的条件。实际上，断言更多是用于自我检测代码的一种手段。在产品真正交付时，往往都会消除所有断言。\n\n\n# 5. 重复代码\n\n> 重复代码(Duplicate Code)\n> \n> 重复代码堪称为代码坏味道之首。消除重复代码总是有利无害的。\n\n\n\n\n# 5.1. 问题原因\n\n重复代码通常发生在多个程序员同时在同一程序的不同部分上工作时。由于他们正在处理不同的任务，他们可能不知道他们的同事已经写了类似的代码。\n\n还有一种更隐晦的重复，特定部分的代码看上去不同但实际在做同一件事。这种重复代码往往难以找到和消除。\n\n有时重复是有目的性的。当急于满足 deadline，并且现有代码对于要交付的任务是“几乎正确的”时，新手程序员可能无法抵抗复制和粘贴相关代码的诱惑。在某些情况下，程序员只是太懒惰。\n\n\n# 5.2. 解决方法\n\n * 同一个类的两个函数含有相同的表达式，这时可以采用 提炼函数(Extract Method) 提炼出重复的代码，然后让这两个地点都调用被提炼出来的那段代码。\n\n\n\n * 如果两个互为兄弟的子类含有重复代码：\n   * 首先对两个类都运用 提炼函数(Extract Method) ，然后对被提炼出来的函数运用 函数上移(Pull Up Method) ，将它推入超类。\n   * 如果重复代码在构造函数中，运用 构造函数本体上移(Pull Up Constructor Body) 。\n   * 如果重复代码只是相似但不是完全相同，运用 塑造模板函数(Form Template Method) 获得一个 模板方法模式(Template Method) 。\n   * 如果有些函数以不同的算法做相同的事，你可以选择其中较清晰地一个，并运用 替换算法(Substitute Algorithm) 将其他函数的算法替换掉。\n * 如果两个毫不相关的类中有重复代码：\n   * 请尝试运用 提炼超类(Extract Superclass) ，以便为维护所有先前功能的这些类创建一个超类。\n   * 如果创建超类十分困难，可以在一个类中运用 提炼类(Extract Class) ，并在另一个类中使用这个新的组件。\n * 如果存在大量的条件表达式，并且它们执行完全相同的代码（仅仅是它们的条件不同），可以运用 合并条件表达式(Consolidate Conditional Expression) 将这些操作合并为单个条件，并运用 提炼函数(Extract Method) 将该条件放入一个名字容易理解的独立函数中。\n * 如果条件表达式的所有分支都有部分相同的代码片段：可以运用 合并重复的条件片段(Consolidate Duplicate Conditional Fragments) 将它们都存在的代码片段置于条件表达式外部。\n\n\n# 5.3. 收益\n\n * 合并重复代码会简化代码的结构，并减少代码量。\n * 代码更简化、更易维护。\n\n\n# 5.4. 重构方法说明\n\n# 5.4.1. 提炼函数(Extract Method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printOwing() {\n  printBanner();\n\n  //print details\n  System.out.println("name: " + name);\n  System.out.println("amount: " + getOutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printOwing() {\n  printBanner();\n  printDetails(getOutstanding());\n}\n\nvoid printDetails(double outstanding) {\n  System.out.println("name: " + name);\n  System.out.println("amount: " + outstanding);\n}\n\n\n# 5.4.2. 函数上移(Pull Up Method)\n\n问题\n\n有些函数，在各个子类中产生完全相同的结果。\n\n\n\n解决\n\n将该函数移至超类。\n\n\n\n# 5.4.3. 构造函数本体上移(Pull Up Constructor Body)\n\n问题\n\n你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。\n\nclass Manager extends Employee {\n  public Manager(String name, String id, int grade) {\n    this.name = name;\n    this.id = id;\n    this.grade = grade;\n  }\n  //...\n}\n\n\n解决\n\n在超类中新建一个构造函数，并在子类构造函数中调用它。\n\nclass Manager extends Employee {\n  public Manager(String name, String id, int grade) {\n    super(name, id);\n    this.grade = grade;\n  }\n  //...\n}\n\n\n# 5.4.4. 塑造模板函数(Form Template Method)\n\n问题\n\n你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作的细节上有所不同。\n\n\n\n解决\n\n将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。\n\n\n\n注：这里只提到具体做法，建议了解一下模板方法设计模式。\n\n# 5.4.5. 替换算法(Substitute Algorithm)\n\n问题\n\n你想要把某个算法替换为另一个更清晰的算法。\n\nString foundPerson(String[] people){\n  for (int i = 0; i < people.length; i++) {\n    if (people[i].equals("Don")){\n      return "Don";\n    }\n    if (people[i].equals("John")){\n      return "John";\n    }\n    if (people[i].equals("Kent")){\n      return "Kent";\n    }\n  }\n  return "";\n}\n\n\n解决\n\n将函数本体替换为另一个算法。\n\nString foundPerson(String[] people){\n  List candidates =\n    Arrays.asList(new String[] {"Don", "John", "Kent"});\n  for (int i=0; i < people.length; i++) {\n    if (candidates.contains(people[i])) {\n      return people[i];\n    }\n  }\n  return "";\n}\n\n\n# 5.4.6. 提炼超类(Extract Superclass)\n\n问题\n\n两个类有相似特性。\n\n\n\n解决\n\n为这两个类建立一个超类，将相同特性移至超类。\n\n\n\n# 5.4.7. 提炼类(Extract Class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 5.4.8. 合并条件表达式(Consolidate Conditional Expression)\n\n问题\n\n你有一系列条件分支，都得到相同结果。\n\ndouble disabilityAmount() {\n  if (seniority < 2) {\n    return 0;\n  }\n  if (monthsDisabled > 12) {\n    return 0;\n  }\n  if (isPartTime) {\n    return 0;\n  }\n  // compute the disability amount\n  //...\n}\n\n\n解决\n\n将这些条件分支合并为一个条件，并将这个条件提炼为一个独立函数。\n\ndouble disabilityAmount() {\n  if (isNotEligableForDisability()) {\n    return 0;\n  }\n  // compute the disability amount\n  //...\n}\n\n\n# 5.4.9. 合并重复的条件片段(Consolidate Duplicate Conditional Fragments)\n\n问题\n\n在条件表达式的每个分支上有着相同的一段代码。\n\nif (isSpecialDeal()) {\n  total = price * 0.95;\n  send();\n}\nelse {\n  total = price * 0.98;\n  send();\n}\n\n\n解决\n\n将这段重复代码搬移到条件表达式之外。\n\nif (isSpecialDeal()) {\n  total = price * 0.95;\n}\nelse {\n  total = price * 0.98;\n}\nsend();\n\n\n\n# 6. 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 7. 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',normalizedContent:'> 翻译自：https://sourcemaking.com/refactoring/smells/dispensables\n> \n> 非必要的(dispensables)这组坏味道意味着：这样的代码可有可无，它的存在反而影响整体代码的整洁和可读性。\n\n\n# 1. 冗余类\n\n> 冗余类(lazy class)\n> \n> 理解和维护总是费时费力的。如果一个类不值得你花费精力，它就应该被删除。\n\n\n\n\n# 1.1. 问题原因\n\n也许一个类的初始设计是一个功能完全的类，然而随着代码的变迁，变得没什么用了。 又或者类起初的设计是为了支持未来的功能扩展，然而却一直未派上用场。\n\n\n# 1.2. 解决方法\n\n * 没什么用的类可以运用 将类内联化(inline class) 来干掉。\n\n\n\n * 如果子类用处不大，试试 折叠继承体系(collapse hierarchy) 。\n\n\n# 1.3. 收益\n\n * 减少代码量\n * 易于维护\n\n\n# 1.4. 何时忽略\n\n * 有时，创建冗余类是为了描述未来开发的意图。在这种情况下，尝试在代码中保持清晰和简单之间的平衡。\n\n\n# 1.5. 重构方法说明\n\n# 1.5.1. 将类内联化(inline class)\n\n问题\n\n某个类没有做太多事情。\n\n\n\n解决\n\n将这个类的所有特性搬移到另一个类中，然后移除原类。\n\n\n\n# 1.5.2. 折叠继承体系(collapse hierarchy)\n\n问题\n\n超类和子类之间无太大区别。\n\n\n\n解决\n\n将它们合为一体。\n\n\n\n\n# 2. 夸夸其谈未来性\n\n> 夸夸其谈未来性(speculative generality)\n> \n> 存在未被使用的类、函数、字段或参数。\n\n\n\n\n# 2.1. 问题原因\n\n有时，代码仅仅为了支持未来的特性而产生，然而却一直未实现。结果，代码变得难以理解和维护。\n\n\n# 2.2. 解决方法\n\n * 如果你的某个抽象类其实没有太大作用，请运用 折叠继承体系(collapse hierarch) 。\n\n\n\n * 不必要的委托可运用 将类内联化(inline class) 消除。\n * 无用的函数可运用 内联函数(inline method) 消除。\n * 函数中有无用的参数应该运用 移除参数(remove parameter) 消除。\n * 无用字段可以直接删除。\n\n\n# 2.3. 收益\n\n * 减少代码量。\n * 更易维护。\n\n\n# 2.4. 何时忽略\n\n * 如果你在一个框架上工作，创建框架本身没有使用的功能是非常合理的，只要框架的用户需要这个功能。\n * 删除元素之前，请确保它们不在单元测试中使用。如果测试需要从类中获取某些内部信息或执行特殊的测试相关操作，就会发生这种情况。\n\n\n# 2.5. 重构方法说明\n\n# 2.5.1. 折叠继承体系(collapse hierarchy)\n\n问题\n\n超类和子类之间无太大区别。\n\n\n\n解决\n\n将它们合为一体。\n\n\n\n# 2.5.2. 将类内联化(inline class)\n\n问题\n\n某个类没有做太多事情。\n\n\n\n解决\n\n将这个类的所有特性搬移到另一个类中，然后移除原类。\n\n\n\n# 2.5.3. 内联函数(inline method)\n\n问题\n\n一个函数的本体比函数名更清楚易懂。\n\nclass pizzadelivery {\n  //...\n  int getrating() {\n    return morethanfivelatedeliveries() ? 2 : 1;\n  }\n  boolean morethanfivelatedeliveries() {\n    return numberoflatedeliveries > 5;\n  }\n}\n\n\n解决\n\n在函数调用点插入函数本体，然后移除该函数。\n\nclass pizzadelivery {\n  //...\n  int getrating() {\n    return numberoflatedeliveries > 5 ? 2 : 1;\n  }\n}\n\n\n# 2.5.4. 移除参数(remove parameter)\n\n问题\n\n函数本体不再需要某个参数。\n\n\n\n解决\n\n将该参数去除。\n\n\n\n\n# 3. 纯稚的数据类\n\n> 纯稚的数据类(data class) 指的是只包含字段和访问它们的 getter 和 setter 函数的类。这些仅仅是供其他类使用的数据容器。这些类不包含任何附加功能，并且不能对自己拥有的数据进行独立操作。\n\n\n\n\n# 3.1. 问题原因\n\n当一个新创建的类只包含几个公共字段（甚至可能几个 getters / setters）是很正常的。但是对象的真正力量在于它们可以包含作用于数据的行为类型或操作。\n\n\n# 3.2. 解决方法\n\n * 如果一个类有公共字段，你应该运用 封装字段(encapsulated field) 来隐藏字段的直接访问方式。\n * 如果这些类含容器类的字段，你应该检查它们是不是得到了恰当的封装；如果没有，就运用 封装集合(encapsulated collection) 把它们封装起来。\n * 找出这些 getter/setter 函数被其他类运用的地点。尝试以 搬移函数(move method) 把那些调用行为搬移到 纯稚的数据类(data class) 来。如果无法搬移这个函数，就运用 提炼函数(extract method) 产生一个可搬移的函数。\n\n\n\n * 在类已经充满了深思熟虑的函数之后，你可能想要摆脱旧的数据访问方法，以提供适应面较广的类数据访问接口。为此，可以运用 移除设置函数(remove setting method) 和 隐藏函数(hide method) 。\n\n\n# 3.3. 收益\n\n * 提高代码的可读性和组织性。特定数据的操作现在被集中在一个地方，而不是在分散在代码各处。\n * 帮助你发现客户端代码的重复处。\n\n\n# 3.4. 重构方法说明\n\n# 3.4.1. 封装字段(encapsulated field)\n\n问题\n\n你的类中存在 public 字段。\n\nclass person {\n  public string name;\n}\n\n\n解决\n\n将它声明为 private，并提供相应的访问函数。\n\nclass person {\n  private string name;\n\n  public string getname() {\n    return name;\n  }\n  public void setname(string arg) {\n    name = arg;\n  }\n}\n\n\n# 3.4.2. 封装集合(encapsulated collection)\n\n问题\n\n有个函数返回一个集合。\n\n\n\n解决\n\n让该函数返回该集合的一个只读副本，并在这个类中提供添加、移除集合元素的函数。\n\n\n\n# 3.4.3. 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 3.4.4. 提炼函数(extract method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printowing() {\n  printbanner();\n\n  //print details\n  system.out.println("name: " + name);\n  system.out.println("amount: " + getoutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printowing() {\n  printbanner();\n  printdetails(getoutstanding());\n}\n\nvoid printdetails(double outstanding) {\n  system.out.println("name: " + name);\n  system.out.println("amount: " + outstanding);\n}\n\n\n# 3.4.5. 移除设置函数(remove setting method)\n\n问题\n\n类中的某个字段应该在对象创建时被设值，然后就不再改变。\n\n\n\n解决\n\n去掉该字段的所有设值函数。\n\n\n\n# 3.4.6. 隐藏函数(hide method)\n\n问题\n\n有一个函数，从来没有被其他任何类用到。\n\n\n\n解决\n\n将这个函数修改为 private。\n\n\n\n\n# 4. 过多的注释\n\n> 过多的注释(comments)\n> \n> 注释本身并不是坏事。但是常常有这样的情况：一段代码中出现长长的注释，而它之所以存在，是因为代码很糟糕。\n\n\n\n\n# 4.1. 问题原因\n\n注释的作者意识到自己的代码不直观或不明显，所以想使用注释来说明自己的意图。这种情况下，注释就像是烂代码的除臭剂。\n\n> 最好的注释是为函数或类起一个恰当的名字。\n\n如果你觉得一个代码片段没有注释就无法理解，请先尝试重构，试着让所有注释都变得多余。\n\n\n# 4.2. 解决方法\n\n * 如果一个注释是为了解释一个复杂的表达式，可以运用 提炼变量(extract variable) 将表达式切分为易理解的子表达式。\n * 如果你需要通过注释来解释一段代码做了什么，请试试 提炼函数(extract method) 。\n * 如果函数已经被提炼，但仍需要注释函数做了什么，试试运用 函数改名(rename method) 来为函数起一个可以自解释的名字。\n * 如果需要对系统某状态进行断言，请运用 引入断言(introduce assertion) 。\n\n\n# 4.3. 收益\n\n * 代码变得更直观和明显。\n\n\n# 4.4. 何时忽略\n\n注释有时候很有用：\n\n * 当解释为什么某事物要以特殊方式实现时。\n * 当解释某种复杂算法时。\n * 当你实在不知可以做些什么时。\n\n\n# 4.5. 重构方法说明\n\n# 4.5.1. 提炼变量(extract variable)\n\n问题\n\n你有个难以理解的表达式。\n\nvoid renderbanner() {\n  if ((platform.touppercase().indexof("mac") > -1) &&\n       (browser.touppercase().indexof("ie") > -1) &&\n        wasinitialized() && resize > 0 )\n  {\n    // do something\n  }\n}\n\n\n解决\n\n将表达式的结果或它的子表达式的结果用不言自明的变量来替代。\n\nvoid renderbanner() {\n  final boolean ismacos = platform.touppercase().indexof("mac") > -1;\n  final boolean isie = browser.touppercase().indexof("ie") > -1;\n  final boolean wasresized = resize > 0;\n\n  if (ismacos && isie && wasinitialized() && wasresized) {\n    // do something\n  }\n}\n\n\n# 4.5.2. 提炼函数(extract method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printowing() {\n  printbanner();\n\n  //print details\n  system.out.println("name: " + name);\n  system.out.println("amount: " + getoutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printowing() {\n  printbanner();\n  printdetails(getoutstanding());\n}\n\nvoid printdetails(double outstanding) {\n  system.out.println("name: " + name);\n  system.out.println("amount: " + outstanding);\n}\n\n\n# 4.5.3. 函数改名(rename method)\n\n问题\n\n函数的名称未能恰当的揭示函数的用途。\n\nclass person {\n  public string getsnm();\n}\n\n\n解决\n\n修改函数名。\n\nclass person {\n  public string getsecondname();\n}\n\n\n# 4.5.4. 引入断言(introduce assertion)\n\n问题\n\n某一段代码需要对程序状态做出某种假设。\n\ndouble getexpenselimit() {\n  // should have either expense limit or a primary project\n  return (expenselimit != null_expense) ?\n    expenselimit:\n    primaryproject.getmemberexpenselimit();\n}\n\n\n解决\n\n以断言明确表现这种假设。\n\ndouble getexpenselimit() {\n  assert.istrue(expenselimit != null_expense || primaryproject != null);\n\n  return (expenselimit != null_expense) ?\n    expenselimit:\n    primaryproject.getmemberexpenselimit();\n}\n\n\n注：请不要滥用断言。不要使用它来检查”应该为真“的条件，只能使用它来检查“一定必须为真”的条件。实际上，断言更多是用于自我检测代码的一种手段。在产品真正交付时，往往都会消除所有断言。\n\n\n# 5. 重复代码\n\n> 重复代码(duplicate code)\n> \n> 重复代码堪称为代码坏味道之首。消除重复代码总是有利无害的。\n\n\n\n\n# 5.1. 问题原因\n\n重复代码通常发生在多个程序员同时在同一程序的不同部分上工作时。由于他们正在处理不同的任务，他们可能不知道他们的同事已经写了类似的代码。\n\n还有一种更隐晦的重复，特定部分的代码看上去不同但实际在做同一件事。这种重复代码往往难以找到和消除。\n\n有时重复是有目的性的。当急于满足 deadline，并且现有代码对于要交付的任务是“几乎正确的”时，新手程序员可能无法抵抗复制和粘贴相关代码的诱惑。在某些情况下，程序员只是太懒惰。\n\n\n# 5.2. 解决方法\n\n * 同一个类的两个函数含有相同的表达式，这时可以采用 提炼函数(extract method) 提炼出重复的代码，然后让这两个地点都调用被提炼出来的那段代码。\n\n\n\n * 如果两个互为兄弟的子类含有重复代码：\n   * 首先对两个类都运用 提炼函数(extract method) ，然后对被提炼出来的函数运用 函数上移(pull up method) ，将它推入超类。\n   * 如果重复代码在构造函数中，运用 构造函数本体上移(pull up constructor body) 。\n   * 如果重复代码只是相似但不是完全相同，运用 塑造模板函数(form template method) 获得一个 模板方法模式(template method) 。\n   * 如果有些函数以不同的算法做相同的事，你可以选择其中较清晰地一个，并运用 替换算法(substitute algorithm) 将其他函数的算法替换掉。\n * 如果两个毫不相关的类中有重复代码：\n   * 请尝试运用 提炼超类(extract superclass) ，以便为维护所有先前功能的这些类创建一个超类。\n   * 如果创建超类十分困难，可以在一个类中运用 提炼类(extract class) ，并在另一个类中使用这个新的组件。\n * 如果存在大量的条件表达式，并且它们执行完全相同的代码（仅仅是它们的条件不同），可以运用 合并条件表达式(consolidate conditional expression) 将这些操作合并为单个条件，并运用 提炼函数(extract method) 将该条件放入一个名字容易理解的独立函数中。\n * 如果条件表达式的所有分支都有部分相同的代码片段：可以运用 合并重复的条件片段(consolidate duplicate conditional fragments) 将它们都存在的代码片段置于条件表达式外部。\n\n\n# 5.3. 收益\n\n * 合并重复代码会简化代码的结构，并减少代码量。\n * 代码更简化、更易维护。\n\n\n# 5.4. 重构方法说明\n\n# 5.4.1. 提炼函数(extract method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printowing() {\n  printbanner();\n\n  //print details\n  system.out.println("name: " + name);\n  system.out.println("amount: " + getoutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printowing() {\n  printbanner();\n  printdetails(getoutstanding());\n}\n\nvoid printdetails(double outstanding) {\n  system.out.println("name: " + name);\n  system.out.println("amount: " + outstanding);\n}\n\n\n# 5.4.2. 函数上移(pull up method)\n\n问题\n\n有些函数，在各个子类中产生完全相同的结果。\n\n\n\n解决\n\n将该函数移至超类。\n\n\n\n# 5.4.3. 构造函数本体上移(pull up constructor body)\n\n问题\n\n你在各个子类中拥有一些构造函数，它们的本体几乎完全一致。\n\nclass manager extends employee {\n  public manager(string name, string id, int grade) {\n    this.name = name;\n    this.id = id;\n    this.grade = grade;\n  }\n  //...\n}\n\n\n解决\n\n在超类中新建一个构造函数，并在子类构造函数中调用它。\n\nclass manager extends employee {\n  public manager(string name, string id, int grade) {\n    super(name, id);\n    this.grade = grade;\n  }\n  //...\n}\n\n\n# 5.4.4. 塑造模板函数(form template method)\n\n问题\n\n你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作的细节上有所不同。\n\n\n\n解决\n\n将这些操作分别放进独立函数中，并保持它们都有相同的签名，于是原函数也就变得相同了。然后将原函数上移至超类。\n\n\n\n注：这里只提到具体做法，建议了解一下模板方法设计模式。\n\n# 5.4.5. 替换算法(substitute algorithm)\n\n问题\n\n你想要把某个算法替换为另一个更清晰的算法。\n\nstring foundperson(string[] people){\n  for (int i = 0; i < people.length; i++) {\n    if (people[i].equals("don")){\n      return "don";\n    }\n    if (people[i].equals("john")){\n      return "john";\n    }\n    if (people[i].equals("kent")){\n      return "kent";\n    }\n  }\n  return "";\n}\n\n\n解决\n\n将函数本体替换为另一个算法。\n\nstring foundperson(string[] people){\n  list candidates =\n    arrays.aslist(new string[] {"don", "john", "kent"});\n  for (int i=0; i < people.length; i++) {\n    if (candidates.contains(people[i])) {\n      return people[i];\n    }\n  }\n  return "";\n}\n\n\n# 5.4.6. 提炼超类(extract superclass)\n\n问题\n\n两个类有相似特性。\n\n\n\n解决\n\n为这两个类建立一个超类，将相同特性移至超类。\n\n\n\n# 5.4.7. 提炼类(extract class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 5.4.8. 合并条件表达式(consolidate conditional expression)\n\n问题\n\n你有一系列条件分支，都得到相同结果。\n\ndouble disabilityamount() {\n  if (seniority < 2) {\n    return 0;\n  }\n  if (monthsdisabled > 12) {\n    return 0;\n  }\n  if (isparttime) {\n    return 0;\n  }\n  // compute the disability amount\n  //...\n}\n\n\n解决\n\n将这些条件分支合并为一个条件，并将这个条件提炼为一个独立函数。\n\ndouble disabilityamount() {\n  if (isnoteligablefordisability()) {\n    return 0;\n  }\n  // compute the disability amount\n  //...\n}\n\n\n# 5.4.9. 合并重复的条件片段(consolidate duplicate conditional fragments)\n\n问题\n\n在条件表达式的每个分支上有着相同的一段代码。\n\nif (isspecialdeal()) {\n  total = price * 0.95;\n  send();\n}\nelse {\n  total = price * 0.98;\n  send();\n}\n\n\n解决\n\n将这段重复代码搬移到条件表达式之外。\n\nif (isspecialdeal()) {\n  total = price * 0.95;\n}\nelse {\n  total = price * 0.98;\n}\nsend();\n\n\n\n# 6. 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 7. 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"代码坏味道之耦合",frontmatter:{title:"代码坏味道之耦合",categories:["设计","重构"],tags:["设计","重构","代码的坏味道"],date:"2018-10-13T22:48:00.000Z",permalink:"/pages/595d03/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/03.%E9%87%8D%E6%9E%84/06.%E4%BB%A3%E7%A0%81%E5%9D%8F%E5%91%B3%E9%81%93%E4%B9%8B%E8%80%A6%E5%90%88.html",relativePath:"03.设计/03.重构/06.代码坏味道之耦合.md",key:"v-3a98d9f2",path:"/pages/595d03/",headers:[{level:2,title:"不完美的库类",slug:"不完美的库类",normalizedTitle:"不完美的库类",charIndex:100},{level:3,title:"问题原因",slug:"问题原因",normalizedTitle:"问题原因",charIndex:198},{level:3,title:"解决方法",slug:"解决方法",normalizedTitle:"解决方法",charIndex:289},{level:3,title:"收益",slug:"收益",normalizedTitle:"收益",charIndex:415},{level:3,title:"何时忽略",slug:"何时忽略",normalizedTitle:"何时忽略",charIndex:462},{level:3,title:"重构方法说明",slug:"重构方法说明",normalizedTitle:"重构方法说明",charIndex:491},{level:4,title:"引入外加函数(Introduce Foreign Method)",slug:"引入外加函数-introduce-foreign-method",normalizedTitle:"引入外加函数(introduce foreign method)",charIndex:319},{level:4,title:"引入本地扩展(Introduce Local Extension)",slug:"引入本地扩展-introduce-local-extension",normalizedTitle:"引入本地扩展(introduce local extension)",charIndex:375},{level:2,title:"中间人",slug:"中间人",normalizedTitle:"中间人",charIndex:1118},{level:3,title:"问题原因",slug:"问题原因-2",normalizedTitle:"问题原因",charIndex:198},{level:3,title:"解决方法",slug:"解决方法-2",normalizedTitle:"解决方法",charIndex:289},{level:3,title:"收益",slug:"收益-2",normalizedTitle:"收益",charIndex:415},{level:3,title:"何时忽略",slug:"何时忽略-2",normalizedTitle:"何时忽略",charIndex:462},{level:3,title:"重构方法说明",slug:"重构方法说明-2",normalizedTitle:"重构方法说明",charIndex:491},{level:4,title:"移除中间人(Remove Middle Man)",slug:"移除中间人-remove-middle-man",normalizedTitle:"移除中间人(remove middle man)",charIndex:1305},{level:2,title:"依恋情结",slug:"依恋情结",normalizedTitle:"依恋情结",charIndex:1540},{level:3,title:"问题原因",slug:"问题原因-3",normalizedTitle:"问题原因",charIndex:198},{level:3,title:"解决方法",slug:"解决方法-3",normalizedTitle:"解决方法",charIndex:289},{level:3,title:"收益",slug:"收益-3",normalizedTitle:"收益",charIndex:415},{level:3,title:"何时忽略",slug:"何时忽略-3",normalizedTitle:"何时忽略",charIndex:462},{level:3,title:"重构方法说明",slug:"重构方法说明-3",normalizedTitle:"重构方法说明",charIndex:491},{level:4,title:"搬移函数(Move Method)",slug:"搬移函数-move-method",normalizedTitle:"搬移函数(move method)",charIndex:1944},{level:4,title:"提炼函数(Extract Method)",slug:"提炼函数-extract-method",normalizedTitle:"提炼函数(extract method)",charIndex:1993},{level:2,title:"狎昵关系",slug:"狎昵关系",normalizedTitle:"狎昵关系",charIndex:2863},{level:3,title:"问题原因",slug:"问题原因-4",normalizedTitle:"问题原因",charIndex:198},{level:3,title:"解决方法",slug:"解决方法-4",normalizedTitle:"解决方法",charIndex:289},{level:3,title:"收益",slug:"收益-4",normalizedTitle:"收益",charIndex:415},{level:3,title:"重构方法说明",slug:"重构方法说明-4",normalizedTitle:"重构方法说明",charIndex:491},{level:4,title:"搬移函数(Move Method)",slug:"搬移函数-move-method-2",normalizedTitle:"搬移函数(move method)",charIndex:1944},{level:4,title:"搬移字段(Move Field)",slug:"搬移字段-move-field",normalizedTitle:"搬移字段(move field)",charIndex:3019},{level:4,title:"将双向关联改为单向关联(Change Bidirectional Association to Unidirectional)",slug:"将双向关联改为单向关联-change-bidirectional-association-to-unidirectional",normalizedTitle:"将双向关联改为单向关联(change bidirectional association to unidirectional)",charIndex:3065},{level:4,title:"提炼类(Extract Class)",slug:"提炼类-extract-class",normalizedTitle:"提炼类(extract class)",charIndex:3172},{level:4,title:"隐藏委托关系(Hide Delegate)",slug:"隐藏委托关系-hide-delegate",normalizedTitle:"隐藏委托关系(hide delegate)",charIndex:3226},{level:4,title:"以委托取代继承(Replace Inheritance with Delegation)",slug:"以委托取代继承-replace-inheritance-with-delegation",normalizedTitle:"以委托取代继承(replace inheritance with delegation)",charIndex:3323},{level:2,title:"过度耦合的消息链",slug:"过度耦合的消息链",normalizedTitle:"过度耦合的消息链",charIndex:4079},{level:3,title:"问题原因",slug:"问题原因-5",normalizedTitle:"问题原因",charIndex:198},{level:3,title:"解决方法",slug:"解决方法-5",normalizedTitle:"解决方法",charIndex:289},{level:3,title:"收益",slug:"收益-5",normalizedTitle:"收益",charIndex:415},{level:3,title:"何时忽略",slug:"何时忽略-4",normalizedTitle:"何时忽略",charIndex:462},{level:3,title:"重构方法说明",slug:"重构方法说明-5",normalizedTitle:"重构方法说明",charIndex:491},{level:4,title:"隐藏委托关系(Hide Delegate)",slug:"隐藏委托关系-hide-delegate-2",normalizedTitle:"隐藏委托关系(hide delegate)",charIndex:3226},{level:4,title:"提炼函数(Extract Method)",slug:"提炼函数-extract-method-2",normalizedTitle:"提炼函数(extract method)",charIndex:1993},{level:4,title:"搬移函数(Move Method)",slug:"搬移函数-move-method-3",normalizedTitle:"搬移函数(move method)",charIndex:1944},{level:2,title:"扩展阅读",slug:"扩展阅读",normalizedTitle:"扩展阅读",charIndex:5224},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5318}],headersStr:"不完美的库类 问题原因 解决方法 收益 何时忽略 重构方法说明 引入外加函数(Introduce Foreign Method) 引入本地扩展(Introduce Local Extension) 中间人 问题原因 解决方法 收益 何时忽略 重构方法说明 移除中间人(Remove Middle Man) 依恋情结 问题原因 解决方法 收益 何时忽略 重构方法说明 搬移函数(Move Method) 提炼函数(Extract Method) 狎昵关系 问题原因 解决方法 收益 重构方法说明 搬移函数(Move Method) 搬移字段(Move Field) 将双向关联改为单向关联(Change Bidirectional Association to Unidirectional) 提炼类(Extract Class) 隐藏委托关系(Hide Delegate) 以委托取代继承(Replace Inheritance with Delegation) 过度耦合的消息链 问题原因 解决方法 收益 何时忽略 重构方法说明 隐藏委托关系(Hide Delegate) 提炼函数(Extract Method) 搬移函数(Move Method) 扩展阅读 参考资料",content:'> 翻译自：https://sourcemaking.com/refactoring/smells/couplers\n> \n> 耦合(Couplers)这组坏味道意味着：不同类之间过度耦合。\n\n\n# 不完美的库类\n\n> 不完美的库类(Incomplete Library Class)\n> \n> 当一个类库已经不能满足实际需要时，你就不得不改变这个库（如果这个库是只读的，那就没辙了）。\n\n\n# 问题原因\n\n许多编程技术都建立在库类的基础上。库类的作者没用未卜先知的能力，不能因此责怪他们。麻烦的是库往往构造的不够好，而且往往不可能让我们修改其中的类以满足我们的需要。\n\n\n# 解决方法\n\n * 如果你只想修改类库的一两个函数，可以运用 引入外加函数(Introduce Foreign Method)；\n * 如果想要添加一大堆额外行为，就得运用 引入本地扩展(Introduce Local Extension) 。\n\n\n# 收益\n\n * 减少代码重复（你不用一言不合就自己动手实现一个库的全部功能，代价太高）\n\n\n# 何时忽略\n\n * 如果扩展库会带来额外的工作量。\n\n\n# 重构方法说明\n\n# 引入外加函数(Introduce Foreign Method)\n\n问题\n\n你需要为提供服务的类增加一个函数，但你无法修改这个类。\n\nclass Report {\n  //...\n  void sendReport() {\n    Date nextDay = new Date(previousEnd.getYear(),\n      previousEnd.getMonth(), previousEnd.getDate() + 1);\n    //...\n  }\n}\n\n\n解决\n\n在客户类中建立一个函数，并一个第一个参数形式传入一个服务类实例。\n\nclass Report {\n  //...\n  void sendReport() {\n    Date newStart = nextDay(previousEnd);\n    //...\n  }\n  private static Date nextDay(Date arg) {\n    return new Date(arg.getYear(), arg.getMonth(), arg.getDate() + 1);\n  }\n}\n\n\n# 引入本地扩展(Introduce Local Extension)\n\n问题\n\n你需要为服务类提供一些额外函数，但你无法修改这个类。\n\n\n\n解决\n\n建立一个新类，使它包含这些额外函数，让这个扩展品成为源类的子类或包装类。\n\n\n\n\n# 中间人\n\n> 中间人(Middle Man)\n> \n> 如果一个类的作用仅仅是指向另一个类的委托，为什么要存在呢？\n\n\n\n\n# 问题原因\n\n对象的基本特征之一就是封装：对外部世界隐藏其内部细节。封装往往伴随委托。但是人们可能过度运用委托。比如，你也许会看到一个类的大部分有用工作都委托给了其他类，类本身成了一个空壳，除了委托之外不做任何事情。\n\n\n# 解决方法\n\n应该运用 移除中间人(Remove Middle Man)，直接和真正负责的对象打交道。\n\n\n# 收益\n\n * 减少笨重的代码。\n\n\n\n\n# 何时忽略\n\n如果是以下情况，不要删除已创建的中间人：\n\n * 添加中间人是为了避免类之间依赖关系。\n * 一些设计模式有目的地创建中间人（例如代理模式和装饰器模式）。\n\n\n# 重构方法说明\n\n# 移除中间人(Remove Middle Man)\n\n问题\n\n某个类做了过多的简单委托动作。\n\n\n\n解决\n\n让客户直接调用委托类。\n\n\n\n\n# 依恋情结\n\n> 依恋情结(Feature Envy)\n> \n> 一个函数访问其它对象的数据比访问自己的数据更多。\n\n\n\n\n# 问题原因\n\n这种气味可能发生在字段移动到数据类之后。如果是这种情况，你可能想将数据类的操作移动到这个类中。\n\n\n# 解决方法\n\nAs a basic rule, if things change at the same time, you should keep them in the same place. Usually data and functions that use this data are changed together (although exceptions are possible).\n\n有一个基本原则：同时会发生改变的事情应该被放在同一个地方。通常，数据和使用这些数据的函数是一起改变的。\n\n\n\n * 如果一个函数明显应该被移到另一个地方，可运用 搬移函数(Move Method) 。\n * 如果仅仅是函数的部分代码访问另一个对象的数据，运用 提炼函数(Extract Method) 将这部分代码移到独立的函数中。\n * 如果一个方法使用来自其他几个类的函数，首先确定哪个类包含大多数使用的数据。然后，将该方法与其他数据一起放在此类中。或者，使用 提炼函数(Extract Method) 将方法拆分为几个部分，可以放置在不同类中的不同位置。\n\n\n# 收益\n\n * 减少重复代码（如果数据处理的代码放在中心位置）。\n * 更好的代码组织性（处理数据的函数靠近实际数据）。\n\n\n\n\n# 何时忽略\n\n * 有时，行为被有意地与保存数据的类分开。这通常的优点是能够动态地改变行为（见策略设计模式，访问者设计模式和其他模式）。\n\n\n# 重构方法说明\n\n# 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 提炼函数(Extract Method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printOwing() {\n  printBanner();\n\n  //print details\n  System.out.println("name: " + name);\n  System.out.println("amount: " + getOutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printOwing() {\n  printBanner();\n  printDetails(getOutstanding());\n}\n\nvoid printDetails(double outstanding) {\n  System.out.println("name: " + name);\n  System.out.println("amount: " + outstanding);\n}\n\n\n\n# 狎昵关系\n\n> 狎昵关系(Inappropriate Intimacy)\n> \n> 一个类大量使用另一个类的内部字段和方法。\n\n\n\n\n# 问题原因\n\n类和类之间应该尽量少的感知彼此（减少耦合）。这样的类更容易维护和复用。\n\n\n# 解决方法\n\n * 最简单的解决方法是运用 搬移函数(Move Method) 和 搬移字段(Move Field) 来让类之间斩断羁绊。\n\n\n\n * 你也可以看看是否能运用 将双向关联改为单向关联(Change Bidirectional Association to Unidirectional) 让其中一个类对另一个说分手。\n\n * 如果这两个类实在是情比金坚，难分难舍，可以运用 提炼类(Extract Class) 把二者共同点提炼到一个新类中，让它们产生爱的结晶。或者，可以尝试运用 隐藏委托关系(Hide Delegate) 让另一个类来为它们牵线搭桥。\n\n * 继承往往造成类之间过分紧密，因为子类对超类的了解总是超过后者的主观愿望，如果你觉得该让这个子类自己闯荡，请运用 以委托取代继承(Replace Inheritance with Delegation) 来让超类和子类分家。\n\n\n# 收益\n\n * 提高代码组织性。\n * 提高代码复用性。\n\n\n\n\n# 重构方法说明\n\n# 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 搬移字段(Move Field)\n\n问题\n\n在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。\n\n\n\n解决\n\n在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。\n\n\n\n# 将双向关联改为单向关联(Change Bidirectional Association to Unidirectional)\n\n问题\n\n两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。\n\n\n\n解决\n\n去除不必要的关联。\n\n\n\n# 提炼类(Extract Class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 隐藏委托关系(Hide Delegate)\n\n问题\n\n客户通过一个委托类来调用另一个对象。\n\n\n\n解决\n\n在服务类上建立客户所需的所有函数，用以隐藏委托关系。\n\n\n\n# 以委托取代继承(Replace Inheritance with Delegation)\n\n问题\n\n某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。\n\n\n\n解决\n\n在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。\n\n\n\n\n# 过度耦合的消息链\n\n> 过度耦合的消息链(Message Chains)\n> \n> 消息链的形式类似于：obj.getA().getB().getC()。\n\n\n\n\n# 问题原因\n\n如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。实际代码中你看到的可能是一长串 getThis()或一长串临时变量。采取这种方式，意味客户代码将与查找过程中的导航紧密耦合。一旦对象间关系发生任何变化，客户端就不得不做出相应的修改。\n\n\n# 解决方法\n\n * 可以运用 隐藏委托关系(Hide Delegate) 删除一个消息链。\n\n\n\n * 有时更好的选择是：先观察消息链最终得到的对象是用来干什么的。看看能否以 提炼函数(Extract Method)把使用该对象的代码提炼到一个独立函数中，再运用 搬移函数(Move Method) 把这个函数推入消息链。\n\n\n# 收益\n\n * 能减少链中类之间的依赖。\n * 能减少代码量。\n\n\n\n\n# 何时忽略\n\n * 过于侵略性的委托可能会使程序员难以理解功能是如何触发的。\n\n\n# 重构方法说明\n\n# 隐藏委托关系(Hide Delegate)\n\n问题\n\n客户通过一个委托类来调用另一个对象。\n\n\n\n解决\n\n在服务类上建立客户所需的所有函数，用以隐藏委托关系。\n\n\n\n# 提炼函数(Extract Method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printOwing() {\n  printBanner();\n\n  //print details\n  System.out.println("name: " + name);\n  System.out.println("amount: " + getOutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printOwing() {\n  printBanner();\n  printDetails(getOutstanding());\n}\n\nvoid printDetails(double outstanding) {\n  System.out.println("name: " + name);\n  System.out.println("amount: " + outstanding);\n}\n\n\n# 搬移函数(Move Method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n\n# 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',normalizedContent:'> 翻译自：https://sourcemaking.com/refactoring/smells/couplers\n> \n> 耦合(couplers)这组坏味道意味着：不同类之间过度耦合。\n\n\n# 不完美的库类\n\n> 不完美的库类(incomplete library class)\n> \n> 当一个类库已经不能满足实际需要时，你就不得不改变这个库（如果这个库是只读的，那就没辙了）。\n\n\n# 问题原因\n\n许多编程技术都建立在库类的基础上。库类的作者没用未卜先知的能力，不能因此责怪他们。麻烦的是库往往构造的不够好，而且往往不可能让我们修改其中的类以满足我们的需要。\n\n\n# 解决方法\n\n * 如果你只想修改类库的一两个函数，可以运用 引入外加函数(introduce foreign method)；\n * 如果想要添加一大堆额外行为，就得运用 引入本地扩展(introduce local extension) 。\n\n\n# 收益\n\n * 减少代码重复（你不用一言不合就自己动手实现一个库的全部功能，代价太高）\n\n\n# 何时忽略\n\n * 如果扩展库会带来额外的工作量。\n\n\n# 重构方法说明\n\n# 引入外加函数(introduce foreign method)\n\n问题\n\n你需要为提供服务的类增加一个函数，但你无法修改这个类。\n\nclass report {\n  //...\n  void sendreport() {\n    date nextday = new date(previousend.getyear(),\n      previousend.getmonth(), previousend.getdate() + 1);\n    //...\n  }\n}\n\n\n解决\n\n在客户类中建立一个函数，并一个第一个参数形式传入一个服务类实例。\n\nclass report {\n  //...\n  void sendreport() {\n    date newstart = nextday(previousend);\n    //...\n  }\n  private static date nextday(date arg) {\n    return new date(arg.getyear(), arg.getmonth(), arg.getdate() + 1);\n  }\n}\n\n\n# 引入本地扩展(introduce local extension)\n\n问题\n\n你需要为服务类提供一些额外函数，但你无法修改这个类。\n\n\n\n解决\n\n建立一个新类，使它包含这些额外函数，让这个扩展品成为源类的子类或包装类。\n\n\n\n\n# 中间人\n\n> 中间人(middle man)\n> \n> 如果一个类的作用仅仅是指向另一个类的委托，为什么要存在呢？\n\n\n\n\n# 问题原因\n\n对象的基本特征之一就是封装：对外部世界隐藏其内部细节。封装往往伴随委托。但是人们可能过度运用委托。比如，你也许会看到一个类的大部分有用工作都委托给了其他类，类本身成了一个空壳，除了委托之外不做任何事情。\n\n\n# 解决方法\n\n应该运用 移除中间人(remove middle man)，直接和真正负责的对象打交道。\n\n\n# 收益\n\n * 减少笨重的代码。\n\n\n\n\n# 何时忽略\n\n如果是以下情况，不要删除已创建的中间人：\n\n * 添加中间人是为了避免类之间依赖关系。\n * 一些设计模式有目的地创建中间人（例如代理模式和装饰器模式）。\n\n\n# 重构方法说明\n\n# 移除中间人(remove middle man)\n\n问题\n\n某个类做了过多的简单委托动作。\n\n\n\n解决\n\n让客户直接调用委托类。\n\n\n\n\n# 依恋情结\n\n> 依恋情结(feature envy)\n> \n> 一个函数访问其它对象的数据比访问自己的数据更多。\n\n\n\n\n# 问题原因\n\n这种气味可能发生在字段移动到数据类之后。如果是这种情况，你可能想将数据类的操作移动到这个类中。\n\n\n# 解决方法\n\nas a basic rule, if things change at the same time, you should keep them in the same place. usually data and functions that use this data are changed together (although exceptions are possible).\n\n有一个基本原则：同时会发生改变的事情应该被放在同一个地方。通常，数据和使用这些数据的函数是一起改变的。\n\n\n\n * 如果一个函数明显应该被移到另一个地方，可运用 搬移函数(move method) 。\n * 如果仅仅是函数的部分代码访问另一个对象的数据，运用 提炼函数(extract method) 将这部分代码移到独立的函数中。\n * 如果一个方法使用来自其他几个类的函数，首先确定哪个类包含大多数使用的数据。然后，将该方法与其他数据一起放在此类中。或者，使用 提炼函数(extract method) 将方法拆分为几个部分，可以放置在不同类中的不同位置。\n\n\n# 收益\n\n * 减少重复代码（如果数据处理的代码放在中心位置）。\n * 更好的代码组织性（处理数据的函数靠近实际数据）。\n\n\n\n\n# 何时忽略\n\n * 有时，行为被有意地与保存数据的类分开。这通常的优点是能够动态地改变行为（见策略设计模式，访问者设计模式和其他模式）。\n\n\n# 重构方法说明\n\n# 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 提炼函数(extract method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printowing() {\n  printbanner();\n\n  //print details\n  system.out.println("name: " + name);\n  system.out.println("amount: " + getoutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printowing() {\n  printbanner();\n  printdetails(getoutstanding());\n}\n\nvoid printdetails(double outstanding) {\n  system.out.println("name: " + name);\n  system.out.println("amount: " + outstanding);\n}\n\n\n\n# 狎昵关系\n\n> 狎昵关系(inappropriate intimacy)\n> \n> 一个类大量使用另一个类的内部字段和方法。\n\n\n\n\n# 问题原因\n\n类和类之间应该尽量少的感知彼此（减少耦合）。这样的类更容易维护和复用。\n\n\n# 解决方法\n\n * 最简单的解决方法是运用 搬移函数(move method) 和 搬移字段(move field) 来让类之间斩断羁绊。\n\n\n\n * 你也可以看看是否能运用 将双向关联改为单向关联(change bidirectional association to unidirectional) 让其中一个类对另一个说分手。\n\n * 如果这两个类实在是情比金坚，难分难舍，可以运用 提炼类(extract class) 把二者共同点提炼到一个新类中，让它们产生爱的结晶。或者，可以尝试运用 隐藏委托关系(hide delegate) 让另一个类来为它们牵线搭桥。\n\n * 继承往往造成类之间过分紧密，因为子类对超类的了解总是超过后者的主观愿望，如果你觉得该让这个子类自己闯荡，请运用 以委托取代继承(replace inheritance with delegation) 来让超类和子类分家。\n\n\n# 收益\n\n * 提高代码组织性。\n * 提高代码复用性。\n\n\n\n\n# 重构方法说明\n\n# 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n# 搬移字段(move field)\n\n问题\n\n在你的程序中，某个字段被其所驻类之外的另一个类更多地用到。\n\n\n\n解决\n\n在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段。\n\n\n\n# 将双向关联改为单向关联(change bidirectional association to unidirectional)\n\n问题\n\n两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。\n\n\n\n解决\n\n去除不必要的关联。\n\n\n\n# 提炼类(extract class)\n\n问题\n\n某个类做了不止一件事。\n\n\n\n解决\n\n建立一个新类，将相关的字段和函数从旧类搬移到新类。\n\n\n\n# 隐藏委托关系(hide delegate)\n\n问题\n\n客户通过一个委托类来调用另一个对象。\n\n\n\n解决\n\n在服务类上建立客户所需的所有函数，用以隐藏委托关系。\n\n\n\n# 以委托取代继承(replace inheritance with delegation)\n\n问题\n\n某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据。\n\n\n\n解决\n\n在子类中新建一个字段用以保存超类；调整子类函数，令它改而委托超类；然后去掉两者之间的继承关系。\n\n\n\n\n# 过度耦合的消息链\n\n> 过度耦合的消息链(message chains)\n> \n> 消息链的形式类似于：obj.geta().getb().getc()。\n\n\n\n\n# 问题原因\n\n如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象……这就是消息链。实际代码中你看到的可能是一长串 getthis()或一长串临时变量。采取这种方式，意味客户代码将与查找过程中的导航紧密耦合。一旦对象间关系发生任何变化，客户端就不得不做出相应的修改。\n\n\n# 解决方法\n\n * 可以运用 隐藏委托关系(hide delegate) 删除一个消息链。\n\n\n\n * 有时更好的选择是：先观察消息链最终得到的对象是用来干什么的。看看能否以 提炼函数(extract method)把使用该对象的代码提炼到一个独立函数中，再运用 搬移函数(move method) 把这个函数推入消息链。\n\n\n# 收益\n\n * 能减少链中类之间的依赖。\n * 能减少代码量。\n\n\n\n\n# 何时忽略\n\n * 过于侵略性的委托可能会使程序员难以理解功能是如何触发的。\n\n\n# 重构方法说明\n\n# 隐藏委托关系(hide delegate)\n\n问题\n\n客户通过一个委托类来调用另一个对象。\n\n\n\n解决\n\n在服务类上建立客户所需的所有函数，用以隐藏委托关系。\n\n\n\n# 提炼函数(extract method)\n\n问题\n\n你有一段代码可以组织在一起。\n\nvoid printowing() {\n  printbanner();\n\n  //print details\n  system.out.println("name: " + name);\n  system.out.println("amount: " + getoutstanding());\n}\n\n\n解决\n\n移动这段代码到一个新的函数中，使用函数的调用来替代老代码。\n\nvoid printowing() {\n  printbanner();\n  printdetails(getoutstanding());\n}\n\nvoid printdetails(double outstanding) {\n  system.out.println("name: " + name);\n  system.out.println("amount: " + outstanding);\n}\n\n\n# 搬移函数(move method)\n\n问题\n\n你的程序中，有个函数与其所驻类之外的另一个类进行更多交流：调用后者，或被后者调用。\n\n\n\n解决\n\n在该函数最常引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或是旧函数完全移除。\n\n\n\n\n# 扩展阅读\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 参考资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"重构",frontmatter:{title:"重构",categories:["设计","重构"],tags:["设计","重构"],date:"2021-04-29T16:05:03.000Z",permalink:"/pages/156570/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/03.%E9%87%8D%E6%9E%84/",relativePath:"03.设计/03.重构/README.md",key:"v-45cada9f",path:"/pages/156570/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:68},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:163},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:256}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# 重构\n\n> 重构是不改变软件系统外部行为的前提下，改善它的内部结构。\n> \n> 重构的目的是为了提高代码的质量和性能。\n\n\n\n\n# 📖 内容\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 📚 资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring\n\n\n# 🚪 传送\n\n◾ 🏠 DESIGN 首页 ◾ 🎯 我的博客 ◾",normalizedContent:"# 重构\n\n> 重构是不改变软件系统外部行为的前提下，改善它的内部结构。\n> \n> 重构的目的是为了提高代码的质量和性能。\n\n\n\n\n# 📖 内容\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 📚 资料\n\n * 《代码整洁之道》\n * 《重构 - 改善既有代码的设计》\n * 《代码大全》\n * https://sourcemaking.com/refactoring\n\n\n# 🚪 传送\n\n◾ 🏠 design 首页 ◾ 🎯 我的博客 ◾",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"错误处理",frontmatter:{title:"错误处理",categories:["设计","编程范式"],tags:["设计","编程范式"],date:"2020-08-13T23:32:37.000Z",permalink:"/pages/dc158b/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/04.%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/01.%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86.html",relativePath:"03.设计/04.编程范式/01.错误处理.md",key:"v-612a002e",path:"/pages/dc158b/",headers:[{level:2,title:"错误的分类",slug:"错误的分类",normalizedTitle:"错误的分类",charIndex:11},{level:4,title:"资源的错误",slug:"资源的错误",normalizedTitle:"资源的错误",charIndex:20},{level:4,title:"程序的错误",slug:"程序的错误",normalizedTitle:"程序的错误",charIndex:194},{level:4,title:"用户的错误",slug:"用户的错误",normalizedTitle:"用户的错误",charIndex:255},{level:2,title:"错误返回码和异常捕捉",slug:"错误返回码和异常捕捉",normalizedTitle:"错误返回码和异常捕捉",charIndex:464},{level:2,title:"异步编程的错误处理",slug:"异步编程的错误处理",normalizedTitle:"异步编程的错误处理",charIndex:558},{level:3,title:"callback 错误处理",slug:"callback-错误处理",normalizedTitle:"callback 错误处理",charIndex:750},{level:3,title:"JavaScript 的 Promise 错误处理",slug:"javascript-的-promise-错误处理",normalizedTitle:"javascript 的 promise 错误处理",charIndex:1602},{level:3,title:"Java 的 Promise 模式",slug:"java-的-promise-模式",normalizedTitle:"java 的 promise 模式",charIndex:3445},{level:2,title:"错误处理的最佳实践",slug:"错误处理的最佳实践",normalizedTitle:"错误处理的最佳实践",charIndex:4852}],headersStr:"错误的分类 资源的错误 程序的错误 用户的错误 错误返回码和异常捕捉 异步编程的错误处理 callback 错误处理 JavaScript 的 Promise 错误处理 Java 的 Promise 模式 错误处理的最佳实践",content:'# 错误处理\n\n\n# 错误的分类\n\n# 资源的错误\n\n当我们的代码去请求一些资源时导致的错误，比如打开一个没有权限的文件，写文件时出现的写错误，发送文件到网络端发现网络故障的错误，等等。这一类错误属于程序运行环境的问题。对于这类错误，有的我们可以处理，有的我们则无法处理。比如，内存耗尽、栈溢出或是一些程序运行时关键性资源不能满足等等这些情况，我们只能停止运行，甚至退出整个程序。\n\n# 程序的错误\n\n比如：空指针、非法参数等。这类是我们自己程序的错误，我们要记录下来，写入日志，最好触发监控系统报警。\n\n# 用户的错误\n\n比如：Bad Request、Bad Format 等这类由用户不合法输入带来的错误。这类错误基本上是在用户的 API 层上出现的问题。比如，解析一个 XML 或 JSON 文件，或是用户输入的字段不合法之类的。\n\n对于这类问题，我们需要向用户端报错，让用户自己处理修正他们的输入或操作。然后，我们正常执行，但是需要做统计，统计相应的错误率，这样有利于我们改善软件或是侦测是否有恶意的用户请求。\n\n\n# 错误返回码和异常捕捉\n\n错误处理一般有两种方式：错误返回码和异常捕捉。\n\n * 对于我们并不期望会发生的事，我们可以使用异常捕捉；\n * 对于我们觉得可能会发生的事，使用返回码。\n\n\n# 异步编程的错误处理\n\n * 无法使用返回码。因为函数在“被”异步运行中，所谓的返回只是把处理权交给下一条指令，而不是把函数运行完的结果返回。所以，函数返回的语义完全变了，返回码也没有用了。\n * 无法使用抛异常的方式。因为除了上述的函数立马返回的原因之外，抛出的异常也在另外一个线程中，不同线程中的栈是完全不一样的，所以主线程的 catch 完全看不到另外一个线程中的异常。\n\n\n# callback 错误处理\n\n异步编程中，最常用的错误处理方式就是 callback方式。在做异步请求的时候，注册几个 OnSuccess()、 OnFailure() 这样的函数，让在另一个线程中运行的异步代码来回调过来。\n\n【示例】JavaScript 异步编程的错误处理\n\nfunction successCallback(result) {\n  console.log(\'It succeeded with \' + result)\n}\n\nfunction failureCallback(error) {\n  console.log(\'It failed with \' + error)\n}\n\ndoSomething(successCallback, failureCallback)\n\n\n但是， 如果我们需要把几个异步函数顺序执行的话（异步程序中，程序执行的顺序是不可预测的、也是不确定的，而有时候，函数被调用的上下文是有相互依赖的，所以，我们希望它们能按一定的顺序处理），就会出现了所谓的 Callback Hell 的问题。如下所示：\n\ndoSomething(function (result) {\n  doSomethingElse(\n    result,\n    function (newResult) {\n      doThirdThing(\n        newResult,\n        function (finalResult) {\n          console.log(\'Got the final result: \' + finalResult)\n        },\n        failureCallback\n      )\n    },\n    failureCallback\n  )\n}, failureCallback)\n\n\n而这样层层嵌套中需要注册的错误处理函数也有可能是完全不一样的，而且会导致代码非常混乱，难以阅读和维护。\n\n\n# JavaScript 的 Promise 错误处理\n\n在异步编程的实践里，使用 Promise 模式来处理更为优雅。\n\ndoSomething()\n.then(result => doSomethingElse(result))\n.then(newResult => doThirdThing(newResult))\n.then(finalResult => {\n  console.log(`Got the final result: ${finalResult}`);\n}).catch(failureCallback);\n\n\n上面代码中的 then() 和 catch() 方法就是 Promise 对象的方法，then()方法可以把各个异步的函数给串联起来，而catch() 方法则是出错的处理。\n\n看到上面的那个级联式的调用方式，这就要我们的 doSomething() 函数返回 Promise 对象，下面是这个函数的相关代码示例：\n\nfunction doSomething() {\n\tlet promise = new Promise();\n\tlet xhr = new XMLHttpRequest();\n\txhr.open(\'GET\', \'http://coolshell.cn/....\', true);\n\n\txhr.onload = function (e) {\n        if (this.status === 200) {\n            results = JSON.parse(this.responseText);\n            promise.resolve(results); // 成功时，调用 resolve() 方法\n        }\n    };\n\n    xhr.onerror = function (e) {\n        promise.reject(e); // 失败时，调用 reject() 方法\n    };\n\n    xhr.send();\n    return promise;\n}\n\n\n从上面的代码示例中，我们可以看到，如果成功了，要调用 Promise.resolve() 方法，这样 Promise 对象会继续调用下一个 then()。如果出错了就调用 Promise.reject() 方法，这样就会忽略后面的 then() 直到 catch() 方法。\n\n我们可以看到 Promise.reject() 就像是抛异常一样。这个编程模式让我们的代码组织方便了很多。\n\n另外，多说一句，Promise 还可以同时等待两个不同的异步方法。比如下面的代码所展示的方式：\n\npromise1 = doSomething();\npromise2 = doSomethingElse();\nPromise.when(promise1, promise2).then( function (result1, result2) {\n\t... // 处理 result1 和 result2 的代码\n}, handleError);\n\n\n在 ECMAScript 2017 的标准中，我们可以使用async/await 这两个关键字来取代 Promise 对象，这样可以让我们的代码更易读。\n\n比如下面的代码示例：\n\nasync function foo() {\n  try {\n    let result = await doSomething();\n    let newResult = await doSomethingElse(result);\n    let finalResult = await doThirdThing(newResult);\n    console.log(`Got the final result: ${finalResult}`);\n  } catch(error) {\n    failureCallback(error);\n  }\n}\n\n\n如果在函数定义之前使用了 async 关键字，就可以在函数内使用 await。 当在 await 某个 Promise 时，函数暂停执行，直至该 Promise 产生结果，并且暂停不会阻塞主线程。 如果 Promise resolve，则会返回值。 如果 Promise reject，则会抛出拒绝的值。\n\n\n# Java 的 Promise 模式\n\n在 JDK 1.8 里也引入了类似 JavaScript 的玩法 —— CompletableFuture。这个类提供了大量的异步编程中 Promise 的各种方式。\n\n链式处理：\n\nCompletableFuture.supplyAsync(this::findReceiver)\n                 .thenApply(this::sendMsg)\n                 .thenAccept(this::notify);\n\n\n上面的这个链式处理和 JavaScript 中的then()方法很像，其中的 supplyAsync() 表示执行一个异步方法，而 thenApply() 表示执行成功后再串联另外一个异步方法，最后是 thenAccept() 来处理最终结果。\n\n下面这个例子是要合并两个异步函数的结果：\n\nString result = CompletableFuture.supplyAsync(() -> {\n         return "hello";\n     }).thenCombine(CompletableFuture.supplyAsync(() -> {\n         return "world";\n     }), (s1, s2) -> s1 + " " + s2).join());\nSystem.out.println(result);\n\n\n\n接下来，我们再来看一下，Java 这个类相关的异常处理：\n\nCompletableFuture.supplyAsync(Integer::parseInt) // 输入: "ILLEGAL"\n\t\t\t     .thenApply(r -> r * 2 * Math.PI)\n\t\t\t     .thenApply(s -> "apply>> " + s)\n\t\t\t     .exceptionally(ex -> "Error: " + ex.getMessage());\n\n\n我们要注意到上面代码里的 exceptionally() 方法，这个和 JavaScript Promise 中的 catch() 方法相似。\n\n运行上面的代码，会出现如下输出：\n\nError: java.lang.NumberFormatException: For input string: "ILLEGAL"\n\n\n也可以这样：\n\nCompletableFuture.supplyAsync(Integer::parseInt) // 输入: "ILLEGAL"\n\t\t\t\t .thenApply(r -> r * 2 * Math.PI)\n\t\t\t\t .thenApply(s -> "apply>> " + s)\n\t\t\t\t .handle((result, ex) -> {\n\t\t\t\t \tif (result != null) {\n\t\t\t\t \t\treturn result;\n\t\t\t\t \t} else {\n\t\t\t\t \t\treturn "Error handling: " + ex.getMessage();\n\t\t\t\t \t}\n\t\t\t\t });\n\n\n上面代码中，你可以看到，其使用了 handle() 方法来处理最终的结果，其中包含了异步函数中的错误处理。\n\n\n# 错误处理的最佳实践\n\n * 统一分类的错误字典。无论你是使用错误码还是异常捕捉，都需要认真并统一地做好错误的分类。最好是在一个地方定义相关的错误。比如，HTTP 的 4XX 表示客户端有问题，5XX 则表示服务端有问题。也就是说，你要建立一个错误字典。\n * 同类错误的定义最好是可以扩展的。这一点非常重要，而对于这一点，通过面向对象的继承或是像 Go 语言那样的接口多态可以很好地做到。这样可以方便地重用已有的代码。\n * 定义错误的严重程度。比如，Fatal 表示重大错误，Error 表示资源或需求得不到满足，Warning 表示并不一定是个错误但还是需要引起注意，Info 表示不是错误只是一个信息，Debug 表示这是给内部开发人员用于调试程序的。\n * 错误日志的输出最好使用错误码，而不是错误信息。打印错误日志的时候，应该使用统一的格式。但最好不要用错误信息，而应使用相应的错误码，错误码不一定是数字，也可以是一个能从错误字典里找到的一个唯一的可以让人读懂的关键字。这样，会非常有利于日志分析软件进行自动化监控，而不是要从错误信息中做语义分析。比如：HTTP 的日志中就会有 HTTP 的返回码，如：404。但我更推荐使用像PageNotFound这样的标识，这样人和机器都很容易处理。\n * 忽略错误最好有日志。不然会给维护带来很大的麻烦。\n * 对于同一个地方不停的报错，最好不要都打到日志里。不然这样会导致其它日志被淹没了，也会导致日志文件太大。最好的实践是，打出一个错误以及出现的次数。\n * 不要用错误处理逻辑来处理业务逻辑。也就是说，不要使用异常捕捉这样的方式来处理业务逻辑，而是应该用条件判断。如果一个逻辑控制可以用 if - else 清楚地表达，那就不建议使用异常方式处理。异常捕捉是用来处理不期望发生的事情，而错误码则用来处理可能会发生的事。\n * 对于同类的错误处理，用一样的模式。比如，对于null对象的错误，要么都用返回 null，加上条件检查的模式，要么都用抛 NullPointerException 的方式处理。不要混用，这样有助于代码规范。\n * 尽可能在错误发生的地方处理错误。因为这样会让调用者变得更简单。\n * 向上尽可能地返回原始的错误。如果一定要把错误返回到更高层去处理，那么，应该返回原始的错误，而不是重新发明一个错误。\n * 处理错误时，总是要清理已分配的资源。这点非常关键，使用 RAII 技术，或是 try-catch-finally，或是 Go 的 defer 都可以容易地做到。\n * 不推荐在循环体里处理错误。这里说的是 try-catch，绝大多数的情况你不需要这样做。最好把整个循环体外放在 try 语句块内，而在外面做 catch。\n * 不要把大量的代码都放在一个 try 语句块内。一个 try 语句块内的语句应该是完成一个简单单一的事情。\n * 为你的错误定义提供清楚的文档以及每种错误的代码示例。如果你是做 RESTful API 方面的，使用 Swagger 会帮你很容易搞定这个事。\n * 对于异步的方式，推荐使用 Promise 模式处理错误。对于这一点，JavaScript 中有很好的实践。\n * 对于分布式的系统，推荐使用 APM 相关的软件。尤其是使用 Zipkin 这样的服务调用跟踪的分析来关联错误。',normalizedContent:'# 错误处理\n\n\n# 错误的分类\n\n# 资源的错误\n\n当我们的代码去请求一些资源时导致的错误，比如打开一个没有权限的文件，写文件时出现的写错误，发送文件到网络端发现网络故障的错误，等等。这一类错误属于程序运行环境的问题。对于这类错误，有的我们可以处理，有的我们则无法处理。比如，内存耗尽、栈溢出或是一些程序运行时关键性资源不能满足等等这些情况，我们只能停止运行，甚至退出整个程序。\n\n# 程序的错误\n\n比如：空指针、非法参数等。这类是我们自己程序的错误，我们要记录下来，写入日志，最好触发监控系统报警。\n\n# 用户的错误\n\n比如：bad request、bad format 等这类由用户不合法输入带来的错误。这类错误基本上是在用户的 api 层上出现的问题。比如，解析一个 xml 或 json 文件，或是用户输入的字段不合法之类的。\n\n对于这类问题，我们需要向用户端报错，让用户自己处理修正他们的输入或操作。然后，我们正常执行，但是需要做统计，统计相应的错误率，这样有利于我们改善软件或是侦测是否有恶意的用户请求。\n\n\n# 错误返回码和异常捕捉\n\n错误处理一般有两种方式：错误返回码和异常捕捉。\n\n * 对于我们并不期望会发生的事，我们可以使用异常捕捉；\n * 对于我们觉得可能会发生的事，使用返回码。\n\n\n# 异步编程的错误处理\n\n * 无法使用返回码。因为函数在“被”异步运行中，所谓的返回只是把处理权交给下一条指令，而不是把函数运行完的结果返回。所以，函数返回的语义完全变了，返回码也没有用了。\n * 无法使用抛异常的方式。因为除了上述的函数立马返回的原因之外，抛出的异常也在另外一个线程中，不同线程中的栈是完全不一样的，所以主线程的 catch 完全看不到另外一个线程中的异常。\n\n\n# callback 错误处理\n\n异步编程中，最常用的错误处理方式就是 callback方式。在做异步请求的时候，注册几个 onsuccess()、 onfailure() 这样的函数，让在另一个线程中运行的异步代码来回调过来。\n\n【示例】javascript 异步编程的错误处理\n\nfunction successcallback(result) {\n  console.log(\'it succeeded with \' + result)\n}\n\nfunction failurecallback(error) {\n  console.log(\'it failed with \' + error)\n}\n\ndosomething(successcallback, failurecallback)\n\n\n但是， 如果我们需要把几个异步函数顺序执行的话（异步程序中，程序执行的顺序是不可预测的、也是不确定的，而有时候，函数被调用的上下文是有相互依赖的，所以，我们希望它们能按一定的顺序处理），就会出现了所谓的 callback hell 的问题。如下所示：\n\ndosomething(function (result) {\n  dosomethingelse(\n    result,\n    function (newresult) {\n      dothirdthing(\n        newresult,\n        function (finalresult) {\n          console.log(\'got the final result: \' + finalresult)\n        },\n        failurecallback\n      )\n    },\n    failurecallback\n  )\n}, failurecallback)\n\n\n而这样层层嵌套中需要注册的错误处理函数也有可能是完全不一样的，而且会导致代码非常混乱，难以阅读和维护。\n\n\n# javascript 的 promise 错误处理\n\n在异步编程的实践里，使用 promise 模式来处理更为优雅。\n\ndosomething()\n.then(result => dosomethingelse(result))\n.then(newresult => dothirdthing(newresult))\n.then(finalresult => {\n  console.log(`got the final result: ${finalresult}`);\n}).catch(failurecallback);\n\n\n上面代码中的 then() 和 catch() 方法就是 promise 对象的方法，then()方法可以把各个异步的函数给串联起来，而catch() 方法则是出错的处理。\n\n看到上面的那个级联式的调用方式，这就要我们的 dosomething() 函数返回 promise 对象，下面是这个函数的相关代码示例：\n\nfunction dosomething() {\n\tlet promise = new promise();\n\tlet xhr = new xmlhttprequest();\n\txhr.open(\'get\', \'http://coolshell.cn/....\', true);\n\n\txhr.onload = function (e) {\n        if (this.status === 200) {\n            results = json.parse(this.responsetext);\n            promise.resolve(results); // 成功时，调用 resolve() 方法\n        }\n    };\n\n    xhr.onerror = function (e) {\n        promise.reject(e); // 失败时，调用 reject() 方法\n    };\n\n    xhr.send();\n    return promise;\n}\n\n\n从上面的代码示例中，我们可以看到，如果成功了，要调用 promise.resolve() 方法，这样 promise 对象会继续调用下一个 then()。如果出错了就调用 promise.reject() 方法，这样就会忽略后面的 then() 直到 catch() 方法。\n\n我们可以看到 promise.reject() 就像是抛异常一样。这个编程模式让我们的代码组织方便了很多。\n\n另外，多说一句，promise 还可以同时等待两个不同的异步方法。比如下面的代码所展示的方式：\n\npromise1 = dosomething();\npromise2 = dosomethingelse();\npromise.when(promise1, promise2).then( function (result1, result2) {\n\t... // 处理 result1 和 result2 的代码\n}, handleerror);\n\n\n在 ecmascript 2017 的标准中，我们可以使用async/await 这两个关键字来取代 promise 对象，这样可以让我们的代码更易读。\n\n比如下面的代码示例：\n\nasync function foo() {\n  try {\n    let result = await dosomething();\n    let newresult = await dosomethingelse(result);\n    let finalresult = await dothirdthing(newresult);\n    console.log(`got the final result: ${finalresult}`);\n  } catch(error) {\n    failurecallback(error);\n  }\n}\n\n\n如果在函数定义之前使用了 async 关键字，就可以在函数内使用 await。 当在 await 某个 promise 时，函数暂停执行，直至该 promise 产生结果，并且暂停不会阻塞主线程。 如果 promise resolve，则会返回值。 如果 promise reject，则会抛出拒绝的值。\n\n\n# java 的 promise 模式\n\n在 jdk 1.8 里也引入了类似 javascript 的玩法 —— completablefuture。这个类提供了大量的异步编程中 promise 的各种方式。\n\n链式处理：\n\ncompletablefuture.supplyasync(this::findreceiver)\n                 .thenapply(this::sendmsg)\n                 .thenaccept(this::notify);\n\n\n上面的这个链式处理和 javascript 中的then()方法很像，其中的 supplyasync() 表示执行一个异步方法，而 thenapply() 表示执行成功后再串联另外一个异步方法，最后是 thenaccept() 来处理最终结果。\n\n下面这个例子是要合并两个异步函数的结果：\n\nstring result = completablefuture.supplyasync(() -> {\n         return "hello";\n     }).thencombine(completablefuture.supplyasync(() -> {\n         return "world";\n     }), (s1, s2) -> s1 + " " + s2).join());\nsystem.out.println(result);\n\n\n\n接下来，我们再来看一下，java 这个类相关的异常处理：\n\ncompletablefuture.supplyasync(integer::parseint) // 输入: "illegal"\n\t\t\t     .thenapply(r -> r * 2 * math.pi)\n\t\t\t     .thenapply(s -> "apply>> " + s)\n\t\t\t     .exceptionally(ex -> "error: " + ex.getmessage());\n\n\n我们要注意到上面代码里的 exceptionally() 方法，这个和 javascript promise 中的 catch() 方法相似。\n\n运行上面的代码，会出现如下输出：\n\nerror: java.lang.numberformatexception: for input string: "illegal"\n\n\n也可以这样：\n\ncompletablefuture.supplyasync(integer::parseint) // 输入: "illegal"\n\t\t\t\t .thenapply(r -> r * 2 * math.pi)\n\t\t\t\t .thenapply(s -> "apply>> " + s)\n\t\t\t\t .handle((result, ex) -> {\n\t\t\t\t \tif (result != null) {\n\t\t\t\t \t\treturn result;\n\t\t\t\t \t} else {\n\t\t\t\t \t\treturn "error handling: " + ex.getmessage();\n\t\t\t\t \t}\n\t\t\t\t });\n\n\n上面代码中，你可以看到，其使用了 handle() 方法来处理最终的结果，其中包含了异步函数中的错误处理。\n\n\n# 错误处理的最佳实践\n\n * 统一分类的错误字典。无论你是使用错误码还是异常捕捉，都需要认真并统一地做好错误的分类。最好是在一个地方定义相关的错误。比如，http 的 4xx 表示客户端有问题，5xx 则表示服务端有问题。也就是说，你要建立一个错误字典。\n * 同类错误的定义最好是可以扩展的。这一点非常重要，而对于这一点，通过面向对象的继承或是像 go 语言那样的接口多态可以很好地做到。这样可以方便地重用已有的代码。\n * 定义错误的严重程度。比如，fatal 表示重大错误，error 表示资源或需求得不到满足，warning 表示并不一定是个错误但还是需要引起注意，info 表示不是错误只是一个信息，debug 表示这是给内部开发人员用于调试程序的。\n * 错误日志的输出最好使用错误码，而不是错误信息。打印错误日志的时候，应该使用统一的格式。但最好不要用错误信息，而应使用相应的错误码，错误码不一定是数字，也可以是一个能从错误字典里找到的一个唯一的可以让人读懂的关键字。这样，会非常有利于日志分析软件进行自动化监控，而不是要从错误信息中做语义分析。比如：http 的日志中就会有 http 的返回码，如：404。但我更推荐使用像pagenotfound这样的标识，这样人和机器都很容易处理。\n * 忽略错误最好有日志。不然会给维护带来很大的麻烦。\n * 对于同一个地方不停的报错，最好不要都打到日志里。不然这样会导致其它日志被淹没了，也会导致日志文件太大。最好的实践是，打出一个错误以及出现的次数。\n * 不要用错误处理逻辑来处理业务逻辑。也就是说，不要使用异常捕捉这样的方式来处理业务逻辑，而是应该用条件判断。如果一个逻辑控制可以用 if - else 清楚地表达，那就不建议使用异常方式处理。异常捕捉是用来处理不期望发生的事情，而错误码则用来处理可能会发生的事。\n * 对于同类的错误处理，用一样的模式。比如，对于null对象的错误，要么都用返回 null，加上条件检查的模式，要么都用抛 nullpointerexception 的方式处理。不要混用，这样有助于代码规范。\n * 尽可能在错误发生的地方处理错误。因为这样会让调用者变得更简单。\n * 向上尽可能地返回原始的错误。如果一定要把错误返回到更高层去处理，那么，应该返回原始的错误，而不是重新发明一个错误。\n * 处理错误时，总是要清理已分配的资源。这点非常关键，使用 raii 技术，或是 try-catch-finally，或是 go 的 defer 都可以容易地做到。\n * 不推荐在循环体里处理错误。这里说的是 try-catch，绝大多数的情况你不需要这样做。最好把整个循环体外放在 try 语句块内，而在外面做 catch。\n * 不要把大量的代码都放在一个 try 语句块内。一个 try 语句块内的语句应该是完成一个简单单一的事情。\n * 为你的错误定义提供清楚的文档以及每种错误的代码示例。如果你是做 restful api 方面的，使用 swagger 会帮你很容易搞定这个事。\n * 对于异步的方式，推荐使用 promise 模式处理错误。对于这一点，javascript 中有很好的实践。\n * 对于分布式的系统，推荐使用 apm 相关的软件。尤其是使用 zipkin 这样的服务调用跟踪的分析来关联错误。',charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"编程范式",frontmatter:{title:"编程范式",categories:["设计","编程范式"],tags:["设计","编程范式"],date:"2021-04-29T16:05:03.000Z",permalink:"/pages/9e0f8e/"},regularPath:"/03.%E8%AE%BE%E8%AE%A1/04.%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/",relativePath:"03.设计/04.编程范式/README.md",key:"v-179f8f74",path:"/pages/9e0f8e/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:11},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:30},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:76}],headersStr:"📖 内容 📚 资料 🚪 传送",content:"# 编程范式\n\n\n# 📖 内容\n\n * 错误处理\n\n\n# 📚 资料\n\n * 书籍\n   * 《程序员修炼之道》\n   * 《代码整洁之道》\n\n\n# 🚪 传送\n\n◾ 🏠 DESIGN 首页 ◾ 🎯 我的博客",normalizedContent:"# 编程范式\n\n\n# 📖 内容\n\n * 错误处理\n\n\n# 📚 资料\n\n * 书籍\n   * 《程序员修炼之道》\n   * 《代码整洁之道》\n\n\n# 🚪 传送\n\n◾ 🏠 design 首页 ◾ 🎯 我的博客",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-02e2a776",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-20b770b6",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-0480d1c5",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3},{title:"Home",frontmatter:{home:!0,heroImage:"img/bg.gif",heroText:"Design",tagline:"Design 是个人对于架构的心得和总结。",bannerBg:"none",postList:"none",footer:"CC-BY-SA-4.0 Licensed | Copyright © 2018-Now Dunwu"},regularPath:"/",relativePath:"README.md",key:"v-7e5bbd14",path:"/",headers:[{level:2,title:"📖 内容",slug:"📖-内容",normalizedTitle:"📖 内容",charIndex:134},{level:3,title:"设计步骤",slug:"设计步骤",normalizedTitle:"设计步骤",charIndex:144},{level:4,title:"第一步：需求分析",slug:"第一步-需求分析",normalizedTitle:"第一步：需求分析",charIndex:296},{level:4,title:"第二步：顶层设计",slug:"第二步-顶层设计",normalizedTitle:"第二步：顶层设计",charIndex:638},{level:4,title:"第三步：组件设计",slug:"第三步-组件设计",normalizedTitle:"第三步：组件设计",charIndex:699},{level:4,title:"第四步：扩展设计",slug:"第四步-扩展设计",normalizedTitle:"第四步：扩展设计",charIndex:731},{level:3,title:"架构设计",slug:"架构设计",normalizedTitle:"架构设计",charIndex:817},{level:3,title:"分布式",slug:"分布式",normalizedTitle:"分布式",charIndex:1125},{level:4,title:"分布式综合",slug:"分布式综合",normalizedTitle:"分布式综合",charIndex:1132},{level:4,title:"分布式理论",slug:"分布式理论",normalizedTitle:"分布式理论",charIndex:1153},{level:4,title:"分布式关键技术",slug:"分布式关键技术",normalizedTitle:"分布式关键技术",charIndex:1282},{level:5,title:"流量调度",slug:"流量调度",normalizedTitle:"流量调度",charIndex:1318},{level:5,title:"数据调度",slug:"数据调度",normalizedTitle:"数据调度",charIndex:1513},{level:5,title:"资源调度",slug:"资源调度",normalizedTitle:"资源调度",charIndex:1750},{level:5,title:"通信",slug:"通信",normalizedTitle:"通信",charIndex:1767},{level:5,title:"服务治理",slug:"服务治理",normalizedTitle:"服务治理",charIndex:1809},{level:4,title:"分布式应用",slug:"分布式应用",normalizedTitle:"分布式应用",charIndex:2019},{level:5,title:"微服务",slug:"微服务",normalizedTitle:"微服务",charIndex:2028},{level:3,title:"设计方法",slug:"设计方法",normalizedTitle:"设计方法",charIndex:2046},{level:4,title:"UML",slug:"uml",normalizedTitle:"uml",charIndex:2054},{level:4,title:"设计模式",slug:"设计模式",normalizedTitle:"设计模式",charIndex:2279},{level:5,title:"创建型模式",slug:"创建型模式",normalizedTitle:"创建型模式",charIndex:2411},{level:5,title:"结构型模式",slug:"结构型模式",normalizedTitle:"结构型模式",charIndex:2563},{level:5,title:"行为型模式",slug:"行为型模式",normalizedTitle:"行为型模式",charIndex:2702},{level:4,title:"重构",slug:"重构",normalizedTitle:"重构",charIndex:2949},{level:2,title:"📚 资料",slug:"📚-资料",normalizedTitle:"📚 资料",charIndex:3200},{level:2,title:"🚪 传送",slug:"🚪-传送",normalizedTitle:"🚪 传送",charIndex:3742}],headersStr:"📖 内容 设计步骤 第一步：需求分析 第二步：顶层设计 第三步：组件设计 第四步：扩展设计 架构设计 分布式 分布式综合 分布式理论 分布式关键技术 流量调度 数据调度 资源调度 通信 服务治理 分布式应用 微服务 设计方法 UML 设计模式 创建型模式 结构型模式 行为型模式 重构 📚 资料 🚪 传送",content:"> ☕ DESIGN 是个人对于软件系统架构的心得和总结。\n> \n> 架构之道，在于权衡；权衡之术，在于取舍。\n> \n>  * 🔁 项目同步维护：Github | Gitee\n>  * 📖 电子书阅读：Github Pages | Gitee Pages\n\n\n# 📖 内容\n\n\n# 设计步骤\n\n解决方案（Solution），就是针对某些已经体现出的，或者可以预期的问题、不足、缺陷、需求等等，所提出的一个解决整体问题的可行性方案。就软件系统而言，解决方案就是一个可以解决具体业务问题，并且可以落地的软件系统。\n\n解决方案，毫无疑问是顶层系统设计，这需要设计者既懂技术，也懂业务。\n\n# 第一步：需求分析\n\n把所有需要的东西聚集在一起，审视问题。不停的提问，以至于我们可以明确使用场景和约束。讨论假设。\n\n * What：系统的作用是什么？系统的目标是什么？\n * Who：系统的用户群体是谁？\n * How：用户希望怎样使用系统？系统如何为用户提供服务？\n * How many：有多少用户？日活/月活有多少？——用户体量会极大的影响系统的性能要求，从而影响系统的规模和复杂度。\n * 容量：系统需要处理多少数据？\n * 并发量、吞吐量：系统需要每秒钟处理多少请求？\n * 读写比率：系统的读写比率是多少？——读多写少或写多读少决定了不同的架构方案。\n * How much：系统的预算是多少（包括物料、人力成本等）？\n * 输入输出：系统的输入输出分别是什么？\n\n# 第二步：顶层设计\n\n使用所有重要的组件来描绘出一个高层级的设计。\n\n * 画出主要的组件和连接\n * 证明你的想法\n\n# 第三步：组件设计\n\n对每一个核心组件进行详细深入的分析。\n\n# 第四步：扩展设计\n\n确认和处理瓶颈以及一些限制。举例来说就是你需要下面的这些来完成扩展性的议题吗？\n\n * 负载均衡\n * 水平扩展\n * 缓存\n * 数据库分片\n\n\n# 架构设计\n\n> 如果把软件开发工作比作是一场战争，那么系统架构无疑是战略层面的工作。众所周知，万丈高楼平地起，系统架构就像是软件的地基，如果一开始就歪了，那么代码写得再漂亮，软件也难以成功。\n> \n> 软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。重点是分而治之，先将大型系统抽象为各个组件或模块；然后逐一解决各组件、各模块的功能、性能问题；最后将这些组件、模块整合成对外服务的一个整体。\n\n * 系统架构面试题\n * 系统架构概述\n * 系统高性能架构\n * 系统高可用架构\n * 系统伸缩性架构\n * 系统扩展性架构\n * 系统安全性架构\n * 大型系统核心技术\n * 领域驱动设计\n\n\n# 分布式\n\n# 分布式综合\n\n * 分布式面试总结\n\n# 分布式理论\n\n * 分布式理论 - 关键词：拜占庭将军、CAP、BASE、错误的分布式假设\n * 分布式算法 Paxos - 关键词：共识性算法\n * 分布式算法 Raft - 关键词：共识性算法\n * 分布式算法 Gossip - 关键词：数据传播\n\n# 分布式关键技术\n\n * 集群\n * 复制\n * 分区\n * 选主\n\n# 流量调度\n\n * 流量控制 - 关键词：限流、熔断、降级、计数器法、时间窗口法、令牌桶法、漏桶法\n * 负载均衡 - 关键词：轮询、随机、最少连接、源地址哈希、一致性哈希、虚拟 hash 槽\n * 服务路由 - 关键词：路由、条件路由、脚本路由、标签路由\n * 服务网关\n * 分布式会话 - 关键词：粘性 Session、Session 复制共享、基于缓存的 session 共享\n\n# 数据调度\n\n * 数据缓存 - 关键词：进程内缓存、分布式缓存、缓存雪崩、缓存穿透、缓存击穿、缓存更新、缓存预热、缓存降级\n * 读写分离\n * 分库分表 - 关键词：分片、路由、迁移、扩容、双写、聚合\n * 分布式 ID - 关键词：UUID、自增序列、雪花算法、Leaf\n * 分布式事务 - 关键词：2PC、3PC、TCC、本地消息表、MQ 消息、SAGA\n * 分布式锁 - 关键词：数据库、Redis、ZooKeeper、互斥、可重入、死锁、容错、自旋尝试\n\n# 资源调度\n\n * 弹性伸缩\n\n# 通信\n\n * 消息队列 - 关键词：重复消费、消息丢失、消息顺序性、消息积压\n\n# 服务治理\n\n * 服务注册和发现\n * 服务监控\n * 服务链路监控\n * 服务容错\n * 服务编排\n * 服务版本管理\n * 流量调度\n   * 流量控制 - 关键词：限流、熔断、降级、计数器法、时间窗口法、令牌桶法、漏桶法\n   * 负载均衡 - 关键词：轮询、随机、最少连接、源地址哈希、一致性哈希、虚拟 hash 槽\n   * 服务路由 - 关键词：路由、条件路由、脚本路由、标签路由\n   * 服务网关\n\n# 分布式应用\n\n# 微服务\n\n * 微服务简介\n\n\n# 设计方法\n\n# UML\n\n> 统一建模语言（英语 - Unified Modeling Language，缩写 UML）是非专利的第三代建模和规约语言。UML 是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML 展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。\n\n * UML 快速入门\n * UML 结构建模图\n * UML 行为建模图\n\n# 设计模式\n\n> 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n# 创建型模式\n\n * 简单工厂模式 (Simple Factory)\n * 工厂方法模式 (Factory Method)\n * 抽象工厂模式 (Abstract Factory)\n * 建造者模式 (Builder)\n * 原型模式 (Prototype)\n * 单例模式 (Singleton)\n\n# 结构型模式\n\n * 适配器模式 (Adapter)\n * 桥接模式 (Bridge)\n * 组合模式 (Composite)\n * 装饰模式 (Decorator)\n * 外观模式 (Facade)\n * 享元模式 (Flyweight)\n * 代理模式 (Proxy)\n\n# 行为型模式\n\n * 模板方法模式 (Template Method)\n * 命令模式 (Command)\n * 迭代器模式 (Iterator)\n * 观察者模式 (Observer)\n * 解释器模式 (Interpreter)\n * 中介者模式 (Mediator)\n * 职责链模式 (Chain of Responsibility)\n * 备忘录模式 (Memento)\n * 策略模式 (Strategy)\n * 访问者模式 (Visitor)\n * 状态模式 (State)\n\n# 重构\n\n> 改善既有代码的设计。\n> \n> 关键词：过长函数、过大的类、基本类型偏执、过长参数列、数据泥团、switch 声明、临时字段、被拒绝的馈赠、异曲同工的类、发散式变化、霰弹式修改、平行继承体系、过多的注释、重复代码、冗余类、纯稚的数据类、夸夸其谈未来性、依恋情结、狎昵关系、过度耦合的消息链、中间人、不完美的库类\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 📚 资料\n\n * 书籍\n   * 《大型网站技术架构：核心原理与案例分析》 - 浅显易懂的将解大型网站架构演进之路；简介了大型系统所面临的挑战以及核心技术点。\n   * 《亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统》\n   * 大型网站系统与 Java 中间件实践\n   * 企业 IT 架构转型之道：阿里巴巴中台战略思想与架构实战 - 阐述阿里巴巴中台系统发展，更多的是讲解应用场景和能力，没有讲解技术细节。\n   * 逆流而上：阿里巴巴技术成长之路 - 主要以运维的视角阐述系统运维中遇到的困难，定位思路以及解决方法。\n   * 《Head First 设计模式》\n   * 《大话设计模式》\n   * 《重构——改善既有代码的设计》\n * 教程\n   * system-design-primer\n   * 从 0 开始学架构\n   * 从 0 开始学微服务\n   * RPC 实战与核心原理\n   * 微服务架构核心 20 讲\n   * DDD 实战课\n   * Sparx UML 教程\n   * UML Tutorial\n   * W3Cschool UML 教程\n   * https://sourcemaking.com/refactoring\n\n\n# 🚪 传送\n\n◾ 🏠 DESIGN 首页 ◾ 🎯 我的博客 ◾\n\n> 你可能会感兴趣：\n\n * Java 教程 📚\n * JavaCore 教程 📚\n * JavaTech 教程 📚\n * Spring 教程 📚\n * Spring Boot 教程 📚\n * 数据库教程 📚\n * 数据结构和算法教程 📚\n * Linux 教程 📚\n * Nginx 教程 📚",normalizedContent:"> ☕ design 是个人对于软件系统架构的心得和总结。\n> \n> 架构之道，在于权衡；权衡之术，在于取舍。\n> \n>  * 🔁 项目同步维护：github | gitee\n>  * 📖 电子书阅读：github pages | gitee pages\n\n\n# 📖 内容\n\n\n# 设计步骤\n\n解决方案（solution），就是针对某些已经体现出的，或者可以预期的问题、不足、缺陷、需求等等，所提出的一个解决整体问题的可行性方案。就软件系统而言，解决方案就是一个可以解决具体业务问题，并且可以落地的软件系统。\n\n解决方案，毫无疑问是顶层系统设计，这需要设计者既懂技术，也懂业务。\n\n# 第一步：需求分析\n\n把所有需要的东西聚集在一起，审视问题。不停的提问，以至于我们可以明确使用场景和约束。讨论假设。\n\n * what：系统的作用是什么？系统的目标是什么？\n * who：系统的用户群体是谁？\n * how：用户希望怎样使用系统？系统如何为用户提供服务？\n * how many：有多少用户？日活/月活有多少？——用户体量会极大的影响系统的性能要求，从而影响系统的规模和复杂度。\n * 容量：系统需要处理多少数据？\n * 并发量、吞吐量：系统需要每秒钟处理多少请求？\n * 读写比率：系统的读写比率是多少？——读多写少或写多读少决定了不同的架构方案。\n * how much：系统的预算是多少（包括物料、人力成本等）？\n * 输入输出：系统的输入输出分别是什么？\n\n# 第二步：顶层设计\n\n使用所有重要的组件来描绘出一个高层级的设计。\n\n * 画出主要的组件和连接\n * 证明你的想法\n\n# 第三步：组件设计\n\n对每一个核心组件进行详细深入的分析。\n\n# 第四步：扩展设计\n\n确认和处理瓶颈以及一些限制。举例来说就是你需要下面的这些来完成扩展性的议题吗？\n\n * 负载均衡\n * 水平扩展\n * 缓存\n * 数据库分片\n\n\n# 架构设计\n\n> 如果把软件开发工作比作是一场战争，那么系统架构无疑是战略层面的工作。众所周知，万丈高楼平地起，系统架构就像是软件的地基，如果一开始就歪了，那么代码写得再漂亮，软件也难以成功。\n> \n> 软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计。重点是分而治之，先将大型系统抽象为各个组件或模块；然后逐一解决各组件、各模块的功能、性能问题；最后将这些组件、模块整合成对外服务的一个整体。\n\n * 系统架构面试题\n * 系统架构概述\n * 系统高性能架构\n * 系统高可用架构\n * 系统伸缩性架构\n * 系统扩展性架构\n * 系统安全性架构\n * 大型系统核心技术\n * 领域驱动设计\n\n\n# 分布式\n\n# 分布式综合\n\n * 分布式面试总结\n\n# 分布式理论\n\n * 分布式理论 - 关键词：拜占庭将军、cap、base、错误的分布式假设\n * 分布式算法 paxos - 关键词：共识性算法\n * 分布式算法 raft - 关键词：共识性算法\n * 分布式算法 gossip - 关键词：数据传播\n\n# 分布式关键技术\n\n * 集群\n * 复制\n * 分区\n * 选主\n\n# 流量调度\n\n * 流量控制 - 关键词：限流、熔断、降级、计数器法、时间窗口法、令牌桶法、漏桶法\n * 负载均衡 - 关键词：轮询、随机、最少连接、源地址哈希、一致性哈希、虚拟 hash 槽\n * 服务路由 - 关键词：路由、条件路由、脚本路由、标签路由\n * 服务网关\n * 分布式会话 - 关键词：粘性 session、session 复制共享、基于缓存的 session 共享\n\n# 数据调度\n\n * 数据缓存 - 关键词：进程内缓存、分布式缓存、缓存雪崩、缓存穿透、缓存击穿、缓存更新、缓存预热、缓存降级\n * 读写分离\n * 分库分表 - 关键词：分片、路由、迁移、扩容、双写、聚合\n * 分布式 id - 关键词：uuid、自增序列、雪花算法、leaf\n * 分布式事务 - 关键词：2pc、3pc、tcc、本地消息表、mq 消息、saga\n * 分布式锁 - 关键词：数据库、redis、zookeeper、互斥、可重入、死锁、容错、自旋尝试\n\n# 资源调度\n\n * 弹性伸缩\n\n# 通信\n\n * 消息队列 - 关键词：重复消费、消息丢失、消息顺序性、消息积压\n\n# 服务治理\n\n * 服务注册和发现\n * 服务监控\n * 服务链路监控\n * 服务容错\n * 服务编排\n * 服务版本管理\n * 流量调度\n   * 流量控制 - 关键词：限流、熔断、降级、计数器法、时间窗口法、令牌桶法、漏桶法\n   * 负载均衡 - 关键词：轮询、随机、最少连接、源地址哈希、一致性哈希、虚拟 hash 槽\n   * 服务路由 - 关键词：路由、条件路由、脚本路由、标签路由\n   * 服务网关\n\n# 分布式应用\n\n# 微服务\n\n * 微服务简介\n\n\n# 设计方法\n\n# uml\n\n> 统一建模语言（英语 - unified modeling language，缩写 uml）是非专利的第三代建模和规约语言。uml 是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。uml 展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在软件架构层次已经被验证有效。\n\n * uml 快速入门\n * uml 结构建模图\n * uml 行为建模图\n\n# 设计模式\n\n> 设计模式（design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n\n# 创建型模式\n\n * 简单工厂模式 (simple factory)\n * 工厂方法模式 (factory method)\n * 抽象工厂模式 (abstract factory)\n * 建造者模式 (builder)\n * 原型模式 (prototype)\n * 单例模式 (singleton)\n\n# 结构型模式\n\n * 适配器模式 (adapter)\n * 桥接模式 (bridge)\n * 组合模式 (composite)\n * 装饰模式 (decorator)\n * 外观模式 (facade)\n * 享元模式 (flyweight)\n * 代理模式 (proxy)\n\n# 行为型模式\n\n * 模板方法模式 (template method)\n * 命令模式 (command)\n * 迭代器模式 (iterator)\n * 观察者模式 (observer)\n * 解释器模式 (interpreter)\n * 中介者模式 (mediator)\n * 职责链模式 (chain of responsibility)\n * 备忘录模式 (memento)\n * 策略模式 (strategy)\n * 访问者模式 (visitor)\n * 状态模式 (state)\n\n# 重构\n\n> 改善既有代码的设计。\n> \n> 关键词：过长函数、过大的类、基本类型偏执、过长参数列、数据泥团、switch 声明、临时字段、被拒绝的馈赠、异曲同工的类、发散式变化、霰弹式修改、平行继承体系、过多的注释、重复代码、冗余类、纯稚的数据类、夸夸其谈未来性、依恋情结、狎昵关系、过度耦合的消息链、中间人、不完美的库类\n\n * 代码的坏味道和重构\n * 代码坏味道之代码臃肿\n * 代码坏味道之滥用面向对象\n * 代码坏味道之变革的障碍\n * 代码坏味道之非必要的\n * 代码坏味道之耦合\n\n\n# 📚 资料\n\n * 书籍\n   * 《大型网站技术架构：核心原理与案例分析》 - 浅显易懂的将解大型网站架构演进之路；简介了大型系统所面临的挑战以及核心技术点。\n   * 《亿级流量网站架构核心技术：跟开涛学搭建高可用高并发系统》\n   * 大型网站系统与 java 中间件实践\n   * 企业 it 架构转型之道：阿里巴巴中台战略思想与架构实战 - 阐述阿里巴巴中台系统发展，更多的是讲解应用场景和能力，没有讲解技术细节。\n   * 逆流而上：阿里巴巴技术成长之路 - 主要以运维的视角阐述系统运维中遇到的困难，定位思路以及解决方法。\n   * 《head first 设计模式》\n   * 《大话设计模式》\n   * 《重构——改善既有代码的设计》\n * 教程\n   * system-design-primer\n   * 从 0 开始学架构\n   * 从 0 开始学微服务\n   * rpc 实战与核心原理\n   * 微服务架构核心 20 讲\n   * ddd 实战课\n   * sparx uml 教程\n   * uml tutorial\n   * w3cschool uml 教程\n   * https://sourcemaking.com/refactoring\n\n\n# 🚪 传送\n\n◾ 🏠 design 首页 ◾ 🎯 我的博客 ◾\n\n> 你可能会感兴趣：\n\n * java 教程 📚\n * javacore 教程 📚\n * javatech 教程 📚\n * spring 教程 📚\n * spring boot 教程 📚\n * 数据库教程 📚\n * 数据结构和算法教程 📚\n * linux 教程 📚\n * nginx 教程 📚",charsets:{cjk:!0},lastUpdated:"2022/04/22, 20:07:55",lastUpdatedTimestamp:1650629275e3}],themeConfig:{nav:[{text:"架构",link:"/01.架构/"},{text:"分布式",link:"/02.分布式/"},{text:"设计",link:"/03.设计/",items:[{text:"UML",link:"/03.设计/01.UML/"},{text:"设计模式",link:"/03.设计/02.设计模式/"},{text:"重构",link:"/03.设计/03.重构/"}]}],sidebarDepth:2,logo:"https://raw.githubusercontent.com/dunwu/images/dev/common/dunwu-logo.png",repo:"dunwu/design",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"📝 帮助改善此页面！",sidebar:{"/01.架构/":[{title:"解决方案",collapsable:!1,children:[]},["02.系统架构概述.md","系统架构概述","/pages/ce2da4/"],["03.系统高性能架构.md","系统高性能架构","/pages/41c2c7/"],["04.系统高可用架构.md","系统高可用架构","/pages/ad5762/"],["05.系统伸缩性架构.md","系统伸缩性架构","/pages/ed2a88/"],["06.系统扩展性架构.md","系统扩展性架构","/pages/1580de/"],["07.系统安全性架构.md","系统安全性架构","/pages/039552/"],["08.大型系统核心技术.md","大型系统核心技术","/pages/eb0425/"],["09.领域驱动设计.md","领域驱动设计","/pages/4dfb51/"]],catalogue:{},"/02.分布式/":[{title:"分布式综合",collapsable:!1,children:[["01.分布式综合/01.分布式面试总结.md","分布式面试总结","/pages/cd56bb/"]]},{title:"分布式理论",collapsable:!1,children:[["02.分布式理论/01.分布式理论.md","分布式理论","/pages/367308/"],["02.分布式理论/02.分布式算法Paxos.md","深入剖析共识性算法 Paxos","/pages/874539/"],["02.分布式理论/03.分布式算法Raft.md","深入剖析共识性算法 Raft","/pages/e40812/"],["02.分布式理论/04.分布式算法Gossip.md","分布式算法 Gossip","/pages/d15993/"]]},{title:"分布式关键技术",collapsable:!1,children:[{title:"流量调度",collapsable:!1,children:[["03.分布式关键技术/01.流量调度/01.流量控制.md","流量控制","/pages/282676/"],["03.分布式关键技术/01.流量调度/02.负载均衡.md","深入浅出负载均衡","/pages/b7ca44/"],["03.分布式关键技术/01.流量调度/03.服务路由.md","服务路由","/pages/d04ece/"],["03.分布式关键技术/01.流量调度/10.分布式会话.md","分布式会话基本原理","/pages/3e66c2/"]]},{title:"数据调度",collapsable:!1,children:[["03.分布式关键技术/02.数据调度/01.数据缓存.md","缓存基本原理","/pages/471208/"],["03.分布式关键技术/02.数据调度/02.读写分离.md","读写分离基本原理","/pages/7da6ca/"],["03.分布式关键技术/02.数据调度/03.分库分表.md","分库分表基本原理","/pages/103382/"],["03.分布式关键技术/02.数据调度/04.分布式ID.md","分布式 ID 基本原理","/pages/0b2e59/"],["03.分布式关键技术/02.数据调度/05.分布式事务.md","分布式事务基本原理","/pages/910bad/"],["03.分布式关键技术/02.数据调度/06.分布式锁.md","分布式锁基本原理","/pages/69360c/"]]},{title:"通信",collapsable:!1,children:[["03.分布式关键技术/04.通信/01.消息队列.md","消息队列基本原理","/pages/4bba35/"]]},{title:"服务治理",collapsable:!1,children:[["03.分布式关键技术/05.服务治理/01.服务注册和发现.md","服务注册和发现","/pages/516f3b/"],["03.分布式关键技术/05.服务治理/02.服务监控.md","服务监控","/pages/4c0174/"],["03.分布式关键技术/05.服务治理/03.服务链路监控.md","服务链路监控","/pages/f918df/"],["03.分布式关键技术/05.服务治理/04.服务容错.md","服务容错","/pages/28bda8/"]]}]},{title:"分布式应用",collapsable:!1,children:[{title:"微服务",collapsable:!1,children:[["04.分布式应用/01.微服务/01.微服务简介.md","微服务简介","/pages/f13c06/"],["04.分布式应用/01.微服务/02.RPC.md","RPC 基本原理","/pages/ebf86b/"],["04.分布式应用/01.微服务/22.Kong.md","kong","/pages/3c87eb/"]]}]}],"/03.设计/":[{title:"UML",collapsable:!1,children:[["01.UML/01.UML快速入门.md","UML 快速入门","/pages/eae6a0/"],["01.UML/02.UML结构建模图.md","UML 结构建模图","/pages/97f796/"],["01.UML/03.UML行为建模图.md","UML行为建模图","/pages/dba425/"]]},{title:"设计模式",collapsable:!1,children:[["02.设计模式/00.设计模式概述.md","设计模式概述","/pages/dad9fd/"],["02.设计模式/01.简单工厂模式.md","设计模式之简单工厂模式","/pages/4244b2/"],["02.设计模式/02.工厂方法模式.md","设计模式之工厂方法模式","/pages/58cd12/"],["02.设计模式/03.抽象工厂模式.md","设计模式之抽象工厂模式","/pages/d40cbb/"],["02.设计模式/04.建造者模式.md","设计模式之建造者模式","/pages/cb480c/"],["02.设计模式/05.原型模式.md","设计模式之原型模式","/pages/c5ff69/"],["02.设计模式/06.单例模式.md","设计模式之单例模式","/pages/b271ff/"],["02.设计模式/07.适配器模式.md","设计模式之适配器模式","/pages/2c4733/"],["02.设计模式/08.桥接模式.md","设计模式之桥接模式","/pages/9f520d/"],["02.设计模式/09.组合模式.md","设计模式之组合模式","/pages/b18a73/"],["02.设计模式/10.装饰模式.md","设计模式之装饰模式","/pages/12897e/"],["02.设计模式/11.外观模式.md","设计模式之外观模式","/pages/427347/"],["02.设计模式/12.享元模式.md","设计模式之享元模式","/pages/265866/"],["02.设计模式/13.代理模式.md","设计模式之代理模式","/pages/2937c1/"],["02.设计模式/14.模板方法模式.md","设计模式之模板方法模式","/pages/604ebc/"],["02.设计模式/15.命令模式.md","设计模式之命令模式","/pages/6389ed/"],["02.设计模式/16.迭代器模式.md","设计模式之迭代器模式","/pages/d2026d/"],["02.设计模式/17.观察者模式.md","设计模式之观察者模式","/pages/87fbaa/"],["02.设计模式/18.解释器模式.md","设计模式之解释器模式","/pages/1e0eff/"],["02.设计模式/19.中介者模式.md","设计模式之中介者模式","/pages/b5886f/"],["02.设计模式/20.职责链模式.md","设计模式之职责链模式","/pages/a92964/"],["02.设计模式/21.备忘录模式.md","设计模式之备忘录模式","/pages/e3cd5d/"],["02.设计模式/22.策略模式.md","设计模式之策略模式","/pages/e5bb92/"],["02.设计模式/23.访问者模式.md","设计模式之访问者模式","/pages/6e8ebc/"],["02.设计模式/24.状态模式.md","设计模式之状态模式","/pages/6420d5/"],["02.设计模式/25.面向对象原则.md","面向对象原则","/pages/b3c94e/"]]},{title:"重构",collapsable:!1,children:[["03.重构/01.代码的坏味道和重构.md","代码的坏味道和重构","/pages/89848c/"],["03.重构/02.代码坏味道之代码臃肿.md","代码坏味道之代码臃肿","/pages/82f4c8/"],["03.重构/03.代码坏味道之滥用面向对象.md","代码坏味道之滥用面向对象","/pages/9ae679/"],["03.重构/04.代码坏味道之变革的障碍.md","代码坏味道之变革的障碍","/pages/76e1cc/"],["03.重构/05.代码坏味道之非必要的.md","代码坏味道之非必要的","/pages/dff53d/"],["03.重构/06.代码坏味道之耦合.md","代码坏味道之耦合","/pages/595d03/"]]},{title:"编程范式",collapsable:!1,children:[["04.编程范式/01.错误处理.md","错误处理","/pages/dc158b/"]]}]},updateBar:{showToArticle:!0},category:!0,tag:!0,archive:!0,author:{name:"dunwu",href:"https://github.com/dunwu"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:forbreak@163.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/dunwu"}]},footer:{createYear:2019,copyrightInfo:"钝悟（dunwu） | CC-BY-SA-4.0"},htmlModules:{pageB:'\n  <div class="wwads-cn wwads-horizontal pageB" data-id="136" style="width:100%;max-height:80px;min-height:auto;"></div>\n  <style>\n    .pageB img{width:80px!important;}\n    .wwads-horizontal .wwads-text, .wwads-content .wwads-text{line-height:1;}\n  </style>\n  ',windowRB:'\n    <div class="wwads-cn wwads-vertical windowRB" data-id="136" style="max-width:160px;\n    min-width: auto;min-height:auto;"></div>\n    <style>\n      .windowRB{ padding: 0;}\n      .windowRB .wwads-img{margin-top: 10px;}\n      .windowRB .wwads-content{margin: 0 10px 10px 10px;}\n      .custom-html-window-rb .close-but{\n        display: none;\n      }\n    </style>\n  '}}};t(155),t(213),t(144);var ss=t(223),cs=t(224),ds=(t(390),t(240),t(43));var us={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var e=n.frontmatter,t=e.pageComponent,r=e.article,i=e.home;return!(t||!1===r||!0===i)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,e){var t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(ds.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(ds.a)(n,e)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,e){return Object(ds.a)(n,e)})),n;var n},$groupPosts:function(){return function(n){for(var e={},t={},r=function(r,i){var a=n[r].frontmatter,o=a.categories,l=a.tags;"array"===Object(ds.n)(o)&&o.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[r]))})),"array"===Object(ds.n)(l)&&l.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[r]))}))},i=0,a=n.length;i<a;i++)r(i);return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var e=[],t=[];for(var r in n.categories)e.push({key:r,length:n.categories[r].length});for(var i in n.tags)t.push({key:i,length:n.tags[i].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Bi.component(ss.default),Bi.component(cs.default);function ps(n){return n.toString().padStart(2,"0")}t(394);Bi.component("Badge",(function(){return Promise.all([t.e(0),t.e(3)]).then(t.bind(null,585))})),Bi.component("CodeBlock",(function(){return Promise.resolve().then(t.bind(null,223))})),Bi.component("CodeGroup",(function(){return Promise.resolve().then(t.bind(null,224))}));t(395),t(396);var ms=[function(n){n.Vue,n.options;var e=n.router;n.siteData;n.isServer||e.afterEach((function(){var n;n=function(){},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(n,1):document.addEventListener("DOMContentLoaded",n),setTimeout((function(){var n=document.querySelector(".pageB");if(n){var e=n.querySelector(".wwads-hide");e&&(e.onclick=function(){n.style.display="none"}),n.style.display="flex"}}),0)}))},function(n){var e=n.Vue,t=(n.options,n.router,n.siteData);t.pages.map((function(n){var e=n.frontmatter,r=e.date,i=e.author;"string"==typeof r&&"Z"===r.charAt(r.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(ps(n.getUTCMonth()+1),"-").concat(ps(n.getUTCDate())," ").concat(ps(n.getUTCHours()),":").concat(ps(n.getUTCMinutes()),":").concat(ps(n.getUTCSeconds()))}(r)),i?n.author=i:t.themeConfig.author&&(n.author=t.themeConfig.author)})),e.mixin(us)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(){"undefined"!=typeof window&&function(n,e,t){function r(n){var t=e.createElement("div");t.className="heart",i.push({el:t,x:n.clientX-5,y:n.clientY-5,scale:1,alpha:1,color:"#11a8cd"}),e.body.appendChild(t)}var i=[];n.requestAnimationFrame=n.requestAnimationFrame||n.webkitRequestAnimationFrame||n.mozRequestAnimationFrame||n.oRequestAnimationFrame||n.msRequestAnimationFrame||function(n){setTimeout(n,1e3/60)},function(n){var t=e.createElement("style");t.type="text/css";try{t.appendChild(e.createTextNode(n))}catch(e){t.styleSheet.cssText=n}e.getElementsByTagName("head")[0].appendChild(t)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),function(){var e="function"==typeof n.onclick&&n.onclick;n.onclick=function(n){var t=!0;n.path&&n.path.forEach((function(n){1===n.nodeType&&"string"==typeof n.className&&n.className.indexOf("theme-vdoing-content")>-1&&(t=!1)})),t&&(e&&e(),r(n))}}(),function n(){for(var t=0;t<i.length;t++)i[t].alpha<=0?(e.body.removeChild(i[t].el),i.splice(t,1)):(i[t].y--,i[t].scale+=.004,i[t].alpha-=.013,i[t].el.style.cssText="left:"+i[t].x+"px;top:"+i[t].y+"px;opacity:"+i[t].alpha+";transform:scale("+i[t].scale+","+i[t].scale+") rotate(45deg);background:"+i[t].color+";z-index:99999");requestAnimationFrame(n)}()}(window,document)}],hs=[];t(216);function gs(n,e){return(gs=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(217),t(218);function fs(n){return(fs=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function vs(n,e){if(e&&("object"===So(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}function bs(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=fs(n);if(e){var i=fs(this).constructor;t=Reflect.construct(r,arguments,i)}else t=r.apply(this,arguments);return vs(this,t)}}var ys=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&gs(n,e)}(t,n);var e=bs(t);function t(){return cl(this,t),e.apply(this,arguments)}return ul(t)}(function(){function n(){cl(this,n),this.store=new Bi({data:{state:{}}})}return ul(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){Bi.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(ys.prototype,{getPageAsyncComponent:No,getLayoutAsyncComponent:Ho,getAsyncComponent:$o,getVueComponent:Qo});var xs={install:function(n){var e=new ys;n.$vuepress=e,n.prototype.$vuepress=e}};function Ts(n){n.beforeEach((function(e,t,r){if(ks(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var i=e.path.replace(/\/$/,"")+".html";ks(n,i)?r(i):r()}else r();else{var a=e.path+"/",o=e.path+".html";ks(n,o)?r(o):ks(n,a)?r(a):r()}}))}function ks(n,e){var t=e.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===t}))}var ws={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return Go("pageKey",e),Bi.component(e)||Bi.component(e,No(e)),Bi.component(e)?n(e):n("")}},Is={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,r=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},r()[t.slotKey])}},Cs={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Ss=(t(397),t(398),Object(is.a)(Cs,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function Es(){return(Es=Object(r.a)(regeneratorRuntime.mark((function n(e){var t,r,i,a;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:ls.routerBase||ls.base,Ts(r=new Io({base:t,mode:"history",fallback:!1,routes:os,scrollBehavior:function(n,e,t){return t||(n.hash?!Bi.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),i={},n.prev=4,n.next=7,Promise.all(ms.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Bi,options:i,router:r,siteData:ls,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return a=new Bi(Object.assign(i,{router:r,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},hs.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:a,router:r});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Bi.config.productionTip=!1,Bi.use(Io),Bi.use(xs),Bi.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Bi;Co(e),t.$vuepress.$set("siteData",e);var r=n(t.$vuepress.$get("siteData")),i=new r,a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(i)),o={};return Object.keys(a).reduce((function(n,e){return e.startsWith("$")&&(n[e]=a[e].get),n}),o),{computed:o}}((function(n){return function(){function e(){cl(this,e)}return ul(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,r=void 0===t?{}:t;for(var i in r)"/"===i?e=r[i]:0===this.$page.path.indexOf(i)&&(n=r[i]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),ls)),Bi.component("Content",ws),Bi.component("ContentSlotsDistributor",Is),Bi.component("OutboundLink",Ss),Bi.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,r=e.children;if(t._isMounted)return r;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),Bi.component("Layout",Ho("Layout")),Bi.component("NotFound",Ho("NotFound")),Bi.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.2",hash:"18815ff"},function(n){return Es.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);